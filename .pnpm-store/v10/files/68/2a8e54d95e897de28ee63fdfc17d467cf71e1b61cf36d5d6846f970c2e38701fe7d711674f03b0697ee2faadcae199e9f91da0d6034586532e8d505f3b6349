{"version":3,"sources":["../../src/memory/memory.ts","../../src/memory/mock.ts"],"names":["MastraBase","augmentWithInit","ModelRouterEmbeddingModel","deepMerge","ZodObject","InMemoryStore","MessageList","zodToJsonSchema"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { EmbeddingModelV2 } from '@ai-sdk/provider-v5';\nimport type { EmbeddingModel, AssistantContent, UserContent, CoreMessage } from '@internal/ai-sdk-v4';\nimport type { MastraDBMessage } from '../agent/message-list';\nimport { MastraBase } from '../base';\nimport { ModelRouterEmbeddingModel } from '../llm/model/index.js';\nimport type { Mastra } from '../mastra';\nimport type {\n  MastraStorage,\n  StorageListMessagesInput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n} from '../storage';\nimport { augmentWithInit } from '../storage/storageWithInit';\nimport type { ToolAction } from '../tools';\nimport { deepMerge } from '../utils';\nimport type { MastraVector } from '../vector';\n\nimport type {\n  SharedMemoryConfig,\n  StorageThreadType,\n  MemoryConfig,\n  MastraMessageV1,\n  WorkingMemoryTemplate,\n  MessageDeleteInput,\n} from './types';\n\nexport type MemoryProcessorOpts = {\n  systemMessage?: string;\n  memorySystemMessage?: string;\n  newMessages?: CoreMessage[];\n};\n/**\n * Interface for message processors that can filter or transform messages\n * before they're sent to the LLM.\n */\nexport abstract class MemoryProcessor extends MastraBase {\n  /**\n   * Process a list of messages and return a filtered or transformed list.\n   * @param messages The messages to process\n   * @returns The processed messages\n   */\n  process(messages: CoreMessage[], _opts: MemoryProcessorOpts): CoreMessage[] | Promise<CoreMessage[]> {\n    return messages;\n  }\n}\n\nexport const memoryDefaultOptions = {\n  lastMessages: 10,\n  semanticRecall: false,\n  generateTitle: false,\n  workingMemory: {\n    enabled: false,\n    template: `\n# User Information\n- **First Name**: \n- **Last Name**: \n- **Location**: \n- **Occupation**: \n- **Interests**: \n- **Goals**: \n- **Events**: \n- **Facts**: \n- **Projects**: \n`,\n  },\n} satisfies MemoryConfig;\n\n/**\n * Abstract base class for implementing conversation memory systems.\n *\n * Key features:\n * - Thread-based conversation organization with resource association\n * - Optional vector database integration for semantic similarity search\n * - Working memory templates for structured conversation state\n * - Handles memory processors to manipulate messages before they are sent to the LLM\n */\nexport abstract class MastraMemory extends MastraBase {\n  MAX_CONTEXT_TOKENS?: number;\n\n  protected _storage?: MastraStorage;\n  vector?: MastraVector;\n  embedder?: EmbeddingModel<string> | EmbeddingModelV2<string>;\n  private processors: MemoryProcessor[] = [];\n  protected threadConfig: MemoryConfig = { ...memoryDefaultOptions };\n  #mastra?: Mastra;\n\n  constructor(config: { name: string } & SharedMemoryConfig) {\n    super({ component: 'MEMORY', name: config.name });\n\n    if (config.options) this.threadConfig = this.getMergedThreadConfig(config.options);\n    if (config.processors) this.processors = config.processors;\n    if (config.storage) {\n      this._storage = augmentWithInit(config.storage);\n      this._hasOwnStorage = true;\n    }\n\n    if (this.threadConfig.semanticRecall) {\n      if (!config.vector) {\n        throw new Error(\n          `Semantic recall requires a vector store to be configured.\\n\\nhttps://mastra.ai/en/docs/memory/semantic-recall`,\n        );\n      }\n      this.vector = config.vector;\n\n      if (!config.embedder) {\n        throw new Error(\n          `Semantic recall requires an embedder to be configured.\\n\\nhttps://mastra.ai/en/docs/memory/semantic-recall`,\n        );\n      }\n\n      // Convert string embedder to ModelRouterEmbeddingModel\n      if (typeof config.embedder === 'string') {\n        this.embedder = new ModelRouterEmbeddingModel(config.embedder);\n      } else {\n        this.embedder = config.embedder;\n      }\n    }\n  }\n\n  /**\n   * Internal method used by Mastra to register itself with the memory.\n   * @param mastra The Mastra instance.\n   * @internal\n   */\n  __registerMastra(mastra: Mastra): void {\n    this.#mastra = mastra;\n  }\n\n  protected _hasOwnStorage = false;\n  get hasOwnStorage() {\n    return this._hasOwnStorage;\n  }\n\n  get storage() {\n    if (!this._storage) {\n      throw new Error(\n        `Memory requires a storage provider to function. Add a storage configuration to Memory or to your Mastra instance.\\n\\nhttps://mastra.ai/en/docs/memory/overview`,\n      );\n    }\n    return this._storage;\n  }\n\n  public setStorage(storage: MastraStorage) {\n    this._storage = augmentWithInit(storage);\n  }\n\n  public setVector(vector: MastraVector) {\n    this.vector = vector;\n  }\n\n  public setEmbedder(embedder: EmbeddingModel<string>) {\n    this.embedder = embedder;\n  }\n\n  /**\n   * Get a system message to inject into the conversation.\n   * This will be called before each conversation turn.\n   * Implementations can override this to inject custom system messages.\n   */\n  public async getSystemMessage(_input: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null> {\n    return null;\n  }\n\n  /**\n   * Get tools that should be available to the agent.\n   * This will be called when converting tools for the agent.\n   * Implementations can override this to provide additional tools.\n   */\n  public listTools(_config?: MemoryConfig): Record<string, ToolAction<any, any, any>> {\n    return {};\n  }\n\n  protected async createEmbeddingIndex(dimensions?: number, config?: MemoryConfig): Promise<{ indexName: string }> {\n    const defaultDimensions = 1536;\n    const isDefault = dimensions === defaultDimensions;\n    const usedDimensions = dimensions ?? defaultDimensions;\n    const separator = this.vector?.indexSeparator ?? '_';\n    const indexName = isDefault\n      ? `memory${separator}messages`\n      : `memory${separator}messages${separator}${usedDimensions}`;\n\n    if (typeof this.vector === `undefined`) {\n      throw new Error(`Tried to create embedding index but no vector db is attached to this Memory instance.`);\n    }\n\n    // Get index configuration from memory config\n    const semanticConfig = typeof config?.semanticRecall === 'object' ? config.semanticRecall : undefined;\n    const indexConfig = semanticConfig?.indexConfig;\n\n    // Base parameters that all vector stores support\n    const createParams: any = {\n      indexName,\n      dimension: usedDimensions,\n      ...(indexConfig?.metric && { metric: indexConfig.metric }),\n    };\n\n    // Add PG-specific configuration if provided\n    // Only PG vector store will use these parameters\n    if (indexConfig && (indexConfig.type || indexConfig.ivf || indexConfig.hnsw)) {\n      createParams.indexConfig = {};\n      if (indexConfig.type) createParams.indexConfig.type = indexConfig.type;\n      if (indexConfig.ivf) createParams.indexConfig.ivf = indexConfig.ivf;\n      if (indexConfig.hnsw) createParams.indexConfig.hnsw = indexConfig.hnsw;\n    }\n\n    await this.vector.createIndex(createParams);\n    return { indexName };\n  }\n\n  public getMergedThreadConfig(config?: MemoryConfig): MemoryConfig {\n    if (config?.workingMemory && 'use' in config.workingMemory) {\n      throw new Error('The workingMemory.use option has been removed. Working memory always uses tool-call mode.');\n    }\n\n    if (config?.threads?.generateTitle !== undefined) {\n      throw new Error(\n        'The threads.generateTitle option has been moved. Use the top-level generateTitle option instead.',\n      );\n    }\n\n    const mergedConfig = deepMerge(this.threadConfig, config || {});\n\n    if (config?.workingMemory?.schema) {\n      if (mergedConfig.workingMemory) {\n        mergedConfig.workingMemory.schema = config.workingMemory.schema;\n      }\n    }\n\n    return mergedConfig;\n  }\n\n  /**\n   * Apply all configured message processors to a list of messages.\n   * @param messages The messages to process\n   * @returns The processed messages\n   */\n  protected async applyProcessors(\n    messages: CoreMessage[],\n    opts: {\n      processors?: MemoryProcessor[];\n    } & MemoryProcessorOpts,\n  ): Promise<CoreMessage[]> {\n    const processors = opts.processors || this.processors;\n    if (!processors || processors.length === 0) {\n      return messages;\n    }\n\n    let processedMessages = [...messages];\n\n    for (const processor of processors) {\n      processedMessages = await processor.process(processedMessages, {\n        systemMessage: opts.systemMessage,\n        newMessages: opts.newMessages,\n        memorySystemMessage: opts.memorySystemMessage,\n      });\n    }\n\n    return processedMessages;\n  }\n\n  processMessages({\n    messages,\n    processors,\n    ...opts\n  }: {\n    messages: CoreMessage[];\n    processors?: MemoryProcessor[];\n  } & MemoryProcessorOpts) {\n    return this.applyProcessors(messages, { processors: processors || this.processors, ...opts });\n  }\n\n  estimateTokens(text: string): number {\n    return Math.ceil(text.split(' ').length * 1.3);\n  }\n\n  /**\n   * Retrieves a specific thread by its ID\n   * @param threadId - The unique identifier of the thread\n   * @returns Promise resolving to the thread or null if not found\n   */\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  /**\n   * Lists all threads that belong to the specified resource.\n   * @param args.resourceId - The unique identifier of the resource\n   * @param args.offset - The number of threads to skip (for pagination)\n   * @param args.limit - The maximum number of threads to return\n   * @param args.orderBy - Optional sorting configuration with `field` (`'createdAt'` or `'updatedAt'`)\n   *                       and `direction` (`'ASC'` or `'DESC'`);\n   *                       defaults to `{ field: 'createdAt', direction: 'DESC' }`\n   * @returns Promise resolving to paginated thread results with metadata;\n   *          resolves to an empty array if the resource has no threads\n   */\n  abstract listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput>;\n\n  /**\n   * Saves or updates a thread\n   * @param thread - The thread data to save\n   * @returns Promise resolving to the saved thread\n   */\n  abstract saveThread({\n    thread,\n    memoryConfig,\n  }: {\n    thread: StorageThreadType;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType>;\n\n  /**\n   * Saves messages to a thread\n   * @param messages - Array of messages to save\n   * @returns Promise resolving to the saved messages\n   */\n  abstract saveMessages(args: {\n    messages: MastraDBMessage[];\n    memoryConfig?: MemoryConfig | undefined;\n  }): Promise<{ messages: MastraDBMessage[] }>;\n\n  /**\n   * Retrieves messages for a specific thread with optional semantic recall\n   * @param threadId - The unique identifier of the thread\n   * @param resourceId - Optional resource ID for validation\n   * @param vectorSearchString - Optional search string for semantic recall\n   * @param config - Optional memory configuration\n   * @returns Promise resolving to array of messages in mastra-db format\n   */\n  abstract recall(\n    args: StorageListMessagesInput & {\n      threadConfig?: MemoryConfig;\n      vectorSearchString?: string;\n    },\n  ): Promise<{ messages: MastraDBMessage[] }>;\n\n  /**\n   * Helper method to create a new thread\n   * @param title - Optional title for the thread\n   * @param metadata - Optional metadata for the thread\n   * @returns Promise resolving to the created thread\n   */\n  async createThread({\n    threadId,\n    resourceId,\n    title,\n    metadata,\n    memoryConfig,\n    saveThread = true,\n  }: {\n    resourceId: string;\n    threadId?: string;\n    title?: string;\n    metadata?: Record<string, unknown>;\n    memoryConfig?: MemoryConfig;\n    saveThread?: boolean;\n  }): Promise<StorageThreadType> {\n    const thread: StorageThreadType = {\n      id: threadId || this.generateId(),\n      title: title || `New Thread ${new Date().toISOString()}`,\n      resourceId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      metadata,\n    };\n\n    return saveThread ? this.saveThread({ thread, memoryConfig }) : thread;\n  }\n\n  /**\n   * Helper method to delete a thread\n   * @param threadId - the id of the thread to delete\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Helper method to add a single message to a thread\n   * @param threadId - The thread to add the message to\n   * @param content - The message content\n   * @param role - The role of the message sender\n   * @param type - The type of the message\n   * @param toolNames - Optional array of tool names that were called\n   * @param toolCallArgs - Optional array of tool call arguments\n   * @param toolCallIds - Optional array of tool call ids\n   * @returns Promise resolving to the saved message\n   * @deprecated use saveMessages instead\n   */\n  async addMessage(_params: {\n    threadId: string;\n    resourceId: string;\n    config?: MemoryConfig;\n    content: UserContent | AssistantContent;\n    role: 'user' | 'assistant';\n    type: 'text' | 'tool-call' | 'tool-result';\n    toolNames?: string[];\n    toolCallArgs?: Record<string, unknown>[];\n    toolCallIds?: string[];\n  }): Promise<MastraMessageV1> {\n    throw new Error('addMessage is deprecated. Please use saveMessages instead.');\n  }\n\n  /**\n   * Generates a unique identifier\n   * @returns A unique string ID\n   */\n  public generateId(): string {\n    return this.#mastra?.generateId() || crypto.randomUUID();\n  }\n\n  /**\n   * Retrieves working memory for a specific thread\n   * @param threadId - The unique identifier of the thread\n   * @param resourceId - The unique identifier of the resource\n   * @param memoryConfig - Optional memory configuration\n   * @returns Promise resolving to working memory data or null if not found\n   */\n  abstract getWorkingMemory({\n    threadId,\n    resourceId,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null>;\n\n  /**\n   * Retrieves working memory template for a specific thread\n   * @param memoryConfig - Optional memory configuration\n   * @returns Promise resolving to working memory template or null if not found\n   */\n  abstract getWorkingMemoryTemplate({\n    memoryConfig,\n  }?: {\n    memoryConfig?: MemoryConfig;\n  }): Promise<WorkingMemoryTemplate | null>;\n\n  abstract updateWorkingMemory({\n    threadId,\n    resourceId,\n    workingMemory,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<void>;\n\n  /**\n   * @warning experimental! can be removed or changed at any time\n   */\n  abstract __experimental_updateWorkingMemoryVNext({\n    threadId,\n    resourceId,\n    workingMemory,\n    searchString,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    searchString?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<{ success: boolean; reason: string }>;\n\n  /**\n   * Deletes multiple messages by their IDs\n   * @param messageIds - Array of message IDs to delete\n   * @returns Promise that resolves when all messages are deleted\n   */\n  abstract deleteMessages(messageIds: MessageDeleteInput): Promise<void>;\n}\n","import { zodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport type { JSONSchema7 } from 'json-schema';\nimport type { ZodTypeAny } from 'zod';\nimport { ZodObject } from 'zod';\nimport type { MastraDBMessage } from '../agent/message-list';\nimport { MessageList } from '../agent/message-list';\nimport type {\n  StorageListMessagesInput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n} from '../storage';\nimport { InMemoryStore } from '../storage';\nimport { MastraMemory } from './memory';\nimport type { StorageThreadType, MemoryConfig, MessageDeleteInput, WorkingMemoryTemplate } from './types';\n\nconst isZodObject = (v: ZodTypeAny): v is ZodObject<any, any, any> => v instanceof ZodObject;\n\nexport class MockMemory extends MastraMemory {\n  constructor({ storage }: { storage?: InMemoryStore } = {}) {\n    super({ name: 'mock', storage: storage || new InMemoryStore() });\n    this._hasOwnStorage = true;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.storage.getThreadById({ threadId });\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType; memoryConfig?: MemoryConfig }): Promise<StorageThreadType> {\n    return this.storage.saveThread({ thread });\n  }\n\n  async saveMessages({\n    messages,\n  }: {\n    messages: MastraDBMessage[];\n    memoryConfig?: MemoryConfig;\n  }): Promise<{ messages: MastraDBMessage[] }> {\n    // Convert messages to MastraDBMessage format and ensure IDs are generated\n    const dbMessages = new MessageList({\n      generateMessageId: () => this.generateId(),\n    })\n      .add(messages, 'memory')\n      .get.all.db();\n\n    return this.storage.saveMessages({ messages: dbMessages });\n  }\n\n  async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    return this.storage.listThreadsByResourceId(args);\n  }\n\n  async recall(args: StorageListMessagesInput & { threadConfig?: MemoryConfig; vectorSearchString?: string }): Promise<{\n    messages: MastraDBMessage[];\n  }> {\n    // Get raw messages from storage\n    const result = await this.storage.listMessages({\n      threadId: args.threadId,\n      resourceId: args.resourceId,\n      perPage: args.perPage,\n      page: args.page,\n      orderBy: args.orderBy,\n      filter: args.filter,\n      include: args.include,\n    });\n\n    return result;\n  }\n\n  async deleteThread(threadId: string) {\n    return this.storage.deleteThread({ threadId });\n  }\n\n  async deleteMessages(messageIds: MessageDeleteInput): Promise<void> {\n    const ids = Array.isArray(messageIds)\n      ? messageIds?.map(item => (typeof item === 'string' ? item : item.id))\n      : [messageIds];\n    return this.storage.deleteMessages(ids);\n  }\n\n  async getWorkingMemory({\n    threadId,\n    resourceId,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null> {\n    const mergedConfig = this.getMergedThreadConfig(memoryConfig);\n    const workingMemoryConfig = mergedConfig.workingMemory;\n\n    if (!workingMemoryConfig?.enabled) {\n      return null;\n    }\n\n    const scope = workingMemoryConfig.scope || 'resource';\n    const id = scope === 'resource' ? resourceId : threadId;\n\n    if (!id) {\n      return null;\n    }\n\n    const resource = await this.storage.getResourceById({ resourceId: id });\n    return resource?.workingMemory || null;\n  }\n\n  async getWorkingMemoryTemplate({\n    memoryConfig,\n  }: {\n    memoryConfig?: MemoryConfig;\n  } = {}): Promise<WorkingMemoryTemplate | null> {\n    const mergedConfig = this.getMergedThreadConfig(memoryConfig);\n    const workingMemoryConfig = mergedConfig.workingMemory;\n\n    if (!workingMemoryConfig?.enabled) {\n      return null;\n    }\n\n    if (workingMemoryConfig.template) {\n      return {\n        format: 'markdown' as const,\n        content: workingMemoryConfig.template,\n      };\n    }\n\n    if (workingMemoryConfig.schema) {\n      try {\n        const schema = workingMemoryConfig.schema;\n        let convertedSchema: JSONSchema7;\n\n        if (isZodObject(schema as ZodTypeAny)) {\n          convertedSchema = zodToJsonSchema(schema as ZodTypeAny);\n        } else {\n          convertedSchema = schema as JSONSchema7;\n        }\n\n        return { format: 'json', content: JSON.stringify(convertedSchema) };\n      } catch (error) {\n        this.logger?.error?.('Error converting schema', error);\n        throw error;\n      }\n    }\n\n    return null;\n  }\n\n  async updateWorkingMemory({\n    threadId,\n    resourceId,\n    workingMemory,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    memoryConfig?: MemoryConfig;\n  }) {\n    const mergedConfig = this.getMergedThreadConfig(memoryConfig);\n    const workingMemoryConfig = mergedConfig.workingMemory;\n\n    if (!workingMemoryConfig?.enabled) {\n      return;\n    }\n\n    const scope = workingMemoryConfig.scope || 'resource';\n    const id = scope === 'resource' ? resourceId : threadId;\n\n    if (!id) {\n      throw new Error(`Cannot update working memory: ${scope} ID is required`);\n    }\n\n    await this.storage.updateResource({\n      resourceId: id,\n      workingMemory,\n    });\n  }\n\n  async __experimental_updateWorkingMemoryVNext({\n    threadId,\n    resourceId,\n    workingMemory,\n    searchString: _searchString,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    searchString?: string;\n    memoryConfig?: MemoryConfig;\n  }) {\n    try {\n      await this.updateWorkingMemory({\n        threadId,\n        resourceId,\n        workingMemory,\n        memoryConfig,\n      });\n      return { success: true, reason: 'Working memory updated successfully' };\n    } catch (error) {\n      return {\n        success: false,\n        reason: error instanceof Error ? error.message : 'Failed to update working memory',\n      };\n    }\n  }\n}\n"]}