'use strict';

var chunkSVLMF4UZ_cjs = require('./chunk-SVLMF4UZ.cjs');
var chunkTWH4PTDG_cjs = require('./chunk-TWH4PTDG.cjs');
var uuid = require('@lukeed/uuid');
var AIV5 = require('ai-v5');
var providerUtilsV5 = require('@ai-sdk/provider-utils-v5');
var zod = require('zod');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AIV5__namespace = /*#__PURE__*/_interopNamespace(AIV5);

var DefaultGeneratedFile = class {
  base64Data;
  uint8ArrayData;
  mediaType;
  constructor({ data, mediaType }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data;
    this.uint8ArrayData = isUint8Array ? data : void 0;
    this.mediaType = mediaType;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = providerUtilsV5.convertUint8ArrayToBase64(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = providerUtilsV5.convertBase64ToUint8Array(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
  type = "file";
  constructor(options) {
    super(options);
  }
};

// src/stream/aisdk/v5/compat/content.ts
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header?.split(";")[0]?.split(":")[1],
      base64Content
    };
  } catch {
    return {
      mediaType: void 0,
      base64Content: void 0
    };
  }
}
function convertToDataContent(content) {
  if (content instanceof Uint8Array) {
    return { data: content, mediaType: void 0 };
  }
  if (content instanceof ArrayBuffer) {
    return { data: new Uint8Array(content), mediaType: void 0 };
  }
  if (typeof content === "string") {
    try {
      content = new URL(content);
    } catch {
    }
  }
  if (content instanceof URL && content.protocol === "data:") {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
    if (dataUrlMediaType == null || base64Content == null) {
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "INVALID_DATA_URL_FORMAT",
        text: `Invalid data URL format in content ${content.toString()}`,
        domain: "LLM" /* LLM */,
        category: "USER" /* USER */
      });
    }
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: void 0 };
}
var imageMediaTypeSignatures = [
  {
    mediaType: "image/gif",
    bytesPrefix: [71, 73, 70],
    base64Prefix: "R0lG"
  },
  {
    mediaType: "image/png",
    bytesPrefix: [137, 80, 78, 71],
    base64Prefix: "iVBORw"
  },
  {
    mediaType: "image/jpeg",
    bytesPrefix: [255, 216],
    base64Prefix: "/9j/"
  },
  {
    mediaType: "image/webp",
    bytesPrefix: [82, 73, 70, 70],
    base64Prefix: "UklGRg"
  },
  {
    mediaType: "image/bmp",
    bytesPrefix: [66, 77],
    base64Prefix: "Qk"
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0],
    base64Prefix: "SUkqAA"
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42],
    base64Prefix: "TU0AKg"
  },
  {
    mediaType: "image/avif",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 97, 118, 105, 102],
    base64Prefix: "AAAAIGZ0eXBhdmlm"
  },
  {
    mediaType: "image/heic",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 104, 101, 105, 99],
    base64Prefix: "AAAAIGZ0eXBoZWlj"
  }
];
var stripID3 = (data) => {
  const bytes = typeof data === "string" ? providerUtilsV5.convertBase64ToUint8Array(data) : data;
  const id3Size = (
    // @ts-ignore
    (bytes[6] & 127) << 21 | // @ts-ignore
    (bytes[7] & 127) << 14 | // @ts-ignore
    (bytes[8] & 127) << 7 | // @ts-ignore
    bytes[9] & 127
  );
  return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
  data[1] === 68 && // 'D'
  data[2] === 51;
  return hasId3 ? stripID3(data) : data;
}
function detectMediaType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent(data);
  for (const signature of signatures) {
    if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index) => processedData[index] === byte)) {
      return signature.mediaType;
    }
  }
  return void 0;
}

// src/agent/message-list/prompt/convert-file.ts
function convertImageFilePart(part, downloadedAssets) {
  let originalData;
  const type = part.type;
  switch (type) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  const { data: convertedData, mediaType: convertedMediaType } = convertToDataContent(originalData);
  let mediaType = convertedMediaType ?? part.mediaType;
  let data = convertedData;
  if (data instanceof URL && downloadedAssets) {
    const downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile) {
      data = downloadedFile.data;
      mediaType ??= downloadedFile.mediaType;
    }
  }
  switch (type) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string") {
        mediaType = detectMediaType({ data, signatures: imageMediaTypeSignatures }) ?? mediaType;
      }
      return {
        type: "file",
        mediaType: mediaType ?? "image/*",
        // any image
        filename: void 0,
        data,
        providerOptions: part.providerOptions
      };
    }
    case "file": {
      if (mediaType == null) {
        throw new Error(`Media type is missing for file part`);
      }
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions
      };
    }
  }
}
zod.z.union([
  zod.z.string(),
  zod.z.instanceof(Uint8Array),
  zod.z.instanceof(ArrayBuffer),
  zod.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => globalThis.Buffer?.isBuffer(value) ?? false,
    { message: "Must be a Buffer" }
  )
]);
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return chunkSVLMF4UZ_cjs.convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return chunkSVLMF4UZ_cjs.convertUint8ArrayToBase64(content);
}

// src/agent/message-list/prompt/image-utils.ts
function parseDataUri(dataUri) {
  if (!dataUri.startsWith("data:")) {
    return {
      isDataUri: false,
      base64Content: dataUri
    };
  }
  const base64Index = dataUri.indexOf(",");
  if (base64Index === -1) {
    return {
      isDataUri: true,
      base64Content: dataUri
    };
  }
  const header = dataUri.substring(5, base64Index);
  const base64Content = dataUri.substring(base64Index + 1);
  const semicolonIndex = header.indexOf(";");
  const mimeType = semicolonIndex !== -1 ? header.substring(0, semicolonIndex) : header;
  return {
    isDataUri: true,
    mimeType: mimeType || void 0,
    base64Content
  };
}
function createDataUri(base64Content, mimeType = "application/octet-stream") {
  if (base64Content.startsWith("data:")) {
    return base64Content;
  }
  return `data:${mimeType};base64,${base64Content}`;
}
function imageContentToString(image, fallbackMimeType) {
  if (typeof image === "string") {
    return image;
  }
  if (image instanceof URL) {
    return image.toString();
  }
  if (image instanceof Uint8Array || image instanceof ArrayBuffer || globalThis.Buffer && Buffer.isBuffer(image)) {
    const base64 = convertDataContentToBase64String(image);
    return base64;
  }
  return String(image);
}
function getImageCacheKey(image) {
  if (image instanceof URL) {
    return image.toString();
  }
  if (typeof image === "string") {
    return image.length;
  }
  if (image instanceof Uint8Array) {
    return image.byteLength;
  }
  if (image instanceof ArrayBuffer) {
    return image.byteLength;
  }
  return image;
}
function isValidUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    if (str.startsWith("//")) {
      try {
        new URL(`https:${str}`);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
}
function categorizeFileData(data, fallbackMimeType) {
  const parsed = parseDataUri(data);
  const mimeType = parsed.isDataUri && parsed.mimeType ? parsed.mimeType : fallbackMimeType;
  if (parsed.isDataUri) {
    return {
      type: "dataUri",
      mimeType,
      data
    };
  }
  if (isValidUrl(data)) {
    return {
      type: "url",
      mimeType,
      data
    };
  }
  return {
    type: "raw",
    mimeType,
    data
  };
}

// src/agent/message-list/prompt/attachments-to-parts.ts
function attachmentsToParts(attachments) {
  const parts = [];
  for (const attachment of attachments) {
    const categorized = categorizeFileData(attachment.url, attachment.contentType);
    let urlString = attachment.url;
    if (categorized.type === "raw") {
      urlString = createDataUri(attachment.url, attachment.contentType || "application/octet-stream");
    }
    let url;
    try {
      url = new URL(urlString);
    } catch {
      throw new Error(`Invalid URL: ${attachment.url}`);
    }
    switch (url.protocol) {
      case "http:":
      case "https:": {
        if (attachment.contentType?.startsWith("image/")) {
          parts.push({ type: "image", image: url.toString(), mimeType: attachment.contentType });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image, it must specify a content type");
          }
          parts.push({
            type: "file",
            data: url.toString(),
            mimeType: attachment.contentType
          });
        }
        break;
      }
      case "data:": {
        if (attachment.contentType?.startsWith("image/")) {
          parts.push({
            type: "image",
            image: urlString,
            mimeType: attachment.contentType
          });
        } else if (attachment.contentType?.startsWith("text/")) {
          parts.push({
            type: "file",
            data: urlString,
            mimeType: attachment.contentType
          });
        } else {
          if (!attachment.contentType) {
            throw new Error("If the attachment is not an image or text, it must specify a content type");
          }
          parts.push({
            type: "file",
            data: urlString,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      default: {
        throw new Error(`Unsupported URL protocol: ${url.protocol}`);
      }
    }
  }
  return parts;
}

// src/agent/message-list/prompt/convert-to-mastra-v1.ts
var makePushOrCombine = (v1Messages) => {
  const idUsageCount = /* @__PURE__ */ new Map();
  const SPLIT_SUFFIX_PATTERN = /__split-\d+$/;
  return (msg) => {
    const previousMessage = v1Messages.at(-1);
    if (msg.role === previousMessage?.role && Array.isArray(previousMessage.content) && Array.isArray(msg.content) && // we were creating new messages for tool calls before and not appending to the assistant message
    // so don't append here so everything works as before
    (msg.role !== `assistant` || msg.role === `assistant` && msg.content.at(-1)?.type !== `tool-call`)) {
      for (const part of msg.content) {
        previousMessage.content.push(part);
      }
    } else {
      let baseId = msg.id;
      const hasSplitSuffix = SPLIT_SUFFIX_PATTERN.test(baseId);
      if (hasSplitSuffix) {
        v1Messages.push(msg);
        return;
      }
      const currentCount = idUsageCount.get(baseId) || 0;
      if (currentCount > 0) {
        msg.id = `${baseId}__split-${currentCount}`;
      }
      idUsageCount.set(baseId, currentCount + 1);
      v1Messages.push(msg);
    }
  };
};
function convertToV1Messages(messages) {
  const v1Messages = [];
  const pushOrCombine = makePushOrCombine(v1Messages);
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const isLastMessage = i === messages.length - 1;
    if (!message?.content) continue;
    const { content, experimental_attachments: inputAttachments = [], parts: inputParts } = message.content;
    const { role } = message;
    const fields = {
      id: message.id,
      createdAt: message.createdAt,
      resourceId: message.resourceId,
      threadId: message.threadId
    };
    const experimental_attachments = [...inputAttachments];
    const parts = [];
    for (const part of inputParts) {
      if (part.type === "file") {
        experimental_attachments.push({
          url: part.data,
          contentType: part.mimeType
        });
      } else {
        parts.push(part);
      }
    }
    switch (role) {
      case "user": {
        if (parts == null) {
          const userContent = experimental_attachments ? [{ type: "text", text: content || "" }, ...attachmentsToParts(experimental_attachments)] : { type: "text", text: content || "" };
          pushOrCombine({
            role: "user",
            ...fields,
            type: "text",
            // @ts-ignore
            content: userContent
          });
        } else {
          const textParts = message.content.parts.filter((part) => part.type === "text").map((part) => ({
            type: "text",
            text: part.text
          }));
          const userContent = experimental_attachments ? [...textParts, ...attachmentsToParts(experimental_attachments)] : textParts;
          pushOrCombine({
            role: "user",
            ...fields,
            type: "text",
            content: Array.isArray(userContent) && userContent.length === 1 && userContent[0]?.type === `text` && typeof content !== `undefined` ? content : userContent
          });
        }
        break;
      }
      case "assistant": {
        if (message.content.parts != null) {
          let processBlock2 = function() {
            const content2 = [];
            for (const part of block) {
              switch (part.type) {
                case "file":
                case "text": {
                  content2.push(part);
                  break;
                }
                case "reasoning": {
                  for (const detail of part.details) {
                    switch (detail.type) {
                      case "text":
                        content2.push({
                          type: "reasoning",
                          text: detail.text,
                          signature: detail.signature
                        });
                        break;
                      case "redacted":
                        content2.push({
                          type: "redacted-reasoning",
                          data: detail.data
                        });
                        break;
                    }
                  }
                  break;
                }
                case "tool-invocation":
                  if (part.toolInvocation.toolName !== "updateWorkingMemory") {
                    content2.push({
                      type: "tool-call",
                      toolCallId: part.toolInvocation.toolCallId,
                      toolName: part.toolInvocation.toolName,
                      args: part.toolInvocation.args
                    });
                  }
                  break;
              }
            }
            pushOrCombine({
              role: "assistant",
              ...fields,
              type: content2.some((c) => c.type === `tool-call`) ? "tool-call" : "text",
              content: typeof content2 !== `string` && Array.isArray(content2) && content2.length === 1 && content2[0]?.type === `text` ? content2[0].text : content2
            });
            const stepInvocations = block.filter((part) => `type` in part && part.type === "tool-invocation").map((part) => part.toolInvocation).filter((ti) => ti.toolName !== "updateWorkingMemory");
            const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
            if (invocationsWithResults.length > 0) {
              pushOrCombine({
                role: "tool",
                ...fields,
                type: "tool-result",
                content: invocationsWithResults.map((toolInvocation) => {
                  const { toolCallId, toolName, result } = toolInvocation;
                  return {
                    type: "tool-result",
                    toolCallId,
                    toolName,
                    result
                  };
                })
              });
            }
            block = [];
            blockHasToolInvocations = false;
            currentStep++;
          };
          let currentStep = 0;
          let blockHasToolInvocations = false;
          let block = [];
          for (const part of message.content.parts) {
            switch (part.type) {
              case "text": {
                if (blockHasToolInvocations) {
                  processBlock2();
                }
                block.push(part);
                break;
              }
              case "file":
              case "reasoning": {
                block.push(part);
                break;
              }
              case "tool-invocation": {
                const hasNonToolContent = block.some(
                  (p) => p.type === "text" || p.type === "file" || p.type === "reasoning"
                );
                if (hasNonToolContent || (part.toolInvocation.step ?? 0) !== currentStep) {
                  processBlock2();
                }
                block.push(part);
                blockHasToolInvocations = true;
                break;
              }
            }
          }
          processBlock2();
          const toolInvocations2 = message.content.toolInvocations;
          if (toolInvocations2 && toolInvocations2.length > 0) {
            const processedToolCallIds = /* @__PURE__ */ new Set();
            for (const part of message.content.parts) {
              if (part.type === "tool-invocation" && part.toolInvocation.toolCallId) {
                processedToolCallIds.add(part.toolInvocation.toolCallId);
              }
            }
            const unprocessedToolInvocations = toolInvocations2.filter(
              (ti) => !processedToolCallIds.has(ti.toolCallId) && ti.toolName !== "updateWorkingMemory"
            );
            if (unprocessedToolInvocations.length > 0) {
              const invocationsByStep = /* @__PURE__ */ new Map();
              for (const inv of unprocessedToolInvocations) {
                const step = inv.step ?? 0;
                if (!invocationsByStep.has(step)) {
                  invocationsByStep.set(step, []);
                }
                invocationsByStep.get(step).push(inv);
              }
              const sortedSteps = Array.from(invocationsByStep.keys()).sort((a, b) => a - b);
              for (const step of sortedSteps) {
                const stepInvocations = invocationsByStep.get(step);
                pushOrCombine({
                  role: "assistant",
                  ...fields,
                  type: "tool-call",
                  content: [
                    ...stepInvocations.map(({ toolCallId, toolName, args }) => ({
                      type: "tool-call",
                      toolCallId,
                      toolName,
                      args
                    }))
                  ]
                });
                const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
                if (invocationsWithResults.length > 0) {
                  pushOrCombine({
                    role: "tool",
                    ...fields,
                    type: "tool-result",
                    content: invocationsWithResults.map((toolInvocation) => {
                      const { toolCallId, toolName, result } = toolInvocation;
                      return {
                        type: "tool-result",
                        toolCallId,
                        toolName,
                        result
                      };
                    })
                  });
                }
              }
            }
          }
          break;
        }
        const toolInvocations = message.content.toolInvocations;
        if (toolInvocations == null || toolInvocations.length === 0) {
          pushOrCombine({ role: "assistant", ...fields, content: content || "", type: "text" });
          break;
        }
        const maxStep = toolInvocations.reduce((max, toolInvocation) => {
          return Math.max(max, toolInvocation.step ?? 0);
        }, 0);
        for (let i2 = 0; i2 <= maxStep; i2++) {
          const stepInvocations = toolInvocations.filter(
            (toolInvocation) => (toolInvocation.step ?? 0) === i2 && toolInvocation.toolName !== "updateWorkingMemory"
          );
          if (stepInvocations.length === 0) {
            continue;
          }
          pushOrCombine({
            role: "assistant",
            ...fields,
            type: "tool-call",
            content: [
              ...isLastMessage && content && i2 === 0 ? [{ type: "text", text: content }] : [],
              ...stepInvocations.map(({ toolCallId, toolName, args }) => ({
                type: "tool-call",
                toolCallId,
                toolName,
                args
              }))
            ]
          });
          const invocationsWithResults = stepInvocations.filter((ti) => ti.state === "result" && "result" in ti);
          if (invocationsWithResults.length > 0) {
            pushOrCombine({
              role: "tool",
              ...fields,
              type: "tool-result",
              content: invocationsWithResults.map((toolInvocation) => {
                const { toolCallId, toolName, result } = toolInvocation;
                return {
                  type: "tool-result",
                  toolCallId,
                  toolName,
                  result
                };
              })
            });
          }
        }
        if (content && !isLastMessage) {
          pushOrCombine({ role: "assistant", ...fields, type: "text", content: content || "" });
        }
        break;
      }
    }
  }
  return v1Messages;
}

// src/utils/fetchWithRetry.ts
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let retryCount = 0;
  let lastError = null;
  while (retryCount < maxRetries) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        if (response.status >= 400 && response.status < 500) {
          throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);
        }
        lastError = new Error(`Request failed with status: ${response.status} ${response.statusText}`);
        retryCount++;
        if (retryCount >= maxRetries) {
          throw lastError;
        }
        const delay = Math.min(1e3 * Math.pow(2, retryCount), 1e4);
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }
      return response;
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (lastError.message.includes("status: 4")) {
        throw lastError;
      }
      retryCount++;
      if (retryCount >= maxRetries) {
        break;
      }
      const delay = Math.min(1e3 * Math.pow(2, retryCount), 1e4);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw lastError || new Error("Request failed after multiple retry attempts");
}

// src/agent/message-list/prompt/download-assets.ts
var downloadFromUrl = async ({ url, downloadRetries }) => {
  const urlText = url.toString();
  try {
    const response = await fetchWithRetry(
      urlText,
      {
        method: "GET"
      },
      downloadRetries
    );
    if (!response.ok) {
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "DOWNLOAD_ASSETS_FAILED",
        text: "Failed to download asset",
        domain: "LLM" /* LLM */,
        category: "USER" /* USER */
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mediaType: response.headers.get("content-type") ?? void 0
    };
  } catch (error) {
    throw new chunkTWH4PTDG_cjs.MastraError(
      {
        id: "DOWNLOAD_ASSETS_FAILED",
        text: "Failed to download asset",
        domain: "LLM" /* LLM */,
        category: "USER" /* USER */
      },
      error
    );
  }
};
async function downloadAssetsFromMessages({
  messages,
  downloadConcurrency = 10,
  downloadRetries = 3,
  supportedUrls
}) {
  const pMap = (await import('p-map')).default;
  const filesToDownload = messages.filter((message) => message.role === "user").map((message) => message.content).filter((content) => Array.isArray(content)).flat().filter((part) => part.type === "image" || part.type === "file").map((part) => {
    const mediaType = part.mediaType ?? (part.type === "image" ? "image/*" : void 0);
    let data = part.type === "image" ? part.image : part.data;
    if (typeof data === "string") {
      try {
        data = new URL(data);
      } catch {
      }
    }
    return { mediaType, data };
  }).filter((part) => part.data instanceof URL).map((part) => {
    return {
      url: part.data,
      isUrlSupportedByModel: part.mediaType != null && providerUtilsV5.isUrlSupported({
        url: part.data.toString(),
        mediaType: part.mediaType,
        supportedUrls: supportedUrls ?? {}
      })
    };
  });
  const downloadedFiles = await pMap(
    filesToDownload,
    async (fileItem) => {
      if (fileItem.isUrlSupportedByModel) {
        return null;
      }
      return {
        url: fileItem.url.toString(),
        ...await downloadFromUrl({ url: fileItem.url, downloadRetries })
      };
    },
    {
      concurrency: downloadConcurrency
    }
  );
  const downloadFileList = downloadedFiles.filter(
    (downloadedFile) => downloadedFile?.data != null
  ).map(({ url, data, mediaType }) => [url, { data, mediaType }]);
  return Object.fromEntries(downloadFileList);
}

// src/agent/message-list/utils/ai-v5/gemini-compatibility.ts
function ensureGeminiCompatibleMessages(messages) {
  const result = [...messages];
  const firstNonSystemIndex = result.findIndex((m) => m.role !== "system");
  if (firstNonSystemIndex === -1) {
    throw new chunkTWH4PTDG_cjs.MastraError({
      id: "NO_USER_OR_ASSISTANT_MESSAGES",
      domain: "AGENT" /* AGENT */,
      category: "USER" /* USER */,
      text: "This request does not contain any user or assistant messages. At least one user or assistant message is required to generate a response."
    });
  } else if (result[firstNonSystemIndex]?.role === "assistant") {
    result.splice(firstNonSystemIndex, 0, {
      role: "user",
      content: "."
    });
  }
  return result;
}

// src/agent/message-list/utils/ai-v5/tool.ts
function getToolName(type) {
  if (typeof type === "object" && type && "type" in type) {
    type = type.type;
  }
  if (typeof type !== "string") {
    return "unknown";
  }
  if (type === "dynamic-tool") {
    return "dynamic-tool";
  }
  if (type.startsWith("tool-")) {
    return type.slice("tool-".length);
  }
  return type;
}

// src/agent/message-list/utils/convert-messages.ts
var MessageConverter = class {
  messageList;
  constructor(messages) {
    this.messageList = new MessageList();
    this.messageList.add(messages, "memory");
  }
  to(format) {
    switch (format) {
      // Old format keys (backward compatibility)
      case "Mastra.V2":
        return this.messageList.get.all.db();
      case "AIV4.UI":
        return this.messageList.get.all.aiV4.ui();
      case "AIV4.Core":
        return this.messageList.get.all.aiV4.core();
      case "AIV5.UI":
        return this.messageList.get.all.aiV5.ui();
      case "AIV5.Model":
        return this.messageList.get.all.aiV5.model();
      default:
        throw new Error(`Unsupported output format: ${format}`);
    }
  }
};
function convertMessages(messages) {
  return new MessageConverter(messages);
}

// src/agent/message-list/index.ts
var MessageList = class _MessageList {
  messages = [];
  // passed in by dev in input or context
  systemMessages = [];
  // passed in by us for a specific purpose, eg memory system message
  taggedSystemMessages = {};
  memoryInfo = null;
  // used to filter this.messages by how it was added: input/response/memory
  memoryMessages = /* @__PURE__ */ new Set();
  newUserMessages = /* @__PURE__ */ new Set();
  newResponseMessages = /* @__PURE__ */ new Set();
  userContextMessages = /* @__PURE__ */ new Set();
  memoryMessagesPersisted = /* @__PURE__ */ new Set();
  newUserMessagesPersisted = /* @__PURE__ */ new Set();
  newResponseMessagesPersisted = /* @__PURE__ */ new Set();
  userContextMessagesPersisted = /* @__PURE__ */ new Set();
  generateMessageId;
  _agentNetworkAppend = false;
  constructor({
    threadId,
    resourceId,
    generateMessageId,
    // @ts-ignore Flag for agent network messages
    _agentNetworkAppend
  } = {}) {
    if (threadId) {
      this.memoryInfo = { threadId, resourceId };
    }
    this.generateMessageId = generateMessageId;
    this._agentNetworkAppend = _agentNetworkAppend || false;
  }
  add(messages, messageSource) {
    if (messageSource === `user`) messageSource = `input`;
    if (!messages) return this;
    for (const message of Array.isArray(messages) ? messages : [messages]) {
      this.addOne(
        typeof message === `string` ? {
          role: "user",
          content: message
        } : message,
        messageSource
      );
    }
    return this;
  }
  serializeSet(set) {
    return Array.from(set).map((value) => value.id);
  }
  deserializeSet(ids) {
    return new Set(ids.map((id) => this.messages.find((m) => m.id === id)).filter(Boolean));
  }
  serializeMessage(message) {
    return {
      ...message,
      createdAt: message.createdAt.toUTCString()
    };
  }
  deserializeMessage(state) {
    return {
      ...state,
      createdAt: new Date(state.createdAt)
    };
  }
  serialize() {
    return {
      messages: this.messages.map(this.serializeMessage),
      systemMessages: this.systemMessages,
      taggedSystemMessages: this.taggedSystemMessages,
      memoryInfo: this.memoryInfo,
      _agentNetworkAppend: this._agentNetworkAppend,
      memoryMessages: this.serializeSet(this.memoryMessages),
      newUserMessages: this.serializeSet(this.newUserMessages),
      newResponseMessages: this.serializeSet(this.newResponseMessages),
      userContextMessages: this.serializeSet(this.userContextMessages),
      memoryMessagesPersisted: this.serializeSet(this.memoryMessagesPersisted),
      newUserMessagesPersisted: this.serializeSet(this.newUserMessagesPersisted),
      newResponseMessagesPersisted: this.serializeSet(this.newResponseMessagesPersisted),
      userContextMessagesPersisted: this.serializeSet(this.userContextMessagesPersisted)
    };
  }
  deserialize(state) {
    this.messages = state.messages.map(this.deserializeMessage);
    this.systemMessages = state.systemMessages;
    this.taggedSystemMessages = state.taggedSystemMessages;
    this.memoryInfo = state.memoryInfo;
    this._agentNetworkAppend = state._agentNetworkAppend;
    this.memoryMessages = this.deserializeSet(state.memoryMessages);
    this.newUserMessages = this.deserializeSet(state.newUserMessages);
    this.newResponseMessages = this.deserializeSet(state.newResponseMessages);
    this.userContextMessages = this.deserializeSet(state.userContextMessages);
    this.memoryMessagesPersisted = this.deserializeSet(state.memoryMessagesPersisted);
    this.newUserMessagesPersisted = this.deserializeSet(state.newUserMessagesPersisted);
    this.newResponseMessagesPersisted = this.deserializeSet(state.newResponseMessagesPersisted);
    this.userContextMessagesPersisted = this.deserializeSet(state.userContextMessagesPersisted);
    return this;
  }
  getLatestUserContent() {
    const currentUserMessages = this.all.core().filter((m) => m.role === "user");
    const content = currentUserMessages.at(-1)?.content;
    if (!content) return null;
    return _MessageList.coreContentToString(content);
  }
  get get() {
    return {
      all: this.all,
      remembered: this.remembered,
      input: this.input,
      response: this.response
    };
  }
  get getPersisted() {
    return {
      remembered: this.rememberedPersisted,
      input: this.inputPersisted,
      taggedSystemMessages: this.taggedSystemMessages,
      response: this.responsePersisted
    };
  }
  get clear() {
    return {
      input: {
        db: () => {
          const userMessages = Array.from(this.newUserMessages);
          this.messages = this.messages.filter((m) => !this.newUserMessages.has(m));
          this.newUserMessages.clear();
          return userMessages;
        }
      },
      response: {
        db: () => {
          const responseMessages = Array.from(this.newResponseMessages);
          this.messages = this.messages.filter((m) => !this.newResponseMessages.has(m));
          this.newResponseMessages.clear();
          return responseMessages;
        }
      }
    };
  }
  all = {
    db: () => this.messages,
    v1: () => convertToV1Messages(this.all.db()),
    aiV5: {
      model: () => this.aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui()),
      ui: () => this.all.db().map(_MessageList.mastraDBMessageToAIV5UIMessage),
      // Used when calling AI SDK streamText/generateText
      prompt: () => {
        const systemMessages = this.aiV4CoreMessagesToAIV5ModelMessages(
          [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()],
          `system`
        );
        const modelMessages = this.aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui(), true);
        const messages = [...systemMessages, ...modelMessages];
        return ensureGeminiCompatibleMessages(messages);
      },
      // Used for creating LLM prompt messages without AI SDK streamText/generateText
      llmPrompt: async (options = {
        downloadConcurrency: 10,
        downloadRetries: 3
      }) => {
        const modelMessages = this.aiV5UIMessagesToAIV5ModelMessages(this.all.aiV5.ui(), true);
        const systemMessages = this.aiV4CoreMessagesToAIV5ModelMessages(
          [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()],
          `system`
        );
        const downloadedAssets = await downloadAssetsFromMessages({
          messages: modelMessages,
          downloadConcurrency: options?.downloadConcurrency,
          downloadRetries: options?.downloadRetries,
          supportedUrls: options?.supportedUrls
        });
        let messages = [...systemMessages, ...modelMessages];
        const hasImageOrFileContent = modelMessages.some(
          (message) => message.role === "user" && typeof message.content !== "string" && message.content.some((part) => part.type === "image" || part.type === "file")
        );
        if (hasImageOrFileContent) {
          messages = messages.map((message) => {
            if (message.role === "user") {
              if (typeof message.content === "string") {
                return {
                  role: "user",
                  content: [{ type: "text", text: message.content }],
                  providerOptions: message.providerOptions
                };
              }
              const convertedContent = message.content.map((part) => {
                if (part.type === "image" || part.type === "file") {
                  return convertImageFilePart(part, downloadedAssets);
                }
                return part;
              }).filter((part) => part.type !== "text" || part.text !== "");
              return {
                role: "user",
                content: convertedContent,
                providerOptions: message.providerOptions
              };
            }
            return message;
          });
        }
        messages = ensureGeminiCompatibleMessages(messages);
        return messages.map(_MessageList.aiV5ModelMessageToV2PromptMessage);
      }
    },
    /* @deprecated use list.get.all.aiV4.prompt() instead */
    prompt: () => this.all.aiV4.prompt(),
    /* @deprecated use list.get.all.aiV4.ui() */
    ui: () => this.all.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
    /* @deprecated use list.get.all.aiV4.core() */
    core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
    aiV4: {
      ui: () => this.all.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
      core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
      // Used when calling AI SDK streamText/generateText
      prompt: () => {
        const coreMessages = this.all.aiV4.core();
        const messages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat(), ...coreMessages];
        return ensureGeminiCompatibleMessages(messages);
      },
      // Used for creating LLM prompt messages without AI SDK streamText/generateText
      llmPrompt: () => {
        const coreMessages = this.all.aiV4.core();
        const systemMessages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat()];
        let messages = [...systemMessages, ...coreMessages];
        messages = ensureGeminiCompatibleMessages(messages);
        return messages.map(_MessageList.aiV4CoreMessageToV1PromptMessage);
      }
    }
  };
  remembered = {
    db: () => this.messages.filter((m) => this.memoryMessages.has(m)),
    v1: () => convertToV1Messages(this.remembered.db()),
    aiV5: {
      model: () => this.aiV5UIMessagesToAIV5ModelMessages(this.remembered.aiV5.ui()),
      ui: () => this.remembered.db().map(_MessageList.mastraDBMessageToAIV5UIMessage)
    },
    /* @deprecated use list.get.remembered.aiV4.ui() */
    ui: () => this.remembered.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
    /* @deprecated use list.get.remembered.aiV4.core() */
    core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui()),
    aiV4: {
      ui: () => this.remembered.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
      core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.all.aiV4.ui())
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  rememberedPersisted = {
    db: () => this.all.db().filter((m) => this.memoryMessagesPersisted.has(m)),
    v1: () => convertToV1Messages(this.rememberedPersisted.db()),
    ui: () => this.rememberedPersisted.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
    core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.rememberedPersisted.ui())
  };
  input = {
    db: () => this.messages.filter((m) => this.newUserMessages.has(m)),
    v1: () => convertToV1Messages(this.input.db()),
    aiV5: {
      model: () => this.aiV5UIMessagesToAIV5ModelMessages(this.input.aiV5.ui()),
      ui: () => this.input.db().map(_MessageList.mastraDBMessageToAIV5UIMessage)
    },
    /* @deprecated use list.get.input.aiV4.ui() instead */
    ui: () => this.input.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
    /* @deprecated use list.get.core.aiV4.ui() instead */
    core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.input.ui()),
    aiV4: {
      ui: () => this.input.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
      core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.input.aiV4.ui())
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  inputPersisted = {
    db: () => this.messages.filter((m) => this.newUserMessagesPersisted.has(m)),
    v1: () => convertToV1Messages(this.inputPersisted.db()),
    ui: () => this.inputPersisted.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
    core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.inputPersisted.ui())
  };
  response = {
    db: () => this.messages.filter((m) => this.newResponseMessages.has(m)),
    v1: () => convertToV1Messages(this.response.db()),
    aiV5: {
      ui: () => this.response.db().map(_MessageList.mastraDBMessageToAIV5UIMessage),
      model: () => this.aiV5UIMessagesToAIV5ModelMessages(this.response.aiV5.ui()).filter(
        (m) => m.role === `tool` || m.role === `assistant`
      ),
      modelContent: (stepNumber) => {
        if (typeof stepNumber === "number") {
          const uiMessages = this.response.aiV5.ui();
          const uiMessagesParts = uiMessages.flatMap((item) => item.parts);
          const stepBoundaries = [];
          uiMessagesParts.forEach((part, index) => {
            if (part.type === "step-start") {
              stepBoundaries.push(index);
            }
          });
          if (stepNumber === -1) {
            const toolParts = uiMessagesParts.filter((p) => p.type?.startsWith("tool-"));
            const hasStepStart = stepBoundaries.length > 0;
            if (!hasStepStart && toolParts.length > 0) {
              const lastToolPart = toolParts[toolParts.length - 1];
              if (!lastToolPart) {
                return [];
              }
              const lastToolIndex = uiMessagesParts.indexOf(lastToolPart);
              const previousToolPart = toolParts[toolParts.length - 2];
              const previousToolIndex = previousToolPart ? uiMessagesParts.indexOf(previousToolPart) : -1;
              const startIndex2 = previousToolIndex + 1;
              const stepParts3 = uiMessagesParts.slice(startIndex2, lastToolIndex + 1);
              const stepUiMessages3 = [
                {
                  id: "last-step",
                  role: "assistant",
                  parts: stepParts3
                }
              ];
              const modelMessages3 = AIV5__namespace.convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages3));
              return modelMessages3.flatMap(this.response.aiV5.stepContent);
            }
            const totalSteps = stepBoundaries.length + 1;
            if (totalSteps === 1 && !hasStepStart) {
              const stepUiMessages3 = [
                {
                  id: "last-step",
                  role: "assistant",
                  parts: uiMessagesParts
                }
              ];
              const modelMessages3 = AIV5__namespace.convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages3));
              return modelMessages3.flatMap(this.response.aiV5.stepContent);
            }
            const lastStepStart = stepBoundaries[stepBoundaries.length - 1];
            if (lastStepStart === void 0) {
              return [];
            }
            const stepParts2 = uiMessagesParts.slice(lastStepStart + 1);
            if (stepParts2.length === 0) {
              return [];
            }
            const stepUiMessages2 = [
              {
                id: "last-step",
                role: "assistant",
                parts: stepParts2
              }
            ];
            const modelMessages2 = AIV5__namespace.convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages2));
            return modelMessages2.flatMap(this.response.aiV5.stepContent);
          }
          if (stepNumber === 1) {
            const firstStepStart = stepBoundaries[0] ?? uiMessagesParts.length;
            if (firstStepStart === 0) {
              return [];
            }
            const stepParts2 = uiMessagesParts.slice(0, firstStepStart);
            const stepUiMessages2 = [
              {
                id: "step-1",
                role: "assistant",
                parts: stepParts2
              }
            ];
            const modelMessages2 = AIV5__namespace.convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages2));
            return modelMessages2.flatMap(this.response.aiV5.stepContent);
          }
          const stepIndex = stepNumber - 2;
          if (stepIndex < 0 || stepIndex >= stepBoundaries.length) {
            return [];
          }
          const startIndex = (stepBoundaries[stepIndex] ?? 0) + 1;
          const endIndex = stepBoundaries[stepIndex + 1] ?? uiMessagesParts.length;
          if (startIndex >= endIndex) {
            return [];
          }
          const stepParts = uiMessagesParts.slice(startIndex, endIndex);
          const stepUiMessages = [
            {
              id: `step-${stepNumber}`,
              role: "assistant",
              parts: stepParts
            }
          ];
          const modelMessages = AIV5__namespace.convertToModelMessages(this.sanitizeV5UIMessages(stepUiMessages));
          return modelMessages.flatMap(this.response.aiV5.stepContent);
        }
        return this.response.aiV5.model().map(this.response.aiV5.stepContent).flat();
      },
      stepContent: (message) => {
        const latest = message ? message : this.response.aiV5.model().at(-1);
        if (!latest) return [];
        if (typeof latest.content === `string`) {
          return [{ type: "text", text: latest.content }];
        }
        return latest.content.map((c) => {
          if (c.type === `tool-result`)
            return {
              type: "tool-result",
              input: {},
              // TODO: we need to find the tool call here and add the input from it
              output: c.output,
              toolCallId: c.toolCallId,
              toolName: c.toolName
            };
          if (c.type === `file`)
            return {
              type: "file",
              file: new DefaultGeneratedFileWithType({
                data: typeof c.data === `string` ? parseDataUri(c.data).base64Content : c.data instanceof URL ? c.data.toString() : convertDataContentToBase64String(c.data),
                mediaType: c.mediaType
              })
            };
          if (c.type === `image`) {
            return {
              type: "file",
              file: new DefaultGeneratedFileWithType({
                data: typeof c.image === `string` ? parseDataUri(c.image).base64Content : c.image instanceof URL ? c.image.toString() : convertDataContentToBase64String(c.image),
                mediaType: c.mediaType || "unknown"
              })
            };
          }
          return { ...c };
        });
      }
    },
    aiV4: {
      ui: () => this.response.db().map(_MessageList.mastraDBMessageToAIV4UIMessage),
      core: () => this.aiV4UIMessagesToAIV4CoreMessages(this.response.aiV4.ui())
    }
  };
  // TODO: need to update this for new .aiV4/5.x() pattern
  responsePersisted = {
    db: () => this.messages.filter((m) => this.newResponseMessagesPersisted.has(m)),
    ui: () => this.responsePersisted.db().map(_MessageList.mastraDBMessageToAIV4UIMessage)
  };
  drainUnsavedMessages() {
    const messages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));
    this.newUserMessages.clear();
    this.newResponseMessages.clear();
    return messages;
  }
  getEarliestUnsavedMessageTimestamp() {
    const unsavedMessages = this.messages.filter((m) => this.newUserMessages.has(m) || this.newResponseMessages.has(m));
    if (unsavedMessages.length === 0) return void 0;
    return Math.min(...unsavedMessages.map((m) => new Date(m.createdAt).getTime()));
  }
  getSystemMessages(tag) {
    if (tag) {
      return this.taggedSystemMessages[tag] || [];
    }
    return this.systemMessages;
  }
  addSystem(messages, tag) {
    if (!messages) return this;
    for (const message of Array.isArray(messages) ? messages : [messages]) {
      this.addOneSystem(message, tag);
    }
    return this;
  }
  aiV4UIMessagesToAIV4CoreMessages(messages) {
    return chunkSVLMF4UZ_cjs.convertToCoreMessages(this.sanitizeAIV4UIMessages(messages));
  }
  sanitizeAIV4UIMessages(messages) {
    const msgs = messages.map((m) => {
      if (m.parts.length === 0) return false;
      const safeParts = m.parts.filter(
        (p) => p.type !== `tool-invocation` || // calls and partial-calls should be updated to be results at this point
        // if they haven't we can't send them back to the llm and need to remove them.
        p.toolInvocation.state !== `call` && p.toolInvocation.state !== `partial-call`
      );
      if (!safeParts.length) return false;
      const sanitized = {
        ...m,
        parts: safeParts
      };
      if (`toolInvocations` in m && m.toolInvocations) {
        sanitized.toolInvocations = m.toolInvocations.filter((t) => t.state === `result`);
      }
      return sanitized;
    }).filter((m) => Boolean(m));
    return msgs;
  }
  /**
   * Converts various message formats to AIV4 CoreMessage format for system messages
   * @param message - The message to convert (can be string, MastraDBMessage, or AI SDK message types)
   * @returns AIV4 CoreMessage in the proper format
   */
  systemMessageToAICore(message) {
    if (typeof message === `string`) {
      return { role: "system", content: message };
    }
    if (_MessageList.isAIV5CoreMessage(message)) {
      const dbMsg = _MessageList.aiV5ModelMessageToMastraDBMessage(message, "system");
      return _MessageList.mastraDBMessageSystemToV4Core(dbMsg);
    }
    if (_MessageList.isMastraDBMessage(message)) {
      return _MessageList.mastraDBMessageSystemToV4Core(message);
    }
    return message;
  }
  addOneSystem(message, tag) {
    const coreMessage = this.systemMessageToAICore(message);
    if (coreMessage.role !== `system`) {
      throw new Error(
        `Expected role "system" but saw ${coreMessage.role} for message ${JSON.stringify(coreMessage, null, 2)}`
      );
    }
    if (tag && !this.isDuplicateSystem(coreMessage, tag)) {
      this.taggedSystemMessages[tag] ||= [];
      this.taggedSystemMessages[tag].push(coreMessage);
    } else if (!tag && !this.isDuplicateSystem(coreMessage)) {
      this.systemMessages.push(coreMessage);
    }
  }
  isDuplicateSystem(message, tag) {
    if (tag) {
      if (!this.taggedSystemMessages[tag]) return false;
      return this.taggedSystemMessages[tag].some(
        (m) => _MessageList.cacheKeyFromAIV4CoreMessageContent(m.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(message.content)
      );
    }
    return this.systemMessages.some(
      (m) => _MessageList.cacheKeyFromAIV4CoreMessageContent(m.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(message.content)
    );
  }
  static mastraDBMessageToAIV4UIMessage(m) {
    const experimentalAttachments = m.content.experimental_attachments ? [...m.content.experimental_attachments] : [];
    const contentString = typeof m.content.content === `string` && m.content.content !== "" ? m.content.content : m.content.parts.reduce((prev, part) => {
      if (part.type === `text`) {
        return part.text;
      }
      return prev;
    }, "");
    const parts = [];
    if (m.content.parts.length) {
      for (const part of m.content.parts) {
        if (part.type === `file`) {
          let normalizedUrl;
          if (typeof part.data === "string") {
            const categorized = categorizeFileData(part.data, part.mimeType);
            if (categorized.type === "raw") {
              normalizedUrl = createDataUri(part.data, part.mimeType || "application/octet-stream");
            } else {
              normalizedUrl = part.data;
            }
          } else {
            normalizedUrl = part.data;
          }
          experimentalAttachments.push({
            contentType: part.mimeType,
            url: normalizedUrl
          });
        } else if (part.type === "tool-invocation" && (part.toolInvocation.state === "call" || part.toolInvocation.state === "partial-call")) {
          continue;
        } else if (part.type === "tool-invocation") {
          const toolInvocation = { ...part.toolInvocation };
          let currentStep = -1;
          let toolStep = -1;
          for (const innerPart of m.content.parts) {
            if (innerPart.type === `step-start`) currentStep++;
            if (innerPart.type === `tool-invocation` && innerPart.toolInvocation.toolCallId === part.toolInvocation.toolCallId) {
              toolStep = currentStep;
              break;
            }
          }
          if (toolStep >= 0) {
            const preparedInvocation = {
              step: toolStep,
              ...toolInvocation
            };
            parts.push({
              type: "tool-invocation",
              toolInvocation: preparedInvocation
            });
          } else {
            parts.push({
              type: "tool-invocation",
              toolInvocation
            });
          }
        } else {
          parts.push(part);
        }
      }
    }
    if (parts.length === 0 && experimentalAttachments.length > 0) {
      parts.push({ type: "text", text: "" });
    }
    if (m.role === `user`) {
      const uiMessage2 = {
        id: m.id,
        role: m.role,
        content: m.content.content || contentString,
        createdAt: m.createdAt,
        parts,
        experimental_attachments: experimentalAttachments
      };
      if (m.content.metadata) {
        uiMessage2.metadata = m.content.metadata;
      }
      return uiMessage2;
    } else if (m.role === `assistant`) {
      const isSingleTextContentArray = Array.isArray(m.content.content) && m.content.content.length === 1 && m.content.content[0].type === `text`;
      const uiMessage2 = {
        id: m.id,
        role: m.role,
        content: isSingleTextContentArray ? contentString : m.content.content || contentString,
        createdAt: m.createdAt,
        parts,
        reasoning: void 0,
        toolInvocations: `toolInvocations` in m.content ? m.content.toolInvocations?.filter((t) => t.state === "result") : void 0
      };
      if (m.content.metadata) {
        uiMessage2.metadata = m.content.metadata;
      }
      return uiMessage2;
    }
    const uiMessage = {
      id: m.id,
      role: m.role,
      content: m.content.content || contentString,
      createdAt: m.createdAt,
      parts,
      experimental_attachments: experimentalAttachments
    };
    if (m.content.metadata) {
      uiMessage.metadata = m.content.metadata;
    }
    return uiMessage;
  }
  /**
   * Converts a MastraDBMessage system message directly to AIV4 CoreMessage format
   * This is more efficient than converting to UI message first and then to core
   * @param message - The MastraDBMessage message to convert
   * @returns AIV4 CoreMessage with system role
   */
  static mastraDBMessageSystemToV4Core(message) {
    if (message.role !== `system` || !message.content.content)
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "INVALID_SYSTEM_MESSAGE_FORMAT",
        domain: "AGENT" /* AGENT */,
        category: "USER" /* USER */,
        text: `Invalid system message format. System messages must include 'role' and 'content' properties. The content should be a string.`,
        details: {
          receivedMessage: JSON.stringify(message, null, 2)
        }
      });
    return { role: "system", content: message.content.content };
  }
  getMessageById(id) {
    return this.messages.find((m) => m.id === id);
  }
  shouldReplaceMessage(message) {
    if (!this.messages.length) return { exists: false };
    if (!(`id` in message) || !message?.id) {
      return { exists: false };
    }
    const existingMessage = this.getMessageById(message.id);
    if (!existingMessage) return { exists: false };
    return {
      exists: true,
      shouldReplace: !_MessageList.messagesAreEqual(existingMessage, message),
      id: existingMessage.id
    };
  }
  addOne(message, messageSource) {
    if ((!(`content` in message) || !message.content && // allow empty strings
    typeof message.content !== "string") && (!(`parts` in message) || !message.parts)) {
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "INVALID_MESSAGE_CONTENT",
        domain: "AGENT" /* AGENT */,
        category: "USER" /* USER */,
        text: `Message with role "${message.role}" must have either a 'content' property (string or array) or a 'parts' property (array) that is not empty, null, or undefined. Received message: ${JSON.stringify(message, null, 2)}`,
        details: {
          role: message.role,
          messageSource,
          hasContent: "content" in message,
          hasParts: "parts" in message
        }
      });
    }
    if (message.role === `system`) {
      if (messageSource === `memory`) return null;
      const isSupportedSystemFormat = _MessageList.isAIV4CoreMessage(message) || _MessageList.isAIV5CoreMessage(message) || _MessageList.isMastraDBMessage(message);
      if (isSupportedSystemFormat) {
        return this.addSystem(message);
      }
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "INVALID_SYSTEM_MESSAGE_FORMAT",
        domain: "AGENT" /* AGENT */,
        category: "USER" /* USER */,
        text: `Invalid system message format. System messages must be CoreMessage format with 'role' and 'content' properties. The content should be a string or valid content array.`,
        details: {
          messageSource,
          receivedMessage: JSON.stringify(message, null, 2)
        }
      });
    }
    const messageV2 = this.inputToMastraDBMessage(message, messageSource);
    const { exists, shouldReplace, id } = this.shouldReplaceMessage(messageV2);
    const latestMessage = this.messages.at(-1);
    if (messageSource === `memory`) {
      for (const existingMessage of this.messages) {
        if (_MessageList.messagesAreEqual(existingMessage, messageV2)) {
          return;
        }
      }
    }
    const shouldAppendToLastAssistantMessage = latestMessage?.role === "assistant" && messageV2.role === "assistant" && latestMessage.threadId === messageV2.threadId && // If the message is from memory, don't append to the last assistant message
    messageSource !== "memory";
    const appendNetworkMessage = this._agentNetworkAppend && latestMessage && !this.memoryMessages.has(latestMessage) || !this._agentNetworkAppend;
    if (shouldAppendToLastAssistantMessage && appendNetworkMessage) {
      latestMessage.createdAt = messageV2.createdAt || latestMessage.createdAt;
      const toolResultAnchorMap = /* @__PURE__ */ new Map();
      const partsToAdd = /* @__PURE__ */ new Map();
      for (const [index, part] of messageV2.content.parts.entries()) {
        if (part.type === "tool-invocation") {
          const existingCallPart = [...latestMessage.content.parts].reverse().find((p) => p.type === "tool-invocation" && p.toolInvocation.toolCallId === part.toolInvocation.toolCallId);
          const existingCallToolInvocation = !!existingCallPart && existingCallPart.type === "tool-invocation";
          if (existingCallToolInvocation) {
            if (part.toolInvocation.state === "result") {
              existingCallPart.toolInvocation = {
                ...existingCallPart.toolInvocation,
                step: part.toolInvocation.step,
                state: "result",
                result: part.toolInvocation.result,
                args: {
                  ...existingCallPart.toolInvocation.args,
                  ...part.toolInvocation.args
                }
              };
              if (!latestMessage.content.toolInvocations) {
                latestMessage.content.toolInvocations = [];
              }
              const toolInvocationIndex = latestMessage.content.toolInvocations.findIndex(
                (t) => t.toolCallId === existingCallPart.toolInvocation.toolCallId
              );
              if (toolInvocationIndex === -1) {
                latestMessage.content.toolInvocations.push(existingCallPart.toolInvocation);
              } else {
                latestMessage.content.toolInvocations[toolInvocationIndex] = existingCallPart.toolInvocation;
              }
            }
            const existingIndex = latestMessage.content.parts.findIndex((p) => p === existingCallPart);
            toolResultAnchorMap.set(index, existingIndex);
          } else {
            partsToAdd.set(index, part);
          }
        } else {
          partsToAdd.set(index, part);
        }
      }
      this.addPartsToLatestMessage({
        latestMessage,
        messageV2,
        anchorMap: toolResultAnchorMap,
        partsToAdd
      });
      if (latestMessage.createdAt.getTime() < messageV2.createdAt.getTime()) {
        latestMessage.createdAt = messageV2.createdAt;
      }
      if (!latestMessage.content.content && messageV2.content.content) {
        latestMessage.content.content = messageV2.content.content;
      }
      if (latestMessage.content.content && messageV2.content.content && latestMessage.content.content !== messageV2.content.content) {
        latestMessage.content.content = messageV2.content.content;
      }
      this.pushMessageToSource(latestMessage, messageSource);
    } else {
      let existingIndex = -1;
      if (shouldReplace) {
        existingIndex = this.messages.findIndex((m) => m.id === id);
      }
      const existingMessage = existingIndex !== -1 && this.messages[existingIndex];
      if (shouldReplace && existingMessage) {
        this.messages[existingIndex] = messageV2;
      } else if (!exists) {
        this.messages.push(messageV2);
      }
      this.pushMessageToSource(messageV2, messageSource);
    }
    this.messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
    return this;
  }
  pushMessageToSource(messageV2, messageSource) {
    if (messageSource === `memory`) {
      this.memoryMessages.add(messageV2);
      this.memoryMessagesPersisted.add(messageV2);
    } else if (messageSource === `response`) {
      this.newResponseMessages.add(messageV2);
      this.newResponseMessagesPersisted.add(messageV2);
    } else if (messageSource === `input`) {
      this.newUserMessages.add(messageV2);
      this.newUserMessagesPersisted.add(messageV2);
    } else if (messageSource === `context`) {
      this.userContextMessages.add(messageV2);
      this.userContextMessagesPersisted.add(messageV2);
    } else {
      throw new Error(`Missing message source for message ${messageV2}`);
    }
  }
  /**
   * Pushes a new message part to the latest message.
   * @param latestMessage - The latest message to push the part to.
   * @param newMessage - The new message to push the part from.
   * @param part - The part to push.
   * @param insertAt - The index at which to insert the part. Optional.
   */
  pushNewMessagePart({
    latestMessage,
    newMessage,
    part,
    insertAt
    // optional
  }) {
    const partKey = _MessageList.cacheKeyFromAIV4Parts([part]);
    const latestPartCount = latestMessage.content.parts.filter(
      (p) => _MessageList.cacheKeyFromAIV4Parts([p]) === partKey
    ).length;
    const newPartCount = newMessage.content.parts.filter(
      (p) => _MessageList.cacheKeyFromAIV4Parts([p]) === partKey
    ).length;
    if (latestPartCount < newPartCount) {
      const partIndex = newMessage.content.parts.indexOf(part);
      const hasStepStartBefore = partIndex > 0 && newMessage.content.parts[partIndex - 1]?.type === "step-start";
      const needsStepStart = latestMessage.role === "assistant" && part.type === "text" && !hasStepStartBefore && latestMessage.content.parts.length > 0 && latestMessage.content.parts.at(-1)?.type === "tool-invocation";
      if (typeof insertAt === "number") {
        if (needsStepStart) {
          latestMessage.content.parts.splice(insertAt, 0, { type: "step-start" });
          latestMessage.content.parts.splice(insertAt + 1, 0, part);
        } else {
          latestMessage.content.parts.splice(insertAt, 0, part);
        }
      } else {
        if (needsStepStart) {
          latestMessage.content.parts.push({ type: "step-start" });
        }
        latestMessage.content.parts.push(part);
      }
    }
  }
  /**
   * Upserts parts of messageV2 into latestMessage based on the anchorMap.
   * This is used when appending a message to the last assistant message to ensure that parts are inserted in the correct order.
   * @param latestMessage - The latest message to upsert parts into.
   * @param messageV2 - The message to upsert parts from.
   * @param anchorMap - The anchor map to use for upserting parts.
   */
  addPartsToLatestMessage({
    latestMessage,
    messageV2,
    anchorMap,
    partsToAdd
  }) {
    for (let i = 0; i < messageV2.content.parts.length; ++i) {
      const part = messageV2.content.parts[i];
      if (!part) continue;
      const key = _MessageList.cacheKeyFromAIV4Parts([part]);
      const partToAdd = partsToAdd.get(i);
      if (!key || !partToAdd) continue;
      if (anchorMap.size > 0) {
        if (anchorMap.has(i)) continue;
        const leftAnchorV2 = [...anchorMap.keys()].filter((idx) => idx < i).pop() ?? -1;
        const rightAnchorV2 = [...anchorMap.keys()].find((idx) => idx > i) ?? -1;
        const leftAnchorLatest = leftAnchorV2 !== -1 ? anchorMap.get(leftAnchorV2) : 0;
        const offset = leftAnchorV2 === -1 ? i : i - leftAnchorV2;
        const insertAt = leftAnchorLatest + offset;
        const rightAnchorLatest = rightAnchorV2 !== -1 ? anchorMap.get(rightAnchorV2) : latestMessage.content.parts.length;
        if (insertAt >= 0 && insertAt <= rightAnchorLatest && !latestMessage.content.parts.slice(insertAt, rightAnchorLatest).some((p) => _MessageList.cacheKeyFromAIV4Parts([p]) === _MessageList.cacheKeyFromAIV4Parts([part]))) {
          this.pushNewMessagePart({
            latestMessage,
            newMessage: messageV2,
            part,
            insertAt
          });
          for (const [v2Idx, latestIdx] of anchorMap.entries()) {
            if (latestIdx >= insertAt) {
              anchorMap.set(v2Idx, latestIdx + 1);
            }
          }
        }
      } else {
        this.pushNewMessagePart({
          latestMessage,
          newMessage: messageV2,
          part
        });
      }
    }
  }
  inputToMastraDBMessage(message, messageSource) {
    if (
      // we can't throw if the threadId doesn't match and this message came from memory
      // this is because per-user semantic recall can retrieve messages from other threads
      messageSource !== `memory` && `threadId` in message && message.threadId && this.memoryInfo && message.threadId !== this.memoryInfo.threadId
    ) {
      throw new Error(
        `Received input message with wrong threadId. Input ${message.threadId}, expected ${this.memoryInfo.threadId}`
      );
    }
    if (`resourceId` in message && message.resourceId && this.memoryInfo?.resourceId && message.resourceId !== this.memoryInfo.resourceId) {
      throw new Error(
        `Received input message with wrong resourceId. Input ${message.resourceId}, expected ${this.memoryInfo.resourceId}`
      );
    }
    if (_MessageList.isMastraMessageV1(message)) {
      return this.mastraMessageV1ToMastraDBMessage(message, messageSource);
    }
    if (_MessageList.isMastraDBMessage(message)) {
      return this.hydrateMastraDBMessageFields(message);
    }
    if (_MessageList.isAIV4CoreMessage(message)) {
      return this.aiV4CoreMessageToMastraDBMessage(message, messageSource);
    }
    if (_MessageList.isAIV4UIMessage(message)) {
      return this.aiV4UIMessageToMastraDBMessage(message, messageSource);
    }
    if (_MessageList.isAIV5CoreMessage(message)) {
      const dbMsg = _MessageList.aiV5ModelMessageToMastraDBMessage(message, messageSource);
      const result = {
        ...dbMsg,
        threadId: this.memoryInfo?.threadId,
        resourceId: this.memoryInfo?.resourceId
      };
      return result;
    }
    if (_MessageList.isAIV5UIMessage(message)) {
      const dbMsg = _MessageList.aiV5UIMessageToMastraDBMessage(message);
      return {
        ...dbMsg,
        threadId: this.memoryInfo?.threadId,
        resourceId: this.memoryInfo?.resourceId
      };
    }
    throw new Error(`Found unhandled message ${JSON.stringify(message)}`);
  }
  lastCreatedAt;
  // this makes sure messages added in order will always have a date atleast 1ms apart.
  generateCreatedAt(messageSource, start) {
    start = start instanceof Date ? start : start ? new Date(start) : void 0;
    if (start && !this.lastCreatedAt) {
      this.lastCreatedAt = start.getTime();
      return start;
    }
    if (start && messageSource === `memory`) {
      return start;
    }
    const now = /* @__PURE__ */ new Date();
    const nowTime = start?.getTime() || now.getTime();
    const lastTime = this.messages.reduce((p, m) => {
      if (m.createdAt.getTime() > p) return m.createdAt.getTime();
      return p;
    }, this.lastCreatedAt || 0);
    if (nowTime <= lastTime) {
      const newDate = new Date(lastTime + 1);
      this.lastCreatedAt = newDate.getTime();
      return newDate;
    }
    this.lastCreatedAt = nowTime;
    return now;
  }
  newMessageId() {
    if (this.generateMessageId) {
      return this.generateMessageId();
    }
    return uuid.v4();
  }
  mastraMessageV1ToMastraDBMessage(message, messageSource) {
    const coreV2 = this.aiV4CoreMessageToMastraDBMessage(
      {
        content: message.content,
        role: message.role
      },
      messageSource
    );
    return {
      id: message.id,
      role: coreV2.role,
      createdAt: this.generateCreatedAt(messageSource, message.createdAt),
      threadId: message.threadId,
      resourceId: message.resourceId,
      content: coreV2.content
    };
  }
  hydrateMastraDBMessageFields(message) {
    if (!message.id) {
      message.id = this.newMessageId();
    }
    if (!(message.createdAt instanceof Date)) message.createdAt = new Date(message.createdAt);
    if (message.content.toolInvocations && message.content.parts) {
      message.content.toolInvocations = message.content.toolInvocations.map((ti) => {
        if (!ti.args || Object.keys(ti.args).length === 0) {
          const partWithArgs = message.content.parts.find(
            (part) => part.type === "tool-invocation" && part.toolInvocation && part.toolInvocation.toolCallId === ti.toolCallId && part.toolInvocation.args && Object.keys(part.toolInvocation.args).length > 0
          );
          if (partWithArgs && partWithArgs.type === "tool-invocation") {
            return { ...ti, args: partWithArgs.toolInvocation.args };
          }
        }
        return ti;
      });
    }
    if (!message.threadId && this.memoryInfo?.threadId) {
      message.threadId = this.memoryInfo.threadId;
      if (!message.resourceId && this.memoryInfo?.resourceId) {
        message.resourceId = this.memoryInfo.resourceId;
      }
    }
    return message;
  }
  aiV4UIMessageToMastraDBMessage(message, messageSource) {
    const content = {
      format: 2,
      parts: message.parts
    };
    if (message.toolInvocations) content.toolInvocations = message.toolInvocations;
    if (message.reasoning) content.reasoning = message.reasoning;
    if (message.annotations) content.annotations = message.annotations;
    if (message.experimental_attachments) {
      content.experimental_attachments = message.experimental_attachments;
    }
    if ("metadata" in message && message.metadata !== null && message.metadata !== void 0) {
      content.metadata = message.metadata;
    }
    return {
      id: message.id || this.newMessageId(),
      role: _MessageList.getRole(message),
      createdAt: this.generateCreatedAt(messageSource, message.createdAt),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  aiV4CoreMessageToMastraDBMessage(coreMessage, messageSource) {
    const id = `id` in coreMessage ? coreMessage.id : this.newMessageId();
    const parts = [];
    const experimentalAttachments = [];
    const toolInvocations = [];
    const isSingleTextContent = messageSource === `response` && Array.isArray(coreMessage.content) && coreMessage.content.length === 1 && coreMessage.content[0] && coreMessage.content[0].type === `text` && `text` in coreMessage.content[0] && coreMessage.content[0].text;
    if (isSingleTextContent && messageSource === `response`) {
      coreMessage.content = isSingleTextContent;
    }
    if (typeof coreMessage.content === "string") {
      parts.push({
        type: "text",
        text: coreMessage.content
      });
    } else if (Array.isArray(coreMessage.content)) {
      for (const aiV4Part of coreMessage.content) {
        switch (aiV4Part.type) {
          case "text": {
            const prevPart = parts.at(-1);
            if (coreMessage.role === "assistant" && prevPart && prevPart.type === "tool-invocation") {
              parts.push({ type: "step-start" });
            }
            const part = {
              type: "text",
              text: aiV4Part.text
            };
            if (aiV4Part.providerOptions) {
              part.providerMetadata = aiV4Part.providerOptions;
            }
            parts.push(part);
            break;
          }
          case "tool-call": {
            const part = {
              type: "tool-invocation",
              toolInvocation: {
                state: "call",
                toolCallId: aiV4Part.toolCallId,
                toolName: aiV4Part.toolName,
                args: aiV4Part.args
              }
            };
            if (aiV4Part.providerOptions) {
              part.providerMetadata = aiV4Part.providerOptions;
            }
            parts.push(part);
            break;
          }
          case "tool-result":
            {
              let toolArgs = {};
              const toolCallInSameMsg = coreMessage.content.find(
                (p) => p.type === "tool-call" && p.toolCallId === aiV4Part.toolCallId
              );
              if (toolCallInSameMsg && toolCallInSameMsg.type === "tool-call") {
                toolArgs = toolCallInSameMsg.args;
              }
              if (Object.keys(toolArgs).length === 0) {
                for (let i = this.messages.length - 1; i >= 0; i--) {
                  const msg = this.messages[i];
                  if (msg && msg.role === "assistant" && msg.content.parts) {
                    const toolCallPart = msg.content.parts.find(
                      (p) => p.type === "tool-invocation" && p.toolInvocation.toolCallId === aiV4Part.toolCallId && p.toolInvocation.state === "call"
                    );
                    if (toolCallPart && toolCallPart.type === "tool-invocation" && toolCallPart.toolInvocation.args) {
                      toolArgs = toolCallPart.toolInvocation.args;
                      break;
                    }
                  }
                }
              }
              const invocation = {
                state: "result",
                toolCallId: aiV4Part.toolCallId,
                toolName: aiV4Part.toolName,
                result: aiV4Part.result ?? "",
                // undefined will cause AI SDK to throw an error, but for client side tool calls this really could be undefined
                args: toolArgs
                // Use the args from the corresponding tool-call
              };
              const part = {
                type: "tool-invocation",
                toolInvocation: invocation
              };
              if (aiV4Part.providerOptions) {
                part.providerMetadata = aiV4Part.providerOptions;
              }
              parts.push(part);
              toolInvocations.push(invocation);
            }
            break;
          case "reasoning":
            {
              const part = {
                type: "reasoning",
                reasoning: "",
                // leave this blank so we aren't double storing it in the db along with details
                details: [{ type: "text", text: aiV4Part.text, signature: aiV4Part.signature }]
              };
              if (aiV4Part.providerOptions) {
                part.providerMetadata = aiV4Part.providerOptions;
              }
              parts.push(part);
            }
            break;
          case "redacted-reasoning":
            {
              const part = {
                type: "reasoning",
                reasoning: "",
                // No text reasoning for redacted parts
                details: [{ type: "redacted", data: aiV4Part.data }]
              };
              if (aiV4Part.providerOptions) {
                part.providerMetadata = aiV4Part.providerOptions;
              }
              parts.push(part);
            }
            break;
          case "image": {
            const part = {
              type: "file",
              data: imageContentToString(aiV4Part.image),
              mimeType: aiV4Part.mimeType
            };
            if (aiV4Part.providerOptions) {
              part.providerMetadata = aiV4Part.providerOptions;
            }
            parts.push(part);
            break;
          }
          case "file": {
            if (aiV4Part.data instanceof URL) {
              const part = {
                type: "file",
                data: aiV4Part.data.toString(),
                mimeType: aiV4Part.mimeType
              };
              if (aiV4Part.providerOptions) {
                part.providerMetadata = aiV4Part.providerOptions;
              }
              parts.push(part);
            } else if (typeof aiV4Part.data === "string") {
              const categorized = categorizeFileData(aiV4Part.data, aiV4Part.mimeType);
              if (categorized.type === "url" || categorized.type === "dataUri") {
                const part = {
                  type: "file",
                  data: aiV4Part.data,
                  mimeType: categorized.mimeType || "image/png"
                };
                if (aiV4Part.providerOptions) {
                  part.providerMetadata = aiV4Part.providerOptions;
                }
                parts.push(part);
              } else {
                try {
                  const part = {
                    type: "file",
                    mimeType: categorized.mimeType || "image/png",
                    data: convertDataContentToBase64String(aiV4Part.data)
                  };
                  if (aiV4Part.providerOptions) {
                    part.providerMetadata = aiV4Part.providerOptions;
                  }
                  parts.push(part);
                } catch (error) {
                  console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);
                }
              }
            } else {
              try {
                const part = {
                  type: "file",
                  mimeType: aiV4Part.mimeType,
                  data: convertDataContentToBase64String(aiV4Part.data)
                };
                if (aiV4Part.providerOptions) {
                  part.providerMetadata = aiV4Part.providerOptions;
                }
                parts.push(part);
              } catch (error) {
                console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);
              }
            }
            break;
          }
        }
      }
    }
    const content = {
      format: 2,
      parts
    };
    if (toolInvocations.length) content.toolInvocations = toolInvocations;
    if (typeof coreMessage.content === `string`) content.content = coreMessage.content;
    if (experimentalAttachments.length) content.experimental_attachments = experimentalAttachments;
    if (coreMessage.providerOptions) {
      content.providerMetadata = coreMessage.providerOptions;
    }
    if ("metadata" in coreMessage && coreMessage.metadata !== null && coreMessage.metadata !== void 0) {
      content.metadata = coreMessage.metadata;
    }
    return {
      id,
      role: _MessageList.getRole(coreMessage),
      createdAt: this.generateCreatedAt(messageSource),
      threadId: this.memoryInfo?.threadId,
      resourceId: this.memoryInfo?.resourceId,
      content
    };
  }
  static isAIV4UIMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !_MessageList.isAIV4CoreMessage(msg) && `parts` in msg && !_MessageList.hasAIV5UIMessageCharacteristics(msg);
  }
  static isAIV5CoreMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !(`parts` in msg) && `content` in msg && _MessageList.hasAIV5CoreMessageCharacteristics(msg);
  }
  static isAIV4CoreMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !(`parts` in msg) && `content` in msg && !_MessageList.hasAIV5CoreMessageCharacteristics(msg);
  }
  static isMastraMessage(msg) {
    return _MessageList.isMastraDBMessage(msg) || _MessageList.isMastraMessageV1(msg);
  }
  static isMastraMessageV1(msg) {
    return !_MessageList.isMastraDBMessage(msg) && (`threadId` in msg || `resourceId` in msg);
  }
  static isMastraDBMessage(msg) {
    return Boolean(
      `content` in msg && msg.content && !Array.isArray(msg.content) && typeof msg.content !== `string` && `format` in msg.content && msg.content.format === 2
    );
  }
  static getRole(message) {
    if (message.role === `assistant` || message.role === `tool`) return `assistant`;
    if (message.role === `user`) return `user`;
    if (message.role === `system`) return `system`;
    throw new Error(
      `BUG: add handling for message role ${message.role} in message ${JSON.stringify(message, null, 2)}`
    );
  }
  static cacheKeyFromAIV4Parts(parts) {
    let key = ``;
    for (const part of parts) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text;
      }
      if (part.type === `tool-invocation`) {
        key += part.toolInvocation.toolCallId;
        key += part.toolInvocation.state;
      }
      if (part.type === `reasoning`) {
        key += part.reasoning;
        key += part.details.reduce((prev, current) => {
          if (current.type === `text`) {
            return prev + current.text.length + (current.signature?.length || 0);
          }
          return prev;
        }, 0);
      }
      if (part.type === `file`) {
        key += part.data;
        key += part.mimeType;
      }
    }
    return key;
  }
  static coreContentToString(content) {
    if (typeof content === `string`) return content;
    return content.reduce((p, c) => {
      if (c.type === `text`) {
        p += c.text;
      }
      return p;
    }, "");
  }
  static cacheKeyFromAIV4CoreMessageContent(content) {
    if (typeof content === `string`) return content;
    let key = ``;
    for (const part of content) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text.length;
      }
      if (part.type === `reasoning`) {
        key += part.text.length;
      }
      if (part.type === `tool-call`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `tool-result`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `file`) {
        key += part.filename;
        key += part.mimeType;
      }
      if (part.type === `image`) {
        key += getImageCacheKey(part.image);
        key += part.mimeType;
      }
      if (part.type === `redacted-reasoning`) {
        key += part.data.length;
      }
    }
    return key;
  }
  static messagesAreEqual(one, two) {
    const oneUIV4 = _MessageList.isAIV4UIMessage(one) && one;
    const twoUIV4 = _MessageList.isAIV4UIMessage(two) && two;
    if (oneUIV4 && !twoUIV4) return false;
    if (oneUIV4 && twoUIV4) {
      return _MessageList.cacheKeyFromAIV4Parts(one.parts) === _MessageList.cacheKeyFromAIV4Parts(two.parts);
    }
    const oneCMV4 = _MessageList.isAIV4CoreMessage(one) && one;
    const twoCMV4 = _MessageList.isAIV4CoreMessage(two) && two;
    if (oneCMV4 && !twoCMV4) return false;
    if (oneCMV4 && twoCMV4) {
      return _MessageList.cacheKeyFromAIV4CoreMessageContent(oneCMV4.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(twoCMV4.content);
    }
    const oneMM1 = _MessageList.isMastraMessageV1(one) && one;
    const twoMM1 = _MessageList.isMastraMessageV1(two) && two;
    if (oneMM1 && !twoMM1) return false;
    if (oneMM1 && twoMM1) {
      return oneMM1.id === twoMM1.id && _MessageList.cacheKeyFromAIV4CoreMessageContent(oneMM1.content) === _MessageList.cacheKeyFromAIV4CoreMessageContent(twoMM1.content);
    }
    const oneMM2 = _MessageList.isMastraDBMessage(one) && one;
    const twoMM2 = _MessageList.isMastraDBMessage(two) && two;
    if (oneMM2 && !twoMM2) return false;
    if (oneMM2 && twoMM2) {
      return oneMM2.id === twoMM2.id && _MessageList.cacheKeyFromAIV4Parts(oneMM2.content.parts) === _MessageList.cacheKeyFromAIV4Parts(twoMM2.content.parts);
    }
    const oneUIV5 = _MessageList.isAIV5UIMessage(one) && one;
    const twoUIV5 = _MessageList.isAIV5UIMessage(two) && two;
    if (oneUIV5 && !twoUIV5) return false;
    if (oneUIV5 && twoUIV5) {
      return _MessageList.cacheKeyFromAIV5Parts(one.parts) === _MessageList.cacheKeyFromAIV5Parts(two.parts);
    }
    const oneCMV5 = _MessageList.isAIV5CoreMessage(one) && one;
    const twoCMV5 = _MessageList.isAIV5CoreMessage(two) && two;
    if (oneCMV5 && !twoCMV5) return false;
    if (oneCMV5 && twoCMV5) {
      return _MessageList.cacheKeyFromAIV5ModelMessageContent(oneCMV5.content) === _MessageList.cacheKeyFromAIV5ModelMessageContent(twoCMV5.content);
    }
    return true;
  }
  static aiV4CoreMessageToV1PromptMessage(coreMessage) {
    if (coreMessage.role === `system`) {
      return coreMessage;
    }
    if (typeof coreMessage.content === `string` && (coreMessage.role === `assistant` || coreMessage.role === `user`)) {
      return {
        ...coreMessage,
        content: [{ type: "text", text: coreMessage.content }]
      };
    }
    if (typeof coreMessage.content === `string`) {
      throw new Error(
        `Saw text content for input CoreMessage, but the role is ${coreMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`
      );
    }
    const roleContent = {
      user: [],
      assistant: [],
      tool: []
    };
    const role = coreMessage.role;
    for (const part of coreMessage.content) {
      const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
      switch (part.type) {
        case "text": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "redacted-reasoning":
        case "reasoning": {
          if (role !== `assistant`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-call": {
          if (role === `tool` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-result": {
          if (role === `assistant` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "image": {
          if (role === `tool` || role === `assistant`) {
            throw new Error(incompatibleMessage);
          }
          let processedImage;
          if (part.image instanceof URL || part.image instanceof Uint8Array) {
            processedImage = part.image;
          } else if (Buffer.isBuffer(part.image) || part.image instanceof ArrayBuffer) {
            processedImage = new Uint8Array(part.image);
          } else {
            const categorized = categorizeFileData(part.image, part.mimeType);
            if (categorized.type === "raw") {
              const dataUri = createDataUri(part.image, part.mimeType || "image/png");
              processedImage = new URL(dataUri);
            } else {
              processedImage = new URL(part.image);
            }
          }
          roleContent[role].push({
            ...part,
            image: processedImage
          });
          break;
        }
        case "file": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            data: part.data instanceof URL ? part.data : typeof part.data === "string" ? part.data : convertDataContentToBase64String(part.data)
          });
          break;
        }
      }
    }
    if (role === `tool`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    if (role === `user`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    if (role === `assistant`) {
      return {
        ...coreMessage,
        content: roleContent[role]
      };
    }
    throw new Error(
      `Encountered unknown role ${role} when converting V4 CoreMessage -> V4 LanguageModelV1Prompt, input message: ${JSON.stringify(coreMessage, null, 2)}`
    );
  }
  static aiV5ModelMessageToV2PromptMessage(modelMessage) {
    if (modelMessage.role === `system`) {
      return modelMessage;
    }
    if (typeof modelMessage.content === `string` && (modelMessage.role === `assistant` || modelMessage.role === `user`)) {
      return {
        role: modelMessage.role,
        content: [{ type: "text", text: modelMessage.content }],
        providerOptions: modelMessage.providerOptions
      };
    }
    if (typeof modelMessage.content === `string`) {
      throw new Error(
        `Saw text content for input ModelMessage, but the role is ${modelMessage.role}. This is only allowed for "system", "assistant", and "user" roles.`
      );
    }
    const roleContent = {
      user: [],
      assistant: [],
      tool: []
    };
    const role = modelMessage.role;
    for (const part of modelMessage.content) {
      const incompatibleMessage = `Saw incompatible message content part type ${part.type} for message role ${role}`;
      switch (part.type) {
        case "text": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "reasoning": {
          if (role === `tool` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-call": {
          if (role !== `assistant`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "tool-result": {
          if (role === `assistant` || role === `user`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push(part);
          break;
        }
        case "file": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            data: part.data instanceof ArrayBuffer ? new Uint8Array(part.data) : part.data
          });
          break;
        }
        case "image": {
          if (role === `tool`) {
            throw new Error(incompatibleMessage);
          }
          roleContent[role].push({
            ...part,
            mediaType: part.mediaType || "image/unknown",
            type: "file",
            data: part.image instanceof ArrayBuffer ? new Uint8Array(part.image) : part.image
          });
          break;
        }
      }
    }
    if (role === `tool`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    if (role === `user`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    if (role === `assistant`) {
      return {
        ...modelMessage,
        content: roleContent[role]
      };
    }
    throw new Error(
      `Encountered unknown role ${role} when converting V5 ModelMessage -> V5 LanguageModelV2Message, input message: ${JSON.stringify(modelMessage, null, 2)}`
    );
  }
  /**
   * Direct conversion from MastraDBMessage to AIV5 UIMessage
   */
  static mastraDBMessageToAIV5UIMessage(dbMsg) {
    const parts = [];
    const metadata = { ...dbMsg.content.metadata || {} };
    if (dbMsg.createdAt) metadata.createdAt = dbMsg.createdAt;
    if (dbMsg.threadId) metadata.threadId = dbMsg.threadId;
    if (dbMsg.resourceId) metadata.resourceId = dbMsg.resourceId;
    if (dbMsg.content.providerMetadata) {
      metadata.providerMetadata = dbMsg.content.providerMetadata;
    }
    const hasToolInvocationParts = dbMsg.content.parts?.some((p) => p.type === "tool-invocation");
    if (dbMsg.content.toolInvocations && !hasToolInvocationParts) {
      for (const invocation of dbMsg.content.toolInvocations) {
        if (invocation.state === "result") {
          parts.push({
            type: `tool-${invocation.toolName}`,
            toolCallId: invocation.toolCallId,
            state: "output-available",
            input: invocation.args,
            output: invocation.result
          });
        } else {
          parts.push({
            type: `tool-${invocation.toolName}`,
            toolCallId: invocation.toolCallId,
            state: invocation.state === "call" ? "input-available" : "input-streaming",
            input: invocation.args
          });
        }
      }
    }
    const hasReasoningInParts = dbMsg.content.parts?.some((p) => p.type === "reasoning");
    const hasFileInParts = dbMsg.content.parts?.some((p) => p.type === "file");
    if (dbMsg.content.reasoning && !hasReasoningInParts) {
      parts.push({
        type: "reasoning",
        text: dbMsg.content.reasoning
      });
    }
    const attachmentUrls = /* @__PURE__ */ new Set();
    if (dbMsg.content.experimental_attachments && !hasFileInParts) {
      for (const attachment of dbMsg.content.experimental_attachments) {
        attachmentUrls.add(attachment.url);
        parts.push({
          type: "file",
          url: attachment.url,
          mediaType: attachment.contentType || "unknown"
        });
      }
    }
    let hasNonToolReasoningParts = false;
    if (dbMsg.content.parts) {
      for (const part of dbMsg.content.parts) {
        if (part.type === "tool-invocation" && part.toolInvocation) {
          const inv = part.toolInvocation;
          if (inv.state === "result") {
            parts.push({
              type: `tool-${inv.toolName}`,
              toolCallId: inv.toolCallId,
              input: inv.args,
              output: inv.result,
              state: "output-available",
              callProviderMetadata: part.providerMetadata
            });
          } else {
            parts.push({
              type: `tool-${inv.toolName}`,
              toolCallId: inv.toolCallId,
              input: inv.args,
              state: "input-available",
              callProviderMetadata: part.providerMetadata
            });
          }
          continue;
        }
        if (part.type === "reasoning") {
          const text = part.reasoning || (part.details?.reduce((p, c) => {
            if (c.type === `text` && c.text) return p + c.text;
            return p;
          }, "") ?? "");
          if (text || part.details?.length) {
            const v5UIPart = {
              type: "reasoning",
              text: text || "",
              state: "done"
            };
            if (part.providerMetadata) {
              v5UIPart.providerMetadata = part.providerMetadata;
            }
            parts.push(v5UIPart);
          }
          continue;
        }
        if (part.type === "tool-invocation" || part.type.startsWith("tool-")) {
          continue;
        }
        if (part.type === "file") {
          if (typeof part.data === "string" && attachmentUrls.has(part.data)) {
            continue;
          }
          const categorized = typeof part.data === "string" ? categorizeFileData(part.data, part.mimeType) : { type: "raw", mimeType: part.mimeType};
          if (categorized.type === "url" && typeof part.data === "string") {
            const v5UIPart = {
              type: "file",
              url: part.data,
              mediaType: categorized.mimeType || "image/png"
            };
            if (part.providerMetadata) {
              v5UIPart.providerMetadata = part.providerMetadata;
            }
            parts.push(v5UIPart);
          } else {
            let filePartData;
            let extractedMimeType = part.mimeType;
            if (typeof part.data === "string") {
              const parsed = parseDataUri(part.data);
              if (parsed.isDataUri) {
                filePartData = parsed.base64Content;
                if (parsed.mimeType) {
                  extractedMimeType = extractedMimeType || parsed.mimeType;
                }
              } else {
                filePartData = part.data;
              }
            } else {
              filePartData = part.data;
            }
            const finalMimeType = extractedMimeType || "image/png";
            let dataUri;
            if (typeof filePartData === "string" && filePartData.startsWith("data:")) {
              dataUri = filePartData;
            } else {
              dataUri = createDataUri(filePartData, finalMimeType);
            }
            const v5UIPart = {
              type: "file",
              url: dataUri,
              // Use url field with data URI
              mediaType: finalMimeType
            };
            if (part.providerMetadata) {
              v5UIPart.providerMetadata = part.providerMetadata;
            }
            parts.push(v5UIPart);
          }
        } else if (part.type === "source") {
          const v5UIPart = {
            type: "source-url",
            url: part.source.url,
            sourceId: part.source.id,
            title: part.source.title
          };
          if (part.providerMetadata) {
            v5UIPart.providerMetadata = part.providerMetadata;
          }
          parts.push(v5UIPart);
        } else if (part.type === "text") {
          const v5UIPart = {
            type: "text",
            text: part.text
          };
          if (part.providerMetadata) {
            v5UIPart.providerMetadata = part.providerMetadata;
          }
          parts.push(v5UIPart);
          hasNonToolReasoningParts = true;
        } else {
          parts.push(part);
          hasNonToolReasoningParts = true;
        }
      }
    }
    if (dbMsg.content.content && !hasNonToolReasoningParts) {
      parts.push({ type: "text", text: dbMsg.content.content });
    }
    return {
      id: dbMsg.id,
      role: dbMsg.role,
      metadata,
      parts
    };
  }
  /**
   * Direct conversion from AIV5 UIMessage to MastraDBMessage
   * Combines logic from aiV5UIMessageToMastraMessageV3 + mastraMessageV3ToV2
   */
  static aiV5UIMessageToMastraDBMessage(uiMsg) {
    const { parts, metadata: rawMetadata } = uiMsg;
    const metadata = rawMetadata || {};
    const createdAtValue = metadata.createdAt;
    const createdAt = createdAtValue ? typeof createdAtValue === "string" ? new Date(createdAtValue) : createdAtValue instanceof Date ? createdAtValue : /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date();
    const threadId = metadata.threadId;
    const resourceId = metadata.resourceId;
    const cleanMetadata = { ...metadata };
    delete cleanMetadata.createdAt;
    delete cleanMetadata.threadId;
    delete cleanMetadata.resourceId;
    const toolInvocationParts = parts.filter((p) => AIV5__namespace.isToolUIPart(p));
    const reasoningParts = parts.filter((p) => p.type === "reasoning");
    const fileParts = parts.filter((p) => p.type === "file");
    const textParts = parts.filter((p) => p.type === "text");
    let toolInvocations = void 0;
    if (toolInvocationParts.length > 0) {
      toolInvocations = toolInvocationParts.map((p) => {
        const toolName = getToolName(p);
        if (p.state === "output-available") {
          return {
            args: p.input,
            result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output,
            toolCallId: p.toolCallId,
            toolName,
            state: "result"
          };
        }
        return {
          args: p.input,
          toolCallId: p.toolCallId,
          toolName,
          state: "call"
        };
      });
    }
    let reasoning = void 0;
    if (reasoningParts.length > 0) {
      reasoning = reasoningParts.map((p) => p.text).join("\n");
    }
    let experimental_attachments = void 0;
    if (fileParts.length > 0) {
      experimental_attachments = fileParts.map((p) => ({
        url: p.url || "",
        contentType: p.mediaType
      }));
    }
    let content = void 0;
    if (textParts.length > 0) {
      content = textParts.map((p) => p.text).join("");
    }
    const v2Parts = parts.map((p) => {
      if (AIV5__namespace.isToolUIPart(p)) {
        const toolName = getToolName(p);
        const callProviderMetadata = "callProviderMetadata" in p ? p.callProviderMetadata : void 0;
        if (p.state === "output-available") {
          return {
            type: "tool-invocation",
            toolInvocation: {
              toolCallId: p.toolCallId,
              toolName,
              args: p.input,
              result: typeof p.output === "object" && p.output && "value" in p.output ? p.output.value : p.output,
              state: "result"
            },
            providerMetadata: callProviderMetadata
          };
        }
        return {
          type: "tool-invocation",
          toolInvocation: {
            toolCallId: p.toolCallId,
            toolName,
            args: p.input,
            state: "call"
          },
          providerMetadata: callProviderMetadata
        };
      }
      if (p.type === "reasoning") {
        return {
          type: "reasoning",
          reasoning: "",
          details: [
            {
              type: "text",
              text: p.text
            }
          ],
          providerMetadata: p.providerMetadata
        };
      }
      if (p.type === "file") {
        return {
          type: "file",
          mimeType: p.mediaType,
          data: p.url || "",
          providerMetadata: p.providerMetadata
        };
      }
      if (p.type === "source-url") {
        return {
          type: "source",
          source: {
            url: p.url,
            sourceType: "url",
            id: p.url,
            // Use URL as ID
            providerMetadata: p.providerMetadata
          },
          providerMetadata: p.providerMetadata
        };
      }
      if (p.type === "text") {
        return {
          type: "text",
          text: p.text,
          providerMetadata: p.providerMetadata
        };
      }
      if (p.type === "step-start") {
        return p;
      }
      return null;
    }).filter((p) => p !== null);
    return {
      id: uiMsg.id,
      role: uiMsg.role,
      createdAt,
      threadId,
      resourceId,
      content: {
        format: 2,
        parts: v2Parts,
        toolInvocations,
        reasoning,
        experimental_attachments,
        content,
        metadata: Object.keys(cleanMetadata).length > 0 ? cleanMetadata : void 0
      }
    };
  }
  /**
   * Convert image or file to data URI or URL for V2 file part
   */
  static getDataStringFromAIV5DataPart = (part) => {
    let mimeType;
    let data;
    if ("data" in part) {
      mimeType = part.mediaType || "application/octet-stream";
      data = part.data;
    } else if ("image" in part) {
      mimeType = part.mediaType || "image/jpeg";
      data = part.image;
    } else {
      throw new chunkTWH4PTDG_cjs.MastraError({
        id: "MASTRA_AIV5_DATA_PART_INVALID",
        domain: "AGENT" /* AGENT */,
        category: "USER" /* USER */,
        text: "Invalid AIV5 data part in getDataStringFromAIV5DataPart",
        details: {
          part
        }
      });
    }
    if (data instanceof URL) {
      return data.toString();
    } else {
      if (data instanceof Buffer) {
        const base64 = data.toString("base64");
        return `data:${mimeType};base64,${base64}`;
      } else if (typeof data === "string") {
        return data.startsWith("data:") || data.startsWith("http") ? data : `data:${mimeType};base64,${data}`;
      } else if (data instanceof Uint8Array) {
        const base64 = Buffer.from(data).toString("base64");
        return `data:${mimeType};base64,${base64}`;
      } else if (data instanceof ArrayBuffer) {
        const base64 = Buffer.from(data).toString("base64");
        return `data:${mimeType};base64,${base64}`;
      } else {
        return "";
      }
    }
  };
  /**
   * Direct conversion from AIV5 ModelMessage to MastraDBMessage
   * Combines logic from aiV5ModelMessageToMastraMessageV3 + mastraMessageV3ToV2
   */
  static aiV5ModelMessageToMastraDBMessage(modelMsg, _messageSource) {
    const content = Array.isArray(modelMsg.content) ? modelMsg.content : [{ type: "text", text: modelMsg.content }];
    const mastraDBParts = [];
    const toolInvocations = [];
    const reasoningParts = [];
    const experimental_attachments = [];
    let lastPartWasToolResult = false;
    for (const part of content) {
      if (part.type === "text") {
        const textPart = {
          type: "text",
          text: part.text
        };
        if (part.providerOptions) {
          textPart.providerMetadata = part.providerOptions;
        }
        mastraDBParts.push(textPart);
        lastPartWasToolResult = false;
      } else if (part.type === "tool-call") {
        const toolCallPart = part;
        const toolInvocationPart = {
          type: "tool-invocation",
          toolInvocation: {
            toolCallId: toolCallPart.toolCallId,
            toolName: toolCallPart.toolName,
            args: toolCallPart.input,
            state: "call"
          }
        };
        if (part.providerOptions) {
          toolInvocationPart.providerMetadata = part.providerOptions;
        }
        mastraDBParts.push(toolInvocationPart);
        toolInvocations.push({
          toolCallId: toolCallPart.toolCallId,
          toolName: toolCallPart.toolName,
          args: toolCallPart.input,
          state: "call"
        });
        lastPartWasToolResult = false;
      } else if (part.type === "tool-result") {
        const toolResultPart = part;
        const matchingCall = toolInvocations.find((inv) => inv.toolCallId === toolResultPart.toolCallId);
        const matchingV2Part = mastraDBParts.find(
          (p) => p.type === "tool-invocation" && "toolInvocation" in p && p.toolInvocation.toolCallId === toolResultPart.toolCallId
        );
        const updateMatchingCallInvocationResult = (toolResultPart2, matchingCall2) => {
          matchingCall2.state = "result";
          matchingCall2.result = typeof toolResultPart2.output === "object" && toolResultPart2.output && "value" in toolResultPart2.output ? toolResultPart2.output.value : toolResultPart2.output;
        };
        if (matchingCall) {
          updateMatchingCallInvocationResult(toolResultPart, matchingCall);
        } else {
          const call = {
            state: "call",
            toolCallId: toolResultPart.toolCallId,
            toolName: toolResultPart.toolName || "unknown",
            args: {}
          };
          updateMatchingCallInvocationResult(toolResultPart, call);
          toolInvocations.push(call);
        }
        if (matchingV2Part && matchingV2Part.type === "tool-invocation") {
          updateMatchingCallInvocationResult(toolResultPart, matchingV2Part.toolInvocation);
        } else {
          const toolInvocationPart = {
            type: "tool-invocation",
            toolInvocation: {
              toolCallId: toolResultPart.toolCallId,
              toolName: toolResultPart.toolName || "unknown",
              args: {},
              state: "call"
            }
          };
          updateMatchingCallInvocationResult(toolResultPart, toolInvocationPart.toolInvocation);
          mastraDBParts.push(toolInvocationPart);
        }
        lastPartWasToolResult = true;
      } else if (part.type === "reasoning") {
        const v2ReasoningPart = {
          type: "reasoning",
          reasoning: "",
          // leave this blank so we aren't double storing it in the db along with details
          details: [{ type: "text", text: part.text }]
        };
        if (part.providerOptions) {
          v2ReasoningPart.providerMetadata = part.providerOptions;
        }
        mastraDBParts.push(v2ReasoningPart);
        reasoningParts.push(part.text);
        lastPartWasToolResult = false;
      } else if (part.type === "image") {
        const imagePart = part;
        const mimeType = imagePart.mediaType || "image/jpeg";
        const imageData = this.getDataStringFromAIV5DataPart(imagePart);
        const imageFilePart = {
          type: "file",
          data: imageData,
          mimeType
        };
        if (part.providerOptions) {
          imageFilePart.providerMetadata = part.providerOptions;
        }
        mastraDBParts.push(imageFilePart);
        experimental_attachments.push({
          url: imageData,
          contentType: mimeType
        });
        lastPartWasToolResult = false;
      } else if (part.type === "file") {
        const filePart = part;
        const mimeType = filePart.mediaType || "application/octet-stream";
        const fileData = this.getDataStringFromAIV5DataPart(filePart);
        const v2FilePart = {
          type: "file",
          data: fileData,
          mimeType
        };
        if (part.providerOptions) {
          v2FilePart.providerMetadata = part.providerOptions;
        }
        mastraDBParts.push(v2FilePart);
        experimental_attachments.push({
          url: fileData,
          contentType: mimeType
        });
        lastPartWasToolResult = false;
      }
    }
    if (modelMsg.role === "assistant" && lastPartWasToolResult && mastraDBParts.length > 0) {
      const lastPart = mastraDBParts[mastraDBParts.length - 1];
      if (lastPart && lastPart.type !== "text") {
        const emptyTextPart = { type: "text", text: "" };
        mastraDBParts.push(emptyTextPart);
      }
    }
    const contentString = mastraDBParts.filter((p) => p.type === "text").map((p) => p.text).join("\n");
    const metadata = "metadata" in modelMsg && modelMsg.metadata !== null && modelMsg.metadata !== void 0 ? modelMsg.metadata : {};
    const id = `id` in modelMsg && typeof modelMsg.id === `string` ? modelMsg.id : `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const message = {
      id,
      role: _MessageList.getRole(modelMsg),
      createdAt: /* @__PURE__ */ new Date(),
      content: {
        format: 2,
        parts: mastraDBParts,
        toolInvocations: toolInvocations.length > 0 ? toolInvocations : void 0,
        reasoning: reasoningParts.length > 0 ? reasoningParts.join("\n") : void 0,
        experimental_attachments: experimental_attachments.length > 0 ? experimental_attachments : void 0,
        content: contentString || void 0,
        metadata: Object.keys(metadata).length > 0 ? metadata : void 0
      }
    };
    if (modelMsg.providerOptions) {
      message.content.providerMetadata = modelMsg.providerOptions;
    }
    return message;
  }
  aiV4CoreMessagesToAIV5ModelMessages(messages, source) {
    return this.aiV5UIMessagesToAIV5ModelMessages(
      messages.map((m) => this.aiV4CoreMessageToMastraDBMessage(m, source)).map((m) => _MessageList.mastraDBMessageToAIV5UIMessage(m))
    );
  }
  aiV5UIMessagesToAIV5ModelMessages(messages, filterIncompleteToolCalls = false) {
    const sanitized = this.sanitizeV5UIMessages(messages, filterIncompleteToolCalls);
    const preprocessed = this.addStartStepPartsForAIV5(sanitized);
    const result = AIV5__namespace.convertToModelMessages(preprocessed);
    return result.map((modelMsg, index) => {
      const uiMsg = preprocessed[index];
      if (uiMsg?.metadata && typeof uiMsg.metadata === "object" && "providerMetadata" in uiMsg.metadata && uiMsg.metadata.providerMetadata) {
        return {
          ...modelMsg,
          providerOptions: uiMsg.metadata.providerMetadata
        };
      }
      return modelMsg;
    });
  }
  addStartStepPartsForAIV5(messages) {
    for (const message of messages) {
      if (message.role !== `assistant`) continue;
      for (const [index, part] of message.parts.entries()) {
        if (!AIV5__namespace.isToolUIPart(part)) continue;
        const nextPart = message.parts.at(index + 1);
        if (nextPart && nextPart.type !== `step-start` && !AIV5__namespace.isToolUIPart(nextPart)) {
          message.parts.splice(index + 1, 0, { type: "step-start" });
        }
      }
    }
    return messages;
  }
  sanitizeV5UIMessages(messages, filterIncompleteToolCalls = false) {
    const msgs = messages.map((m) => {
      if (m.parts.length === 0) return false;
      const safeParts = m.parts.filter((p) => {
        if (!AIV5__namespace.isToolUIPart(p)) return true;
        if (filterIncompleteToolCalls) {
          return p.state === "output-available" || p.state === "output-error";
        }
        return p.state !== "input-streaming";
      });
      if (!safeParts.length) return false;
      const sanitized = {
        ...m,
        parts: safeParts.map((part) => {
          if (AIV5__namespace.isToolUIPart(part) && part.state === "output-available") {
            return {
              ...part,
              output: typeof part.output === "object" && part.output && "value" in part.output ? part.output.value : part.output
            };
          }
          return part;
        })
      };
      return sanitized;
    }).filter((m) => Boolean(m));
    return msgs;
  }
  static hasAIV5UIMessageCharacteristics(msg) {
    if (`toolInvocations` in msg || `reasoning` in msg || `experimental_attachments` in msg || `data` in msg || `annotations` in msg)
      return false;
    if (!msg.parts) return false;
    for (const part of msg.parts) {
      if (`metadata` in part) return true;
      if (`toolInvocation` in part) return false;
      if (`toolCallId` in part) return true;
      if (part.type === `source`) return false;
      if (part.type === `source-url`) return true;
      if (part.type === `reasoning`) {
        if (`state` in part || `text` in part) return true;
        if (`reasoning` in part || `details` in part) return false;
      }
      if (part.type === `file` && `mediaType` in part) return true;
    }
    return false;
  }
  static isAIV5UIMessage(msg) {
    return !_MessageList.isMastraMessage(msg) && !_MessageList.isAIV5CoreMessage(msg) && `parts` in msg && _MessageList.hasAIV5UIMessageCharacteristics(msg);
  }
  static hasAIV5CoreMessageCharacteristics(msg) {
    if (`experimental_providerMetadata` in msg) return false;
    if (typeof msg.content === `string`) return false;
    for (const part of msg.content) {
      if (part.type === `tool-result` && `output` in part) return true;
      if (part.type === `tool-call` && `input` in part) return true;
      if (part.type === `tool-result` && `result` in part) return false;
      if (part.type === `tool-call` && `args` in part) return false;
      if (`mediaType` in part) return true;
      if (`mimeType` in part) return false;
      if (`experimental_providerMetadata` in part) return false;
      if (part.type === `reasoning` && `signature` in part) return false;
      if (part.type === `redacted-reasoning`) return false;
    }
    return false;
  }
  static cacheKeyFromAIV5Parts(parts) {
    let key = ``;
    for (const part of parts) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text;
      }
      if (AIV5__namespace.isToolUIPart(part) || part.type === "dynamic-tool") {
        key += part.toolCallId;
        key += part.state;
      }
      if (part.type === `reasoning`) {
        key += part.text;
      }
      if (part.type === `file`) {
        key += part.url.length;
        key += part.mediaType;
        key += part.filename || "";
      }
    }
    return key;
  }
  static cacheKeyFromAIV5ModelMessageContent(content) {
    if (typeof content === `string`) return content;
    let key = ``;
    for (const part of content) {
      key += part.type;
      if (part.type === `text`) {
        key += part.text.length;
      }
      if (part.type === `reasoning`) {
        key += part.text.length;
      }
      if (part.type === `tool-call`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `tool-result`) {
        key += part.toolCallId;
        key += part.toolName;
      }
      if (part.type === `file`) {
        key += part.filename;
        key += part.mediaType;
      }
      if (part.type === `image`) {
        key += getImageCacheKey(part.image);
        key += part.mediaType;
      }
    }
    return key;
  }
};

exports.DefaultGeneratedFile = DefaultGeneratedFile;
exports.DefaultGeneratedFileWithType = DefaultGeneratedFileWithType;
exports.MessageList = MessageList;
exports.convertMessages = convertMessages;
//# sourceMappingURL=chunk-DQIZ5FFX.cjs.map
//# sourceMappingURL=chunk-DQIZ5FFX.cjs.map