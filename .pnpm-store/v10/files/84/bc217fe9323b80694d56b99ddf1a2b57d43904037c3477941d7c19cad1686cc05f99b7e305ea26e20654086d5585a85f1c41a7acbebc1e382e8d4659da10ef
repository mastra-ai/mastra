"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } async function _asyncOptionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = await fn(value); } else if (op === 'call' || op === 'optionalCall') { value = await fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class; var _class2; var _class3; var _class4; var _class5; var _class6; var _class7; var _class8; var _class9; var _class10; var _class11; var _class12; var _class13; var _class14; var _class15; var _class16; var _class17; var _class18; var _class19; var _class20; var _class21;var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/isomorph.ts
var DefaultAsyncLocalStorage, iso, isomorph_default;
var init_isomorph = __esm({
  "src/isomorph.ts"() {
    "use strict";
    DefaultAsyncLocalStorage = class {
      constructor() {
      }
      enterWith(_) {
      }
      run(_, callback) {
        return callback();
      }
      getStore() {
        return void 0;
      }
    };
    iso = {
      getRepoInfo: async (_settings) => void 0,
      getPastNAncestors: async () => [],
      getEnv: (_name) => void 0,
      getCallerLocation: () => void 0,
      newAsyncLocalStorage: () => new DefaultAsyncLocalStorage(),
      processOn: (_0, _1) => {
      }
    };
    isomorph_default = iso;
  }
});

// src/queue.ts
var DEFAULT_QUEUE_SIZE, Queue;
var init_queue = __esm({
  "src/queue.ts"() {
    "use strict";
    DEFAULT_QUEUE_SIZE = 15e3;
    Queue = (_class = class {
      __init2() {this.items = []}
      
      __init3() {this.enforceSizeLimit = false}
      constructor(maxSize) {;_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);
        if (maxSize < 1) {
          console.warn(
            `maxSize ${maxSize} is <1, using default ${DEFAULT_QUEUE_SIZE}`
          );
          maxSize = DEFAULT_QUEUE_SIZE;
        }
        this.maxSize = maxSize;
      }
      /**
       * Set queue size limit enforcement. When enabled, the queue will drop new items
       * when it reaches maxSize. When disabled (default), the queue can grow unlimited.
       */
      enforceQueueSizeLimit(enforce) {
        this.enforceSizeLimit = enforce;
      }
      push(...items) {
        const dropped = [];
        for (const item of items) {
          if (!this.enforceSizeLimit) {
            this.items.push(item);
          } else {
            if (this.items.length >= this.maxSize) {
              dropped.push(item);
            } else {
              this.items.push(item);
            }
          }
        }
        return dropped;
      }
      peek() {
        return this.items[0];
      }
      drain() {
        const items = [...this.items];
        this.items = [];
        return items;
      }
      clear() {
        this.items = [];
      }
      length() {
        return this.items.length;
      }
      get capacity() {
        return this.maxSize;
      }
    }, _class);
  }
});

// src/id-gen.ts
var _uuid = require('uuid'); var uuid = _interopRequireWildcard(_uuid); var uuid2 = _interopRequireWildcard(_uuid); var uuid3 = _interopRequireWildcard(_uuid);
function generateHexId(bytes) {
  let result = "";
  for (let i = 0; i < bytes; i++) {
    result += Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
  }
  return result;
}
function getIdGenerator() {
  const useOtel = typeof process !== "undefined" && _optionalChain([process, 'access', _2 => _2.env, 'optionalAccess', _3 => _3.BRAINTRUST_OTEL_COMPAT, 'optionalAccess', _4 => _4.toLowerCase, 'call', _5 => _5()]) === "true";
  return useOtel ? new OTELIDGenerator() : new UUIDGenerator();
}
var IDGenerator, UUIDGenerator, OTELIDGenerator;
var init_id_gen = __esm({
  "src/id-gen.ts"() {
    "use strict";
    IDGenerator = exports.IDGenerator = class {
    };
    UUIDGenerator = exports.UUIDGenerator = class extends IDGenerator {
      getSpanId() {
        return _uuid.v4.call(void 0, );
      }
      getTraceId() {
        return _uuid.v4.call(void 0, );
      }
      shareRootSpanId() {
        return true;
      }
    };
    OTELIDGenerator = exports.OTELIDGenerator = class extends IDGenerator {
      getSpanId() {
        return generateHexId(8);
      }
      getTraceId() {
        return generateHexId(16);
      }
      shareRootSpanId() {
        return false;
      }
    };
  }
});

// util/db_fields.ts
var TRANSACTION_ID_FIELD, IS_MERGE_FIELD, AUDIT_SOURCE_FIELD, AUDIT_METADATA_FIELD, VALID_SOURCES, PARENT_ID_FIELD;
var init_db_fields = __esm({
  "util/db_fields.ts"() {
    "use strict";
    TRANSACTION_ID_FIELD = "_xact_id";
    IS_MERGE_FIELD = "_is_merge";
    AUDIT_SOURCE_FIELD = "_audit_source";
    AUDIT_METADATA_FIELD = "_audit_metadata";
    VALID_SOURCES = ["app", "api", "external"];
    PARENT_ID_FIELD = "_parent_id";
  }
});

// util/span_identifier_v1.ts

var _v3 = require('zod/v3');
function tryMakeUuid(s) {
  try {
    const ret = uuid.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER, INVALID_ENCODING_ERRMSG, SpanObjectTypeV1, SpanObjectTypeV1EnumSchema, SpanRowIdsV1, SpanComponentsV1;
var init_span_identifier_v1 = __esm({
  "util/span_identifier_v1.ts"() {
    "use strict";
    ENCODING_VERSION_NUMBER = 1;
    INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
    SpanObjectTypeV1 = /* @__PURE__ */ ((SpanObjectTypeV12) => {
      SpanObjectTypeV12[SpanObjectTypeV12["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV12[SpanObjectTypeV12["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      return SpanObjectTypeV12;
    })(SpanObjectTypeV1 || {});
    SpanObjectTypeV1EnumSchema = _v3.z.nativeEnum(SpanObjectTypeV1);
    SpanRowIdsV1 = class {
      
      
      
      constructor(args) {
        this.rowId = args.rowId;
        this.spanId = args.spanId;
        this.rootSpanId = args.rootSpanId;
        if (!this.rowId) {
          throw new Error("rowId must be nonempty string");
        }
        if (!this.spanId) {
          throw new Error("spanId must be nonempty string");
        }
        if (!this.rootSpanId) {
          throw new Error("rootSpanId must be nonempty string");
        }
      }
      toObject() {
        return {
          rowId: this.rowId,
          spanId: this.spanId,
          rootSpanId: this.rootSpanId
        };
      }
    };
    SpanComponentsV1 = class _SpanComponentsV1 {
      
      
      
      constructor(args) {
        this.objectType = args.objectType;
        this.objectId = args.objectId;
        this.rowIds = args.rowIds;
      }
      toStr() {
        const allBuffers = [];
        const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
        allBuffers.push(
          Buffer.from([
            ENCODING_VERSION_NUMBER,
            this.objectType,
            this.rowIds ? 1 : 0,
            rowIdIsUUID ? 1 : 0
          ])
        );
        const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
          this.objectId
        );
        if (!objectIdIsUUID) {
          throw new Error("object_id component must be a valid UUID");
        }
        allBuffers.push(objectIdBytes);
        if (this.rowIds) {
          const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
            this.rowIds.spanId
          );
          if (!spanIdIsUUID) {
            throw new Error("span_id component must be a valid UUID");
          }
          const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
            this.rowIds.rootSpanId
          );
          if (!rootSpanIdIsUUID) {
            throw new Error("root_span_id component must be a valid UUID");
          }
          allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
        }
        return Buffer.concat(allBuffers).toString("base64");
      }
      static fromStr(s) {
        try {
          const rawBytes = Buffer.from(s, "base64");
          if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
            throw new Error();
          }
          const objectType = SpanObjectTypeV1EnumSchema.parse(rawBytes[1]);
          if (![0, 1].includes(rawBytes[2])) {
            throw new Error();
          }
          if (![0, 1].includes(rawBytes[3])) {
            throw new Error();
          }
          const hasRowId = rawBytes[2] == 1;
          const rowIdIsUUID = rawBytes[3] == 1;
          const objectId = uuid.stringify(rawBytes.subarray(4, 20));
          const rowIds = (() => {
            if (!hasRowId) {
              return void 0;
            }
            const spanId = uuid.stringify(rawBytes.subarray(20, 36));
            const rootSpanId = uuid.stringify(rawBytes.subarray(36, 52));
            const rowId = rowIdIsUUID ? uuid.stringify(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
            return new SpanRowIdsV1({ rowId, spanId, rootSpanId });
          })();
          return new _SpanComponentsV1({ objectType, objectId, rowIds });
        } catch (e) {
          throw new Error(INVALID_ENCODING_ERRMSG);
        }
      }
      objectIdFields() {
        switch (this.objectType) {
          case 1 /* EXPERIMENT */:
            return { experiment_id: this.objectId };
          case 2 /* PROJECT_LOGS */:
            return { project_id: this.objectId, log_id: "g" };
          default:
            throw new Error("Impossible");
        }
      }
      toObject() {
        return {
          objectType: this.objectType,
          objectId: this.objectId,
          rowIds: _optionalChain([this, 'access', _6 => _6.rowIds, 'optionalAccess', _7 => _7.toObject, 'call', _8 => _8()])
        };
      }
    };
  }
});

// util/span_identifier_v2.ts


function tryMakeUuid2(s) {
  try {
    const ret = uuid2.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER2, INVALID_ENCODING_ERRMSG2, INTEGER_ENCODING_NUM_BYTES, SpanObjectTypeV2, SpanObjectTypeV2EnumSchema, SpanRowIdsV2, SpanComponentsV2;
var init_span_identifier_v2 = __esm({
  "util/span_identifier_v2.ts"() {
    "use strict";
    init_span_identifier_v1();
    ENCODING_VERSION_NUMBER2 = 2;
    INVALID_ENCODING_ERRMSG2 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER2}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    INTEGER_ENCODING_NUM_BYTES = 4;
    SpanObjectTypeV2 = /* @__PURE__ */ ((SpanObjectTypeV22) => {
      SpanObjectTypeV22[SpanObjectTypeV22["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV22[SpanObjectTypeV22["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      return SpanObjectTypeV22;
    })(SpanObjectTypeV2 || {});
    SpanObjectTypeV2EnumSchema = _v3.z.nativeEnum(SpanObjectTypeV2);
    SpanRowIdsV2 = class {
      
      
      
      constructor(args) {
        this.rowId = args.rowId;
        this.spanId = args.spanId;
        this.rootSpanId = args.rootSpanId;
        if (!this.rowId) {
          throw new Error("rowId must be nonempty string");
        }
        if (!this.spanId) {
          throw new Error("spanId must be nonempty string");
        }
        if (!this.rootSpanId) {
          throw new Error("rootSpanId must be nonempty string");
        }
      }
      toObject() {
        return {
          rowId: this.rowId,
          spanId: this.spanId,
          rootSpanId: this.rootSpanId
        };
      }
    };
    SpanComponentsV2 = class _SpanComponentsV2 {
      
      
      
      
      constructor(args) {
        this.objectType = args.objectType;
        this.objectId = args.objectId;
        this.computeObjectMetadataArgs = args.computeObjectMetadataArgs;
        this.rowIds = args.rowIds;
        if (!(this.objectId || this.computeObjectMetadataArgs)) {
          throw new Error(
            "Must provide either objectId or computeObjectMetadataArgs"
          );
        }
      }
      toStr() {
        const allBuffers = [];
        const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid2(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
        allBuffers.push(
          Buffer.from([
            ENCODING_VERSION_NUMBER2,
            this.objectType,
            this.objectId ? 1 : 0,
            this.computeObjectMetadataArgs ? 1 : 0,
            this.rowIds ? 1 : 0,
            rowIdIsUUID ? 1 : 0
          ])
        );
        if (this.objectId) {
          const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid2(
            this.objectId
          );
          if (!objectIdIsUUID) {
            throw new Error("object_id component must be a valid UUID");
          }
          allBuffers.push(objectIdBytes);
        }
        if (this.computeObjectMetadataArgs) {
          const computeObjectMetadataBytes = Buffer.from(
            JSON.stringify(this.computeObjectMetadataArgs),
            "utf-8"
          );
          const serializedLenBytes = Buffer.alloc(INTEGER_ENCODING_NUM_BYTES);
          serializedLenBytes.writeInt32BE(computeObjectMetadataBytes.length);
          allBuffers.push(serializedLenBytes, computeObjectMetadataBytes);
        }
        if (this.rowIds) {
          const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid2(
            this.rowIds.spanId
          );
          if (!spanIdIsUUID) {
            throw new Error("span_id component must be a valid UUID");
          }
          const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid2(
            this.rowIds.rootSpanId
          );
          if (!rootSpanIdIsUUID) {
            throw new Error("root_span_id component must be a valid UUID");
          }
          allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
        }
        return Buffer.concat(allBuffers).toString("base64");
      }
      static fromStr(s) {
        try {
          const rawBytes = Buffer.from(s, "base64");
          if (rawBytes[0] < ENCODING_VERSION_NUMBER2) {
            const spanComponentsOld = SpanComponentsV1.fromStr(s);
            return new _SpanComponentsV2({
              objectType: SpanObjectTypeV2EnumSchema.parse(
                spanComponentsOld.objectType
              ),
              objectId: spanComponentsOld.objectId,
              rowIds: spanComponentsOld.rowIds ? new SpanRowIdsV2({
                rowId: spanComponentsOld.rowIds.rowId,
                spanId: spanComponentsOld.rowIds.spanId,
                rootSpanId: spanComponentsOld.rowIds.rootSpanId
              }) : void 0
            });
          }
          if (rawBytes[0] !== ENCODING_VERSION_NUMBER2) {
            throw new Error();
          }
          const objectType = SpanObjectTypeV2EnumSchema.parse(rawBytes[1]);
          for (let i = 2; i < 6; ++i) {
            if (![0, 1].includes(rawBytes[i])) {
              throw new Error();
            }
          }
          const hasObjectId = rawBytes[2] == 1;
          const hasComputeObjectMetadataArgs = rawBytes[3] == 1;
          const hasRowId = rawBytes[4] == 1;
          const rowIdIsUUID = rawBytes[5] == 1;
          let byteCursor = 6;
          let objectId = void 0;
          if (hasObjectId) {
            const nextByteCursor = byteCursor + 16;
            objectId = uuid2.stringify(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
          }
          let computeObjectMetadataArgs;
          if (hasComputeObjectMetadataArgs) {
            let nextByteCursor = byteCursor + INTEGER_ENCODING_NUM_BYTES;
            const serializedLenBytes = rawBytes.readInt32BE(byteCursor);
            byteCursor = nextByteCursor;
            nextByteCursor = byteCursor + serializedLenBytes;
            computeObjectMetadataArgs = JSON.parse(
              rawBytes.subarray(byteCursor, nextByteCursor).toString("utf-8")
            );
            byteCursor = nextByteCursor;
          }
          const rowIds = (() => {
            if (!hasRowId) {
              return void 0;
            }
            let nextByteCursor = byteCursor + 16;
            const spanId = uuid2.stringify(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
            nextByteCursor = byteCursor + 16;
            const rootSpanId = uuid2.stringify(
              rawBytes.subarray(byteCursor, nextByteCursor)
            );
            byteCursor = nextByteCursor;
            const rowId = rowIdIsUUID ? uuid2.stringify(rawBytes.subarray(byteCursor)) : rawBytes.subarray(byteCursor).toString("utf-8");
            return new SpanRowIdsV2({ rowId, spanId, rootSpanId });
          })();
          return new _SpanComponentsV2({
            objectType,
            objectId,
            computeObjectMetadataArgs,
            rowIds
          });
        } catch (e) {
          throw new Error(INVALID_ENCODING_ERRMSG2);
        }
      }
      objectIdFields() {
        if (!this.objectId) {
          throw new Error(
            "Impossible: cannot invoke `object_id_fields` unless SpanComponentsV2 is initialized with an `object_id`"
          );
        }
        switch (this.objectType) {
          case 1 /* EXPERIMENT */:
            return { experiment_id: this.objectId };
          case 2 /* PROJECT_LOGS */:
            return { project_id: this.objectId, log_id: "g" };
          default:
            throw new Error("Impossible");
        }
      }
      toObject() {
        return {
          objectType: this.objectType,
          objectId: this.objectId,
          computeObjectMetadataArgs: this.computeObjectMetadataArgs,
          rowIds: _optionalChain([this, 'access', _9 => _9.rowIds, 'optionalAccess', _10 => _10.toObject, 'call', _11 => _11()])
        };
      }
    };
  }
});

// util/bytes.ts
function concatUint8Arrays(...arrays) {
  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function uint8ArrayToBase64(uint8Array) {
  let binary = "";
  for (let i = 0; i < uint8Array.length; i++) {
    binary += String.fromCharCode(uint8Array[i]);
  }
  return btoa(binary);
}
function base64ToUint8Array(base64) {
  const binary = atob(base64);
  const uint8Array = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    uint8Array[i] = binary.charCodeAt(i);
  }
  return uint8Array;
}
function uint8ArrayToString(uint8Array) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(uint8Array);
}
function stringToUint8Array(str) {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}
var init_bytes = __esm({
  "util/bytes.ts"() {
    "use strict";
  }
});

// util/span_identifier_v3.ts


function tryMakeUuid3(s) {
  try {
    const ret = uuid3.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: new Uint8Array(ret), isUUID: true };
  } catch (e2) {
    return { bytes: void 0, isUUID: false };
  }
}
function spanObjectTypeV3ToString(objectType) {
  switch (objectType) {
    case 1 /* EXPERIMENT */:
      return "experiment";
    case 2 /* PROJECT_LOGS */:
      return "project_logs";
    case 3 /* PLAYGROUND_LOGS */:
      return "playground_logs";
    default:
      const x = objectType;
      throw new Error(`Unknown SpanObjectTypeV3: ${x}`);
  }
}
var ENCODING_VERSION_NUMBER3, INVALID_ENCODING_ERRMSG3, SpanObjectTypeV3, spanObjectTypeV3EnumSchema, InternalSpanComponentUUIDFields, internalSpanComponentUUIDFieldsEnumSchema, _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME, spanComponentsV3Schema, SpanComponentsV3;
var init_span_identifier_v3 = __esm({
  "util/span_identifier_v3.ts"() {
    "use strict";
    init_span_identifier_v2();
    init_bytes();
    ENCODING_VERSION_NUMBER3 = 3;
    INVALID_ENCODING_ERRMSG3 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER3}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    SpanObjectTypeV3 = /* @__PURE__ */ ((SpanObjectTypeV32) => {
      SpanObjectTypeV32[SpanObjectTypeV32["EXPERIMENT"] = 1] = "EXPERIMENT";
      SpanObjectTypeV32[SpanObjectTypeV32["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
      SpanObjectTypeV32[SpanObjectTypeV32["PLAYGROUND_LOGS"] = 3] = "PLAYGROUND_LOGS";
      return SpanObjectTypeV32;
    })(SpanObjectTypeV3 || {});
    spanObjectTypeV3EnumSchema = _v3.z.nativeEnum(SpanObjectTypeV3);
    InternalSpanComponentUUIDFields = /* @__PURE__ */ ((InternalSpanComponentUUIDFields2) => {
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["OBJECT_ID"] = 1] = "OBJECT_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROW_ID"] = 2] = "ROW_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["SPAN_ID"] = 3] = "SPAN_ID";
      InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROOT_SPAN_ID"] = 4] = "ROOT_SPAN_ID";
      return InternalSpanComponentUUIDFields2;
    })(InternalSpanComponentUUIDFields || {});
    internalSpanComponentUUIDFieldsEnumSchema = _v3.z.nativeEnum(
      InternalSpanComponentUUIDFields
    );
    _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME = {
      [1 /* OBJECT_ID */]: "object_id",
      [2 /* ROW_ID */]: "row_id",
      [3 /* SPAN_ID */]: "span_id",
      [4 /* ROOT_SPAN_ID */]: "root_span_id"
    };
    spanComponentsV3Schema = _v3.z.object({
      object_type: spanObjectTypeV3EnumSchema,
      // TODO(manu): We should have a more elaborate zod schema for
      // `propagated_event`. This will required zod-ifying the contents of
      // sdk/js/util/object.ts.
      propagated_event: _v3.z.record(_v3.z.unknown()).nullish()
    }).and(
      _v3.z.union([
        // Must provide one or the other.
        _v3.z.object({
          object_id: _v3.z.string().nullish(),
          compute_object_metadata_args: _v3.z.optional(_v3.z.null())
        }),
        _v3.z.object({
          object_id: _v3.z.optional(_v3.z.null()),
          compute_object_metadata_args: _v3.z.record(_v3.z.unknown())
        })
      ])
    ).and(
      _v3.z.union([
        // Either all of these must be provided or none.
        _v3.z.object({
          row_id: _v3.z.string(),
          span_id: _v3.z.string(),
          root_span_id: _v3.z.string()
        }),
        _v3.z.object({
          row_id: _v3.z.optional(_v3.z.null()),
          span_id: _v3.z.optional(_v3.z.null()),
          root_span_id: _v3.z.optional(_v3.z.null())
        })
      ])
    );
    SpanComponentsV3 = class _SpanComponentsV3 {
      constructor(data) {
        this.data = data;
      }
      toStr() {
        const jsonObj = {
          compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
          propagated_event: this.data.propagated_event || void 0
        };
        const allBuffers = [];
        allBuffers.push(
          new Uint8Array([ENCODING_VERSION_NUMBER3, this.data.object_type])
        );
        const uuidEntries = [];
        function addUuidField(origVal, fieldId) {
          const ret = tryMakeUuid3(origVal);
          if (ret.isUUID) {
            uuidEntries.push(
              concatUint8Arrays(new Uint8Array([fieldId]), ret.bytes)
            );
          } else {
            jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = origVal;
          }
        }
        if (this.data.object_id) {
          addUuidField(
            this.data.object_id,
            1 /* OBJECT_ID */
          );
        }
        if (this.data.row_id) {
          addUuidField(this.data.row_id, 2 /* ROW_ID */);
        }
        if (this.data.span_id) {
          addUuidField(this.data.span_id, 3 /* SPAN_ID */);
        }
        if (this.data.root_span_id) {
          addUuidField(
            this.data.root_span_id,
            4 /* ROOT_SPAN_ID */
          );
        }
        if (uuidEntries.length > 255) {
          throw new Error("Impossible: too many UUID entries to encode");
        }
        allBuffers.push(new Uint8Array([uuidEntries.length]));
        allBuffers.push(...uuidEntries);
        if (Object.keys(jsonObj).length > 0) {
          allBuffers.push(stringToUint8Array(JSON.stringify(jsonObj)));
        }
        return uint8ArrayToBase64(concatUint8Arrays(...allBuffers));
      }
      static fromStr(s) {
        try {
          const rawBytes = base64ToUint8Array(s);
          const jsonObj = {};
          if (rawBytes[0] < ENCODING_VERSION_NUMBER3) {
            const spanComponentsOld = SpanComponentsV2.fromStr(s);
            jsonObj["object_type"] = spanComponentsOld.objectType;
            jsonObj["object_id"] = spanComponentsOld.objectId;
            jsonObj["compute_object_metadata_args"] = spanComponentsOld.computeObjectMetadataArgs;
            if (spanComponentsOld.rowIds) {
              jsonObj["row_id"] = spanComponentsOld.rowIds.rowId;
              jsonObj["span_id"] = spanComponentsOld.rowIds.spanId;
              jsonObj["root_span_id"] = spanComponentsOld.rowIds.rootSpanId;
            }
          } else {
            jsonObj["object_type"] = rawBytes[1];
            const numUuidEntries = rawBytes[2];
            let byteOffset = 3;
            for (let i = 0; i < numUuidEntries; ++i) {
              const fieldId = internalSpanComponentUUIDFieldsEnumSchema.parse(
                rawBytes[byteOffset]
              );
              const fieldBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
              byteOffset += 17;
              jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = uuid3.stringify(fieldBytes);
            }
            if (byteOffset < rawBytes.length) {
              const remainingJsonObj = JSON.parse(
                uint8ArrayToString(rawBytes.subarray(byteOffset))
              );
              Object.assign(jsonObj, remainingJsonObj);
            }
          }
          return _SpanComponentsV3.fromJsonObj(jsonObj);
        } catch (e3) {
          throw new Error(INVALID_ENCODING_ERRMSG3);
        }
      }
      objectIdFields() {
        if (!this.data.object_id) {
          throw new Error(
            "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV3 is initialized with an `object_id`"
          );
        }
        switch (this.data.object_type) {
          case 1 /* EXPERIMENT */:
            return { experiment_id: this.data.object_id };
          case 2 /* PROJECT_LOGS */:
            return { project_id: this.data.object_id, log_id: "g" };
          case 3 /* PLAYGROUND_LOGS */:
            return { prompt_session_id: this.data.object_id, log_id: "x" };
          default:
            const _ = this.data.object_type;
            throw new Error("Impossible");
        }
      }
      async export() {
        return this.toStr();
      }
      static fromJsonObj(jsonObj) {
        return new _SpanComponentsV3(spanComponentsV3Schema.parse(jsonObj));
      }
    };
  }
});

// util/http_headers.ts
var init_http_headers = __esm({
  "util/http_headers.ts"() {
    "use strict";
    init_span_identifier_v3();
  }
});

// util/type_util.ts
function isObject(value) {
  return value instanceof Object && !(value instanceof Array);
}
function isArray(value) {
  return value instanceof Array;
}
function isObjectOrArray(value) {
  return value instanceof Object;
}
var init_type_util = __esm({
  "util/type_util.ts"() {
    "use strict";
  }
});

// util/object_util.ts
function mergeDictsWithPaths({
  mergeInto,
  mergeFrom,
  mergePaths
}) {
  const mergePathsSerialized = new Set(
    mergePaths.map((p) => JSON.stringify(p))
  );
  return mergeDictsWithPathsHelper({
    mergeInto,
    mergeFrom,
    path: [],
    mergePaths: mergePathsSerialized
  });
}
function mergeDictsWithPathsHelper({
  mergeInto,
  mergeFrom,
  path: path3,
  mergePaths
}) {
  Object.entries(mergeFrom).forEach(([k, mergeFromV]) => {
    const fullPath = path3.concat([k]);
    const fullPathSerialized = JSON.stringify(fullPath);
    const mergeIntoV = recordFind(mergeInto, k);
    if (isObject(mergeIntoV) && isObject(mergeFromV) && !mergePaths.has(fullPathSerialized)) {
      mergeDictsWithPathsHelper({
        mergeInto: mergeIntoV,
        mergeFrom: mergeFromV,
        path: fullPath,
        mergePaths
      });
    } else {
      if (mergeFromV !== void 0) {
        mergeInto[k] = mergeFromV;
      }
    }
  });
  return mergeInto;
}
function mergeDicts(mergeInto, mergeFrom) {
  return mergeDictsWithPaths({ mergeInto, mergeFrom, mergePaths: [] });
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}
function recordFind(m, k) {
  return m[k];
}
function getObjValueByPath(row, path3) {
  let curr = row;
  for (const p of path3) {
    if (!isObjectOrArray(curr)) {
      return null;
    }
    curr = curr[p];
  }
  return curr;
}
var init_object_util = __esm({
  "util/object_util.ts"() {
    "use strict";
    init_type_util();
  }
});

// util/graph_util.ts
function depthFirstSearch(args) {
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = _nullishCoalesce(args.visitationOrder, () => ( [...graph.keys()]));
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      _optionalChain([lastVisitF, 'optionalCall', _12 => _12(vertex)]);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    _optionalChain([firstVisitF, 'optionalCall', _13 => _13(vertex, { parentVertex: extras.parentVertex })]);
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = _optionalChain([args, 'optionalAccess', _14 => _14.parentVertex]) !== void 0 ? mapAt(vertexLabels, _optionalChain([args, 'optionalAccess', _15 => _15.parentVertex])) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}
var init_graph_util = __esm({
  "util/graph_util.ts"() {
    "use strict";
    init_object_util();
  }
});

// util/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      _nullishCoalesce(useParentIdForId, () => ( false)) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
function popMergeRowSkipFields(row) {
  const popped = {};
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    if (field in row) {
      popped[field] = row[field];
      delete row[field];
    }
  }
  return popped;
}
function restoreMergeRowSkipFields(row, skipFields) {
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    delete row[field];
    if (field in skipFields) {
      row[field] = skipFields[field];
    }
  }
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrust.dev for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const skipFields = popMergeRowSkipFields(existingRow);
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      restoreMergeRowSkipFields(existingRow, skipFields);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  let { items } = args;
  const batchMaxNumItems = _nullishCoalesce(args.batchMaxNumItems, () => ( Number.POSITIVE_INFINITY));
  const batchMaxNumBytes = _nullishCoalesce(args.batchMaxNumBytes, () => ( Number.POSITIVE_INFINITY));
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}
var MERGE_ROW_SKIP_FIELDS;
var init_merge_row_batch = __esm({
  "util/merge_row_batch.ts"() {
    "use strict";
    init_db_fields();
    init_object_util();
    init_graph_util();
    MERGE_ROW_SKIP_FIELDS = [
      "created",
      "span_id",
      "root_span_id",
      "span_parents",
      "_parent_id"
      // TODO: handle merge paths.
    ];
  }
});

// util/object.ts
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
var DEFAULT_IS_LEGACY_DATASET;
var init_object = __esm({
  "util/object.ts"() {
    "use strict";
    DEFAULT_IS_LEGACY_DATASET = false;
  }
});

// util/score.ts
var init_score = __esm({
  "util/score.ts"() {
    "use strict";
  }
});

// util/json_util.ts
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}
var init_json_util = __esm({
  "util/json_util.ts"() {
    "use strict";
  }
});

// util/string_util.ts
function _urljoin(...parts) {
  return parts.map(
    (x, i) => x.replace(/^\//, "").replace(i < parts.length - 1 ? /\/$/ : "", "")
  ).filter((x) => x.trim() !== "").join("/");
}
var init_string_util = __esm({
  "util/string_util.ts"() {
    "use strict";
  }
});

// util/span_identifier_v4.ts

function tryMakeHexTraceId(s) {
  try {
    if (typeof s === "string" && s.length === 32) {
      const bytes = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        const hex = s.substr(i * 2, 2);
        const byte = parseInt(hex, 16);
        if (isNaN(byte)) throw new Error();
        bytes[i] = byte;
      }
      return { bytes, isHex: true };
    }
  } catch (e4) {
  }
  return { bytes: void 0, isHex: false };
}
function tryMakeHexSpanId(s) {
  try {
    if (typeof s === "string" && s.length === 16) {
      const bytes = new Uint8Array(8);
      for (let i = 0; i < 8; i++) {
        const hex = s.substr(i * 2, 2);
        const byte = parseInt(hex, 16);
        if (isNaN(byte)) throw new Error();
        bytes[i] = byte;
      }
      return { bytes, isHex: true };
    }
  } catch (e5) {
  }
  return { bytes: void 0, isHex: false };
}
var ENCODING_VERSION_NUMBER_V4, INVALID_ENCODING_ERRMSG_V4, FIELDS_ID_TO_NAME, spanComponentsV4Schema, SpanComponentsV4;
var init_span_identifier_v4 = __esm({
  "util/span_identifier_v4.ts"() {
    "use strict";
    init_span_identifier_v3();
    init_bytes();
    ENCODING_VERSION_NUMBER_V4 = 4;
    INVALID_ENCODING_ERRMSG_V4 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER_V4}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
    FIELDS_ID_TO_NAME = {
      [1 /* OBJECT_ID */]: "object_id",
      [2 /* ROW_ID */]: "row_id",
      [3 /* SPAN_ID */]: "span_id",
      [4 /* ROOT_SPAN_ID */]: "root_span_id"
    };
    spanComponentsV4Schema = _v3.z.object({
      object_type: spanObjectTypeV3EnumSchema,
      propagated_event: _v3.z.record(_v3.z.unknown()).nullish()
    }).and(
      _v3.z.union([
        // Must provide one or the other.
        _v3.z.object({
          object_id: _v3.z.string().nullish(),
          compute_object_metadata_args: _v3.z.optional(_v3.z.null())
        }),
        _v3.z.object({
          object_id: _v3.z.optional(_v3.z.null()),
          compute_object_metadata_args: _v3.z.record(_v3.z.unknown())
        })
      ])
    ).and(
      _v3.z.union([
        // Either all of these must be provided or none.
        _v3.z.object({
          row_id: _v3.z.string(),
          span_id: _v3.z.string(),
          root_span_id: _v3.z.string()
        }),
        _v3.z.object({
          row_id: _v3.z.optional(_v3.z.null()),
          span_id: _v3.z.optional(_v3.z.null()),
          root_span_id: _v3.z.optional(_v3.z.null())
        })
      ])
    );
    SpanComponentsV4 = class _SpanComponentsV4 {
      constructor(data) {
        this.data = data;
      }
      toStr() {
        const jsonObj = {
          compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
          propagated_event: this.data.propagated_event || void 0
        };
        Object.keys(jsonObj).forEach((key) => {
          if (jsonObj[key] === void 0) {
            delete jsonObj[key];
          }
        });
        const allBuffers = [];
        allBuffers.push(
          new Uint8Array([ENCODING_VERSION_NUMBER_V4, this.data.object_type])
        );
        const hexEntries = [];
        function addHexField(origVal, fieldId) {
          let hexResult;
          if (fieldId === 3 /* SPAN_ID */) {
            hexResult = tryMakeHexSpanId(origVal);
          } else if (fieldId === 4 /* ROOT_SPAN_ID */) {
            hexResult = tryMakeHexTraceId(origVal);
          } else {
            hexResult = { bytes: void 0, isHex: false };
          }
          if (hexResult.isHex) {
            hexEntries.push(
              concatUint8Arrays(new Uint8Array([fieldId]), hexResult.bytes)
            );
          } else {
            jsonObj[FIELDS_ID_TO_NAME[fieldId]] = origVal;
          }
        }
        if (this.data.object_id) {
          addHexField(this.data.object_id, 1 /* OBJECT_ID */);
        }
        if (this.data.row_id) {
          addHexField(this.data.row_id, 2 /* ROW_ID */);
        }
        if (this.data.span_id) {
          addHexField(this.data.span_id, 3 /* SPAN_ID */);
        }
        if (this.data.root_span_id) {
          addHexField(this.data.root_span_id, 4 /* ROOT_SPAN_ID */);
        }
        if (hexEntries.length > 255) {
          throw new Error("Impossible: too many hex entries to encode");
        }
        allBuffers.push(new Uint8Array([hexEntries.length]));
        allBuffers.push(...hexEntries);
        if (Object.keys(jsonObj).length > 0) {
          allBuffers.push(stringToUint8Array(JSON.stringify(jsonObj)));
        }
        return uint8ArrayToBase64(concatUint8Arrays(...allBuffers));
      }
      static fromStr(s) {
        try {
          const rawBytes = base64ToUint8Array(s);
          const jsonObj = {};
          if (rawBytes[0] < ENCODING_VERSION_NUMBER_V4) {
            const v3Components = SpanComponentsV3.fromStr(s);
            jsonObj["object_type"] = v3Components.data.object_type;
            jsonObj["object_id"] = v3Components.data.object_id;
            jsonObj["compute_object_metadata_args"] = v3Components.data.compute_object_metadata_args;
            jsonObj["row_id"] = v3Components.data.row_id;
            jsonObj["span_id"] = v3Components.data.span_id;
            jsonObj["root_span_id"] = v3Components.data.root_span_id;
            jsonObj["propagated_event"] = v3Components.data.propagated_event;
          } else {
            jsonObj["object_type"] = rawBytes[1];
            const numHexEntries = rawBytes[2];
            let byteOffset = 3;
            for (let i = 0; i < numHexEntries; i++) {
              const fieldId = rawBytes[byteOffset];
              if (fieldId === 3 /* SPAN_ID */) {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 9);
                byteOffset += 9;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              } else if (fieldId === 4 /* ROOT_SPAN_ID */) {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
                byteOffset += 17;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              } else {
                const hexBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
                byteOffset += 17;
                jsonObj[FIELDS_ID_TO_NAME[fieldId]] = Array.from(
                  hexBytes,
                  (b) => b.toString(16).padStart(2, "0")
                ).join("");
              }
            }
            if (byteOffset < rawBytes.length) {
              const remainingJsonObj = JSON.parse(
                uint8ArrayToString(rawBytes.subarray(byteOffset))
              );
              Object.assign(jsonObj, remainingJsonObj);
            }
          }
          return _SpanComponentsV4.fromJsonObj(jsonObj);
        } catch (e6) {
          throw new Error(INVALID_ENCODING_ERRMSG_V4);
        }
      }
      objectIdFields() {
        if (!this.data.object_id) {
          throw new Error(
            "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV4 is initialized with an `object_id`"
          );
        }
        switch (this.data.object_type) {
          case 1 /* EXPERIMENT */:
            return { experiment_id: this.data.object_id };
          case 2 /* PROJECT_LOGS */:
            return { project_id: this.data.object_id, log_id: "g" };
          case 3 /* PLAYGROUND_LOGS */:
            return { prompt_session_id: this.data.object_id, log_id: "x" };
          default:
            const _ = this.data.object_type;
            throw new Error(`Invalid object_type ${this.data.object_type}`);
        }
      }
      async export() {
        return this.toStr();
      }
      static fromJsonObj(jsonObj) {
        return new _SpanComponentsV4(spanComponentsV4Schema.parse(jsonObj));
      }
    };
  }
});

// util/span_types.ts
var init_span_types = __esm({
  "util/span_types.ts"() {
    "use strict";
  }
});

// util/git_fields.ts
function mergeGitMetadataSettings(s1, s2) {
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = (_nullishCoalesce(s1.fields, () => ( []))).filter((f) => (_nullishCoalesce(s2.fields, () => ( []))).includes(f));
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}
var init_git_fields = __esm({
  "util/git_fields.ts"() {
    "use strict";
  }
});

// util/xact-ids.ts
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  if (encodedHex.length !== 16) {
    return encodedHex;
  }
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}
var TOP_BITS, MOD, COPRIME, COPRIME_INVERSE;
var init_xact_ids = __esm({
  "util/xact-ids.ts"() {
    "use strict";
    TOP_BITS = BigInt("0x0DE1") << BigInt(48);
    MOD = BigInt(1) << BigInt(64);
    COPRIME = BigInt("205891132094649");
    COPRIME_INVERSE = BigInt("1522336535492693385");
  }
});

// util/zod_util.ts

var init_zod_util = __esm({
  "util/zod_util.ts"() {
    "use strict";
    init_object_util();
  }
});

// util/index.ts
var init_util = __esm({
  "util/index.ts"() {
    "use strict";
    init_db_fields();
    init_http_headers();
    init_merge_row_batch();
    init_object();
    init_score();
    init_json_util();
    init_object_util();
    init_string_util();
    init_type_util();
    init_span_identifier_v1();
    init_span_identifier_v2();
    init_span_identifier_v3();
    init_span_identifier_v4();
    init_span_types();
    init_git_fields();
    init_xact_ids();
    init_zod_util();
    init_bytes();
  }
});

// src/generated_types.ts

var AclObjectType, Permission, Acl, AISecret, ResponseFormatJsonSchema, ResponseFormatNullish, AnyModelParams, ApiKey, AsyncScoringState, AsyncScoringControl, BraintrustAttachmentReference, ExternalAttachmentReference, AttachmentReference, UploadStatus, AttachmentStatus, BraintrustModelParams, CallEvent, ChatCompletionContentPartTextWithTitle, ChatCompletionContentPartImageWithTitle, ChatCompletionContentPart, ChatCompletionContentPartText, ChatCompletionMessageToolCall, ChatCompletionMessageReasoning, ChatCompletionMessageParam, ChatCompletionOpenAIMessageParam, ChatCompletionTool, CodeBundle, Dataset, ObjectReferenceNullish, DatasetEvent, EnvVar, RepoInfo, Experiment, SpanType, SpanAttributes, ExperimentEvent, ExtendedSavedFunctionId, PromptBlockDataNullish, ModelParams, PromptOptionsNullish, PromptParserNullish, SavedFunctionId, PromptDataNullish, FunctionTypeEnumNullish, FunctionIdRef, PromptBlockData, GraphNode, GraphEdge, GraphData, FunctionData, Function, FunctionFormat, PromptData, FunctionTypeEnum, FunctionId, FunctionObjectType, FunctionOutputType, GitMetadataSettings, Group, IfExists, InvokeParent, StreamingMode, InvokeFunction, MessageRole, ObjectReference, OnlineScoreConfig, Organization, ProjectSettings, Project, RetentionObjectType, ProjectAutomation, ProjectLogsEvent, ProjectScoreType, ProjectScoreCategory, ProjectScoreCategories, ProjectScoreConfig, ProjectScore, ProjectTag, Prompt, PromptOptions, PromptSessionEvent, ResponseFormat, Role, RunEval, ServiceToken, SpanIFrame, SSEConsoleEventData, SSEProgressEventData, ToolFunctionDefinition, User, ViewDataSearch, ViewData, ViewOptions, View;
var init_generated_types = __esm({
  "src/generated_types.ts"() {
    "use strict";
    AclObjectType = _v3.z.union([
      _v3.z.enum([
        "organization",
        "project",
        "experiment",
        "dataset",
        "prompt",
        "prompt_session",
        "group",
        "role",
        "org_member",
        "project_log",
        "org_project"
      ]),
      _v3.z.null()
    ]);
    Permission = _v3.z.enum([
      "create",
      "read",
      "update",
      "delete",
      "create_acls",
      "read_acls",
      "update_acls",
      "delete_acls"
    ]);
    Acl = _v3.z.object({
      id: _v3.z.string().uuid(),
      object_type: AclObjectType.and(_v3.z.string()),
      object_id: _v3.z.string().uuid(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      group_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      permission: Permission.and(_v3.z.union([_v3.z.string(), _v3.z.null()])).optional(),
      restrict_object_type: AclObjectType.and(_v3.z.unknown()).optional(),
      role_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      _object_org_id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    AISecret = _v3.z.object({
      id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      updated_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      org_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      type: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional(),
      preview_secret: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    ResponseFormatJsonSchema = _v3.z.object({
      name: _v3.z.string(),
      description: _v3.z.string().optional(),
      schema: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.string()]).optional(),
      strict: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
    });
    ResponseFormatNullish = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("json_object") }),
      _v3.z.object({
        type: _v3.z.literal("json_schema"),
        json_schema: ResponseFormatJsonSchema
      }),
      _v3.z.object({ type: _v3.z.literal("text") }),
      _v3.z.null()
    ]);
    AnyModelParams = _v3.z.object({
      temperature: _v3.z.number().optional(),
      top_p: _v3.z.number().optional(),
      max_tokens: _v3.z.number(),
      max_completion_tokens: _v3.z.number().optional(),
      frequency_penalty: _v3.z.number().optional(),
      presence_penalty: _v3.z.number().optional(),
      response_format: ResponseFormatNullish.optional(),
      tool_choice: _v3.z.union([
        _v3.z.literal("auto"),
        _v3.z.literal("none"),
        _v3.z.literal("required"),
        _v3.z.object({
          type: _v3.z.literal("function"),
          function: _v3.z.object({ name: _v3.z.string() })
        })
      ]).optional(),
      function_call: _v3.z.union([
        _v3.z.literal("auto"),
        _v3.z.literal("none"),
        _v3.z.object({ name: _v3.z.string() })
      ]).optional(),
      n: _v3.z.number().optional(),
      stop: _v3.z.array(_v3.z.string()).optional(),
      reasoning_effort: _v3.z.enum(["minimal", "low", "medium", "high"]).optional(),
      verbosity: _v3.z.enum(["low", "medium", "high"]).optional(),
      top_k: _v3.z.number().optional(),
      stop_sequences: _v3.z.array(_v3.z.string()).optional(),
      max_tokens_to_sample: _v3.z.number().optional(),
      maxOutputTokens: _v3.z.number().optional(),
      topP: _v3.z.number().optional(),
      topK: _v3.z.number().optional(),
      use_cache: _v3.z.boolean().optional()
    });
    ApiKey = _v3.z.object({
      id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      preview_name: _v3.z.string(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_email: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_given_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_family_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      org_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    AsyncScoringState = _v3.z.union([
      _v3.z.object({
        status: _v3.z.literal("enabled"),
        token: _v3.z.string(),
        function_ids: _v3.z.array(_v3.z.unknown()).min(1),
        skip_logging: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
      }),
      _v3.z.object({ status: _v3.z.literal("disabled") }),
      _v3.z.null(),
      _v3.z.null()
    ]);
    AsyncScoringControl = _v3.z.union([
      _v3.z.object({ kind: _v3.z.literal("score_update"), token: _v3.z.string() }),
      _v3.z.object({ kind: _v3.z.literal("state_override"), state: AsyncScoringState }),
      _v3.z.object({ kind: _v3.z.literal("state_force_reselect") }),
      _v3.z.object({ kind: _v3.z.literal("state_enabled_force_rescore") })
    ]);
    BraintrustAttachmentReference = _v3.z.object({
      type: _v3.z.literal("braintrust_attachment"),
      filename: _v3.z.string().min(1),
      content_type: _v3.z.string().min(1),
      key: _v3.z.string().min(1)
    });
    ExternalAttachmentReference = _v3.z.object({
      type: _v3.z.literal("external_attachment"),
      filename: _v3.z.string().min(1),
      content_type: _v3.z.string().min(1),
      url: _v3.z.string().min(1)
    });
    AttachmentReference = _v3.z.discriminatedUnion("type", [
      BraintrustAttachmentReference,
      ExternalAttachmentReference
    ]);
    UploadStatus = _v3.z.enum(["uploading", "done", "error"]);
    AttachmentStatus = _v3.z.object({
      upload_status: UploadStatus,
      error_message: _v3.z.string().optional()
    });
    BraintrustModelParams = _v3.z.object({ use_cache: _v3.z.boolean() }).partial();
    CallEvent = _v3.z.union([
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("text_delta")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("reasoning_delta")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("json_delta")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("progress")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("error")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        data: _v3.z.string(),
        event: _v3.z.literal("console")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        event: _v3.z.literal("start"),
        data: _v3.z.literal("")
      }),
      _v3.z.object({
        id: _v3.z.string().optional(),
        event: _v3.z.literal("done"),
        data: _v3.z.literal("")
      })
    ]);
    ChatCompletionContentPartTextWithTitle = _v3.z.object({
      text: _v3.z.string().default(""),
      type: _v3.z.literal("text"),
      cache_control: _v3.z.object({ type: _v3.z.literal("ephemeral") }).optional()
    });
    ChatCompletionContentPartImageWithTitle = _v3.z.object({
      image_url: _v3.z.object({
        url: _v3.z.string(),
        detail: _v3.z.union([_v3.z.literal("auto"), _v3.z.literal("low"), _v3.z.literal("high")]).optional()
      }),
      type: _v3.z.literal("image_url")
    });
    ChatCompletionContentPart = _v3.z.union([
      ChatCompletionContentPartTextWithTitle,
      ChatCompletionContentPartImageWithTitle
    ]);
    ChatCompletionContentPartText = _v3.z.object({
      text: _v3.z.string().default(""),
      type: _v3.z.literal("text"),
      cache_control: _v3.z.object({ type: _v3.z.literal("ephemeral") }).optional()
    });
    ChatCompletionMessageToolCall = _v3.z.object({
      id: _v3.z.string(),
      function: _v3.z.object({ arguments: _v3.z.string(), name: _v3.z.string() }),
      type: _v3.z.literal("function")
    });
    ChatCompletionMessageReasoning = _v3.z.object({ id: _v3.z.string(), content: _v3.z.string() }).partial();
    ChatCompletionMessageParam = _v3.z.union([
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("system"),
        name: _v3.z.string().optional()
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPart)]),
        role: _v3.z.literal("user"),
        name: _v3.z.string().optional()
      }),
      _v3.z.object({
        role: _v3.z.literal("assistant"),
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText), _v3.z.null()]).optional(),
        function_call: _v3.z.object({ arguments: _v3.z.string(), name: _v3.z.string() }).optional(),
        name: _v3.z.string().optional(),
        tool_calls: _v3.z.array(ChatCompletionMessageToolCall).optional(),
        reasoning: _v3.z.array(ChatCompletionMessageReasoning).optional()
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("tool"),
        tool_call_id: _v3.z.string().default("")
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        name: _v3.z.string(),
        role: _v3.z.literal("function")
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("developer"),
        name: _v3.z.string().optional()
      }),
      _v3.z.object({
        role: _v3.z.literal("model"),
        content: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      })
    ]);
    ChatCompletionOpenAIMessageParam = _v3.z.union([
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("system"),
        name: _v3.z.string().optional()
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPart)]),
        role: _v3.z.literal("user"),
        name: _v3.z.string().optional()
      }),
      _v3.z.object({
        role: _v3.z.literal("assistant"),
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText), _v3.z.null()]).optional(),
        function_call: _v3.z.object({ arguments: _v3.z.string(), name: _v3.z.string() }).optional(),
        name: _v3.z.string().optional(),
        tool_calls: _v3.z.array(ChatCompletionMessageToolCall).optional(),
        reasoning: _v3.z.array(ChatCompletionMessageReasoning).optional()
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("tool"),
        tool_call_id: _v3.z.string().default("")
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        name: _v3.z.string(),
        role: _v3.z.literal("function")
      }),
      _v3.z.object({
        content: _v3.z.union([_v3.z.string(), _v3.z.array(ChatCompletionContentPartText)]),
        role: _v3.z.literal("developer"),
        name: _v3.z.string().optional()
      })
    ]);
    ChatCompletionTool = _v3.z.object({
      function: _v3.z.object({
        name: _v3.z.string(),
        description: _v3.z.string().optional(),
        parameters: _v3.z.object({}).partial().passthrough().optional()
      }),
      type: _v3.z.literal("function")
    });
    CodeBundle = _v3.z.object({
      runtime_context: _v3.z.object({
        runtime: _v3.z.enum(["node", "python"]),
        version: _v3.z.string()
      }),
      location: _v3.z.union([
        _v3.z.object({
          type: _v3.z.literal("experiment"),
          eval_name: _v3.z.string(),
          position: _v3.z.union([
            _v3.z.object({ type: _v3.z.literal("task") }),
            _v3.z.object({ type: _v3.z.literal("scorer"), index: _v3.z.number().int().gte(0) })
          ])
        }),
        _v3.z.object({ type: _v3.z.literal("function"), index: _v3.z.number().int().gte(0) })
      ]),
      bundle_id: _v3.z.string(),
      preview: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    Dataset = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional()
    });
    ObjectReferenceNullish = _v3.z.union([
      _v3.z.object({
        object_type: _v3.z.enum([
          "project_logs",
          "experiment",
          "dataset",
          "prompt",
          "function",
          "prompt_session"
        ]),
        object_id: _v3.z.string().uuid(),
        id: _v3.z.string(),
        _xact_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      }),
      _v3.z.null()
    ]);
    DatasetEvent = _v3.z.object({
      id: _v3.z.string(),
      _xact_id: _v3.z.string(),
      created: _v3.z.string().datetime({ offset: true }),
      _pagination_key: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      project_id: _v3.z.string().uuid(),
      dataset_id: _v3.z.string().uuid(),
      input: _v3.z.unknown().optional(),
      expected: _v3.z.unknown().optional(),
      metadata: _v3.z.union([
        _v3.z.object({ model: _v3.z.union([_v3.z.string(), _v3.z.null()]) }).partial().passthrough(),
        _v3.z.null()
      ]).optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      span_id: _v3.z.string(),
      root_span_id: _v3.z.string(),
      is_root: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      origin: ObjectReferenceNullish.optional()
    });
    EnvVar = _v3.z.object({
      id: _v3.z.string().uuid(),
      object_type: _v3.z.enum(["organization", "project", "function"]),
      object_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      used: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    RepoInfo = _v3.z.union([
      _v3.z.object({
        commit: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        branch: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        tag: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        dirty: _v3.z.union([_v3.z.boolean(), _v3.z.null()]),
        author_name: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        author_email: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        commit_message: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        commit_time: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        git_diff: _v3.z.union([_v3.z.string(), _v3.z.null()])
      }).partial(),
      _v3.z.null()
    ]);
    Experiment = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      repo_info: RepoInfo.optional(),
      commit: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      base_exp_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      dataset_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      dataset_version: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      public: _v3.z.boolean(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional()
    });
    SpanType = _v3.z.union([
      _v3.z.enum(["llm", "score", "function", "eval", "task", "tool"]),
      _v3.z.null()
    ]);
    SpanAttributes = _v3.z.union([
      _v3.z.object({ name: _v3.z.union([_v3.z.string(), _v3.z.null()]), type: SpanType }).partial().passthrough(),
      _v3.z.null()
    ]);
    ExperimentEvent = _v3.z.object({
      id: _v3.z.string(),
      _xact_id: _v3.z.string(),
      created: _v3.z.string().datetime({ offset: true }),
      _pagination_key: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      project_id: _v3.z.string().uuid(),
      experiment_id: _v3.z.string().uuid(),
      input: _v3.z.unknown().optional(),
      output: _v3.z.unknown().optional(),
      expected: _v3.z.unknown().optional(),
      error: _v3.z.unknown().optional(),
      scores: _v3.z.union([_v3.z.record(_v3.z.union([_v3.z.number(), _v3.z.null()])), _v3.z.null()]).optional(),
      metadata: _v3.z.union([
        _v3.z.object({ model: _v3.z.union([_v3.z.string(), _v3.z.null()]) }).partial().passthrough(),
        _v3.z.null()
      ]).optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      metrics: _v3.z.union([_v3.z.record(_v3.z.number()), _v3.z.null()]).optional(),
      context: _v3.z.union([
        _v3.z.object({
          caller_functionname: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          caller_filename: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          caller_lineno: _v3.z.union([_v3.z.number(), _v3.z.null()])
        }).partial().passthrough(),
        _v3.z.null()
      ]).optional(),
      span_id: _v3.z.string(),
      span_parents: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      root_span_id: _v3.z.string(),
      span_attributes: SpanAttributes.optional(),
      is_root: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      origin: ObjectReferenceNullish.optional()
    });
    ExtendedSavedFunctionId = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("function"), id: _v3.z.string() }),
      _v3.z.object({ type: _v3.z.literal("global"), name: _v3.z.string() }),
      _v3.z.object({
        type: _v3.z.literal("slug"),
        project_id: _v3.z.string(),
        slug: _v3.z.string()
      })
    ]);
    PromptBlockDataNullish = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("completion"), content: _v3.z.string() }),
      _v3.z.object({
        type: _v3.z.literal("chat"),
        messages: _v3.z.array(ChatCompletionMessageParam),
        tools: _v3.z.string().optional()
      }),
      _v3.z.null()
    ]);
    ModelParams = _v3.z.union([
      _v3.z.object({
        use_cache: _v3.z.boolean(),
        temperature: _v3.z.number(),
        top_p: _v3.z.number(),
        max_tokens: _v3.z.number(),
        max_completion_tokens: _v3.z.number(),
        frequency_penalty: _v3.z.number(),
        presence_penalty: _v3.z.number(),
        response_format: ResponseFormatNullish,
        tool_choice: _v3.z.union([
          _v3.z.literal("auto"),
          _v3.z.literal("none"),
          _v3.z.literal("required"),
          _v3.z.object({
            type: _v3.z.literal("function"),
            function: _v3.z.object({ name: _v3.z.string() })
          })
        ]),
        function_call: _v3.z.union([
          _v3.z.literal("auto"),
          _v3.z.literal("none"),
          _v3.z.object({ name: _v3.z.string() })
        ]),
        n: _v3.z.number(),
        stop: _v3.z.array(_v3.z.string()),
        reasoning_effort: _v3.z.enum(["minimal", "low", "medium", "high"]),
        verbosity: _v3.z.enum(["low", "medium", "high"])
      }).partial().passthrough(),
      _v3.z.object({
        use_cache: _v3.z.boolean().optional(),
        max_tokens: _v3.z.number(),
        temperature: _v3.z.number(),
        top_p: _v3.z.number().optional(),
        top_k: _v3.z.number().optional(),
        stop_sequences: _v3.z.array(_v3.z.string()).optional(),
        max_tokens_to_sample: _v3.z.number().optional()
      }).passthrough(),
      _v3.z.object({
        use_cache: _v3.z.boolean(),
        temperature: _v3.z.number(),
        maxOutputTokens: _v3.z.number(),
        topP: _v3.z.number(),
        topK: _v3.z.number()
      }).partial().passthrough(),
      _v3.z.object({
        use_cache: _v3.z.boolean(),
        temperature: _v3.z.number(),
        topK: _v3.z.number()
      }).partial().passthrough(),
      _v3.z.object({ use_cache: _v3.z.boolean() }).partial().passthrough()
    ]);
    PromptOptionsNullish = _v3.z.union([
      _v3.z.object({ model: _v3.z.string(), params: ModelParams, position: _v3.z.string() }).partial(),
      _v3.z.null()
    ]);
    PromptParserNullish = _v3.z.union([
      _v3.z.object({
        type: _v3.z.literal("llm_classifier"),
        use_cot: _v3.z.boolean(),
        choice_scores: _v3.z.record(_v3.z.number().gte(0).lte(1))
      }),
      _v3.z.null()
    ]);
    SavedFunctionId = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("function"), id: _v3.z.string() }),
      _v3.z.object({ type: _v3.z.literal("global"), name: _v3.z.string() })
    ]);
    PromptDataNullish = _v3.z.union([
      _v3.z.object({
        prompt: PromptBlockDataNullish,
        options: PromptOptionsNullish,
        parser: PromptParserNullish,
        tool_functions: _v3.z.union([_v3.z.array(SavedFunctionId), _v3.z.null()]),
        origin: _v3.z.union([
          _v3.z.object({
            prompt_id: _v3.z.string(),
            project_id: _v3.z.string(),
            prompt_version: _v3.z.string()
          }).partial(),
          _v3.z.null()
        ])
      }).partial(),
      _v3.z.null()
    ]);
    FunctionTypeEnumNullish = _v3.z.union([
      _v3.z.enum(["llm", "scorer", "task", "tool"]),
      _v3.z.null()
    ]);
    FunctionIdRef = _v3.z.object({}).partial().passthrough();
    PromptBlockData = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("completion"), content: _v3.z.string() }),
      _v3.z.object({
        type: _v3.z.literal("chat"),
        messages: _v3.z.array(ChatCompletionMessageParam),
        tools: _v3.z.string().optional()
      })
    ]);
    GraphNode = _v3.z.union([
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("function"),
        function: FunctionIdRef
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("input")
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("output")
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("literal"),
        value: _v3.z.unknown().optional()
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("btql"),
        expr: _v3.z.string()
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("gate"),
        condition: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("aggregator")
      }),
      _v3.z.object({
        description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        position: _v3.z.union([_v3.z.object({ x: _v3.z.number(), y: _v3.z.number() }), _v3.z.null()]).optional(),
        type: _v3.z.literal("prompt_template"),
        prompt: PromptBlockData
      })
    ]);
    GraphEdge = _v3.z.object({
      source: _v3.z.object({ node: _v3.z.string().max(1024), variable: _v3.z.string() }),
      target: _v3.z.object({ node: _v3.z.string().max(1024), variable: _v3.z.string() }),
      purpose: _v3.z.enum(["control", "data", "messages"])
    });
    GraphData = _v3.z.object({
      type: _v3.z.literal("graph"),
      nodes: _v3.z.record(GraphNode),
      edges: _v3.z.record(GraphEdge)
    });
    FunctionData = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("prompt") }),
      _v3.z.object({
        type: _v3.z.literal("code"),
        data: _v3.z.union([
          _v3.z.object({ type: _v3.z.literal("bundle") }).and(CodeBundle),
          _v3.z.object({
            type: _v3.z.literal("inline"),
            runtime_context: _v3.z.object({
              runtime: _v3.z.enum(["node", "python"]),
              version: _v3.z.string()
            }),
            code: _v3.z.string()
          })
        ])
      }),
      GraphData,
      _v3.z.object({
        type: _v3.z.literal("remote_eval"),
        endpoint: _v3.z.string(),
        eval_name: _v3.z.string(),
        parameters: _v3.z.object({}).partial().passthrough()
      }),
      _v3.z.object({ type: _v3.z.literal("global"), name: _v3.z.string() })
    ]);
    Function = _v3.z.object({
      id: _v3.z.string().uuid(),
      _xact_id: _v3.z.string(),
      project_id: _v3.z.string().uuid(),
      log_id: _v3.z.literal("p"),
      org_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      slug: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      prompt_data: PromptDataNullish.optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional(),
      function_type: FunctionTypeEnumNullish.optional(),
      function_data: FunctionData,
      origin: _v3.z.union([
        _v3.z.object({
          object_type: AclObjectType.and(_v3.z.string()),
          object_id: _v3.z.string().uuid(),
          internal: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
        }),
        _v3.z.null()
      ]).optional(),
      function_schema: _v3.z.union([
        _v3.z.object({ parameters: _v3.z.unknown(), returns: _v3.z.unknown() }).partial(),
        _v3.z.null()
      ]).optional()
    });
    FunctionFormat = _v3.z.enum(["llm", "code", "global", "graph"]);
    PromptData = _v3.z.object({
      prompt: PromptBlockDataNullish,
      options: PromptOptionsNullish,
      parser: PromptParserNullish,
      tool_functions: _v3.z.union([_v3.z.array(SavedFunctionId), _v3.z.null()]),
      origin: _v3.z.union([
        _v3.z.object({
          prompt_id: _v3.z.string(),
          project_id: _v3.z.string(),
          prompt_version: _v3.z.string()
        }).partial(),
        _v3.z.null()
      ])
    }).partial();
    FunctionTypeEnum = _v3.z.enum(["llm", "scorer", "task", "tool"]);
    FunctionId = _v3.z.union([
      _v3.z.object({ function_id: _v3.z.string(), version: _v3.z.string().optional() }),
      _v3.z.object({
        project_name: _v3.z.string(),
        slug: _v3.z.string(),
        version: _v3.z.string().optional()
      }),
      _v3.z.object({ global_function: _v3.z.string() }),
      _v3.z.object({
        prompt_session_id: _v3.z.string(),
        prompt_session_function_id: _v3.z.string(),
        version: _v3.z.string().optional()
      }),
      _v3.z.object({
        inline_context: _v3.z.object({
          runtime: _v3.z.enum(["node", "python"]),
          version: _v3.z.string()
        }),
        code: _v3.z.string(),
        name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      }),
      _v3.z.object({
        inline_prompt: PromptData.optional(),
        inline_function: _v3.z.object({}).partial().passthrough(),
        function_type: FunctionTypeEnum.optional(),
        name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      }),
      _v3.z.object({
        inline_prompt: PromptData,
        function_type: FunctionTypeEnum.optional(),
        name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
      })
    ]);
    FunctionObjectType = _v3.z.enum([
      "prompt",
      "tool",
      "scorer",
      "task",
      "agent"
    ]);
    FunctionOutputType = _v3.z.enum(["completion", "score", "any"]);
    GitMetadataSettings = _v3.z.object({
      collect: _v3.z.enum(["all", "none", "some"]),
      fields: _v3.z.array(
        _v3.z.enum([
          "commit",
          "branch",
          "tag",
          "dirty",
          "author_name",
          "author_email",
          "commit_message",
          "commit_time",
          "git_diff"
        ])
      ).optional()
    });
    Group = _v3.z.object({
      id: _v3.z.string().uuid(),
      org_id: _v3.z.string().uuid(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      member_users: _v3.z.union([_v3.z.array(_v3.z.string().uuid()), _v3.z.null()]).optional(),
      member_groups: _v3.z.union([_v3.z.array(_v3.z.string().uuid()), _v3.z.null()]).optional()
    });
    IfExists = _v3.z.enum(["error", "ignore", "replace"]);
    InvokeParent = _v3.z.union([
      _v3.z.object({
        object_type: _v3.z.enum(["project_logs", "experiment", "playground_logs"]),
        object_id: _v3.z.string(),
        row_ids: _v3.z.union([
          _v3.z.object({
            id: _v3.z.string(),
            span_id: _v3.z.string(),
            root_span_id: _v3.z.string()
          }),
          _v3.z.null()
        ]).optional(),
        propagated_event: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional()
      }),
      _v3.z.string()
    ]);
    StreamingMode = _v3.z.union([_v3.z.enum(["auto", "parallel"]), _v3.z.null()]);
    InvokeFunction = FunctionId.and(
      _v3.z.object({
        input: _v3.z.unknown(),
        expected: _v3.z.unknown(),
        metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]),
        tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]),
        messages: _v3.z.array(ChatCompletionMessageParam),
        parent: InvokeParent,
        stream: _v3.z.union([_v3.z.boolean(), _v3.z.null()]),
        mode: StreamingMode,
        strict: _v3.z.union([_v3.z.boolean(), _v3.z.null()])
      }).partial()
    );
    MessageRole = _v3.z.enum([
      "system",
      "user",
      "assistant",
      "function",
      "tool",
      "model",
      "developer"
    ]);
    ObjectReference = _v3.z.object({
      object_type: _v3.z.enum([
        "project_logs",
        "experiment",
        "dataset",
        "prompt",
        "function",
        "prompt_session"
      ]),
      object_id: _v3.z.string().uuid(),
      id: _v3.z.string(),
      _xact_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    OnlineScoreConfig = _v3.z.union([
      _v3.z.object({
        sampling_rate: _v3.z.number().gte(0).lte(1),
        scorers: _v3.z.array(SavedFunctionId),
        btql_filter: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
        apply_to_root_span: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
        apply_to_span_names: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
        skip_logging: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
      }),
      _v3.z.null()
    ]);
    Organization = _v3.z.object({
      id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      api_url: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      is_universal_api: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      proxy_url: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      realtime_url: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    ProjectSettings = _v3.z.union([
      _v3.z.object({
        comparison_key: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        baseline_experiment_id: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        spanFieldOrder: _v3.z.union([
          _v3.z.array(
            _v3.z.object({
              object_type: _v3.z.string(),
              column_id: _v3.z.string(),
              position: _v3.z.string(),
              layout: _v3.z.union([_v3.z.literal("full"), _v3.z.literal("two_column"), _v3.z.null()]).optional()
            })
          ),
          _v3.z.null()
        ]),
        remote_eval_sources: _v3.z.union([
          _v3.z.array(
            _v3.z.object({
              url: _v3.z.string(),
              name: _v3.z.string(),
              description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
            })
          ),
          _v3.z.null()
        ])
      }).partial(),
      _v3.z.null()
    ]);
    Project = _v3.z.object({
      id: _v3.z.string().uuid(),
      org_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      settings: ProjectSettings.optional()
    });
    RetentionObjectType = _v3.z.enum([
      "project_logs",
      "experiment",
      "dataset"
    ]);
    ProjectAutomation = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      config: _v3.z.union([
        _v3.z.object({
          event_type: _v3.z.literal("logs"),
          btql_filter: _v3.z.string(),
          interval_seconds: _v3.z.number().gte(1).lte(2592e3),
          action: _v3.z.object({ type: _v3.z.literal("webhook"), url: _v3.z.string() })
        }),
        _v3.z.object({
          event_type: _v3.z.literal("btql_export"),
          export_definition: _v3.z.union([
            _v3.z.object({ type: _v3.z.literal("log_traces") }),
            _v3.z.object({ type: _v3.z.literal("log_spans") }),
            _v3.z.object({ type: _v3.z.literal("btql_query"), btql_query: _v3.z.string() })
          ]),
          export_path: _v3.z.string(),
          format: _v3.z.enum(["jsonl", "parquet"]),
          interval_seconds: _v3.z.number().gte(1).lte(2592e3),
          credentials: _v3.z.object({
            type: _v3.z.literal("aws_iam"),
            role_arn: _v3.z.string(),
            external_id: _v3.z.string()
          }),
          batch_size: _v3.z.union([_v3.z.number(), _v3.z.null()]).optional()
        }),
        _v3.z.object({
          event_type: _v3.z.literal("retention"),
          object_type: RetentionObjectType,
          retention_days: _v3.z.number().gte(0)
        })
      ])
    });
    ProjectLogsEvent = _v3.z.object({
      id: _v3.z.string(),
      _xact_id: _v3.z.string(),
      _pagination_key: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.string().datetime({ offset: true }),
      org_id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      log_id: _v3.z.literal("g"),
      input: _v3.z.unknown().optional(),
      output: _v3.z.unknown().optional(),
      expected: _v3.z.unknown().optional(),
      error: _v3.z.unknown().optional(),
      scores: _v3.z.union([_v3.z.record(_v3.z.union([_v3.z.number(), _v3.z.null()])), _v3.z.null()]).optional(),
      metadata: _v3.z.union([
        _v3.z.object({ model: _v3.z.union([_v3.z.string(), _v3.z.null()]) }).partial().passthrough(),
        _v3.z.null()
      ]).optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      metrics: _v3.z.union([_v3.z.record(_v3.z.number()), _v3.z.null()]).optional(),
      context: _v3.z.union([
        _v3.z.object({
          caller_functionname: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          caller_filename: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          caller_lineno: _v3.z.union([_v3.z.number(), _v3.z.null()])
        }).partial().passthrough(),
        _v3.z.null()
      ]).optional(),
      span_id: _v3.z.string(),
      span_parents: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      root_span_id: _v3.z.string(),
      is_root: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      span_attributes: SpanAttributes.optional(),
      origin: ObjectReferenceNullish.optional()
    });
    ProjectScoreType = _v3.z.enum([
      "slider",
      "categorical",
      "weighted",
      "minimum",
      "maximum",
      "online",
      "free-form"
    ]);
    ProjectScoreCategory = _v3.z.object({
      name: _v3.z.string(),
      value: _v3.z.number()
    });
    ProjectScoreCategories = _v3.z.union([
      _v3.z.array(ProjectScoreCategory),
      _v3.z.record(_v3.z.number()),
      _v3.z.array(_v3.z.string()),
      _v3.z.null()
    ]);
    ProjectScoreConfig = _v3.z.union([
      _v3.z.object({
        multi_select: _v3.z.union([_v3.z.boolean(), _v3.z.null()]),
        destination: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        online: OnlineScoreConfig
      }).partial(),
      _v3.z.null()
    ]);
    ProjectScore = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      user_id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      score_type: ProjectScoreType,
      categories: ProjectScoreCategories.optional(),
      config: ProjectScoreConfig.optional(),
      position: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    ProjectTag = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      user_id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      color: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      position: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    Prompt = _v3.z.object({
      id: _v3.z.string().uuid(),
      _xact_id: _v3.z.string(),
      project_id: _v3.z.string().uuid(),
      log_id: _v3.z.literal("p"),
      org_id: _v3.z.string().uuid(),
      name: _v3.z.string(),
      slug: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      prompt_data: PromptDataNullish.optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional(),
      metadata: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional(),
      function_type: FunctionTypeEnumNullish.optional()
    });
    PromptOptions = _v3.z.object({ model: _v3.z.string(), params: ModelParams, position: _v3.z.string() }).partial();
    PromptSessionEvent = _v3.z.object({
      id: _v3.z.string(),
      _xact_id: _v3.z.string(),
      created: _v3.z.string().datetime({ offset: true }),
      _pagination_key: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      project_id: _v3.z.string().uuid(),
      prompt_session_id: _v3.z.string().uuid(),
      prompt_session_data: _v3.z.unknown().optional(),
      prompt_data: _v3.z.unknown().optional(),
      function_data: _v3.z.unknown().optional(),
      function_type: FunctionTypeEnumNullish.optional(),
      object_data: _v3.z.unknown().optional(),
      completion: _v3.z.unknown().optional(),
      tags: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]).optional()
    });
    ResponseFormat = _v3.z.union([
      _v3.z.object({ type: _v3.z.literal("json_object") }),
      _v3.z.object({
        type: _v3.z.literal("json_schema"),
        json_schema: ResponseFormatJsonSchema
      }),
      _v3.z.object({ type: _v3.z.literal("text") })
    ]);
    Role = _v3.z.object({
      id: _v3.z.string().uuid(),
      org_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      member_permissions: _v3.z.union([
        _v3.z.array(
          _v3.z.object({
            permission: Permission,
            restrict_object_type: AclObjectType.optional()
          })
        ),
        _v3.z.null()
      ]).optional(),
      member_roles: _v3.z.union([_v3.z.array(_v3.z.string().uuid()), _v3.z.null()]).optional()
    });
    RunEval = _v3.z.object({
      project_id: _v3.z.string(),
      data: _v3.z.union([
        _v3.z.object({
          dataset_id: _v3.z.string(),
          _internal_btql: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional()
        }),
        _v3.z.object({
          project_name: _v3.z.string(),
          dataset_name: _v3.z.string(),
          _internal_btql: _v3.z.union([_v3.z.object({}).partial().passthrough(), _v3.z.null()]).optional()
        }),
        _v3.z.object({ data: _v3.z.array(_v3.z.unknown()) })
      ]),
      task: FunctionId.and(_v3.z.unknown()),
      scores: _v3.z.array(FunctionId),
      experiment_name: _v3.z.string().optional(),
      metadata: _v3.z.object({}).partial().passthrough().optional(),
      parent: InvokeParent.and(_v3.z.unknown()).optional(),
      stream: _v3.z.boolean().optional(),
      trial_count: _v3.z.union([_v3.z.number(), _v3.z.null()]).optional(),
      is_public: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      timeout: _v3.z.union([_v3.z.number(), _v3.z.null()]).optional(),
      max_concurrency: _v3.z.union([_v3.z.number(), _v3.z.null()]).optional().default(10),
      base_experiment_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      base_experiment_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      git_metadata_settings: GitMetadataSettings.and(
        _v3.z.union([_v3.z.object({}).partial(), _v3.z.null()])
      ).optional(),
      repo_info: RepoInfo.and(_v3.z.unknown()).optional(),
      strict: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional(),
      stop_token: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      extra_messages: _v3.z.string().optional(),
      tags: _v3.z.array(_v3.z.string()).optional()
    });
    ServiceToken = _v3.z.object({
      id: _v3.z.string().uuid(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      preview_name: _v3.z.string(),
      service_account_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      service_account_email: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      service_account_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      org_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    SpanIFrame = _v3.z.object({
      id: _v3.z.string().uuid(),
      project_id: _v3.z.string().uuid(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      name: _v3.z.string(),
      description: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      url: _v3.z.string(),
      post_message: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
    });
    SSEConsoleEventData = _v3.z.object({
      stream: _v3.z.enum(["stderr", "stdout"]),
      message: _v3.z.string()
    });
    SSEProgressEventData = _v3.z.object({
      id: _v3.z.string(),
      object_type: FunctionObjectType,
      origin: ObjectReferenceNullish.and(_v3.z.unknown()).optional(),
      format: FunctionFormat,
      output_type: FunctionOutputType,
      name: _v3.z.string(),
      event: _v3.z.enum([
        "reasoning_delta",
        "text_delta",
        "json_delta",
        "error",
        "console",
        "start",
        "done",
        "progress"
      ]),
      data: _v3.z.string()
    });
    ToolFunctionDefinition = exports.toolFunctionDefinitionSchema = _v3.z.object({
      type: _v3.z.literal("function"),
      function: _v3.z.object({
        name: _v3.z.string(),
        description: _v3.z.string().optional(),
        parameters: _v3.z.object({}).partial().passthrough().optional(),
        strict: _v3.z.union([_v3.z.boolean(), _v3.z.null()]).optional()
      })
    });
    User = _v3.z.object({
      id: _v3.z.string().uuid(),
      given_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      family_name: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      email: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      avatar_url: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
    ViewDataSearch = _v3.z.union([
      _v3.z.object({
        filter: _v3.z.union([_v3.z.array(_v3.z.unknown()), _v3.z.null()]),
        tag: _v3.z.union([_v3.z.array(_v3.z.unknown()), _v3.z.null()]),
        match: _v3.z.union([_v3.z.array(_v3.z.unknown()), _v3.z.null()]),
        sort: _v3.z.union([_v3.z.array(_v3.z.unknown()), _v3.z.null()])
      }).partial(),
      _v3.z.null()
    ]);
    ViewData = _v3.z.union([
      _v3.z.object({ search: ViewDataSearch }).partial(),
      _v3.z.null()
    ]);
    ViewOptions = _v3.z.union([
      _v3.z.object({
        viewType: _v3.z.literal("monitor"),
        options: _v3.z.object({
          spanType: _v3.z.union([_v3.z.enum(["range", "frame"]), _v3.z.null()]),
          rangeValue: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          frameStart: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          frameEnd: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          tzUTC: _v3.z.union([_v3.z.boolean(), _v3.z.null()]),
          chartVisibility: _v3.z.union([_v3.z.record(_v3.z.boolean()), _v3.z.null()]),
          projectId: _v3.z.union([_v3.z.string(), _v3.z.null()]),
          type: _v3.z.union([_v3.z.enum(["project", "experiment"]), _v3.z.null()]),
          groupBy: _v3.z.union([_v3.z.string(), _v3.z.null()])
        }).partial()
      }),
      _v3.z.object({
        columnVisibility: _v3.z.union([_v3.z.record(_v3.z.boolean()), _v3.z.null()]),
        columnOrder: _v3.z.union([_v3.z.array(_v3.z.string()), _v3.z.null()]),
        columnSizing: _v3.z.union([_v3.z.record(_v3.z.number()), _v3.z.null()]),
        grouping: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        rowHeight: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        tallGroupRows: _v3.z.union([_v3.z.boolean(), _v3.z.null()]),
        layout: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        chartHeight: _v3.z.union([_v3.z.number(), _v3.z.null()]),
        excludedMeasures: _v3.z.union([
          _v3.z.array(
            _v3.z.object({
              type: _v3.z.enum(["none", "score", "metric", "metadata"]),
              value: _v3.z.string()
            })
          ),
          _v3.z.null()
        ]),
        yMetric: _v3.z.union([
          _v3.z.object({
            type: _v3.z.enum(["none", "score", "metric", "metadata"]),
            value: _v3.z.string()
          }),
          _v3.z.null()
        ]),
        xAxis: _v3.z.union([
          _v3.z.object({
            type: _v3.z.enum(["none", "score", "metric", "metadata"]),
            value: _v3.z.string()
          }),
          _v3.z.null()
        ]),
        symbolGrouping: _v3.z.union([
          _v3.z.object({
            type: _v3.z.enum(["none", "score", "metric", "metadata"]),
            value: _v3.z.string()
          }),
          _v3.z.null()
        ]),
        xAxisAggregation: _v3.z.union([_v3.z.string(), _v3.z.null()]),
        chartAnnotations: _v3.z.union([
          _v3.z.array(_v3.z.object({ id: _v3.z.string(), text: _v3.z.string() })),
          _v3.z.null()
        ]),
        timeRangeFilter: _v3.z.union([
          _v3.z.string(),
          _v3.z.object({ from: _v3.z.string(), to: _v3.z.string() }),
          _v3.z.null()
        ])
      }).partial(),
      _v3.z.null()
    ]);
    View = _v3.z.object({
      id: _v3.z.string().uuid(),
      object_type: AclObjectType.and(_v3.z.string()),
      object_id: _v3.z.string().uuid(),
      view_type: _v3.z.enum([
        "projects",
        "experiments",
        "experiment",
        "playgrounds",
        "playground",
        "datasets",
        "dataset",
        "prompts",
        "tools",
        "scorers",
        "logs",
        "agents",
        "monitor"
      ]),
      name: _v3.z.string(),
      created: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      view_data: ViewData.optional(),
      options: ViewOptions.optional(),
      user_id: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional(),
      deleted_at: _v3.z.union([_v3.z.string(), _v3.z.null()]).optional()
    });
  }
});

// src/functions/stream.ts


var _eventsourceparser = require('eventsource-parser');

function btStreamParser() {
  const decoder = new TextDecoder();
  let parser;
  return new TransformStream({
    async start(controller) {
      parser = _eventsourceparser.createParser.call(void 0, (event) => {
        if (event.type === "reconnect-interval") {
          return;
        }
        const parsed = CallEvent.safeParse(event);
        if (!parsed.success) {
          throw new Error(`Failed to parse event: ${parsed.error}`);
        }
        controller.enqueue(BraintrustStream.parseRawEvent(parsed.data));
      });
    },
    async transform(chunk, controller) {
      if (chunk instanceof Uint8Array) {
        parser.feed(decoder.decode(chunk));
      } else if (typeof chunk === "string") {
        parser.feed(chunk);
      } else {
        controller.enqueue(chunk);
      }
    },
    async flush(controller) {
      controller.terminate();
    }
  });
}
function createFinalValuePassThroughStream(onFinal, onError) {
  const decoder = new TextDecoder();
  const textChunks = [];
  const jsonChunks = [];
  const reasoningChunks = [];
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      if (typeof chunk === "string") {
        textChunks.push(chunk);
        controller.enqueue({
          type: "text_delta",
          data: chunk
        });
      } else if (chunk instanceof Uint8Array) {
        textChunks.push(decoder.decode(chunk));
        controller.enqueue({
          type: "text_delta",
          data: decoder.decode(chunk)
        });
      } else if (braintrustStreamChunkSchema.safeParse(chunk).success) {
        const chunkType = chunk.type;
        switch (chunkType) {
          case "text_delta":
            textChunks.push(chunk.data);
            break;
          case "json_delta":
            jsonChunks.push(chunk.data);
            break;
          case "reasoning_delta":
            reasoningChunks.push(chunk.data);
            break;
          case "error":
            onError(chunk.data);
            break;
          case "progress":
          case "start":
          case "done":
          case "console":
            break;
          default:
            const _type = chunkType;
            onError(`Unknown chunk type: ${_type}`);
        }
        controller.enqueue(chunk);
      } else {
        onError(`Unknown chunk type ${JSON.stringify(chunk)}`);
      }
    },
    flush(controller) {
      if (jsonChunks.length > 0) {
        onFinal(JSON.parse(jsonChunks.join("")));
      } else if (textChunks.length > 0) {
        onFinal(textChunks.join(""));
      } else if (reasoningChunks.length > 0) {
        onFinal(reasoningChunks.join(""));
      } else {
        onFinal(void 0);
      }
      controller.terminate();
    }
  });
  return transformStream;
}
function devNullWritableStream() {
  return new WritableStream({
    write(chunk) {
    },
    close() {
    },
    abort(reason) {
    },
    start(controller) {
    }
  });
}
var braintrustStreamChunkSchema, BraintrustStream;
var init_stream = __esm({
  "src/functions/stream.ts"() {
    "use strict";
    init_generated_types();
    braintrustStreamChunkSchema = exports.braintrustStreamChunkSchema = _v3.z.union([
      _v3.z.object({
        type: _v3.z.literal("text_delta"),
        data: _v3.z.string()
      }),
      _v3.z.object({
        type: _v3.z.literal("reasoning_delta"),
        data: _v3.z.string()
      }),
      _v3.z.object({
        type: _v3.z.literal("json_delta"),
        data: _v3.z.string()
      }),
      _v3.z.object({
        type: _v3.z.literal("error"),
        data: _v3.z.string()
      }),
      _v3.z.object({
        type: _v3.z.literal("console"),
        data: SSEConsoleEventData
      }),
      _v3.z.object({
        type: _v3.z.literal("progress"),
        data: SSEProgressEventData
      }),
      _v3.z.object({
        type: _v3.z.literal("start"),
        data: _v3.z.string()
      }),
      _v3.z.object({
        type: _v3.z.literal("done"),
        data: _v3.z.string()
      })
    ]);
    BraintrustStream = exports.BraintrustStream = class _BraintrustStream {
      
      
      
      constructor(baseStream, { signal } = {}) {
        this.signal = signal;
        this.stream = baseStream.pipeThrough(btStreamParser(), { signal });
      }
      /**
       * Copy the stream. This returns a new stream that shares the same underlying
       * stream (via `tee`). Since streams are consumed in Javascript, use `copy()` if you
       * need to use the stream multiple times.
       *
       * @returns A new stream that you can independently consume.
       */
      copy() {
        const [newStream, copyStream] = this.stream.tee();
        this.stream = copyStream;
        return new _BraintrustStream(newStream, { signal: this.signal });
      }
      /**
       * Get the underlying ReadableStream.
       *
       * @returns The underlying `ReadableStream<BraintrustStreamChunk>`.
       */
      toReadableStream() {
        return this.stream;
      }
      /**
       * Returns an async iterator for the BraintrustStream.
       * This allows for easy consumption of the stream using a for-await...of loop.
       *
       * @returns An async iterator that yields BraintrustStreamChunk objects.
       */
      [Symbol.asyncIterator]() {
        const reader = this.stream.getReader();
        return {
          async next() {
            const { done, value } = await reader.read();
            if (done) {
              reader.releaseLock();
              return { done: true, value: void 0 };
            }
            return { done: false, value };
          },
          async return() {
            reader.releaseLock();
            return { done: true, value: void 0 };
          },
          async throw(error2) {
            reader.releaseLock();
            throw error2;
          }
        };
      }
      /**
       * Get the final value of the stream. The final value is the concatenation of all
       * the chunks in the stream, deserialized into a string or JSON object, depending on
       * the value's type.
       *
       * This function returns a promise that resolves when the stream is closed, and
       * contains the final value. Multiple calls to `finalValue()` will return the same
       * promise, so it is safe to call this multiple times.
       *
       * This function consumes the stream, so if you need to use the stream multiple
       * times, you should call `copy()` first.
       *
       * @returns A promise that resolves with the final value of the stream or `undefined` if the stream is empty.
       */
      finalValue() {
        if (this.memoizedFinalValue) {
          return this.memoizedFinalValue;
        }
        this.memoizedFinalValue = new Promise((resolve, reject2) => {
          this.stream.pipeThrough(createFinalValuePassThroughStream(resolve, reject2), {
            signal: this.signal
          }).pipeTo(devNullWritableStream(), { signal: this.signal }).catch(reject2);
        });
        return this.memoizedFinalValue;
      }
      static parseRawEvent(event) {
        switch (event.event) {
          case "text_delta":
            return {
              type: "text_delta",
              data: JSON.parse(event.data)
            };
          case "reasoning_delta":
            return {
              type: "reasoning_delta",
              data: JSON.parse(event.data)
            };
          case "json_delta":
            return {
              type: "json_delta",
              data: event.data
            };
          case "error":
            return {
              type: "error",
              data: JSON.parse(event.data)
            };
          case "progress":
            return {
              type: "progress",
              data: SSEProgressEventData.parse(JSON.parse(event.data))
            };
          case "console":
            return {
              type: "console",
              data: SSEConsoleEventData.parse(JSON.parse(event.data))
            };
          case "start":
            return {
              type: "start",
              data: ""
            };
          case "done":
            return {
              type: "done",
              data: ""
            };
          default: {
            const _event = event;
            throw new Error(`Unknown event type ${JSON.stringify(_event)}`);
          }
        }
      }
      static serializeRawEvent(event) {
        switch (event.type) {
          case "text_delta":
            return {
              event: "text_delta",
              data: JSON.stringify(event.data)
            };
          case "reasoning_delta":
            return {
              event: "reasoning_delta",
              data: JSON.stringify(event.data)
            };
          case "json_delta":
            return {
              event: "json_delta",
              data: event.data
            };
          case "error":
            return {
              event: "error",
              data: JSON.stringify(event.data)
            };
          case "progress":
            return {
              event: "progress",
              data: JSON.stringify(event.data)
            };
          case "console":
            return {
              event: "console",
              data: JSON.stringify(event.data)
            };
          case "start":
            return {
              event: "start",
              data: ""
            };
          case "done":
            return {
              event: "done",
              data: ""
            };
          default: {
            const _event = event;
            throw new Error(`Unknown event type ${JSON.stringify(_event)}`);
          }
        }
      }
    };
  }
});

// src/prompt-cache/disk-cache.ts
function canUseDiskCache() {
  return !!(isomorph_default.hash && isomorph_default.gunzip && isomorph_default.gzip && isomorph_default.stat && isomorph_default.readFile && isomorph_default.writeFile && isomorph_default.utimes && isomorph_default.readdir && isomorph_default.mkdir && isomorph_default.unlink && isomorph_default.homedir);
}
var DiskCache;
var init_disk_cache = __esm({
  "src/prompt-cache/disk-cache.ts"() {
    "use strict";
    init_isomorph();
    DiskCache = class {
      
      
      
      
      /**
       * Creates a new DiskCache instance.
       * @param options - Configuration options for the cache.
       */
      constructor(options) {
        if (!canUseDiskCache()) {
          throw new Error("Disk cache is not supported on this platform");
        }
        this.dir = options.cacheDir;
        this.max = options.max;
        this.logWarnings = _nullishCoalesce(options.logWarnings, () => ( true));
        this.mkdir = _nullishCoalesce(options.mkdir, () => ( true));
      }
      getEntryPath(key) {
        const hashed = isomorph_default.hash(key);
        return isomorph_default.pathJoin(this.dir, hashed);
      }
      /**
       * Retrieves a value from the cache.
       * Updates the entry's access time when read.
       *
       * @param key - The key to look up in the cache.
       * @returns The cached value if found, undefined otherwise.
       */
      async get(key) {
        try {
          const filePath = this.getEntryPath(key);
          const data = await isomorph_default.gunzip(await isomorph_default.readFile(filePath));
          await isomorph_default.utimes(filePath, /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date());
          return JSON.parse(data.toString());
        } catch (e) {
          if (e.code === "ENOENT") {
            return void 0;
          }
          if (this.logWarnings) {
            console.warn("Failed to read from disk cache", e);
          }
          return void 0;
        }
      }
      /**
       * Stores a value in the cache.
       * If the cache is at its maximum size, the least recently used entries will be evicted.
       *
       * @param key - The key to store the value under.
       * @param value - The value to store in the cache.
       */
      async set(key, value) {
        try {
          if (this.mkdir) {
            await isomorph_default.mkdir(this.dir, { recursive: true });
          }
          const filePath = this.getEntryPath(key);
          const data = await isomorph_default.gzip(JSON.stringify(value));
          await isomorph_default.writeFile(filePath, data);
          await this.evictOldestIfFull();
        } catch (e) {
          if (this.logWarnings) {
            console.warn("Failed to write to disk cache", e);
          }
          return;
        }
      }
      async evictOldestIfFull() {
        if (!this.max) {
          return;
        }
        const files = await isomorph_default.readdir(this.dir);
        const paths = files.map((file) => isomorph_default.pathJoin(this.dir, file));
        if (paths.length <= this.max) {
          return;
        }
        const stats = await Promise.all(
          paths.map(async (path3) => {
            const stat2 = await isomorph_default.stat(path3);
            return {
              path: path3,
              mtime: stat2.mtime.getTime()
            };
          })
        );
        stats.sort((a, b) => a.mtime - b.mtime);
        const toRemove = stats.slice(0, stats.length - this.max);
        await Promise.all(toRemove.map((stat2) => isomorph_default.unlink(stat2.path)));
      }
    };
  }
});

// src/prompt-cache/lru-cache.ts
var LRUCache;
var init_lru_cache = __esm({
  "src/prompt-cache/lru-cache.ts"() {
    "use strict";
    LRUCache = class {
      
      
      constructor(options = {}) {
        this.cache = /* @__PURE__ */ new Map();
        this.maxSize = options.max;
      }
      /**
       * Retrieves a value from the cache.
       * If the key exists, the item is marked as most recently used.
       *
       * @param key - The key to look up.
       * @returns The cached value if found, undefined otherwise.
       */
      get(key) {
        const value = this.cache.get(key);
        if (value === void 0) {
          return void 0;
        }
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
      }
      /**
       * Stores a value in the cache.
       * If the key already exists, the value is updated and marked as most recently used.
       * If the cache is at its maximum size, the least recently used item is evicted.
       *
       * @param key - The key to store.
       * @param value - The value to store.
       */
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key);
        } else if (this.maxSize && this.cache.size >= this.maxSize) {
          const first = this.cache.keys().next().value;
          this.cache.delete(first);
        }
        this.cache.set(key, value);
      }
      /**
       * Removes all items from the cache.
       */
      clear() {
        this.cache.clear();
      }
    };
  }
});

// src/prompt-cache/prompt-cache.ts
function createCacheKey(key) {
  if (key.id) {
    return `id:${key.id}`;
  }
  const prefix = _nullishCoalesce(key.projectId, () => ( key.projectName));
  if (!prefix) {
    throw new Error("Either projectId or projectName must be provided");
  }
  if (!key.slug) {
    throw new Error("Slug must be provided when not using ID");
  }
  return `${prefix}:${key.slug}:${_nullishCoalesce(key.version, () => ( "latest"))}`;
}
var PromptCache;
var init_prompt_cache = __esm({
  "src/prompt-cache/prompt-cache.ts"() {
    "use strict";
    PromptCache = class {
      
      
      constructor(options) {
        this.memoryCache = options.memoryCache;
        this.diskCache = options.diskCache;
      }
      /**
       * Retrieves a prompt from the cache.
       * First checks the in-memory LRU cache, then falls back to checking the disk cache if available.
       */
      async get(key) {
        const cacheKey = createCacheKey(key);
        const memoryPrompt = this.memoryCache.get(cacheKey);
        if (memoryPrompt !== void 0) {
          return memoryPrompt;
        }
        if (this.diskCache) {
          const diskPrompt = await this.diskCache.get(cacheKey);
          if (!diskPrompt) {
            return void 0;
          }
          this.memoryCache.set(cacheKey, diskPrompt);
          return diskPrompt;
        }
        return void 0;
      }
      /**
       * Stores a prompt in the cache.
       * Writes to the in-memory cache and the disk cache if available.
       *
       * @param key - The key to store the value under.
       * @param value - The value to store in the cache.
       * @throws If there is an error writing to the disk cache.
       */
      async set(key, value) {
        const cacheKey = createCacheKey(key);
        this.memoryCache.set(cacheKey, value);
        if (this.diskCache) {
          await this.diskCache.set(cacheKey, value);
        }
      }
    };
  }
});

// src/util.ts
function runCatchFinally(f, catchF, finallyF) {
  let runSyncCleanup = true;
  try {
    const ret = f();
    if (ret instanceof Promise) {
      runSyncCleanup = false;
      return ret.catch(catchF).finally(finallyF);
    } else {
      return ret;
    }
  } catch (e) {
    return catchF(e);
  } finally {
    if (runSyncCleanup) {
      finallyF();
    }
  }
}
function getCurrentUnixTimestamp() {
  return (/* @__PURE__ */ new Date()).getTime() / 1e3;
}
function isEmpty(a) {
  return a === void 0 || a === null;
}
function addAzureBlobHeaders(headers, url) {
  if (url.includes("blob.core.windows.net")) {
    headers["x-ms-blob-type"] = "BlockBlob";
  }
}
function filterFrom(record, keys) {
  const out = {};
  for (const k of Object.keys(record)) {
    if (!keys.includes(k)) {
      out[k] = record[k];
    }
  }
  return out;
}
function objectIsEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var GLOBAL_PROJECT, LazyValue, SyncLazyValue, InternalAbortError;
var init_util2 = __esm({
  "src/util.ts"() {
    "use strict";
    GLOBAL_PROJECT = "Global";
    LazyValue = exports.LazyValue = (_class2 = class {
      
      __init4() {this.resolvedValue = void 0}
      __init5() {this.value = {
        computedState: "uninitialized"
      }}
      constructor(callable) {;_class2.prototype.__init4.call(this);_class2.prototype.__init5.call(this);
        this.callable = callable;
      }
      get() {
        if (this.value.computedState !== "uninitialized") {
          return this.value.val;
        }
        this.value = {
          computedState: "in_progress",
          val: this.callable().then((x) => {
            this.value.computedState = "succeeded";
            this.resolvedValue = x;
            return x;
          })
        };
        return this.value.val;
      }
      getSync() {
        return {
          resolved: this.value.computedState === "succeeded",
          value: this.resolvedValue
        };
      }
      // If this is true, the caller should be able to obtain the LazyValue without
      // it throwing.
      get hasSucceeded() {
        return this.value.computedState === "succeeded";
      }
    }, _class2);
    SyncLazyValue = (_class3 = class {
      
      __init6() {this.value = {
        computedState: "uninitialized"
      }}
      constructor(callable) {;_class3.prototype.__init6.call(this);
        this.callable = callable;
      }
      get() {
        if (this.value.computedState !== "uninitialized") {
          return this.value.val;
        }
        const result = this.callable();
        this.value = { computedState: "succeeded", val: result };
        return result;
      }
      // If this is true, the caller should be able to obtain the SyncLazyValue without
      // it throwing.
      get hasSucceeded() {
        return this.value.computedState === "succeeded";
      }
    }, _class3);
    InternalAbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InternalAbortError";
      }
    };
  }
});

// src/mustache-utils.ts
var _mustache = require('mustache'); var _mustache2 = _interopRequireDefault(_mustache);
function lintTemplate(template, context2) {
  const variables = getMustacheVars(template);
  for (const variable of variables) {
    const arrPathsReplaced = variable[1].replaceAll(/\.\d+/g, ".0");
    const fieldExists = getObjValueByPath(context2, arrPathsReplaced.split(".")) !== void 0;
    if (!fieldExists) {
      throw new Error(`Variable '${variable[1]}' does not exist.`);
    }
  }
}
function getMustacheVars(prompt) {
  try {
    return _mustache2.default.parse(prompt).filter(
      (span) => span[0] === "name" || span[0] === "&"
    );
  } catch (e7) {
    return [];
  }
}
var init_mustache_utils = __esm({
  "src/mustache-utils.ts"() {
    "use strict";
    init_util();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    "use strict";
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "../node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    "use strict";
    init_globalThis();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "../node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    "use strict";
    init_node();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "../node_modules/@opentelemetry/api/build/esm/version.js"() {
    "use strict";
    VERSION = "1.9.0";
  }
});

// ../node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "../node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    "use strict";
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// ../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    "use strict";
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// ../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    "use strict";
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    (function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "../node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    "use strict";
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    "use strict";
    init_types();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "../node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    "use strict";
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    (function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "../node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    "use strict";
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    (function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "../node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    "use strict";
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// ../node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "../node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    "use strict";
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "../node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    "use strict";
    BaseContext = /** @class */
    /* @__PURE__ */ (function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self.deleteValue = function(key) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    })();
    ROOT_CONTEXT = new BaseContext();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "../node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    "use strict";
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ (function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    "use strict";
    __extends = /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    NoopMeter = /** @class */
    (function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    })();
    NoopMetric = /** @class */
    /* @__PURE__ */ (function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    })();
    NoopCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    })(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    })(NoopMetric);
    NoopGaugeMetric = /** @class */
    (function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    })(NoopMetric);
    NoopHistogramMetric = /** @class */
    (function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    })(NoopMetric);
    NoopObservableMetric = /** @class */
    (function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    })();
    NoopObservableCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    })(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    })(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    })(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "../node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    "use strict";
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "../node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    "use strict";
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// ../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    "use strict";
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    (function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "../node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    "use strict";
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    (function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    "use strict";
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    "use strict";
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    "use strict";
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    (function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    "use strict";
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    "use strict";
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    "use strict";
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    (function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    "use strict";
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    (function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    "use strict";
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    (function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    "use strict";
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    (function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    "use strict";
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    "use strict";
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    "use strict";
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    "use strict";
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    "use strict";
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    (function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    "use strict";
    init_tracestate_impl();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "../node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    "use strict";
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "../node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    "use strict";
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    "use strict";
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    (function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    })();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "../node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    "use strict";
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    (function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "../node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    "use strict";
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "../node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    "use strict";
    NoopTextMapPropagator = /** @class */
    (function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "../node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    "use strict";
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// ../node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "../node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    "use strict";
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    (function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "../node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    "use strict";
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "../node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    "use strict";
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    (function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    })();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "../node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    "use strict";
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// ../node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "../node_modules/@opentelemetry/api/build/esm/index.js"() {
    "use strict";
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// src/otel/context.ts
var context_exports = {};
__export(context_exports, {
  OtelContextManager: () => OtelContextManager
});
function isOtelSpan(span) {
  return typeof span === "object" && span !== null && "spanContext" in span && // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Type guard ensures object has property
  typeof span.spanContext === "function";
}
function isValidSpanContext(spanContext) {
  if (!spanContext || typeof spanContext !== "object" || !("spanId" in spanContext) || !("traceId" in spanContext)) {
    return false;
  }
  const ctx = spanContext;
  return ctx.spanId !== "0000000000000000" && ctx.traceId !== "00000000000000000000000000000000";
}
var OTEL_NOT_INSTALLED_MESSAGE, otelTrace, otelContext, OTEL_AVAILABLE, OtelContextManager;
var init_context3 = __esm({
  "src/otel/context.ts"() {
    "use strict";
    init_logger();
    OTEL_NOT_INSTALLED_MESSAGE = "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base";
    otelTrace = null;
    otelContext = null;
    OTEL_AVAILABLE = false;
    try {
      const otelApi2 = (init_esm(), __toCommonJS(esm_exports));
      otelTrace = otelApi2.trace;
      otelContext = otelApi2.context;
      OTEL_AVAILABLE = true;
    } catch (e8) {
      console.warn(OTEL_NOT_INSTALLED_MESSAGE);
      OTEL_AVAILABLE = false;
    }
    OtelContextManager = class extends ContextManager {
      constructor() {
        super();
        if (!OTEL_AVAILABLE) {
          throw new Error(OTEL_NOT_INSTALLED_MESSAGE);
        }
      }
      getParentSpanIds() {
        if (!OTEL_AVAILABLE || !otelTrace || !otelContext) return void 0;
        const currentSpan2 = otelTrace.getActiveSpan();
        if (!currentSpan2 || !isOtelSpan(currentSpan2)) {
          return void 0;
        }
        const spanContext = currentSpan2.spanContext();
        if (!isValidSpanContext(spanContext)) {
          return void 0;
        }
        const btSpan = _optionalChain([otelContext, 'optionalAccess', _16 => _16.active, 'call', _17 => _17(), 'access', _18 => _18.getValue, 'optionalCall', _19 => _19("braintrust_span")]);
        if (btSpan && currentSpan2.constructor.name === "NonRecordingSpan" && typeof btSpan === "object" && btSpan !== null && "rootSpanId" in btSpan && "spanId" in btSpan) {
          const typedBtSpan = btSpan;
          return {
            rootSpanId: typedBtSpan.rootSpanId,
            spanParents: [typedBtSpan.spanId]
          };
        }
        const otelTraceId = spanContext.traceId.toString().padStart(32, "0");
        const otelSpanId = spanContext.spanId.toString().padStart(16, "0");
        return {
          rootSpanId: otelTraceId,
          spanParents: [otelSpanId]
        };
      }
      runInContext(span, callback) {
        if (!OTEL_AVAILABLE || !otelTrace || !otelContext) {
          return callback();
        }
        try {
          if (typeof span === "object" && span !== null && "spanId" in span && "rootSpanId" in span) {
            const btSpan = span;
            const spanContext = {
              traceId: btSpan.rootSpanId,
              spanId: btSpan.spanId,
              traceFlags: 1
              // sampled
            };
            const wrappedContext = otelTrace.wrapSpanContext(spanContext);
            const currentContext = otelContext.active();
            let newContext = otelTrace.setSpan(currentContext, wrappedContext);
            newContext = newContext.setValue("braintrust_span", span);
            const parentValue = span._getOtelParent();
            if (parentValue) {
              newContext = newContext.setValue("braintrust.parent", parentValue);
            }
            return otelContext.with(newContext, callback);
          }
        } catch (error2) {
          console.warn("Failed to run in OTEL context:", error2);
        }
        return callback();
      }
      getCurrentSpan() {
        if (!OTEL_AVAILABLE || !otelContext) return void 0;
        const btSpan = _optionalChain([otelContext, 'access', _20 => _20.active, 'call', _21 => _21(), 'access', _22 => _22.getValue, 'optionalCall', _23 => _23("braintrust_span")]);
        if (btSpan && typeof btSpan === "object" && btSpan !== null && "spanId" in btSpan && "rootSpanId" in btSpan) {
          return btSpan;
        }
        return void 0;
      }
    };
  }
});

// src/logger.ts

var _functions = require('@vercel/functions');


function applyMaskingToField(maskingFunction, data, fieldName) {
  try {
    return maskingFunction(data);
  } catch (error2) {
    const errorType = error2 instanceof Error ? error2.constructor.name : "Error";
    if (fieldName === "scores" || fieldName === "metrics") {
      return new MaskingError(fieldName, errorType);
    }
    if (fieldName === "metadata") {
      return {
        error: `ERROR: Failed to mask field '${fieldName}' - ${errorType}`
      };
    }
    return `ERROR: Failed to mask field '${fieldName}' - ${errorType}`;
  }
}
function getSpanComponentsClass() {
  const useV4 = typeof process !== "undefined" && _optionalChain([process, 'access', _24 => _24.env, 'optionalAccess', _25 => _25.BRAINTRUST_OTEL_COMPAT, 'optionalAccess', _26 => _26.toLowerCase, 'call', _27 => _27()]) === "true";
  return useV4 ? SpanComponentsV4 : SpanComponentsV3;
}
function getContextManager() {
  const useOtel = typeof process !== "undefined" && _optionalChain([process, 'access', _28 => _28.env, 'optionalAccess', _29 => _29.BRAINTRUST_OTEL_COMPAT, 'optionalAccess', _30 => _30.toLowerCase, 'call', _31 => _31()]) === "true";
  if (useOtel) {
    try {
      const { OtelContextManager: OtelContextManager2 } = (init_context3(), __toCommonJS(context_exports));
      return new OtelContextManager2();
    } catch (e9) {
      console.warn(
        "OTEL not available, falling back to Braintrust-only context manager"
      );
    }
  }
  return new BraintrustContextManager();
}
function useTestBackgroundLogger() {
  const state = _internalGetGlobalState();
  if (!state) {
    throw new Error("global state not set yet");
  }
  const logger = new TestBackgroundLogger();
  state.setOverrideBgLogger(logger);
  return logger;
}
function clearTestBackgroundLogger() {
  _optionalChain([_internalGetGlobalState, 'call', _32 => _32(), 'optionalAccess', _33 => _33.setOverrideBgLogger, 'call', _34 => _34(null)]);
}
function initTestExperiment(experimentName, projectName) {
  setInitialTestState();
  const state = _internalGetGlobalState();
  const project = _nullishCoalesce(projectName, () => ( experimentName));
  const lazyMetadata = new LazyValue(
    async () => ({
      project: { id: project, name: project, fullInfo: {} },
      experiment: { id: experimentName, name: experimentName, fullInfo: {} }
    })
  );
  return new Experiment2(state, lazyMetadata);
}
function _internalSetInitialState() {
  if (_globalState) {
    console.warn(
      "global state already set, should only call _internalSetInitialState once"
    );
    return;
  }
  _globalState = globalThis.__inherited_braintrust_state || new BraintrustState({
    /*empty login options*/
  });
}
async function checkResponse(resp) {
  if (resp.ok) {
    return resp;
  } else {
    throw new FailedHTTPResponse(
      resp.status,
      resp.statusText,
      await resp.text()
    );
  }
}
function logFeedbackImpl(state, parentObjectType, parentObjectId, {
  id,
  expected,
  scores,
  metadata: inputMetadata,
  tags,
  comment,
  source: inputSource
}) {
  const source = _nullishCoalesce(inputSource, () => ( "external"));
  if (!VALID_SOURCES.includes(source)) {
    throw new Error(`source must be one of ${VALID_SOURCES}`);
  }
  if (isEmpty(scores) && isEmpty(expected) && isEmpty(tags) && isEmpty(comment)) {
    throw new Error(
      "At least one of scores, expected, tags, or comment must be specified"
    );
  }
  const validatedEvent = validateAndSanitizeExperimentLogPartialArgs({
    scores,
    metadata: inputMetadata,
    expected,
    tags
  });
  let { metadata, ...updateEvent } = deepCopyEvent(validatedEvent);
  updateEvent = Object.fromEntries(
    Object.entries(updateEvent).filter(([_, v]) => !isEmpty(v))
  );
  const parentIds = async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields();
  if (Object.keys(updateEvent).length > 0) {
    const record = new LazyValue(async () => {
      return {
        id,
        ...updateEvent,
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata,
        [IS_MERGE_FIELD]: true
      };
    });
    state.bgLogger().log([record]);
  }
  if (!isEmpty(comment)) {
    const record = new LazyValue(async () => {
      return {
        id: _uuid.v4.call(void 0, ),
        created: (/* @__PURE__ */ new Date()).toISOString(),
        origin: {
          // NOTE: We do not know (or care?) what the transaction id of the row that
          // we're commenting on is here, so we omit it.
          id
        },
        comment: {
          text: comment
        },
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata
      };
    });
    state.bgLogger().log([record]);
  }
}
function updateSpanImpl({
  state,
  parentObjectType,
  parentObjectId,
  id,
  event
}) {
  const updateEvent = deepCopyEvent(
    validateAndSanitizeExperimentLogPartialArgs({
      id,
      ...event
    })
  );
  const parentIds = async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields();
  const record = new LazyValue(async () => ({
    id,
    ...updateEvent,
    ...await parentIds(),
    [IS_MERGE_FIELD]: true
  }));
  state.bgLogger().log([record]);
}
function updateSpan({
  exported,
  state,
  ...event
}) {
  const resolvedState = _nullishCoalesce(state, () => ( _globalState));
  const components = getSpanComponentsClass().fromStr(exported);
  if (!components.data.row_id) {
    throw new Error("Exported span must have a row id");
  }
  updateSpanImpl({
    state: resolvedState,
    parentObjectType: components.data.object_type,
    parentObjectId: new LazyValue(
      spanComponentsToObjectIdLambda(resolvedState, components)
    ),
    id: components.data.row_id,
    event
  });
}
function spanComponentsToObjectIdLambda(state, components) {
  if (components.data.object_id) {
    const ret = components.data.object_id;
    return async () => ret;
  }
  if (!components.data.compute_object_metadata_args) {
    throw new Error(
      "Impossible: must provide either objectId or computeObjectMetadataArgs"
    );
  }
  switch (components.data.object_type) {
    case 1 /* EXPERIMENT */:
      throw new Error(
        "Impossible: computeObjectMetadataArgs not supported for experiments"
      );
    case 3 /* PLAYGROUND_LOGS */:
      throw new Error(
        "Impossible: computeObjectMetadataArgs not supported for prompt sessions"
      );
    case 2 /* PROJECT_LOGS */:
      return async () => (await computeLoggerMetadata(state, {
        ...components.data.compute_object_metadata_args
      })).project.id;
    default:
      const x = components.data.object_type;
      throw new Error(`Unknown object type: ${x}`);
  }
}
async function spanComponentsToObjectId({
  components,
  state
}) {
  return await spanComponentsToObjectIdLambda(
    _nullishCoalesce(state, () => ( _globalState)),
    components
  )();
}
function getErrPermlink(msg) {
  if (msg == "") {
    return ERR_PERMALINK;
  }
  return `${ERR_PERMALINK}?msg=${encodeURIComponent(msg)}`;
}
async function permalink(slug, opts) {
  if (slug === "") {
    return NOOP_SPAN_PERMALINK;
  }
  const state = _nullishCoalesce(_optionalChain([opts, 'optionalAccess', _35 => _35.state]), () => ( _globalState));
  const getOrgName = async () => {
    if (_optionalChain([opts, 'optionalAccess', _36 => _36.orgName])) {
      return opts.orgName;
    }
    await state.login({});
    if (!state.orgName) {
      throw new Error("provide-org-or-login");
    }
    return state.orgName;
  };
  const getAppUrl = async () => {
    if (_optionalChain([opts, 'optionalAccess', _37 => _37.appUrl])) {
      return opts.appUrl;
    }
    await state.login({});
    if (!state.appUrl) {
      throw new Error("provide-app-url-or-login");
    }
    return state.appUrl;
  };
  try {
    const components = getSpanComponentsClass().fromStr(slug);
    const object_type = spanObjectTypeV3ToString(components.data.object_type);
    const [orgName, appUrl, object_id] = await Promise.all([
      getOrgName(),
      getAppUrl(),
      spanComponentsToObjectId({ components, state })
    ]);
    const id = components.data.row_id;
    if (!id) {
      throw new Error("Span slug does not refer to an individual row");
    }
    const urlParams = new URLSearchParams({ object_type, object_id, id });
    return `${appUrl}/app/${orgName}/object?${urlParams}`;
  } catch (e) {
    if (e instanceof FailedHTTPResponse) {
      return getErrPermlink(`http-error-${e.status}`);
    }
    return getErrPermlink(e instanceof Error ? e.message : String(e));
  }
}
function startSpanParentArgs(args) {
  let argParentObjectId = void 0;
  let argParentSpanIds = void 0;
  let argPropagatedEvent = void 0;
  if (args.parent) {
    if (args.parentSpanIds) {
      throw new Error("Cannot specify both parent and parentSpanIds");
    }
    const parentComponents = getSpanComponentsClass().fromStr(args.parent);
    if (args.parentObjectType !== parentComponents.data.object_type) {
      throw new Error(
        `Mismatch between expected span parent object type ${args.parentObjectType} and provided type ${parentComponents.data.object_type}`
      );
    }
    const parentComponentsObjectIdLambda = spanComponentsToObjectIdLambda(
      args.state,
      parentComponents
    );
    const computeParentObjectId = async () => {
      const parentComponentsObjectId = await parentComponentsObjectIdLambda();
      if (await args.parentObjectId.get() !== parentComponentsObjectId) {
        throw new Error(
          `Mismatch between expected span parent object id ${await args.parentObjectId.get()} and provided id ${parentComponentsObjectId}`
        );
      }
      return await args.parentObjectId.get();
    };
    argParentObjectId = new LazyValue(computeParentObjectId);
    if (parentComponents.data.row_id) {
      argParentSpanIds = {
        spanId: parentComponents.data.span_id,
        rootSpanId: parentComponents.data.root_span_id
      };
    }
    argPropagatedEvent = _nullishCoalesce(args.propagatedEvent, () => ( (_nullishCoalesce(parentComponents.data.propagated_event, () => ( void 0)))));
  } else {
    argParentObjectId = args.parentObjectId;
    argParentSpanIds = args.parentSpanIds;
    argPropagatedEvent = args.propagatedEvent;
  }
  return {
    parentObjectType: args.parentObjectType,
    parentObjectId: argParentObjectId,
    parentComputeObjectMetadataArgs: args.parentComputeObjectMetadataArgs,
    parentSpanIds: argParentSpanIds,
    propagatedEvent: argPropagatedEvent
  };
}
function castLogger(logger, asyncFlush) {
  if (logger === void 0) return void 0;
  if (asyncFlush !== void 0 && !!asyncFlush !== !!logger.asyncFlush) {
    throw new Error(
      `Asserted asyncFlush setting ${asyncFlush} does not match stored logger's setting ${logger.asyncFlush}`
    );
  }
  return logger;
}
function constructLogs3Data(items) {
  return `{"rows": ${constructJsonArray(items)}, "api_version": 2}`;
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function init(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    experiment,
    description,
    dataset,
    baseExperiment,
    isPublic,
    open,
    update,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    metadata,
    gitMetadataSettings,
    projectId,
    baseExperimentId,
    repoInfo: repoInfo2,
    state: stateArg
  } = options;
  if (!project && !projectId) {
    throw new Error("Must specify at least one of project or projectId");
  }
  if (open && update) {
    throw new Error("Cannot open and update an experiment at the same time");
  }
  const state = _nullishCoalesce(stateArg, () => ( _globalState));
  state.enforceQueueSizeLimit(false);
  if (open) {
    if (isEmpty(experiment)) {
      throw new Error(`Cannot open an experiment without specifying its name`);
    }
    const lazyMetadata2 = new LazyValue(
      async () => {
        await state.login({ apiKey, appUrl, orgName, fetch: fetch2, forceLogin });
        const args = {
          project_name: project,
          project_id: projectId,
          org_name: state.orgName,
          experiment_name: experiment
        };
        const response = await state.appConn().post_json("api/experiment/get", args);
        if (response.length === 0) {
          throw new Error(
            `Experiment ${experiment} not found in project ${_nullishCoalesce(projectId, () => ( project))}.`
          );
        }
        const info = response[0];
        return {
          project: {
            id: info.project_id,
            name: _nullishCoalesce(project, () => ( "UNKNOWN_PROJECT")),
            fullInfo: {}
          },
          experiment: {
            id: info.id,
            name: info.name,
            fullInfo: info
          }
        };
      }
    );
    return new ReadonlyExperiment(
      _nullishCoalesce(stateArg, () => ( _globalState)),
      lazyMetadata2
    );
  }
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({ apiKey, appUrl, orgName });
      const args = {
        project_name: project,
        project_id: projectId,
        org_id: state.orgId,
        update
      };
      if (experiment) {
        args["experiment_name"] = experiment;
      }
      if (description) {
        args["description"] = description;
      }
      const repoInfoArg = await (async () => {
        if (repoInfo2) {
          return repoInfo2;
        }
        let mergedGitMetadataSettings = {
          ...state.gitMetadataSettings || {
            collect: "all"
          }
        };
        if (gitMetadataSettings) {
          mergedGitMetadataSettings = mergeGitMetadataSettings(
            mergedGitMetadataSettings,
            gitMetadataSettings
          );
        }
        return await isomorph_default.getRepoInfo(mergedGitMetadataSettings);
      })();
      if (repoInfoArg) {
        args["repo_info"] = repoInfoArg;
      }
      if (baseExperimentId) {
        args["base_exp_id"] = baseExperimentId;
      } else if (baseExperiment) {
        args["base_experiment"] = baseExperiment;
      } else {
        args["ancestor_commits"] = await isomorph_default.getPastNAncestors();
      }
      if (dataset !== void 0) {
        args["dataset_id"] = await dataset.id;
        args["dataset_version"] = await dataset.version();
      }
      if (isPublic !== void 0) {
        args["public"] = isPublic;
      }
      if (metadata) {
        args["metadata"] = metadata;
      }
      let response = null;
      while (true) {
        try {
          response = await state.appConn().post_json("api/experiment/register", args);
          break;
        } catch (e) {
          if (args["base_experiment"] && `${"data" in e && e.data}`.includes("base experiment")) {
            console.warn(
              `Base experiment ${args["base_experiment"]} not found.`
            );
            delete args["base_experiment"];
          } else {
            throw e;
          }
        }
      }
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        experiment: {
          id: response.experiment.id,
          name: response.experiment.name,
          created: response.experiment.created,
          fullInfo: response.experiment
        }
      };
    }
  );
  const ret = new Experiment2(state, lazyMetadata, dataset);
  if (_nullishCoalesce(options.setCurrent, () => ( true))) {
    state.currentExperiment = ret;
  }
  return ret;
}
function initExperiment(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  return init(options);
}
function withExperiment(project, callback, options = {}) {
  console.warn(
    "withExperiment is deprecated and will be removed in a future version of braintrust. Simply create the experiment with `init`."
  );
  const experiment = init(project, options);
  return callback(experiment);
}
function withLogger(callback, options = {}) {
  console.warn(
    "withLogger is deprecated and will be removed in a future version of braintrust. Simply create the logger with `initLogger`."
  );
  const logger = initLogger(options);
  return callback(logger);
}
function initDataset(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either initDataset(project, options) or initDataset(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    dataset,
    description,
    version,
    appUrl,
    apiKey,
    orgName,
    fetch: fetch2,
    forceLogin,
    projectId,
    metadata,
    useOutput: legacy,
    state: stateArg,
    _internal_btql
  } = options;
  const state = _nullishCoalesce(stateArg, () => ( _globalState));
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        fetch: fetch2,
        forceLogin
      });
      const args = {
        org_id: state.orgId,
        project_name: project,
        project_id: projectId,
        dataset_name: dataset,
        description,
        metadata
      };
      const response = await state.appConn().post_json("api/dataset/register", args);
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        dataset: {
          id: response.dataset.id,
          name: response.dataset.name,
          fullInfo: response.dataset
        }
      };
    }
  );
  return new Dataset2(
    _nullishCoalesce(stateArg, () => ( _globalState)),
    lazyMetadata,
    version,
    legacy,
    _internal_btql
  );
}
function withDataset(project, callback, options = {}) {
  console.warn(
    "withDataset is deprecated and will be removed in a future version of braintrust. Simply create the dataset with `initDataset`."
  );
  const dataset = initDataset(project, options);
  return callback(dataset);
}
async function computeLoggerMetadata(state, {
  project_name,
  project_id
}) {
  await state.login({});
  const org_id = state.orgId;
  if (isEmpty(project_id)) {
    const response = await state.appConn().post_json("api/project/register", {
      project_name: project_name || GLOBAL_PROJECT,
      org_id
    });
    return {
      org_id,
      project: {
        id: response.project.id,
        name: response.project.name,
        fullInfo: response.project
      }
    };
  } else if (isEmpty(project_name)) {
    const response = await state.appConn().get_json("api/project", {
      id: project_id
    });
    return {
      org_id,
      project: {
        id: project_id,
        name: response.name,
        fullInfo: response.project
      }
    };
  } else {
    return {
      org_id,
      project: { id: project_id, name: project_name, fullInfo: {} }
    };
  }
}
function initLogger(options = {}) {
  const {
    projectName,
    projectId,
    asyncFlush: asyncFlushArg,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    state: stateArg
  } = options || {};
  const asyncFlush = asyncFlushArg === void 0 ? true : asyncFlushArg;
  const computeMetadataArgs = {
    project_name: projectName,
    project_id: projectId
  };
  const state = _nullishCoalesce(stateArg, () => ( _globalState));
  state.enforceQueueSizeLimit(true);
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        forceLogin,
        fetch: fetch2
      });
      return computeLoggerMetadata(state, computeMetadataArgs);
    }
  );
  const ret = new Logger(state, lazyMetadata, {
    asyncFlush,
    computeMetadataArgs
  });
  if (_nullishCoalesce(options.setCurrent, () => ( true))) {
    state.currentLogger = ret;
  }
  return ret;
}
async function loadPrompt({
  projectName,
  projectId,
  slug,
  version,
  environment,
  id,
  defaults,
  noTrace = false,
  appUrl,
  apiKey,
  orgName,
  fetch: fetch2,
  forceLogin,
  state: stateArg
}) {
  if (version && environment) {
    throw new Error(
      "Cannot specify both 'version' and 'environment' parameters. Please use only one (remove the other)."
    );
  }
  if (id) {
  } else if (isEmpty(projectName) && isEmpty(projectId)) {
    throw new Error("Must specify either projectName or projectId");
  } else if (isEmpty(slug)) {
    throw new Error("Must specify slug");
  }
  const state = _nullishCoalesce(stateArg, () => ( _globalState));
  let response;
  try {
    await state.login({
      orgName,
      apiKey,
      appUrl,
      fetch: fetch2,
      forceLogin
    });
    if (id) {
      response = await state.apiConn().get_json(`v1/prompt/${id}`, {
        ...version && { version },
        ...environment && { environment }
      });
      if (response) {
        response = { objects: [response] };
      }
    } else {
      response = await state.apiConn().get_json("v1/prompt", {
        project_name: projectName,
        project_id: projectId,
        slug,
        version,
        ...environment && { environment }
      });
    }
  } catch (e) {
    if (environment || version) {
      throw new Error(`Prompt not found with specified parameters: ${e}`);
    }
    console.warn("Failed to load prompt, attempting to fall back to cache:", e);
    let prompt2;
    if (id) {
      prompt2 = await state.promptCache.get({ id });
      if (!prompt2) {
        throw new Error(
          `Prompt with id ${id} not found (not found on server or in local cache): ${e}`
        );
      }
    } else {
      prompt2 = await state.promptCache.get({
        slug,
        projectId,
        projectName,
        version: _nullishCoalesce(version, () => ( "latest"))
      });
      if (!prompt2) {
        throw new Error(
          `Prompt ${slug} (version ${_nullishCoalesce(version, () => ( "latest"))}) not found in ${[
            _nullishCoalesce(projectName, () => ( projectId))
          ]} (not found on server or in local cache): ${e}`
        );
      }
    }
    return prompt2;
  }
  if (!("objects" in response) || response.objects.length === 0) {
    if (id) {
      throw new Error(`Prompt with id ${id} not found.`);
    } else {
      throw new Error(
        `Prompt ${slug} not found in ${[_nullishCoalesce(projectName, () => ( projectId))]}`
      );
    }
  } else if (response.objects.length > 1) {
    if (id) {
      throw new Error(
        `Multiple prompts found with id ${id}. This should never happen.`
      );
    } else {
      throw new Error(
        `Multiple prompts found with slug ${slug} in project ${_nullishCoalesce(projectName, () => ( projectId))}. This should never happen.`
      );
    }
  }
  const metadata = Prompt.parse(response["objects"][0]);
  const prompt = new Prompt2(metadata, defaults || {}, noTrace);
  try {
    if (id) {
      await state.promptCache.set({ id }, prompt);
    } else if (slug) {
      await state.promptCache.set(
        { slug, projectId, projectName, version: _nullishCoalesce(version, () => ( "latest")) },
        prompt
      );
    }
  } catch (e) {
    console.warn("Failed to set prompt in cache:", e);
  }
  return prompt;
}
function setMaskingFunction(maskingFunction) {
  _globalState.setMaskingFunction(maskingFunction);
}
async function login(options = {}) {
  const { forceLogin = false } = options || {};
  if (_globalState.loggedIn && !forceLogin) {
    let checkUpdatedParam2 = function(varname, arg, orig) {
      if (!isEmpty(arg) && !isEmpty(orig) && arg !== orig) {
        throw new Error(
          `Re-logging in with different ${varname} (${arg}) than original (${orig}). To force re-login, pass \`forceLogin: true\``
        );
      }
    };
    var checkUpdatedParam = checkUpdatedParam2;
    checkUpdatedParam2("appUrl", options.appUrl, _globalState.appUrl);
    checkUpdatedParam2(
      "apiKey",
      options.apiKey ? HTTPConnection.sanitize_token(options.apiKey) : void 0,
      _globalState.loginToken
    );
    checkUpdatedParam2("orgName", options.orgName, _globalState.orgName);
    return _globalState;
  }
  await _globalState.login(options);
  globalThis.__inherited_braintrust_state = _globalState;
  return _globalState;
}
async function loginToState(options = {}) {
  const {
    appUrl = isomorph_default.getEnv("BRAINTRUST_APP_URL") || "https://www.braintrust.dev",
    apiKey = isomorph_default.getEnv("BRAINTRUST_API_KEY"),
    orgName = isomorph_default.getEnv("BRAINTRUST_ORG_NAME"),
    fetch: fetch2 = globalThis.fetch
  } = options || {};
  const appPublicUrl = isomorph_default.getEnv("BRAINTRUST_APP_PUBLIC_URL") || appUrl;
  const state = new BraintrustState(options);
  state.resetLoginInfo();
  state.appUrl = appUrl;
  state.appPublicUrl = appPublicUrl;
  let conn = null;
  if (!apiKey) {
    throw new Error(
      "Please specify an api key (e.g. by setting BRAINTRUST_API_KEY)."
    );
  } else if (apiKey === TEST_API_KEY) {
    const testOrgInfo = [
      {
        id: "test-org-id",
        name: "test-org-name",
        api_url: "https://braintrust.dev/fake-api-url"
      }
    ];
    state.loggedIn = true;
    state.loginToken = TEST_API_KEY;
    _saveOrgInfo(state, testOrgInfo, testOrgInfo[0].name);
    return state;
  } else {
    const resp = await checkResponse(
      await fetch2(_urljoin(state.appUrl, `/api/apikey/login`), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`
        }
      })
    );
    const info = await resp.json();
    _saveOrgInfo(state, info.org_info, orgName);
    if (!state.apiUrl) {
      if (orgName) {
        throw new Error(
          `Unable to log into organization '${orgName}'. Are you sure this credential is scoped to the organization?`
        );
      } else {
        throw new Error(
          "Unable to log into any organization with the provided credential."
        );
      }
    }
    conn = state.apiConn();
    conn.set_token(apiKey);
    if (!conn) {
      throw new Error("Conn should be set at this point (a bug)");
    }
    conn.make_long_lived();
    state.appConn().set_token(apiKey);
    if (state.proxyUrl) {
      state.proxyConn().set_token(apiKey);
    }
    state.loginToken = conn.token;
    state.loggedIn = true;
    state.loginReplaceApiConn(conn);
  }
  return state;
}
function log(event) {
  console.warn(
    "braintrust.log is deprecated and will be removed in a future version of braintrust. Use `experiment.log` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return e.log(event);
}
async function summarize(options = {}) {
  console.warn(
    "braintrust.summarize is deprecated and will be removed in a future version of braintrust. Use `experiment.summarize` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return await e.summarize(options);
}
function currentExperiment(options) {
  const state = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _38 => _38.state]), () => ( _globalState));
  return state.currentExperiment;
}
function currentLogger(options) {
  const state = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _39 => _39.state]), () => ( _globalState));
  return castLogger(state.currentLogger, _optionalChain([options, 'optionalAccess', _40 => _40.asyncFlush]));
}
function currentSpan(options) {
  const state = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _41 => _41.state]), () => ( _globalState));
  return _nullishCoalesce(state.contextManager.getCurrentSpan(), () => ( NOOP_SPAN));
}
function getSpanParentObject(options) {
  const state = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _42 => _42.state]), () => ( _globalState));
  const parentSpan = currentSpan({ state });
  if (!Object.is(parentSpan, NOOP_SPAN)) {
    return parentSpan;
  }
  const parentStr = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _43 => _43.parent]), () => ( state.currentParent.getStore()));
  if (parentStr) return getSpanComponentsClass().fromStr(parentStr);
  const experiment = currentExperiment();
  if (experiment) {
    return experiment;
  }
  const logger = currentLogger(options);
  if (logger) {
    return logger;
  }
  return NOOP_SPAN;
}
function logError(span, error2) {
  let errorMessage = "<error>";
  let stackTrace = "";
  if (error2 instanceof Error) {
    errorMessage = error2.message;
    stackTrace = error2.stack || "";
  } else {
    errorMessage = String(error2);
  }
  span.log({ error: `${errorMessage}

${stackTrace}` });
}
function traced(callback, args) {
  const { span, isSyncFlushLogger } = startSpanAndIsLogger(args);
  const ret = runCatchFinally(
    () => {
      if (_nullishCoalesce(_optionalChain([args, 'optionalAccess', _44 => _44.setCurrent]), () => ( true))) {
        return withCurrent(span, callback);
      } else {
        return callback(span);
      }
    },
    (e) => {
      logError(span, e);
      throw e;
    },
    () => span.end()
  );
  if (_optionalChain([args, 'optionalAccess', _45 => _45.asyncFlush]) === void 0 || _optionalChain([args, 'optionalAccess', _46 => _46.asyncFlush])) {
    return ret;
  } else {
    return (async () => {
      const awaitedRet = await ret;
      if (isSyncFlushLogger) {
        await span.flush();
      }
      return awaitedRet;
    })();
  }
}
function isGeneratorFunction(fn) {
  return Object.prototype.toString.call(fn) === "[object GeneratorFunction]";
}
function isAsyncGeneratorFunction(fn) {
  return Object.prototype.toString.call(fn) === "[object AsyncGeneratorFunction]";
}
function wrapTracedSyncGenerator(fn, spanArgs, noTraceIO) {
  const wrapper = function* (...fnArgs) {
    const span = startSpan(spanArgs);
    try {
      if (!noTraceIO) {
        span.log({ input: fnArgs });
      }
      const envValue = isomorph_default.getEnv("BRAINTRUST_MAX_GENERATOR_ITEMS");
      const maxItems = envValue !== void 0 ? Number(envValue) : 1e3;
      if (!noTraceIO && maxItems !== 0) {
        let collected = [];
        let truncated = false;
        const gen = generatorWithCurrent(span, fn.apply(this, fnArgs));
        try {
          for (const value of gen) {
            if (maxItems === -1 || !truncated && collected.length < maxItems) {
              collected.push(value);
            } else {
              truncated = true;
              collected = [];
              console.warn(
                `Generator output exceeded limit of ${maxItems} items, output not logged. Increase BRAINTRUST_MAX_GENERATOR_ITEMS or set to -1 to disable limit.`
              );
            }
            yield value;
          }
          if (!truncated) {
            span.log({ output: collected });
          }
        } catch (error2) {
          logError(span, error2);
          if (!truncated && collected.length > 0) {
            span.log({ output: collected });
          }
          throw error2;
        }
      } else {
        const gen = generatorWithCurrent(span, fn.apply(this, fnArgs));
        for (const value of gen) {
          yield value;
        }
      }
    } finally {
      span.end();
    }
  };
  Object.defineProperty(wrapper, "name", { value: fn.name });
  return wrapper;
}
function wrapTracedAsyncGenerator(fn, spanArgs, noTraceIO) {
  const wrapper = async function* (...fnArgs) {
    const span = startSpan(spanArgs);
    try {
      if (!noTraceIO) {
        span.log({ input: fnArgs });
      }
      const envValue = isomorph_default.getEnv("BRAINTRUST_MAX_GENERATOR_ITEMS");
      const maxItems = envValue !== void 0 ? Number(envValue) : 1e3;
      if (!noTraceIO && maxItems !== 0) {
        let collected = [];
        let truncated = false;
        const gen = asyncGeneratorWithCurrent(span, fn.apply(this, fnArgs));
        try {
          for await (const value of gen) {
            if (maxItems === -1 || !truncated && collected.length < maxItems) {
              collected.push(value);
            } else {
              truncated = true;
              collected = [];
              console.warn(
                `Generator output exceeded limit of ${maxItems} items, output not logged. Increase BRAINTRUST_MAX_GENERATOR_ITEMS or set to -1 to disable limit.`
              );
            }
            yield value;
          }
          if (!truncated) {
            span.log({ output: collected });
          }
        } catch (error2) {
          logError(span, error2);
          if (!truncated && collected.length > 0) {
            span.log({ output: collected });
          }
          throw error2;
        }
      } else {
        const gen = asyncGeneratorWithCurrent(span, fn.apply(this, fnArgs));
        for await (const value of gen) {
          yield value;
        }
      }
    } finally {
      span.end();
    }
  };
  Object.defineProperty(wrapper, "name", { value: fn.name });
  return wrapper;
}
function wrapTraced(fn, args) {
  const spanArgs = {
    name: fn.name,
    type: "function",
    ...args
  };
  const hasExplicitInput = args && args.event && "input" in args.event && args.event.input !== void 0;
  const hasExplicitOutput = args && args.event && args.event.output !== void 0;
  const noTraceIO = _optionalChain([args, 'optionalAccess', _47 => _47.noTraceIO]) || hasExplicitInput || hasExplicitOutput;
  if (isGeneratorFunction(fn)) {
    return wrapTracedSyncGenerator(fn, spanArgs, !!noTraceIO);
  }
  if (isAsyncGeneratorFunction(fn)) {
    return wrapTracedAsyncGenerator(fn, spanArgs, !!noTraceIO);
  }
  if (_optionalChain([args, 'optionalAccess', _48 => _48.asyncFlush])) {
    return ((...fnArgs) => traced((span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const output = fn(...fnArgs);
      if (!hasExplicitOutput) {
        if (output instanceof Promise) {
          return (async () => {
            const result = await output;
            span.log({ output: result });
            return result;
          })();
        } else {
          span.log({ output });
        }
      }
      return output;
    }, spanArgs));
  } else {
    return ((...fnArgs) => traced(async (span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const outputResult = fn(...fnArgs);
      const output = await outputResult;
      if (!hasExplicitOutput) {
        span.log({ output });
      }
      return output;
    }, spanArgs));
  }
}
function startSpan(args) {
  return startSpanAndIsLogger(args).span;
}
async function flush(options) {
  const state = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _49 => _49.state]), () => ( _globalState));
  return await state.bgLogger().flush();
}
function setFetch(fetch2) {
  _globalState.setFetch(fetch2);
}
function startSpanAndIsLogger(args) {
  const state = _nullishCoalesce(_optionalChain([args, 'optionalAccess', _50 => _50.state]), () => ( _globalState));
  const parentObject = getSpanParentObject({
    asyncFlush: _optionalChain([args, 'optionalAccess', _51 => _51.asyncFlush]),
    parent: _optionalChain([args, 'optionalAccess', _52 => _52.parent]),
    state
  });
  if (parentObject instanceof SpanComponentsV3 || parentObject instanceof SpanComponentsV4) {
    const parentSpanIds = parentObject.data.row_id ? {
      spanId: parentObject.data.span_id,
      rootSpanId: parentObject.data.root_span_id
    } : void 0;
    const span = new SpanImpl({
      state,
      ...args,
      parentObjectType: parentObject.data.object_type,
      parentObjectId: new LazyValue(
        spanComponentsToObjectIdLambda(state, parentObject)
      ),
      parentComputeObjectMetadataArgs: _nullishCoalesce(parentObject.data.compute_object_metadata_args, () => ( void 0)),
      parentSpanIds,
      propagatedEvent: _nullishCoalesce(_optionalChain([args, 'optionalAccess', _53 => _53.propagatedEvent]), () => ( // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      (_nullishCoalesce(parentObject.data.propagated_event, () => ( void 0)))))
    });
    return {
      span,
      isSyncFlushLogger: parentObject.data.object_type === 2 /* PROJECT_LOGS */ && // Since there's no parent logger here, we're free to choose the async flush
      // behavior, and therefore propagate along whatever we get from the arguments
      _optionalChain([args, 'optionalAccess', _54 => _54.asyncFlush]) === false
    };
  } else {
    const span = parentObject.startSpan(args);
    return {
      span,
      isSyncFlushLogger: parentObject.kind === "logger" && parentObject.asyncFlush === false
    };
  }
}
function withCurrent(span, callback, state = void 0) {
  const currentState = _nullishCoalesce(state, () => ( _globalState));
  return currentState.contextManager.runInContext(span, () => callback(span));
}
function* generatorWithCurrent(span, gen, state = void 0) {
  let nextValue;
  while (true) {
    const result = withCurrent(
      span,
      () => {
        try {
          return gen.next(nextValue);
        } catch (e) {
          return { value: void 0, done: true, error: e };
        }
      },
      state
    );
    if ("error" in result) {
      throw result.error;
    }
    if (result.done) {
      return result.value;
    }
    nextValue = yield result.value;
  }
}
async function* asyncGeneratorWithCurrent(span, gen, state = void 0) {
  let nextValue;
  while (true) {
    const result = await withCurrent(
      span,
      async () => {
        try {
          return await gen.next(nextValue);
        } catch (e) {
          return { value: void 0, done: true, error: e };
        }
      },
      state
    );
    if ("error" in result) {
      throw result.error;
    }
    if (result.done) {
      return result.value;
    }
    nextValue = yield result.value;
  }
}
function withParent(parent, callback, state = void 0) {
  return (_nullishCoalesce(state, () => ( _globalState))).currentParent.run(parent, () => callback());
}
function _saveOrgInfo(state, org_info, org_name) {
  if (org_info.length === 0) {
    throw new Error("This user is not part of any organizations.");
  }
  for (const org of org_info) {
    if (org_name === void 0 || org.name === org_name) {
      state.orgId = org.id;
      state.orgName = org.name;
      state.apiUrl = _nullishCoalesce(isomorph_default.getEnv("BRAINTRUST_API_URL"), () => ( org.api_url));
      state.proxyUrl = _nullishCoalesce(isomorph_default.getEnv("BRAINTRUST_PROXY_URL"), () => ( org.proxy_url));
      state.gitMetadataSettings = org.git_metadata || void 0;
      break;
    }
  }
  if (state.orgId === void 0) {
    throw new Error(
      `Organization ${org_name} not found. Must be one of ${org_info.map((x) => x.name).join(", ")}`
    );
  }
}
function validateTags(tags) {
  const seen = /* @__PURE__ */ new Set();
  for (const tag of tags) {
    if (typeof tag !== "string") {
      throw new Error("tags must be strings");
    }
    if (seen.has(tag)) {
      throw new Error(`duplicate tag: ${tag}`);
    }
  }
}
function validateAndSanitizeExperimentLogPartialArgs(event) {
  if (event.scores) {
    if (Array.isArray(event.scores)) {
      throw new Error("scores must be an object, not an array");
    }
    for (let [name, score] of Object.entries(event.scores)) {
      if (typeof name !== "string") {
        throw new Error("score names must be strings");
      }
      if (score === null || score === void 0) {
        continue;
      }
      if (typeof score === "boolean") {
        score = score ? 1 : 0;
        event.scores[name] = score;
      }
      if (typeof score !== "number") {
        throw new Error("score values must be numbers");
      }
      if (score < 0 || score > 1) {
        throw new Error("score values must be between 0 and 1");
      }
    }
  }
  if (event.metadata) {
    for (const key of Object.keys(event.metadata)) {
      if (typeof key !== "string") {
        throw new Error("metadata keys must be strings");
      }
    }
  }
  if (event.metrics) {
    for (const [key, value] of Object.entries(event.metrics)) {
      if (typeof key !== "string") {
        throw new Error("metric keys must be strings");
      }
      if (value !== void 0 && typeof value !== "number") {
        throw new Error("metric values must be numbers");
      }
    }
  }
  if ("input" in event && event.input && "inputs" in event && event.inputs) {
    throw new Error(
      "Only one of input or inputs (deprecated) can be specified. Prefer input."
    );
  }
  if ("tags" in event && event.tags) {
    validateTags(event.tags);
  }
  if ("inputs" in event) {
    const { inputs, ...rest } = event;
    return { input: inputs, ...rest };
  } else {
    return { ...event };
  }
}
function deepCopyEvent(event) {
  const attachments = [];
  const IDENTIFIER = "_bt_internal_saved_attachment";
  const savedAttachmentSchema = _v3.z.strictObject({ [IDENTIFIER]: _v3.z.number() });
  const serialized = JSON.stringify(event, (_k, v) => {
    if (v instanceof SpanImpl || v instanceof NoopSpan) {
      return `<span>`;
    } else if (v instanceof Experiment2) {
      return `<experiment>`;
    } else if (v instanceof Dataset2) {
      return `<dataset>`;
    } else if (v instanceof Logger) {
      return `<logger>`;
    } else if (v instanceof BaseAttachment) {
      const idx = attachments.push(v);
      return { [IDENTIFIER]: idx - 1 };
    } else if (v instanceof ReadonlyAttachment) {
      return v.reference;
    }
    return v;
  });
  const x = JSON.parse(serialized, (_k, v) => {
    const parsedAttachment = savedAttachmentSchema.safeParse(v);
    if (parsedAttachment.success) {
      return attachments[parsedAttachment.data[IDENTIFIER]];
    }
    return v;
  });
  return x;
}
function extractAttachments(event, attachments) {
  for (const [key, value] of Object.entries(event)) {
    if (!value) {
      continue;
    }
    if (value instanceof BaseAttachment) {
      attachments.push(value);
      event[key] = value.reference;
      continue;
    }
    if (_optionalChain([value, 'optionalAccess', _55 => _55.type]) === BRAINTRUST_ATTACHMENT && value.key && !value.uploader) {
      continue;
    }
    if (_optionalChain([value, 'optionalAccess', _56 => _56.reference, 'optionalAccess', _57 => _57.type]) === BRAINTRUST_ATTACHMENT && _optionalChain([value, 'optionalAccess', _58 => _58.uploader])) {
      const attachment = new Attachment({
        data: value.dataDebugString,
        filename: value.reference.filename,
        contentType: value.reference.content_type
      });
      attachments.push(attachment);
      event[key] = attachment.reference;
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    extractAttachments(value, attachments);
  }
}
function enrichAttachments(event, state) {
  for (const [key, value] of Object.entries(event)) {
    const parsedValue = AttachmentReference.safeParse(value);
    if (parsedValue.success) {
      event[key] = new ReadonlyAttachment(parsedValue.data, state);
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    enrichAttachments(value, state);
  }
  return event;
}
async function resolveAttachmentsToBase64(event, state) {
  for (const [key, value] of Object.entries(event)) {
    if (value instanceof ReadonlyAttachment) {
      event[key] = await value.asBase64Url();
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    await resolveAttachmentsToBase64(value, state);
  }
  return event;
}
function validateAndSanitizeExperimentLogFullArgs(event, hasDataset) {
  if ("input" in event && !isEmpty(event.input) && "inputs" in event && !isEmpty(event.inputs) || !("input" in event) && !("inputs" in event)) {
    throw new Error(
      "Exactly one of input or inputs (deprecated) must be specified. Prefer input."
    );
  }
  if (isEmpty(event.output)) {
    throw new Error("output must be specified");
  }
  if (isEmpty(event.scores)) {
    throw new Error("scores must be specified");
  }
  if (hasDataset && event.datasetRecordId === void 0) {
    throw new Error("datasetRecordId must be specified when using a dataset");
  } else if (!hasDataset && event.datasetRecordId !== void 0) {
    throw new Error(
      "datasetRecordId cannot be specified when not using a dataset"
    );
  }
  return event;
}
function newId() {
  return _uuid.v4.call(void 0, );
}
function _resolveSpanIds(spanId, parentSpanIds, lookupSpanParent, idGenerator, contextManager) {
  const resolvedSpanId = _nullishCoalesce(spanId, () => ( idGenerator.getSpanId()));
  if (parentSpanIds) {
    return {
      spanId: resolvedSpanId,
      rootSpanId: parentSpanIds.rootSpanId,
      spanParents: "parentSpanIds" in parentSpanIds ? parentSpanIds.parentSpanIds : [parentSpanIds.spanId]
    };
  }
  if (lookupSpanParent) {
    const parentInfo = contextManager.getParentSpanIds();
    if (parentInfo) {
      return {
        spanId: resolvedSpanId,
        rootSpanId: parentInfo.rootSpanId,
        spanParents: parentInfo.spanParents
      };
    }
  }
  let resolvedRootSpanId;
  if (idGenerator.shareRootSpanId()) {
    resolvedRootSpanId = resolvedSpanId;
  } else {
    resolvedRootSpanId = idGenerator.getTraceId();
  }
  return {
    spanId: resolvedSpanId,
    rootSpanId: resolvedRootSpanId,
    spanParents: void 0
  };
}
function splitLoggingData({
  event,
  internalData
}) {
  const sanitized = validateAndSanitizeExperimentLogPartialArgs(_nullishCoalesce(event, () => ( {})));
  const sanitizedAndInternalData = {};
  mergeDicts(sanitizedAndInternalData, internalData || {});
  mergeDicts(sanitizedAndInternalData, sanitized);
  const serializableInternalData = {};
  const lazyInternalData = {};
  for (const [key, value] of Object.entries(sanitizedAndInternalData)) {
    if (value instanceof BraintrustStream) {
      const streamCopy = value.copy();
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject2) => {
          streamCopy.toReadableStream().pipeThrough(createFinalValuePassThroughStream(resolve, reject2)).pipeTo(devNullWritableStream());
        });
      });
    } else if (value instanceof ReadableStream) {
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject2) => {
          value.pipeThrough(createFinalValuePassThroughStream(resolve, reject2)).pipeTo(devNullWritableStream());
        });
      });
    } else {
      serializableInternalData[key] = value;
    }
  }
  return [serializableInternalData, lazyInternalData];
}
function renderMessage(render, message) {
  return {
    ...message,
    ..."content" in message ? {
      content: isEmpty(message.content) ? void 0 : typeof message.content === "string" ? render(message.content) : message.content.map((c) => {
        switch (c.type) {
          case "text":
            return { ...c, text: render(c.text) };
          case "image_url":
            if (isObject(c.image_url.url)) {
              throw new Error(
                "Attachments must be replaced with URLs before calling `build()`"
              );
            }
            return {
              ...c,
              image_url: {
                ...c.image_url,
                url: render(c.image_url.url)
              }
            };
          default:
            const _exhaustiveCheck = c;
            return _exhaustiveCheck;
        }
      })
    } : {},
    ..."tool_calls" in message ? {
      tool_calls: isEmpty(message.tool_calls) ? void 0 : message.tool_calls.map((t) => {
        return {
          type: t.type,
          id: render(t.id),
          function: {
            name: render(t.function.name),
            arguments: render(t.function.arguments)
          }
        };
      })
    } : {},
    ..."tool_call_id" in message ? {
      tool_call_id: render(message.tool_call_id)
    } : {}
  };
}
function deserializePlainStringAsJSON(s) {
  if (s.trim() === "") {
    return { value: null, error: void 0 };
  }
  try {
    return { value: JSON.parse(s), error: void 0 };
  } catch (e) {
    return { value: s, error: e };
  }
}
function renderTemplatedObject(obj, args, options) {
  if (typeof obj === "string") {
    if (options.strict) {
      lintTemplate(obj, args);
    }
    return _mustache2.default.render(obj, args, void 0, {
      escape: (value) => {
        if (typeof value === "string") {
          return value;
        } else {
          return JSON.stringify(value);
        }
      }
    });
  } else if (isArray(obj)) {
    return obj.map((item) => renderTemplatedObject(item, args, options));
  } else if (isObject(obj)) {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [
        key,
        renderTemplatedObject(value, args, options)
      ])
    );
  }
  return obj;
}
function renderPromptParams(params, args, options) {
  const schemaParsed = _v3.z.object({
    response_format: _v3.z.object({
      type: _v3.z.literal("json_schema"),
      json_schema: ResponseFormatJsonSchema.omit({ schema: true }).extend({
        schema: _v3.z.unknown()
      })
    })
  }).safeParse(params);
  if (schemaParsed.success) {
    const rawSchema = schemaParsed.data.response_format.json_schema.schema;
    const templatedSchema = renderTemplatedObject(rawSchema, args, options);
    const parsedSchema = typeof templatedSchema === "string" ? deserializePlainStringAsJSON(templatedSchema).value : templatedSchema;
    return {
      ...params,
      response_format: {
        ...schemaParsed.data.response_format,
        json_schema: {
          ...schemaParsed.data.response_format.json_schema,
          schema: parsedSchema
        }
      }
    };
  }
  return params;
}
function setInitialTestState() {
  if (!_internalGetGlobalState()) {
    _internalSetInitialState();
  }
}
async function simulateLoginForTests() {
  return await login({
    apiKey: TEST_API_KEY,
    appUrl: "https://braintrust.dev"
  });
}
function simulateLogoutForTests() {
  _globalState.resetLoginInfo();
  _globalState.appUrl = "https://www.braintrust.dev";
  return _globalState;
}
async function getPromptVersions(projectId, promptId) {
  const state = _internalGetGlobalState();
  if (!state) {
    throw new Error("Must log in first");
  }
  await state.login({});
  const query = {
    from: {
      op: "function",
      name: {
        op: "ident",
        name: ["project_prompts"]
      },
      args: [
        {
          op: "literal",
          value: projectId
        }
      ]
    },
    select: [
      {
        op: "star"
      }
    ],
    filter: {
      op: "eq",
      left: { op: "ident", name: ["id"] },
      right: { op: "literal", value: promptId }
    }
  };
  const response = await state.apiConn().post(
    "btql",
    {
      query,
      audit_log: true,
      use_columnstore: false,
      brainstore_realtime: true
    },
    { headers: { "Accept-Encoding": "gzip" } }
  );
  if (!response.ok) {
    throw new Error(
      `API request failed: ${response.status} ${response.statusText}`
    );
  }
  const result = await response.json();
  return _optionalChain([result, 'access', _59 => _59.data, 'optionalAccess', _60 => _60.filter, 'call', _61 => _61(
    (entry) => ["upsert", "merge"].includes(_optionalChain([entry, 'access', _62 => _62.audit_data, 'optionalAccess', _63 => _63.action]))
  ), 'access', _64 => _64.map, 'call', _65 => _65((entry) => prettifyXact(entry._xact_id))]) || [];
}
function resetIdGenStateForTests() {
  const state = _internalGetGlobalState();
  if (state) {
    state.resetIdGenState();
  }
}
var BRAINTRUST_ATTACHMENT, EXTERNAL_ATTACHMENT, BRAINTRUST_PARAMS, REDACTION_FIELDS, MaskingError, ContextManager, BraintrustContextManager, NoopSpan, NOOP_SPAN, NOOP_SPAN_PERMALINK, loginSchema, stateNonce, BraintrustState, _globalState, _internalGetGlobalState, FailedHTTPResponse, HTTPConnection, BaseAttachment, Attachment, ExternalAttachment, attachmentMetadataSchema, ReadonlyAttachment, JSONAttachment, ERR_PERMALINK, Logger, TestBackgroundLogger, BACKGROUND_LOGGER_BASE_SLEEP_TIME_S, HTTPBackgroundLogger, traceable, INTERNAL_BTQL_LIMIT, MAX_BTQL_ITERATIONS, ObjectFetcher, Experiment2, ReadonlyExperiment, executionCounter, SpanImpl, Dataset2, Prompt2, TEST_API_KEY, _exportsForTestingOnly;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    init_queue();
    init_id_gen();
    init_util();
    init_generated_types();
    init_stream();
    init_isomorph();
    init_disk_cache();
    init_lru_cache();
    init_prompt_cache();
    init_util2();
    init_mustache_utils();
    init_util();
    BRAINTRUST_ATTACHMENT = BraintrustAttachmentReference.shape.type.value;
    EXTERNAL_ATTACHMENT = ExternalAttachmentReference.shape.type.value;
    BRAINTRUST_PARAMS = Object.keys(BraintrustModelParams.shape);
    REDACTION_FIELDS = [
      "input",
      "output",
      "expected",
      "metadata",
      "context",
      "scores",
      "metrics"
    ];
    MaskingError = class {
      constructor(fieldName, errorType) {
        this.fieldName = fieldName;
        this.errorType = errorType;
      }
      get errorMsg() {
        return `ERROR: Failed to mask field '${this.fieldName}' - ${this.errorType}`;
      }
    };
    ContextManager = exports.ContextManager = class {
    };
    BraintrustContextManager = class extends ContextManager {
      
      constructor() {
        super();
        this._currentSpan = isomorph_default.newAsyncLocalStorage();
      }
      getParentSpanIds() {
        const currentSpan2 = this._currentSpan.getStore();
        if (!currentSpan2) {
          return void 0;
        }
        return {
          rootSpanId: currentSpan2.rootSpanId,
          spanParents: [currentSpan2.spanId]
        };
      }
      runInContext(span, callback) {
        return this._currentSpan.run(span, callback);
      }
      getCurrentSpan() {
        return this._currentSpan.getStore();
      }
    };
    NoopSpan = exports.NoopSpan = (_class4 = class {
      
      
      
      
      __init7() {this.kind = "span"}
      constructor() {;_class4.prototype.__init7.call(this);
        this.id = "";
        this.spanId = "";
        this.rootSpanId = "";
        this.spanParents = [];
      }
      log(_) {
      }
      logFeedback(_event) {
      }
      traced(callback, _1) {
        return callback(this);
      }
      startSpan(_1) {
        return this;
      }
      end(args) {
        return _nullishCoalesce(_optionalChain([args, 'optionalAccess', _66 => _66.endTime]), () => ( getCurrentUnixTimestamp()));
      }
      async export() {
        return "";
      }
      async permalink() {
        return NOOP_SPAN_PERMALINK;
      }
      link() {
        return NOOP_SPAN_PERMALINK;
      }
      async flush() {
      }
      close(args) {
        return this.end(args);
      }
      setAttributes(_args) {
      }
      startSpanWithParents(_spanId, _spanParents, _args) {
        return this;
      }
      state() {
        return _internalGetGlobalState();
      }
      _getOtelParent() {
        return void 0;
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `NoopSpan {
  kind: '${this.kind}',
  id: '${this.id}',
  spanId: '${this.spanId}',
  rootSpanId: '${this.rootSpanId}',
  spanParents: ${JSON.stringify(this.spanParents)}
}`;
      }
      // Custom toString
      toString() {
        return `NoopSpan(id=${this.id}, spanId=${this.spanId})`;
      }
    }, _class4);
    NOOP_SPAN = exports.NOOP_SPAN = new NoopSpan();
    NOOP_SPAN_PERMALINK = exports.NOOP_SPAN_PERMALINK = "https://braintrust.dev/noop-span";
    loginSchema = _v3.z.strictObject({
      appUrl: _v3.z.string(),
      appPublicUrl: _v3.z.string(),
      orgName: _v3.z.string(),
      apiUrl: _v3.z.string(),
      proxyUrl: _v3.z.string(),
      loginToken: _v3.z.string(),
      orgId: _v3.z.string().nullish(),
      gitMetadataSettings: GitMetadataSettings.nullish()
    });
    stateNonce = 0;
    BraintrustState = exports.BraintrustState = (_class5 = class _BraintrustState {
      constructor(loginParams) {;_class5.prototype.__init8.call(this);_class5.prototype.__init9.call(this);_class5.prototype.__init10.call(this);_class5.prototype.__init11.call(this);_class5.prototype.__init12.call(this);_class5.prototype.__init13.call(this);_class5.prototype.__init14.call(this);_class5.prototype.__init15.call(this);_class5.prototype.__init16.call(this);_class5.prototype.__init17.call(this);_class5.prototype.__init18.call(this);_class5.prototype.__init19.call(this);_class5.prototype.__init20.call(this);_class5.prototype.__init21.call(this);_class5.prototype.__init22.call(this);
        this.loginParams = loginParams;
        this.id = `${(/* @__PURE__ */ new Date()).toLocaleString()}-${stateNonce++}`;
        this.currentExperiment = void 0;
        this.currentLogger = void 0;
        this.currentParent = isomorph_default.newAsyncLocalStorage();
        this.currentSpan = isomorph_default.newAsyncLocalStorage();
        if (loginParams.fetch) {
          this.fetch = loginParams.fetch;
        }
        const defaultGetLogConn = async () => {
          await this.login({});
          return this.apiConn();
        };
        this._bgLogger = new SyncLazyValue(
          () => new HTTPBackgroundLogger(new LazyValue(defaultGetLogConn), loginParams)
        );
        this.resetLoginInfo();
        const memoryCache = new LRUCache({
          max: _nullishCoalesce(Number(isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_MEMORY_MAX")), () => ( 1 << 10))
        });
        const diskCache = canUseDiskCache() ? new DiskCache({
          cacheDir: _nullishCoalesce(isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_DIR"), () => ( `${_nullishCoalesce(isomorph_default.getEnv("HOME"), () => ( isomorph_default.homedir()))}/.braintrust/prompt_cache`)),
          max: _nullishCoalesce(Number(isomorph_default.getEnv("BRAINTRUST_PROMPT_CACHE_DISK_MAX")), () => ( 1 << 20))
        }) : void 0;
        this.promptCache = new PromptCache({ memoryCache, diskCache });
      }
      
      
      // Note: the value of IsAsyncFlush doesn't really matter here, since we
      // (safely) dynamically cast it whenever retrieving the logger.
      
      
      
      // Any time we re-log in, we directly update the apiConn inside the logger.
      // This is preferable to replacing the whole logger, which would create the
      // possibility of multiple loggers floating around, which may not log in a
      // deterministic order.
      
      __init8() {this._overrideBgLogger = null}
      __init9() {this.appUrl = null}
      __init10() {this.appPublicUrl = null}
      __init11() {this.loginToken = null}
      __init12() {this.orgId = null}
      __init13() {this.orgName = null}
      __init14() {this.apiUrl = null}
      __init15() {this.proxyUrl = null}
      __init16() {this.loggedIn = false}
      
      __init17() {this.fetch = globalThis.fetch}
      __init18() {this._appConn = null}
      __init19() {this._apiConn = null}
      __init20() {this._proxyConn = null}
      
      __init21() {this._idGenerator = null}
      __init22() {this._contextManager = null}
      resetLoginInfo() {
        this.appUrl = null;
        this.appPublicUrl = null;
        this.loginToken = null;
        this.orgId = null;
        this.orgName = null;
        this.apiUrl = null;
        this.proxyUrl = null;
        this.loggedIn = false;
        this.gitMetadataSettings = void 0;
        this._appConn = null;
        this._apiConn = null;
        this._proxyConn = null;
      }
      resetIdGenState() {
        this._idGenerator = null;
      }
      get idGenerator() {
        if (this._idGenerator === null) {
          this._idGenerator = getIdGenerator();
        }
        return this._idGenerator;
      }
      get contextManager() {
        if (this._contextManager === null) {
          this._contextManager = getContextManager();
        }
        return this._contextManager;
      }
      copyLoginInfo(other) {
        this.appUrl = other.appUrl;
        this.appPublicUrl = other.appPublicUrl;
        this.loginToken = other.loginToken;
        this.orgId = other.orgId;
        this.orgName = other.orgName;
        this.apiUrl = other.apiUrl;
        this.proxyUrl = other.proxyUrl;
        this.loggedIn = other.loggedIn;
        this.gitMetadataSettings = other.gitMetadataSettings;
        this._appConn = other._appConn;
        this._apiConn = other._apiConn;
        this.loginReplaceApiConn(this.apiConn());
        this._proxyConn = other._proxyConn;
      }
      serialize() {
        if (!this.loggedIn) {
          throw new Error(
            "Cannot serialize BraintrustState without being logged in"
          );
        }
        if (!this.appUrl || !this.appPublicUrl || !this.apiUrl || !this.proxyUrl || !this.orgName || !this.loginToken || !this.loggedIn) {
          throw new Error(
            "Cannot serialize BraintrustState without all login attributes"
          );
        }
        return {
          appUrl: this.appUrl,
          appPublicUrl: this.appPublicUrl,
          loginToken: this.loginToken,
          orgId: this.orgId,
          orgName: this.orgName,
          apiUrl: this.apiUrl,
          proxyUrl: this.proxyUrl,
          gitMetadataSettings: this.gitMetadataSettings
        };
      }
      static deserialize(serialized, opts) {
        const serializedParsed = loginSchema.safeParse(serialized);
        if (!serializedParsed.success) {
          throw new Error(
            `Cannot deserialize BraintrustState: ${serializedParsed.error.message}`
          );
        }
        const state = new _BraintrustState({ ...opts });
        for (const key of Object.keys(loginSchema.shape)) {
          state[key] = serializedParsed.data[key];
        }
        if (!state.loginToken) {
          throw new Error(
            "Cannot deserialize BraintrustState without a login token"
          );
        }
        state.apiConn().set_token(state.loginToken);
        state.apiConn().make_long_lived();
        state.appConn().set_token(state.loginToken);
        if (state.proxyUrl) {
          state.proxyConn().make_long_lived();
          state.proxyConn().set_token(state.loginToken);
        }
        state.loggedIn = true;
        state.loginReplaceApiConn(state.apiConn());
        return state;
      }
      setFetch(fetch2) {
        this.loginParams.fetch = fetch2;
        this.fetch = fetch2;
        _optionalChain([this, 'access', _67 => _67._apiConn, 'optionalAccess', _68 => _68.setFetch, 'call', _69 => _69(fetch2)]);
        _optionalChain([this, 'access', _70 => _70._appConn, 'optionalAccess', _71 => _71.setFetch, 'call', _72 => _72(fetch2)]);
      }
      setMaskingFunction(maskingFunction) {
        this.bgLogger().setMaskingFunction(maskingFunction);
      }
      async login(loginParams) {
        if (this.apiUrl && !loginParams.forceLogin) {
          return;
        }
        const newState = await loginToState({
          ...this.loginParams,
          ...Object.fromEntries(
            Object.entries(loginParams).filter(([k, v]) => !isEmpty(v))
          )
        });
        this.copyLoginInfo(newState);
      }
      appConn() {
        if (!this._appConn) {
          if (!this.appUrl) {
            throw new Error("Must initialize appUrl before requesting appConn");
          }
          this._appConn = new HTTPConnection(this.appUrl, this.fetch);
        }
        return this._appConn;
      }
      apiConn() {
        if (!this._apiConn) {
          if (!this.apiUrl) {
            throw new Error("Must initialize apiUrl before requesting apiConn");
          }
          this._apiConn = new HTTPConnection(this.apiUrl, this.fetch);
        }
        return this._apiConn;
      }
      proxyConn() {
        if (!this.proxyUrl) {
          return this.apiConn();
        }
        if (!this._proxyConn) {
          if (!this.proxyUrl) {
            throw new Error("Must initialize proxyUrl before requesting proxyConn");
          }
          this._proxyConn = new HTTPConnection(this.proxyUrl, this.fetch);
        }
        return this._proxyConn;
      }
      bgLogger() {
        if (this._overrideBgLogger) {
          return this._overrideBgLogger;
        }
        return this._bgLogger.get();
      }
      httpLogger() {
        return this._bgLogger.get();
      }
      setOverrideBgLogger(logger) {
        this._overrideBgLogger = logger;
      }
      // Should only be called by the login function.
      loginReplaceApiConn(apiConn) {
        this._bgLogger.get().internalReplaceApiConn(apiConn);
      }
      disable() {
        this._bgLogger.get().disable();
      }
      enforceQueueSizeLimit(enforce) {
        this._bgLogger.get().enforceQueueSizeLimit(enforce);
      }
      // Custom serialization to avoid logging sensitive data
      toJSON() {
        return {
          id: this.id,
          orgId: this.orgId,
          orgName: this.orgName,
          appUrl: this.appUrl,
          appPublicUrl: this.appPublicUrl,
          apiUrl: this.apiUrl,
          proxyUrl: this.proxyUrl,
          loggedIn: this.loggedIn
          // Explicitly exclude loginToken, _apiConn, _appConn, _proxyConn and other sensitive fields
        };
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `BraintrustState {
  id: '${this.id}',
  orgId: ${this.orgId ? `'${this.orgId}'` : "null"},
  orgName: ${this.orgName ? `'${this.orgName}'` : "null"},
  appUrl: ${this.appUrl ? `'${this.appUrl}'` : "null"},
  apiUrl: ${this.apiUrl ? `'${this.apiUrl}'` : "null"},
  proxyUrl: ${this.proxyUrl ? `'${this.proxyUrl}'` : "null"},
  loggedIn: ${this.loggedIn},
  loginToken: '[REDACTED]'
}`;
      }
      // Custom toString
      toString() {
        return `BraintrustState(id=${this.id}, org=${this.orgName || "none"}, loggedIn=${this.loggedIn})`;
      }
    }, _class5);
    _internalGetGlobalState = exports._internalGetGlobalState = () => _globalState;
    FailedHTTPResponse = exports.FailedHTTPResponse = class extends Error {
      
      
      
      constructor(status, text, data) {
        super(`${status}: ${text} (${data})`);
        this.status = status;
        this.text = text;
        this.data = data;
      }
    };
    HTTPConnection = class _HTTPConnection {
      
      
      
      
      constructor(base_url, fetch2) {
        this.base_url = base_url;
        this.token = null;
        this.headers = {};
        this._reset();
        this.fetch = fetch2;
      }
      setFetch(fetch2) {
        this.fetch = fetch2;
      }
      async ping() {
        try {
          const resp = await this.get("ping");
          return resp.status === 200;
        } catch (e) {
          return false;
        }
      }
      make_long_lived() {
        this._reset();
      }
      static sanitize_token(token) {
        return token.trim();
      }
      set_token(token) {
        token = _HTTPConnection.sanitize_token(token);
        this.token = token;
        this._reset();
      }
      // As far as I can tell, you cannot set the retry/backoff factor here
      _reset() {
        this.headers = {};
        if (this.token) {
          this.headers["Authorization"] = `Bearer ${this.token}`;
        }
      }
      async get(path3, params = void 0, config) {
        const { headers, ...rest } = config || {};
        const url = new URL(_urljoin(this.base_url, path3));
        url.search = new URLSearchParams(
          params ? Object.entries(params).filter(([_, v]) => v !== void 0).flatMap(
            ([k, v]) => v !== void 0 ? typeof v === "string" ? [[k, v]] : v.map((x) => [k, x]) : []
          ) : []
        ).toString();
        const this_fetch = this.fetch;
        const this_headers = this.headers;
        return await checkResponse(
          // Using toString() here makes it work with isomorphic fetch
          await this_fetch(url.toString(), {
            headers: {
              Accept: "application/json",
              ...this_headers,
              ...headers
            },
            keepalive: true,
            ...rest
          })
        );
      }
      async post(path3, params, config) {
        const { headers, ...rest } = config || {};
        const this_fetch = this.fetch;
        const this_base_url = this.base_url;
        const this_headers = this.headers;
        return await checkResponse(
          await this_fetch(_urljoin(this_base_url, path3), {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              ...this_headers,
              ...headers
            },
            body: typeof params === "string" ? params : params ? JSON.stringify(params) : void 0,
            keepalive: true,
            ...rest
          })
        );
      }
      async get_json(object_type, args = void 0, retries = 0) {
        const tries = retries + 1;
        for (let i = 0; i < tries; i++) {
          try {
            const resp = await this.get(`${object_type}`, args);
            return await resp.json();
          } catch (e) {
            if (i < tries - 1) {
              console.log(
                `Retrying API request ${object_type} ${JSON.stringify(args)} ${e.status} ${e.text}`
              );
              continue;
            }
            throw e;
          }
        }
      }
      async post_json(object_type, args = void 0) {
        const resp = await this.post(`${object_type}`, args, {
          headers: { "Content-Type": "application/json" }
        });
        return await resp.json();
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `HTTPConnection {
  base_url: '${this.base_url}',
  token: '[REDACTED]'
}`;
      }
      // Custom toString
      toString() {
        return `HTTPConnection(${this.base_url})`;
      }
    };
    BaseAttachment = exports.BaseAttachment = class {
      
    };
    Attachment = exports.Attachment = class extends BaseAttachment {
      /**
       * The object that replaces this `Attachment` at upload time.
       */
      
      
      
      
      // For debug logging only.
      
      /**
       * Construct an attachment.
       *
       * @param param A parameter object with:
       *
       * `data`: A string representing the path of the file on disk, or a
       * `Blob`/`ArrayBuffer` with the file's contents. The caller is responsible
       * for ensuring the file/blob/buffer is not modified until upload is complete.
       *
       * `filename`: The desired name of the file in Braintrust after uploading.
       * This parameter is for visualization purposes only and has no effect on
       * attachment storage.
       *
       * `contentType`: The MIME type of the file.
       *
       * `state`: (Optional) For internal use.
       */
      constructor({ data, filename, contentType, state }) {
        super();
        this.reference = {
          type: BRAINTRUST_ATTACHMENT,
          filename,
          content_type: contentType,
          key: newId()
        };
        this.state = state;
        this.dataDebugString = typeof data === "string" ? data : "<in-memory data>";
        this._data = this.initData(data);
        this.uploader = this.initUploader();
      }
      /**
       * On first access, (1) reads the attachment from disk if needed, (2)
       * authenticates with the data plane to request a signed URL, (3) uploads to
       * object store, and (4) updates the attachment.
       *
       * @returns The attachment status.
       */
      async upload() {
        return await this.uploader.get();
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment contents from disk or memory on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * A human-readable description for logging and debugging.
       *
       * @returns The debug object. The return type is not stable and may change in
       * a future release.
       */
      debugInfo() {
        return {
          inputData: this.dataDebugString,
          reference: this.reference,
          state: this.state
        };
      }
      initUploader() {
        const doUpload = async (conn, orgId) => {
          const requestParams = {
            key: this.reference.key,
            filename: this.reference.filename,
            content_type: this.reference.content_type,
            org_id: orgId
          };
          const [metadataPromiseResult, dataPromiseResult] = await Promise.allSettled([
            conn.post("/attachment", requestParams),
            this._data.get()
          ]);
          if (metadataPromiseResult.status === "rejected") {
            const errorStr = JSON.stringify(metadataPromiseResult.reason);
            throw new Error(
              `Failed to request signed URL from API server: ${errorStr}`
            );
          }
          if (dataPromiseResult.status === "rejected") {
            const errorStr = JSON.stringify(dataPromiseResult.reason);
            throw new Error(`Failed to read file: ${errorStr}`);
          }
          const metadataResponse = metadataPromiseResult.value;
          const data = dataPromiseResult.value;
          let signedUrl;
          let headers;
          try {
            ({ signedUrl, headers } = _v3.z.object({
              signedUrl: _v3.z.string().url(),
              headers: _v3.z.record(_v3.z.string())
            }).parse(await metadataResponse.json()));
          } catch (error2) {
            if (error2 instanceof _v3.ZodError) {
              const errorStr = JSON.stringify(error2.flatten());
              throw new Error(`Invalid response from API server: ${errorStr}`);
            }
            throw error2;
          }
          addAzureBlobHeaders(headers, signedUrl);
          let objectStoreResponse;
          try {
            objectStoreResponse = await checkResponse(
              await fetch(signedUrl, {
                method: "PUT",
                headers,
                body: data
              })
            );
          } catch (error2) {
            if (error2 instanceof FailedHTTPResponse) {
              throw new Error(
                `Failed to upload attachment to object store: ${error2.status} ${error2.text} ${error2.data}`
              );
            }
            throw error2;
          }
          return { signedUrl, metadataResponse, objectStoreResponse };
        };
        const errorWrapper = async () => {
          const status = { upload_status: "done" };
          const state = _nullishCoalesce(this.state, () => ( _globalState));
          await state.login({});
          const conn = state.apiConn();
          const orgId = _nullishCoalesce(state.orgId, () => ( ""));
          try {
            await doUpload(conn, orgId);
          } catch (error2) {
            status.upload_status = "error";
            status.error_message = error2 instanceof Error ? error2.message : JSON.stringify(error2);
          }
          const requestParams = {
            key: this.reference.key,
            org_id: orgId,
            status
          };
          const statusResponse = await conn.post(
            "/attachment/status",
            requestParams
          );
          if (!statusResponse.ok) {
            const errorStr = JSON.stringify(statusResponse);
            throw new Error(`Couldn't log attachment status: ${errorStr}`);
          }
          return status;
        };
        return new LazyValue(errorWrapper);
      }
      initData(data) {
        if (typeof data === "string") {
          this.ensureFileReadable(data);
          const readFile2 = isomorph_default.readFile;
          if (!readFile2) {
            throw new Error(
              `This platform does not support reading the filesystem. Construct the Attachment
with a Blob/ArrayBuffer, or run the program on Node.js.`
            );
          }
          return new LazyValue(async () => new Blob([await readFile2(data)]));
        } else {
          return new LazyValue(async () => new Blob([data]));
        }
      }
      ensureFileReadable(data) {
        const statSync2 = isomorph_default.statSync;
        if (!statSync2) {
          throw new Error(
            `This platform does not support reading the filesystem. Construct the Attachment
with a Blob/ArrayBuffer, or run the program on Node.js.`
          );
        }
        try {
          statSync2(data);
        } catch (e) {
          console.warn(`Failed to read file: ${e}`);
        }
      }
    };
    ExternalAttachment = exports.ExternalAttachment = class extends BaseAttachment {
      /**
       * The object that replaces this `ExternalAttachment` at upload time.
       */
      
      
      
      /**
       * Construct an external attachment.
       *
       * @param param A parameter object with:
       *
       * `url`: The fully qualified URL of the file in the external object store.
       *
       * `filename`: The desired name of the file in Braintrust after uploading.
       * This parameter is for visualization purposes only and has no effect on
       * attachment storage.
       *
       * `contentType`: The MIME type of the file.
       *
       * `state`: (Optional) For internal use.
       */
      constructor({ url, filename, contentType, state }) {
        super();
        this.reference = {
          type: EXTERNAL_ATTACHMENT,
          filename,
          content_type: contentType,
          url
        };
        this._data = this.initData();
      }
      /**
       * For ExternalAttachment, this is a no-op since the data already resides
       * in the external object store. It marks the attachment as already uploaded.
       *
       * @returns The attachment status, which will always indicate success.
       */
      async upload() {
        return { upload_status: "done" };
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment contents from the external object store on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * A human-readable description for logging and debugging.
       *
       * @returns The debug object. The return type is not stable and may change in
       * a future release.
       */
      debugInfo() {
        return {
          url: this.reference.url,
          reference: this.reference,
          state: this.state
        };
      }
      initData() {
        return new LazyValue(async () => {
          const readonly = new ReadonlyAttachment(this.reference, this.state);
          return await readonly.data();
        });
      }
    };
    attachmentMetadataSchema = _v3.z.object({
      downloadUrl: _v3.z.string(),
      status: AttachmentStatus
    });
    ReadonlyAttachment = exports.ReadonlyAttachment = class {
      /**
       * Attachment metadata.
       */
      
      
      
      /**
       * Construct a ReadonlyAttachment.
       *
       * @param reference The `AttachmentReference` that should be read by the
       * `ReadonlyAttachment` object.
       * @param state (Optional) For internal use.
       * @returns The new `ReadonlyAttachment` object.
       */
      constructor(reference, state) {
        this.reference = reference;
        this.state = state;
        this._data = this.initDownloader();
      }
      /**
       * The attachment contents. This is a lazy value that will read the attachment
       * contents from the object store on first access.
       */
      async data() {
        return this._data.get();
      }
      /**
       * Returns the attachment contents as a base64-encoded URL that is suitable
       * for use in a prompt.
       *
       * @returns The attachment contents as a base64-encoded URL.
       */
      async asBase64Url() {
        const buf = await (await this.data()).arrayBuffer();
        const base64 = Buffer.from(buf).toString("base64");
        return `data:${this.reference.content_type};base64,${base64}`;
      }
      /**
       * Fetch the attachment metadata, which includes a downloadUrl and a status.
       * This will re-fetch the status each time in case it changes over time.
       */
      async metadata() {
        const state = _nullishCoalesce(this.state, () => ( _globalState));
        await state.login({});
        const params = {
          filename: this.reference.filename,
          content_type: this.reference.content_type,
          org_id: state.orgId || ""
        };
        if (this.reference.type === "braintrust_attachment") {
          params.key = this.reference.key;
        } else if (this.reference.type === "external_attachment") {
          params.url = this.reference.url;
        }
        const resp = await state.apiConn().get("/attachment", params);
        if (!resp.ok) {
          const errorStr = JSON.stringify(resp);
          throw new Error(`Invalid response from API server: ${errorStr}`);
        }
        return attachmentMetadataSchema.parse(await resp.json());
      }
      /**
       * Fetch the attachment upload status. This will re-fetch the status each time
       * in case it changes over time.
       */
      async status() {
        return (await this.metadata()).status;
      }
      initDownloader() {
        const download = async () => {
          const { downloadUrl, status } = await this.metadata();
          if (status.upload_status !== "done") {
            throw new Error(
              `Expected attachment status "done", got "${status.upload_status}"`
            );
          }
          const objResponse = await fetch(downloadUrl);
          if (objResponse.status !== 200) {
            const error2 = await objResponse.text();
            throw new Error(`Couldn't download attachment: ${error2}`);
          }
          return await objResponse.blob();
        };
        return new LazyValue(download);
      }
    };
    JSONAttachment = exports.JSONAttachment = class extends Attachment {
      /**
       * Construct a JSONAttachment from a JSON-serializable object.
       *
       * @param data The JSON object to attach. Must be JSON-serializable.
       * @param options Additional options:
       * - `filename`: The filename for the attachment (defaults to "data.json")
       * - `pretty`: Whether to pretty-print the JSON (defaults to false)
       * - `state`: (Optional) For internal use.
       *
       * @example
       * ```typescript
       * const largeTranscript = [
       *   { role: "user", content: "..." },
       *   { role: "assistant", content: "..." },
       *   // ... many more messages
       * ];
       *
       * logger.log({
       *   input: {
       *     type: "chat",
       *     transcript: new JSONAttachment(largeTranscript, { filename: "transcript.json" })
       *   }
       * });
       * ```
       */
      constructor(data, options) {
        const { filename = "data.json", pretty = false, state } = _nullishCoalesce(options, () => ( {}));
        const jsonString = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
        const blob = new Blob([jsonString], { type: "application/json" });
        super({
          data: blob,
          filename,
          contentType: "application/json",
          state
        });
      }
    };
    ERR_PERMALINK = exports.ERR_PERMALINK = "https://braintrust.dev/error-generating-link";
    Logger = exports.Logger = (_class6 = class {
      
      
      
      
      
      
      
      // For type identification.
      __init23() {this.kind = "logger"}
      constructor(state, lazyMetadata, logOptions = {}) {;_class6.prototype.__init23.call(this);
        this.lazyMetadata = lazyMetadata;
        this._asyncFlush = logOptions.asyncFlush;
        this.computeMetadataArgs = logOptions.computeMetadataArgs;
        this.lastStartTime = getCurrentUnixTimestamp();
        this.lazyId = new LazyValue(async () => await this.id);
        this.calledStartSpan = false;
        this.state = state;
      }
      get org_id() {
        return (async () => {
          return (await this.lazyMetadata.get()).org_id;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      get id() {
        return (async () => (await this.project).id)();
      }
      get loggingState() {
        return this.state;
      }
      parentObjectType() {
        return 2 /* PROJECT_LOGS */;
      }
      /**
       * Log a single event. The event will be batched and uploaded behind the scenes if `logOptions.asyncFlush` is true.
       *
       * @param event The event to log.
       * @param event.input: (Optional) the arguments that uniquely define a user input (an arbitrary, JSON serializable object).
       * @param event.output: (Optional) the output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
       * @param event.expected: (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
       * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
       * @param event.scores: (Optional) a dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs.
       * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
       * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
       * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
       * @param options Additional logging options
       * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the logger elsewhere, set this to true.
       * @returns The `id` of the logged event.
       */
      log(event, options) {
        if (this.calledStartSpan && !_optionalChain([options, 'optionalAccess', _73 => _73.allowConcurrentWithSpans])) {
          throw new Error(
            "Cannot run toplevel `log` method while using spans. To log to the span, call `logger.traced` and then log with `span.log`"
          );
        }
        const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
        this.lastStartTime = span.end();
        const ret = span.id;
        if (this.asyncFlush === true) {
          return ret;
        } else {
          return (async () => {
            await this.flush();
            return ret;
          })();
        }
      }
      /**
       * Create a new toplevel span underneath the logger. The name defaults to "root".
       *
       * See {@link Span.traced} for full details.
       */
      traced(callback, args) {
        const { setCurrent, ...argsRest } = _nullishCoalesce(args, () => ( {}));
        const span = this.startSpan(argsRest);
        const ret = runCatchFinally(
          () => {
            if (_nullishCoalesce(setCurrent, () => ( true))) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
        if (this.asyncFlush) {
          return ret;
        } else {
          return (async () => {
            const awaitedRet = await ret;
            await this.flush();
            return awaitedRet;
          })();
        }
      }
      /**
       * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
       * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
       * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
       *
       * See {@link traced} for full details.
       */
      startSpan(args) {
        this.calledStartSpan = true;
        return this.startSpanImpl(args);
      }
      startSpanImpl(args) {
        return new SpanImpl({
          ...args,
          // Sometimes `args` gets passed directly into this function, and it contains an undefined value for `state`.
          // To ensure that we always use this logger's state, we override the `state` argument no matter what.
          state: this.state,
          ...startSpanParentArgs({
            state: this.state,
            parent: _optionalChain([args, 'optionalAccess', _74 => _74.parent]),
            parentObjectType: this.parentObjectType(),
            parentObjectId: this.lazyId,
            parentComputeObjectMetadataArgs: this.computeMetadataArgs,
            parentSpanIds: _optionalChain([args, 'optionalAccess', _75 => _75.parentSpanIds]),
            propagatedEvent: _optionalChain([args, 'optionalAccess', _76 => _76.propagatedEvent])
          }),
          defaultRootType: "task" /* TASK */
        });
      }
      /**
       * Log feedback to an event. Feedback is used to save feedback scores, set an expected value, or add a comment.
       *
       * @param event
       * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
       * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
       * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
       * @param event.comment (Optional) an optional comment string to log about the event.
       * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
       * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
       */
      logFeedback(event) {
        logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
      }
      /**
       * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
       * since otherwise updates to the span may conflict with the original span.
       *
       * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
       */
      updateSpan(event) {
        const { id, ...eventRest } = event;
        if (!id) {
          throw new Error("Span id is required to update a span");
        }
        updateSpanImpl({
          state: this.state,
          parentObjectType: this.parentObjectType(),
          parentObjectId: this.lazyId,
          id,
          event: eventRest
        });
      }
      /**
       * Return a serialized representation of the logger that can be used to start subspans in other places.
       *
       * See {@link Span.startSpan} for more details.
       */
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType(),
          ...this.computeMetadataArgs && !this.lazyId.hasSucceeded ? { compute_object_metadata_args: this.computeMetadataArgs } : { object_id: await this.lazyId.get() }
        }).toStr();
      }
      /*
       * Flush any pending logs to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      get asyncFlush() {
        return this._asyncFlush;
      }
    }, _class6);
    TestBackgroundLogger = exports.TestBackgroundLogger = (_class7 = class {constructor() { _class7.prototype.__init24.call(this);_class7.prototype.__init25.call(this); }
      __init24() {this.items = []}
      __init25() {this.maskingFunction = null}
      log(items) {
        this.items.push(items);
      }
      setMaskingFunction(maskingFunction) {
        this.maskingFunction = maskingFunction;
      }
      async flush() {
        return Promise.resolve();
      }
      async drain() {
        const items = this.items;
        this.items = [];
        const events = [];
        for (const item of items) {
          for (const event of item) {
            events.push(await event.get());
          }
        }
        const batch = mergeRowBatch(events);
        let flatBatch = batch.flat();
        if (this.maskingFunction) {
          flatBatch = flatBatch.map((item) => {
            const maskedItem = { ...item };
            for (const field of REDACTION_FIELDS) {
              if (item[field] !== void 0) {
                const maskedValue = applyMaskingToField(
                  this.maskingFunction,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  item[field],
                  field
                );
                if (maskedValue instanceof MaskingError) {
                  delete maskedItem[field];
                  if (maskedItem.error) {
                    maskedItem.error = `${maskedItem.error}; ${maskedValue.errorMsg}`;
                  } else {
                    maskedItem.error = maskedValue.errorMsg;
                  }
                } else {
                  maskedItem[field] = maskedValue;
                }
              }
            }
            return maskedItem;
          });
        }
        return flatBatch;
      }
    }, _class7);
    BACKGROUND_LOGGER_BASE_SLEEP_TIME_S = 1;
    HTTPBackgroundLogger = (_class8 = class _HTTPBackgroundLogger {
      
      
      __init26() {this.activeFlush = Promise.resolve()}
      __init27() {this.activeFlushResolved = true}
      __init28() {this.activeFlushError = void 0}
      
      __init29() {this.maskingFunction = null}
      __init30() {this.syncFlush = false}
      // 6 MB for the AWS lambda gateway (from our own testing).
      __init31() {this.maxRequestSize = 6 * 1024 * 1024}
      __init32() {this.defaultBatchSize = 100}
      __init33() {this.numTries = 3}
      __init34() {this.queueDropExceedingMaxsize = DEFAULT_QUEUE_SIZE}
      __init35() {this.queueDropLoggingPeriod = 60}
      __init36() {this.failedPublishPayloadsDir = void 0}
      __init37() {this.allPublishPayloadsDir = void 0}
      __init38() {this._disabled = false}
      __init39() {this.queueDropLoggingState = {
        numDropped: 0,
        lastLoggedTimestamp: 0
      }}
      constructor(apiConn, opts) {;_class8.prototype.__init26.call(this);_class8.prototype.__init27.call(this);_class8.prototype.__init28.call(this);_class8.prototype.__init29.call(this);_class8.prototype.__init30.call(this);_class8.prototype.__init31.call(this);_class8.prototype.__init32.call(this);_class8.prototype.__init33.call(this);_class8.prototype.__init34.call(this);_class8.prototype.__init35.call(this);_class8.prototype.__init36.call(this);_class8.prototype.__init37.call(this);_class8.prototype.__init38.call(this);_class8.prototype.__init39.call(this);
        opts = _nullishCoalesce(opts, () => ( {}));
        this.apiConn = apiConn;
        const syncFlushEnv = Number(isomorph_default.getEnv("BRAINTRUST_SYNC_FLUSH"));
        if (!isNaN(syncFlushEnv)) {
          this.syncFlush = Boolean(syncFlushEnv);
        }
        const defaultBatchSizeEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_DEFAULT_BATCH_SIZE")
        );
        if (!isNaN(defaultBatchSizeEnv)) {
          this.defaultBatchSize = defaultBatchSizeEnv;
        }
        const maxRequestSizeEnv = Number(isomorph_default.getEnv("BRAINTRUST_MAX_REQUEST_SIZE"));
        if (!isNaN(maxRequestSizeEnv)) {
          this.maxRequestSize = maxRequestSizeEnv;
        }
        const numTriesEnv = Number(isomorph_default.getEnv("BRAINTRUST_NUM_RETRIES"));
        if (!isNaN(numTriesEnv)) {
          this.numTries = numTriesEnv + 1;
        }
        const queueDropExceedingMaxsizeEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_EXCEEDING_MAXSIZE")
        );
        if (!isNaN(queueDropExceedingMaxsizeEnv)) {
          this.queueDropExceedingMaxsize = queueDropExceedingMaxsizeEnv;
        }
        this.queue = new Queue(this.queueDropExceedingMaxsize);
        const queueDropLoggingPeriodEnv = Number(
          isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_LOGGING_PERIOD")
        );
        if (!isNaN(queueDropLoggingPeriodEnv)) {
          this.queueDropLoggingPeriod = queueDropLoggingPeriodEnv;
        }
        const failedPublishPayloadsDirEnv = isomorph_default.getEnv(
          "BRAINTRUST_FAILED_PUBLISH_PAYLOADS_DIR"
        );
        if (failedPublishPayloadsDirEnv) {
          this.failedPublishPayloadsDir = failedPublishPayloadsDirEnv;
        }
        const allPublishPayloadsDirEnv = isomorph_default.getEnv(
          "BRAINTRUST_ALL_PUBLISH_PAYLOADS_DIR"
        );
        if (allPublishPayloadsDirEnv) {
          this.allPublishPayloadsDir = allPublishPayloadsDirEnv;
        }
        if (!opts.noExitFlush) {
          isomorph_default.processOn("beforeExit", async () => {
            await this.flush();
          });
        }
        this.onFlushError = opts.onFlushError;
      }
      setMaskingFunction(maskingFunction) {
        this.maskingFunction = maskingFunction;
      }
      log(items) {
        if (this._disabled) {
          return;
        }
        const droppedItems = this.queue.push(...items);
        if (!this.syncFlush) {
          this.triggerActiveFlush();
        }
        if (droppedItems.length) {
          this.registerDroppedItemCount(droppedItems.length);
          if (this.allPublishPayloadsDir || this.failedPublishPayloadsDir) {
            this.dumpDroppedEvents(droppedItems);
          }
        }
      }
      async flush() {
        if (this.syncFlush) {
          this.triggerActiveFlush();
        }
        await this.activeFlush;
        if (this.activeFlushError) {
          const err = this.activeFlushError;
          this.activeFlushError = void 0;
          if (this.syncFlush) {
            throw err;
          }
        }
      }
      async flushOnce(args) {
        if (this._disabled) {
          this.queue.clear();
          return;
        }
        const batchSize = _nullishCoalesce(_optionalChain([args, 'optionalAccess', _77 => _77.batchSize]), () => ( this.defaultBatchSize));
        const wrappedItems = this.queue.drain();
        const [allItems, attachments] = await this.unwrapLazyValues(wrappedItems);
        if (allItems.length === 0) {
          return;
        }
        const allItemsStr = allItems.map(
          (bucket) => bucket.map((item) => JSON.stringify(item))
        );
        const batchSets = batchItems({
          items: allItemsStr,
          batchMaxNumItems: batchSize,
          batchMaxNumBytes: this.maxRequestSize / 2
        });
        for (const batchSet of batchSets) {
          const postPromises = batchSet.map(
            (batch) => (async () => {
              try {
                await this.submitLogsRequest(batch);
                return { type: "success" };
              } catch (e) {
                return { type: "error", value: e };
              }
            })()
          );
          const results = await Promise.all(postPromises);
          const failingResultErrors = results.map((r) => r.type === "success" ? void 0 : r.value).filter((r) => r !== void 0);
          if (failingResultErrors.length) {
            throw new AggregateError(
              failingResultErrors,
              `Encountered the following errors while logging:`
            );
          }
        }
        const attachmentErrors = [];
        for (const attachment of attachments) {
          try {
            const result = await attachment.upload();
            if (result.upload_status === "error") {
              throw new Error(result.error_message);
            }
          } catch (error2) {
            attachmentErrors.push(error2);
          }
        }
        if (attachmentErrors.length === 1) {
          throw attachmentErrors[0];
        } else if (attachmentErrors.length > 1) {
          throw new AggregateError(
            attachmentErrors,
            `Encountered the following errors while uploading attachments:`
          );
        }
        if (this.queue.length() > 0) {
          await this.flushOnce(args);
        }
      }
      async unwrapLazyValues(wrappedItems) {
        for (let i = 0; i < this.numTries; ++i) {
          try {
            const items = await Promise.all(wrappedItems.map((x) => x.get()));
            const attachments = [];
            items.forEach((item) => extractAttachments(item, attachments));
            let mergedItems = mergeRowBatch(items);
            if (this.maskingFunction) {
              mergedItems = mergedItems.map(
                (batch) => batch.map((item) => {
                  const maskedItem = { ...item };
                  for (const field of REDACTION_FIELDS) {
                    if (item[field] !== void 0) {
                      const maskedValue = applyMaskingToField(
                        this.maskingFunction,
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        item[field],
                        field
                      );
                      if (maskedValue instanceof MaskingError) {
                        delete maskedItem[field];
                        if (maskedItem.error) {
                          maskedItem.error = `${maskedItem.error}; ${maskedValue.errorMsg}`;
                        } else {
                          maskedItem.error = maskedValue.errorMsg;
                        }
                      } else {
                        maskedItem[field] = maskedValue;
                      }
                    }
                  }
                  return maskedItem;
                })
              );
            }
            return [mergedItems, attachments];
          } catch (e) {
            let errmsg = "Encountered error when constructing records to flush";
            const isRetrying = i + 1 < this.numTries;
            if (isRetrying) {
              errmsg += ". Retrying";
            }
            console.warn(errmsg);
            if (!isRetrying) {
              console.warn(
                `Failed to construct log records to flush after ${this.numTries} attempts. Dropping batch`
              );
              throw e;
            } else {
              console.warn(e);
              const sleepTimeS = BACKGROUND_LOGGER_BASE_SLEEP_TIME_S * 2 ** i;
              console.info(`Sleeping for ${sleepTimeS}s`);
              await new Promise(
                (resolve) => setTimeout(resolve, sleepTimeS * 1e3)
              );
            }
          }
        }
        throw new Error("Impossible");
      }
      async submitLogsRequest(items) {
        const conn = await this.apiConn.get();
        const dataStr = constructLogs3Data(items);
        if (this.allPublishPayloadsDir) {
          await _HTTPBackgroundLogger.writePayloadToDir({
            payloadDir: this.allPublishPayloadsDir,
            payload: dataStr
          });
        }
        for (let i = 0; i < this.numTries; i++) {
          const startTime = now();
          let error2 = void 0;
          try {
            await conn.post_json("logs3", dataStr);
          } catch (e) {
            error2 = e;
          }
          if (error2 === void 0) {
            return;
          }
          const isRetrying = i + 1 < this.numTries;
          const retryingText = isRetrying ? "" : " Retrying";
          const errorText = (() => {
            if (error2 instanceof FailedHTTPResponse) {
              return `${error2.status} (${error2.text}): ${error2.data}`;
            } else {
              return `${error2}`;
            }
          })();
          const errMsg = `log request failed. Elapsed time: ${(now() - startTime) / 1e3} seconds. Payload size: ${dataStr.length}.${retryingText}
Error: ${errorText}`;
          if (!isRetrying && this.failedPublishPayloadsDir) {
            await _HTTPBackgroundLogger.writePayloadToDir({
              payloadDir: this.failedPublishPayloadsDir,
              payload: dataStr
            });
            this.logFailedPayloadsDir();
          }
          if (!isRetrying) {
            console.warn(
              `log request failed after ${this.numTries} retries. Dropping batch`
            );
            throw new Error(errMsg);
          } else {
            console.warn(errMsg);
            if (isRetrying) {
              const sleepTimeS = BACKGROUND_LOGGER_BASE_SLEEP_TIME_S * 2 ** i;
              console.info(`Sleeping for ${sleepTimeS}s`);
              await new Promise(
                (resolve) => setTimeout(resolve, sleepTimeS * 1e3)
              );
            }
          }
        }
      }
      registerDroppedItemCount(numItems) {
        if (numItems <= 0) {
          return;
        }
        this.queueDropLoggingState.numDropped += numItems;
        const timeNow = getCurrentUnixTimestamp();
        if (timeNow - this.queueDropLoggingState.lastLoggedTimestamp > this.queueDropLoggingPeriod) {
          console.warn(
            `Dropped ${this.queueDropLoggingState.numDropped} elements due to full queue`
          );
          if (this.failedPublishPayloadsDir) {
            this.logFailedPayloadsDir();
          }
          this.queueDropLoggingState.numDropped = 0;
          this.queueDropLoggingState.lastLoggedTimestamp = timeNow;
        }
      }
      async dumpDroppedEvents(wrappedItems) {
        const publishPayloadsDir = [
          this.allPublishPayloadsDir,
          this.failedPublishPayloadsDir
        ].reduce((acc, x) => x ? acc.concat([x]) : acc, new Array());
        if (!(wrappedItems.length && publishPayloadsDir.length)) {
          return;
        }
        try {
          const [allItems, allAttachments] = await this.unwrapLazyValues(wrappedItems);
          const dataStr = constructLogs3Data(
            allItems.map((x) => JSON.stringify(x))
          );
          const attachmentStr = JSON.stringify(
            allAttachments.map((a) => a.debugInfo())
          );
          const payload = `{"data": ${dataStr}, "attachments": ${attachmentStr}}
`;
          for (const payloadDir of publishPayloadsDir) {
            await _HTTPBackgroundLogger.writePayloadToDir({ payloadDir, payload });
          }
        } catch (e) {
          console.error(e);
        }
      }
      static async writePayloadToDir({
        payloadDir,
        payload
      }) {
        if (!(isomorph_default.pathJoin && isomorph_default.mkdir && isomorph_default.writeFile)) {
          console.warn(
            "Cannot dump payloads: filesystem-operations not supported on this platform"
          );
          return;
        }
        const payloadFile = isomorph_default.pathJoin(
          payloadDir,
          `payload_${getCurrentUnixTimestamp()}_${_uuid.v4.call(void 0, ).slice(0, 8)}.json`
        );
        try {
          await isomorph_default.mkdir(payloadDir, { recursive: true });
          await isomorph_default.writeFile(payloadFile, payload);
        } catch (e) {
          console.error(
            `Failed to write failed payload to output file ${payloadFile}:
`,
            e
          );
        }
      }
      triggerActiveFlush() {
        if (this.activeFlushResolved) {
          this.activeFlushResolved = false;
          this.activeFlushError = void 0;
          this.activeFlush = (async () => {
            try {
              await this.flushOnce();
            } catch (err) {
              if (err instanceof AggregateError) {
                for (const e of err.errors) {
                  _optionalChain([this, 'access', _78 => _78.onFlushError, 'optionalCall', _79 => _79(e)]);
                }
              } else {
                _optionalChain([this, 'access', _80 => _80.onFlushError, 'optionalCall', _81 => _81(err)]);
              }
              this.activeFlushError = err;
            } finally {
              this.activeFlushResolved = true;
            }
          })();
          _functions.waitUntil.call(void 0, this.activeFlush);
        }
      }
      logFailedPayloadsDir() {
        console.warn(`Logging failed payloads to ${this.failedPublishPayloadsDir}`);
      }
      // Should only be called by BraintrustState.
      internalReplaceApiConn(apiConn) {
        this.apiConn = new LazyValue(async () => apiConn);
      }
      disable() {
        this._disabled = true;
      }
      enforceQueueSizeLimit(enforce) {
        this.queue.enforceQueueSizeLimit(enforce);
      }
    }, _class8);
    traceable = exports.traceable = wrapTraced;
    INTERNAL_BTQL_LIMIT = exports.INTERNAL_BTQL_LIMIT = 1e3;
    MAX_BTQL_ITERATIONS = 1e4;
    ObjectFetcher = (_class9 = class {
      constructor(objectType, pinnedVersion, mutateRecord, _internal_btql) {;_class9.prototype.__init40.call(this);
        this.objectType = objectType;
        this.pinnedVersion = pinnedVersion;
        this.mutateRecord = mutateRecord;
        this._internal_btql = _internal_btql;
      }
      __init40() {this._fetchedData = void 0}
      get id() {
        throw new Error("ObjectFetcher subclasses must have an 'id' attribute");
      }
      async getState() {
        throw new Error("ObjectFetcher subclasses must have a 'getState' method");
      }
      async *fetch() {
        const records = await this.fetchedData();
        for (const record of records) {
          yield record;
        }
      }
      [Symbol.asyncIterator]() {
        return this.fetch();
      }
      async fetchedData() {
        if (this._fetchedData === void 0) {
          const state = await this.getState();
          let data = void 0;
          let cursor = void 0;
          let iterations = 0;
          while (true) {
            const resp = await state.apiConn().post(
              `btql`,
              {
                query: {
                  ...this._internal_btql,
                  select: [
                    {
                      op: "star"
                    }
                  ],
                  from: {
                    op: "function",
                    name: {
                      op: "ident",
                      name: [this.objectType]
                    },
                    args: [
                      {
                        op: "literal",
                        value: await this.id
                      }
                    ]
                  },
                  cursor,
                  limit: INTERNAL_BTQL_LIMIT
                },
                use_columnstore: false,
                brainstore_realtime: true,
                ...this.pinnedVersion !== void 0 ? {
                  version: this.pinnedVersion
                } : {}
              },
              { headers: { "Accept-Encoding": "gzip" } }
            );
            const respJson = await resp.json();
            data = (_nullishCoalesce(data, () => ( []))).concat(respJson.data);
            if (!respJson.cursor) {
              break;
            }
            cursor = respJson.cursor;
            iterations++;
            if (iterations > MAX_BTQL_ITERATIONS) {
              throw new Error("Too many BTQL iterations");
            }
          }
          this._fetchedData = this.mutateRecord ? _optionalChain([data, 'optionalAccess', _82 => _82.map, 'call', _83 => _83(this.mutateRecord)]) : data;
        }
        return this._fetchedData || [];
      }
      clearCache() {
        this._fetchedData = void 0;
      }
      async version() {
        if (this.pinnedVersion !== void 0) {
          return this.pinnedVersion;
        } else {
          const fetchedData = await this.fetchedData();
          let maxVersion = void 0;
          for (const record of fetchedData) {
            const xactId = String(_nullishCoalesce(record[TRANSACTION_ID_FIELD], () => ( "0")));
            if (maxVersion === void 0 || xactId > maxVersion) {
              maxVersion = xactId;
            }
          }
          return maxVersion;
        }
      }
    }, _class9);
    Experiment2 = exports.Experiment = (_class10 = class extends ObjectFetcher {
      
      
      
      
      
      
      // For type identification.
      __init41() {this.kind = "experiment"}
      constructor(state, lazyMetadata, dataset) {
        super("experiment", void 0, (r) => enrichAttachments(r, state));_class10.prototype.__init41.call(this);;
        this.lazyMetadata = lazyMetadata;
        this.dataset = dataset;
        this.lastStartTime = getCurrentUnixTimestamp();
        this.lazyId = new LazyValue(async () => await this.id);
        this.calledStartSpan = false;
        this.state = state;
      }
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.id;
        })();
      }
      get loggingState() {
        return this.state;
      }
      /**
       * Wait for the experiment ID to be resolved. This is useful for ensuring the ID
       * is available synchronously in child spans (for OTEL parent attributes).
       * @internal
       */
      async _waitForId() {
        await this.lazyId.get().catch(() => {
        });
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.name;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      parentObjectType() {
        return 1 /* EXPERIMENT */;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      /**
       * Log a single event to the experiment. The event will be batched and uploaded behind the scenes.
       *
       * @param event The event to log.
       * @param event.input: The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical.
       * @param event.output: The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
       * @param event.expected: (Optional) The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
       * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
       * @param event.scores: A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments.
       * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
       * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
       * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
       * @param event.dataset_record_id: (Optional) the id of the dataset record that this event is associated with. This field is required if and only if the experiment is associated with a dataset. This field is unused and will be removed in a future version.
       * @param options Additional logging options
       * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the experiment elsewhere, set this to true.
       * @returns The `id` of the logged event.
       */
      log(event, options) {
        if (this.calledStartSpan && !_optionalChain([options, 'optionalAccess', _84 => _84.allowConcurrentWithSpans])) {
          throw new Error(
            "Cannot run toplevel `log` method while using spans. To log to the span, call `experiment.traced` and then log with `span.log`"
          );
        }
        event = validateAndSanitizeExperimentLogFullArgs(event, !!this.dataset);
        const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
        this.lastStartTime = span.end();
        return span.id;
      }
      /**
       * Create a new toplevel span underneath the experiment. The name defaults to "root".
       *
       * See {@link Span.traced} for full details.
       */
      traced(callback, args) {
        const { setCurrent, ...argsRest } = _nullishCoalesce(args, () => ( {}));
        const span = this.startSpan(argsRest);
        const ret = runCatchFinally(
          () => {
            if (_nullishCoalesce(setCurrent, () => ( true))) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
        return ret;
      }
      /**
       * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
       * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
       * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
       *
       * See {@link traced} for full details.
       */
      startSpan(args) {
        this.calledStartSpan = true;
        return this.startSpanImpl(args);
      }
      startSpanImpl(args) {
        return new SpanImpl({
          ...args,
          // Sometimes `args` gets passed directly into this function, and it contains an undefined value for `state`.
          // To ensure that we always use this experiment's state, we override the `state` argument no matter what.
          state: this.state,
          ...startSpanParentArgs({
            state: this.state,
            parent: _optionalChain([args, 'optionalAccess', _85 => _85.parent]),
            parentObjectType: this.parentObjectType(),
            parentObjectId: this.lazyId,
            parentComputeObjectMetadataArgs: void 0,
            parentSpanIds: void 0,
            propagatedEvent: _optionalChain([args, 'optionalAccess', _86 => _86.propagatedEvent])
          }),
          defaultRootType: "eval" /* EVAL */
        });
      }
      async fetchBaseExperiment() {
        const state = await this.getState();
        const conn = state.appConn();
        try {
          const resp = await conn.post("/api/base_experiment/get_id", {
            id: await this.id
          });
          const base = await resp.json();
          return {
            id: base["base_exp_id"],
            name: base["base_exp_name"]
          };
        } catch (e) {
          if (e instanceof FailedHTTPResponse && e.status === 400) {
            return null;
          } else {
            throw e;
          }
        }
      }
      /**
       * Summarize the experiment, including the scores (compared to the closest reference experiment) and metadata.
       *
       * @param options Options for summarizing the experiment.
       * @param options.summarizeScores Whether to summarize the scores. If False, only the metadata will be returned.
       * @param options.comparisonExperimentId The experiment to compare against. If None, the most recent experiment on the origin's main branch will be used.
       * @returns A summary of the experiment, including the scores (compared to the closest reference experiment) and metadata.
       */
      async summarize(options = {}) {
        let { summarizeScores = true, comparisonExperimentId = void 0 } = options || {};
        const state = await this.getState();
        const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
          state.orgName
        )}/p/${encodeURIComponent((await this.project).name)}`;
        const experimentUrl = `${projectUrl}/experiments/${encodeURIComponent(
          await this.name
        )}`;
        let scores = void 0;
        let metrics2 = void 0;
        let comparisonExperimentName = void 0;
        if (summarizeScores) {
          await this.flush();
          if (comparisonExperimentId === void 0) {
            const baseExperiment = await this.fetchBaseExperiment();
            if (baseExperiment !== null) {
              comparisonExperimentId = baseExperiment.id;
              comparisonExperimentName = baseExperiment.name;
            }
          }
          try {
            const results = await state.apiConn().get_json(
              "/experiment-comparison2",
              {
                experiment_id: await this.id,
                base_experiment_id: comparisonExperimentId
              },
              3
            );
            scores = results["scores"];
            metrics2 = results["metrics"];
          } catch (e) {
            console.warn(
              `Failed to fetch experiment scores and metrics: ${e}

View complete results in Braintrust or run experiment.summarize() again.`
            );
            scores = {};
            metrics2 = {};
          }
        }
        return {
          projectName: (await this.project).name,
          experimentName: await this.name,
          projectId: (await this.project).id,
          experimentId: await this.id,
          projectUrl,
          experimentUrl,
          comparisonExperimentName,
          scores: _nullishCoalesce(scores, () => ( {})),
          metrics: _nullishCoalesce(metrics2, () => ( {}))
        };
      }
      /**
       * Log feedback to an event in the experiment. Feedback is used to save feedback scores, set an expected value, or add a comment.
       *
       * @param event
       * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
       * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
       * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
       * @param event.comment (Optional) an optional comment string to log about the event.
       * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
       * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
       */
      logFeedback(event) {
        logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
      }
      /**
       * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
       * since otherwise updates to the span may conflict with the original span.
       *
       * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
       */
      updateSpan(event) {
        const { id, ...eventRest } = event;
        if (!id) {
          throw new Error("Span id is required to update a span");
        }
        updateSpanImpl({
          state: this.state,
          parentObjectType: this.parentObjectType(),
          parentObjectId: this.lazyId,
          id,
          event: eventRest
        });
      }
      /**
       * Return a serialized representation of the experiment that can be used to start subspans in other places.
       *
       * See {@link Span.startSpan} for more details.
       */
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType(),
          object_id: await this.id
        }).toStr();
      }
      /**
       * Flush any pending rows to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      /**
       * @deprecated This function is deprecated. You can simply remove it from your code.
       */
      async close() {
        console.warn(
          "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
        );
        return this.id;
      }
    }, _class10);
    ReadonlyExperiment = exports.ReadonlyExperiment = class extends ObjectFetcher {
      constructor(state, lazyMetadata) {
        super("experiment", void 0, (r) => enrichAttachments(r, state));
        this.state = state;
        this.lazyMetadata = lazyMetadata;
      }
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.id;
        })();
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).experiment.name;
        })();
      }
      get loggingState() {
        return this.state;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      async *asDataset() {
        const records = this.fetch();
        for await (const record of records) {
          if (record.root_span_id !== record.span_id) {
            continue;
          }
          const { output, expected: expectedRecord, metadata } = record;
          const expected = _nullishCoalesce(expectedRecord, () => ( output));
          yield {
            input: record.input,
            tags: record.tags,
            expected,
            metadata
          };
        }
      }
    };
    executionCounter = 0;
    SpanImpl = exports.SpanImpl = (_class11 = class _SpanImpl {
      
      
      
      
      // For internal use only.
      
      
      
      
      
      
      
      __init42() {this.kind = "span"}
      constructor(args) {;_class11.prototype.__init42.call(this);
        this._state = args.state;
        const spanAttributes = _nullishCoalesce(args.spanAttributes, () => ( {}));
        const rawEvent = _nullishCoalesce(args.event, () => ( {}));
        const type = _nullishCoalesce(args.type, () => ( (args.parentSpanIds ? void 0 : args.defaultRootType)));
        this.loggedEndTime = void 0;
        this.parentObjectType = args.parentObjectType;
        this.parentObjectId = args.parentObjectId;
        this.parentComputeObjectMetadataArgs = args.parentComputeObjectMetadataArgs;
        this.propagatedEvent = args.propagatedEvent;
        if (this.propagatedEvent) {
          mergeDicts(rawEvent, this.propagatedEvent);
        }
        const { id: eventId, ...event } = rawEvent;
        const callerLocation = isomorph_default.getCallerLocation();
        const name = (() => {
          if (args.name) return args.name;
          if (!args.parentSpanIds) return "root";
          if (callerLocation) {
            const pathComponents = callerLocation.caller_filename.split("/");
            const filename = pathComponents[pathComponents.length - 1];
            return [callerLocation.caller_functionname].concat(
              filename ? [`${filename}:${callerLocation.caller_lineno}`] : []
            ).join(":");
          }
          return "subspan";
        })();
        const internalData = {
          metrics: {
            start: _nullishCoalesce(args.startTime, () => ( getCurrentUnixTimestamp()))
          },
          context: { ...callerLocation },
          span_attributes: {
            name,
            type,
            ...spanAttributes,
            exec_counter: executionCounter++
          },
          created: (/* @__PURE__ */ new Date()).toISOString()
        };
        this._id = _nullishCoalesce(eventId, () => ( this._state.idGenerator.getSpanId()));
        const resolvedIds = _resolveSpanIds(
          args.spanId,
          args.parentSpanIds,
          true,
          // Always lookup span parent from context manager unless explicit parent provided
          this._state.idGenerator,
          this._state.contextManager
        );
        this._spanId = resolvedIds.spanId;
        this._rootSpanId = resolvedIds.rootSpanId;
        this._spanParents = resolvedIds.spanParents;
        this.isMerge = false;
        this.logInternal({ event, internalData });
        this.isMerge = true;
      }
      get id() {
        return this._id;
      }
      get spanId() {
        return this._spanId;
      }
      get rootSpanId() {
        return this._rootSpanId;
      }
      get spanParents() {
        return _nullishCoalesce(this._spanParents, () => ( []));
      }
      setAttributes(args) {
        this.logInternal({ internalData: { span_attributes: args } });
      }
      setSpanParents(parents) {
        this.logInternal({ internalData: { span_parents: parents } });
      }
      log(event) {
        this.logInternal({ event });
      }
      logInternal({
        event,
        internalData
      }) {
        const [serializableInternalData, lazyInternalData] = splitLoggingData({
          event,
          internalData
        });
        const partialRecord = deepCopyEvent({
          id: this.id,
          span_id: this._spanId,
          root_span_id: this._rootSpanId,
          span_parents: this._spanParents,
          ...serializableInternalData,
          [IS_MERGE_FIELD]: this.isMerge
        });
        if (_optionalChain([partialRecord, 'access', _87 => _87.metrics, 'optionalAccess', _88 => _88.end])) {
          this.loggedEndTime = _optionalChain([partialRecord, 'access', _89 => _89.metrics, 'optionalAccess', _90 => _90.end]);
        }
        if ((_nullishCoalesce(partialRecord.tags, () => ( []))).length > 0 && _optionalChain([this, 'access', _91 => _91._spanParents, 'optionalAccess', _92 => _92.length])) {
          throw new Error("Tags can only be logged to the root span");
        }
        const computeRecord = async () => ({
          ...partialRecord,
          ...Object.fromEntries(
            await Promise.all(
              Object.entries(lazyInternalData).map(async ([key, value]) => [
                key,
                await value.get()
              ])
            )
          ),
          ...new SpanComponentsV3({
            object_type: this.parentObjectType,
            object_id: await this.parentObjectId.get()
          }).objectIdFields()
        });
        this._state.bgLogger().log([new LazyValue(computeRecord)]);
      }
      logFeedback(event) {
        logFeedbackImpl(this._state, this.parentObjectType, this.parentObjectId, {
          ...event,
          id: this.id
        });
      }
      traced(callback, args) {
        const { setCurrent, ...argsRest } = _nullishCoalesce(args, () => ( {}));
        const span = this.startSpan(argsRest);
        return runCatchFinally(
          () => {
            if (_nullishCoalesce(setCurrent, () => ( true))) {
              return withCurrent(span, callback);
            } else {
              return callback(span);
            }
          },
          (e) => {
            logError(span, e);
            throw e;
          },
          () => span.end()
        );
      }
      startSpan(args) {
        const parentSpanIds = _optionalChain([args, 'optionalAccess', _93 => _93.parent]) ? void 0 : { spanId: this._spanId, rootSpanId: this._rootSpanId };
        return new _SpanImpl({
          state: this._state,
          ...args,
          ...startSpanParentArgs({
            state: this._state,
            parent: _optionalChain([args, 'optionalAccess', _94 => _94.parent]),
            parentObjectType: this.parentObjectType,
            parentObjectId: this.parentObjectId,
            parentComputeObjectMetadataArgs: this.parentComputeObjectMetadataArgs,
            parentSpanIds,
            propagatedEvent: _nullishCoalesce(_optionalChain([args, 'optionalAccess', _95 => _95.propagatedEvent]), () => ( this.propagatedEvent))
          })
        });
      }
      startSpanWithParents(spanId, spanParents, args) {
        const parentSpanIds = {
          parentSpanIds: spanParents,
          rootSpanId: this._rootSpanId
        };
        return new _SpanImpl({
          state: this._state,
          ...args,
          ...startSpanParentArgs({
            state: this._state,
            parent: _optionalChain([args, 'optionalAccess', _96 => _96.parent]),
            parentObjectType: this.parentObjectType,
            parentObjectId: this.parentObjectId,
            parentComputeObjectMetadataArgs: this.parentComputeObjectMetadataArgs,
            parentSpanIds,
            propagatedEvent: _nullishCoalesce(_optionalChain([args, 'optionalAccess', _97 => _97.propagatedEvent]), () => ( this.propagatedEvent))
          }),
          spanId
        });
      }
      end(args) {
        let endTime;
        let internalData = {};
        if (!this.loggedEndTime) {
          endTime = _nullishCoalesce(_optionalChain([args, 'optionalAccess', _98 => _98.endTime]), () => ( getCurrentUnixTimestamp()));
          internalData = { metrics: { end: endTime } };
        } else {
          endTime = this.loggedEndTime;
        }
        this.logInternal({ internalData });
        return endTime;
      }
      async export() {
        return new (getSpanComponentsClass())({
          object_type: this.parentObjectType,
          ...this.parentComputeObjectMetadataArgs && !this.parentObjectId.hasSucceeded ? { compute_object_metadata_args: this.parentComputeObjectMetadataArgs } : { object_id: await this.parentObjectId.get() },
          row_id: this.id,
          span_id: this._spanId,
          root_span_id: this._rootSpanId,
          propagated_event: this.propagatedEvent
        }).toStr();
      }
      async permalink() {
        return await permalink(await this.export(), {
          state: this._state
        });
      }
      link() {
        if (!this.id) {
          return NOOP_SPAN_PERMALINK;
        }
        try {
          const orgName = this._state.orgName;
          if (!orgName) {
            throw new Error("log-in-or-provide-org-name");
          }
          return this._link(orgName);
        } catch (e) {
          return getErrPermlink(e instanceof Error ? e.message : String(e));
        }
      }
      _link(orgName) {
        const appUrl = this._state.appUrl || "https://www.braintrust.dev";
        const baseUrl = `${appUrl}/app/${orgName}`;
        const args = this.parentComputeObjectMetadataArgs;
        switch (this.parentObjectType) {
          case 2 /* PROJECT_LOGS */: {
            const projectID = _optionalChain([args, 'optionalAccess', _99 => _99.project_id]) || this.parentObjectId.getSync().value;
            const projectName = _optionalChain([args, 'optionalAccess', _100 => _100.project_name]);
            if (projectID) {
              return `${baseUrl}/object?object_type=project_logs&object_id=${projectID}&id=${this._id}`;
            } else if (projectName) {
              return `${baseUrl}/p/${projectName}/logs?oid=${this._id}`;
            } else {
              return getErrPermlink("provide-project-name-or-id");
            }
          }
          case 1 /* EXPERIMENT */: {
            const expID = _optionalChain([args, 'optionalAccess', _101 => _101.experiment_id]) || _optionalChain([this, 'access', _102 => _102.parentObjectId, 'optionalAccess', _103 => _103.getSync, 'call', _104 => _104(), 'optionalAccess', _105 => _105.value]);
            if (!expID) {
              return getErrPermlink("provide-experiment-id");
            } else {
              return `${baseUrl}/object?object_type=experiment&object_id=${expID}&id=${this._id}`;
            }
          }
          case 3 /* PLAYGROUND_LOGS */: {
            return NOOP_SPAN_PERMALINK;
          }
          default: {
            const _exhaustive = this.parentObjectType;
            _exhaustive;
            return NOOP_SPAN_PERMALINK;
          }
        }
      }
      async flush() {
        return await this._state.bgLogger().flush();
      }
      close(args) {
        return this.end(args);
      }
      state() {
        return this._state;
      }
      /**
       * Internal method to get the OTEL parent string for this span.
       * This is used by OtelContextManager to set the braintrust.parent attribute.
       * @returns A string like "project_id:X" or "experiment_id:X", or undefined if no parent
       */
      _getOtelParent() {
        if (!this.parentObjectType) {
          return void 0;
        }
        try {
          if (this.parentObjectType === 2 /* PROJECT_LOGS */) {
            const syncResult = this.parentObjectId.getSync();
            const id = syncResult.value;
            const args = this.parentComputeObjectMetadataArgs;
            if (id) {
              return `project_id:${id}`;
            }
            const projectName = _optionalChain([args, 'optionalAccess', _106 => _106.project_name]);
            if (projectName) {
              return `project_name:${projectName}`;
            }
          } else if (this.parentObjectType === 1 /* EXPERIMENT */) {
            const syncResult = this.parentObjectId.getSync();
            const id = syncResult.value;
            if (!syncResult.resolved) {
              this.parentObjectId.get().catch(() => {
              });
            }
            if (id) {
              return `experiment_id:${id}`;
            }
          }
        } catch (e) {
        }
        return void 0;
      }
      // Custom inspect for Node.js console.log
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `SpanImpl {
  kind: '${this.kind}',
  id: '${this.id}',
  spanId: '${this.spanId}',
  rootSpanId: '${this.rootSpanId}',
  spanParents: ${JSON.stringify(this.spanParents)}
}`;
      }
      // Custom toString
      toString() {
        return `SpanImpl(id=${this.id}, spanId=${this.spanId})`;
      }
    }, _class11);
    Dataset2 = exports.Dataset = (_class12 = class extends ObjectFetcher {
      constructor(state, lazyMetadata, pinnedVersion, legacy, _internal_btql) {
        const isLegacyDataset = _nullishCoalesce(legacy, () => ( DEFAULT_IS_LEGACY_DATASET));
        if (isLegacyDataset) {
          console.warn(
            `Records will be fetched from this dataset in the legacy format, with the "expected" field renamed to "output". Please update your code to use "expected", and use \`braintrust.initDataset()\` with \`{ useOutput: false }\`, which will become the default in a future version of Braintrust.`
          );
        }
        super(
          "dataset",
          pinnedVersion,
          (r) => (
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            ensureDatasetRecord(
              enrichAttachments(r, this.state),
              isLegacyDataset
            )
          ),
          _internal_btql
        );_class12.prototype.__init43.call(this);_class12.prototype.__init44.call(this);;
        this.state = state;
        this.lazyMetadata = lazyMetadata;
      }
      
      __init43() {this.__braintrust_dataset_marker = true}
      __init44() {this.newRecords = 0}
      get id() {
        return (async () => {
          return (await this.lazyMetadata.get()).dataset.id;
        })();
      }
      get name() {
        return (async () => {
          return (await this.lazyMetadata.get()).dataset.name;
        })();
      }
      get project() {
        return (async () => {
          return (await this.lazyMetadata.get()).project;
        })();
      }
      get loggingState() {
        return this.state;
      }
      async getState() {
        await this.lazyMetadata.get();
        return this.state;
      }
      validateEvent({
        metadata,
        expected,
        output,
        tags
      }) {
        if (metadata !== void 0) {
          for (const key of Object.keys(metadata)) {
            if (typeof key !== "string") {
              throw new Error("metadata keys must be strings");
            }
          }
        }
        if (expected !== void 0 && output !== void 0) {
          throw new Error(
            "Only one of expected or output (deprecated) can be specified. Prefer expected."
          );
        }
        if (tags) {
          validateTags(tags);
        }
      }
      createArgs({
        id,
        input,
        expected,
        metadata,
        tags,
        output,
        isMerge
      }) {
        return new LazyValue(async () => {
          const dataset_id = await this.id;
          const expectedValue = expected === void 0 ? output : expected;
          const args = {
            id,
            input,
            expected: expectedValue,
            tags,
            dataset_id,
            created: !isMerge ? (/* @__PURE__ */ new Date()).toISOString() : void 0,
            //if we're merging/updating an event we will not add this ts
            metadata,
            ...!!isMerge ? {
              [IS_MERGE_FIELD]: true
            } : {}
          };
          return args;
        });
      }
      /**
       * Insert a single record to the dataset. The record will be batched and uploaded behind the scenes. If you pass in an `id`,
       * and a record with that `id` already exists, it will be overwritten (upsert).
       *
       * @param event The event to log.
       * @param event.input The argument that uniquely define an input case (an arbitrary, JSON serializable object).
       * @param event.expected The output of your application, including post-processing (an arbitrary, JSON serializable object).
       * @param event.tags (Optional) a list of strings that you can use to filter and group records later.
       * @param event.metadata (Optional) a dictionary with additional data about the test example, model outputs, or just
       * about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the
       * `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any
       * JSON-serializable type, but its keys must be strings.
       * @param event.id (Optional) a unique identifier for the event. If you don't provide one, Braintrust will generate one for you.
       * @param event.output: (Deprecated) The output of your application. Use `expected` instead.
       * @returns The `id` of the logged record.
       */
      insert({
        input,
        expected,
        metadata,
        tags,
        id,
        output
      }) {
        this.validateEvent({ metadata, expected, output, tags });
        const rowId = id || _uuid.v4.call(void 0, );
        const args = this.createArgs(
          deepCopyEvent({
            id: rowId,
            input,
            expected,
            metadata,
            tags,
            output,
            isMerge: false
          })
        );
        this.state.bgLogger().log([args]);
        this.newRecords++;
        return rowId;
      }
      /**
       * Update fields of a single record in the dataset. The updated fields will be batched and uploaded behind the scenes.
       * You must pass in an `id` of the record to update. Only the fields provided will be updated; other fields will remain unchanged.
       *
       * @param event The fields to update in the record.
       * @param event.id The unique identifier of the record to update.
       * @param event.input (Optional) The new input value for the record (an arbitrary, JSON serializable object).
       * @param event.expected (Optional) The new expected output value for the record (an arbitrary, JSON serializable object).
       * @param event.tags (Optional) A list of strings to update the tags of the record.
       * @param event.metadata (Optional) A dictionary to update the metadata of the record. The values in `metadata` can be any
       * JSON-serializable type, but its keys must be strings.
       * @returns The `id` of the updated record.
       */
      update({
        input,
        expected,
        metadata,
        tags,
        id
      }) {
        this.validateEvent({ metadata, expected, tags });
        const args = this.createArgs(
          deepCopyEvent({
            id,
            input,
            expected,
            metadata,
            tags,
            isMerge: true
          })
        );
        this.state.bgLogger().log([args]);
        return id;
      }
      delete(id) {
        const args = new LazyValue(async () => ({
          id,
          dataset_id: await this.id,
          created: (/* @__PURE__ */ new Date()).toISOString(),
          _object_delete: true
        }));
        this.state.bgLogger().log([args]);
        return id;
      }
      /**
       * Summarize the dataset, including high level metrics about its size and other metadata.
       * @param summarizeData Whether to summarize the data. If false, only the metadata will be returned.
       * @returns `DatasetSummary`
       * @returns A summary of the dataset.
       */
      async summarize(options = {}) {
        const { summarizeData = true } = options || {};
        await this.flush();
        const state = await this.getState();
        const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
          state.orgName
        )}/p/${encodeURIComponent((await this.project).name)}`;
        const datasetUrl = `${projectUrl}/datasets/${encodeURIComponent(
          await this.name
        )}`;
        let dataSummary;
        if (summarizeData) {
          const rawDataSummary = _v3.z.object({
            total_records: _v3.z.number()
          }).parse(
            await state.apiConn().get_json(
              "dataset-summary",
              {
                dataset_id: await this.id
              },
              3
            )
          );
          dataSummary = {
            newRecords: this.newRecords,
            totalRecords: rawDataSummary.total_records
          };
        }
        return {
          projectName: (await this.project).name,
          datasetName: await this.name,
          projectUrl,
          datasetUrl,
          dataSummary
        };
      }
      /**
       * Flush any pending rows to the server.
       */
      async flush() {
        return await this.state.bgLogger().flush();
      }
      /**
       * @deprecated This function is deprecated. You can simply remove it from your code.
       */
      async close() {
        console.warn(
          "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
        );
        return this.id;
      }
      static isDataset(data) {
        return typeof data === "object" && data !== null && "__braintrust_dataset_marker" in data;
      }
    }, _class12);
    Prompt2 = exports.Prompt = (_class13 = class _Prompt {
      constructor(metadata, defaults, noTrace) {;_class13.prototype.__init45.call(this);_class13.prototype.__init46.call(this);
        this.metadata = metadata;
        this.defaults = defaults;
        this.noTrace = noTrace;
      }
      
      __init45() {this.hasParsedPromptData = false}
      __init46() {this.__braintrust_prompt_marker = true}
      get id() {
        return this.metadata.id;
      }
      get projectId() {
        return this.metadata.project_id;
      }
      get name() {
        return "name" in this.metadata ? this.metadata.name : `Playground function ${this.metadata.id}`;
      }
      get slug() {
        return "slug" in this.metadata ? this.metadata.slug : this.metadata.id;
      }
      get prompt() {
        return _optionalChain([this, 'access', _107 => _107.getParsedPromptData, 'call', _108 => _108(), 'optionalAccess', _109 => _109.prompt]);
      }
      get version() {
        return this.metadata[TRANSACTION_ID_FIELD];
      }
      get options() {
        return _optionalChain([this, 'access', _110 => _110.getParsedPromptData, 'call', _111 => _111(), 'optionalAccess', _112 => _112.options]) || {};
      }
      get promptData() {
        return this.getParsedPromptData();
      }
      /**
       * Build the prompt with the given formatting options. The args you pass in will
       * be forwarded to the mustache template that defines the prompt and rendered with
       * the `mustache-js` library.
       *
       * @param buildArgs Args to forward along to the prompt template.
       */
      build(buildArgs, options = {}) {
        return this.runBuild(buildArgs, {
          flavor: _nullishCoalesce(options.flavor, () => ( "chat")),
          messages: options.messages,
          strict: options.strict
        });
      }
      /**
       * This is a special build method that first resolves attachment references, and then
       * calls the regular build method. You should use this if you are building prompts from
       * dataset rows that contain attachments.
       *
       * @param buildArgs Args to forward along to the prompt template.
       */
      async buildWithAttachments(buildArgs, options = {}) {
        const hydrated = buildArgs instanceof Object ? await resolveAttachmentsToBase64(buildArgs, options.state) : buildArgs;
        return this.runBuild(hydrated, {
          flavor: _nullishCoalesce(options.flavor, () => ( "chat")),
          messages: options.messages,
          strict: options.strict
        });
      }
      runBuild(buildArgs, options) {
        const { flavor } = options;
        const params = {
          ...this.defaults,
          ...Object.fromEntries(
            Object.entries(this.options.params || {}).filter(
              ([k, _v]) => !BRAINTRUST_PARAMS.includes(k)
            )
          ),
          ...!isEmpty(this.options.model) ? {
            model: this.options.model
          } : {}
        };
        if (!("model" in params) || isEmpty(params.model)) {
          throw new Error(
            "No model specified. Either specify it in the prompt or as a default"
          );
        }
        const spanInfo = this.noTrace ? {} : {
          span_info: {
            metadata: {
              prompt: this.id ? {
                variables: buildArgs,
                id: this.id,
                project_id: this.projectId,
                version: this.version,
                ..."prompt_session_id" in this.metadata ? { prompt_session_id: this.metadata.prompt_session_id } : {}
              } : void 0
            }
          }
        };
        const prompt = this.prompt;
        if (!prompt) {
          throw new Error("Empty prompt");
        }
        const dictArgParsed = _v3.z.record(_v3.z.unknown()).safeParse(buildArgs);
        const variables = {
          input: buildArgs,
          ...dictArgParsed.success ? dictArgParsed.data : {}
        };
        const renderedPrompt = _Prompt.renderPrompt({
          prompt,
          buildArgs,
          options
        });
        if (flavor === "chat") {
          if (renderedPrompt.type !== "chat") {
            throw new Error(
              "Prompt is a completion prompt. Use buildCompletion() instead"
            );
          }
          return {
            ...renderPromptParams(params, variables, { strict: options.strict }),
            ...spanInfo,
            messages: renderedPrompt.messages,
            ...renderedPrompt.tools ? {
              tools: ChatCompletionTool.array().parse(JSON.parse(renderedPrompt.tools))
            } : void 0
          };
        } else if (flavor === "completion") {
          if (renderedPrompt.type !== "completion") {
            throw new Error(`Prompt is a chat prompt. Use flavor: 'chat' instead`);
          }
          return {
            ...renderPromptParams(params, variables, { strict: options.strict }),
            ...spanInfo,
            prompt: renderedPrompt.content
          };
        } else {
          throw new Error("never!");
        }
      }
      static renderPrompt({
        prompt,
        buildArgs,
        options
      }) {
        const escape = (v) => {
          if (v === void 0) {
            throw new Error("Missing!");
          } else if (typeof v === "string") {
            return v;
          } else if (v instanceof ReadonlyAttachment) {
            throw new Error(
              "Use buildWithAttachments() to build prompts with attachments"
            );
          } else {
            return JSON.stringify(v);
          }
        };
        const dictArgParsed = _v3.z.record(_v3.z.unknown()).safeParse(buildArgs);
        const variables = {
          input: buildArgs,
          ...dictArgParsed.success ? dictArgParsed.data : {}
        };
        if (prompt.type === "chat") {
          const render = (template) => {
            if (options.strict) {
              lintTemplate(template, variables);
            }
            return _mustache2.default.render(template, variables, void 0, {
              escape
            });
          };
          const baseMessages = (prompt.messages || []).map(
            (m) => renderMessage(render, m)
          );
          const hasSystemPrompt = baseMessages.some((m) => m.role === "system");
          const messages = [
            ...baseMessages,
            ...(_nullishCoalesce(options.messages, () => ( []))).filter(
              (m) => !(hasSystemPrompt && m.role === "system")
            )
          ];
          return {
            type: "chat",
            messages,
            ..._optionalChain([prompt, 'access', _113 => _113.tools, 'optionalAccess', _114 => _114.trim, 'call', _115 => _115()]) ? {
              tools: render(prompt.tools)
            } : void 0
          };
        } else if (prompt.type === "completion") {
          if (options.messages) {
            throw new Error(
              "extra messages are not supported for completion prompts"
            );
          }
          if (options.strict) {
            lintTemplate(prompt.content, variables);
          }
          return {
            type: "completion",
            content: _mustache2.default.render(prompt.content, variables, void 0, {
              escape
            })
          };
        } else {
          const _ = prompt;
          throw new Error(`Invalid prompt type: ${_}`);
        }
      }
      getParsedPromptData() {
        if (!this.hasParsedPromptData) {
          this.parsedPromptData = PromptData.parse(this.metadata.prompt_data);
          this.hasParsedPromptData = true;
        }
        return this.parsedPromptData;
      }
      static isPrompt(data) {
        return typeof data === "object" && data !== null && "__braintrust_prompt_marker" in data;
      }
      static fromPromptData(name, promptData) {
        return new _Prompt(
          {
            name,
            slug: name,
            prompt_data: promptData
          },
          {},
          false
        );
      }
    }, _class13);
    TEST_API_KEY = "___TEST_API_KEY__THIS_IS_NOT_REAL___";
    _exportsForTestingOnly = exports._exportsForTestingOnly = {
      extractAttachments,
      deepCopyEvent,
      useTestBackgroundLogger,
      clearTestBackgroundLogger,
      simulateLoginForTests,
      simulateLogoutForTests,
      setInitialTestState,
      initTestExperiment,
      isGeneratorFunction,
      isAsyncGeneratorFunction,
      resetIdGenStateForTests
    };
  }
});

// src/node.ts
init_isomorph();
var _async_hooks = require('async_hooks');
var _path = require('path'); var path = _interopRequireWildcard(_path);
var _promises = require('fs/promises'); var fs = _interopRequireWildcard(_promises);
var _os = require('os'); var os = _interopRequireWildcard(_os);
var _fs = require('fs'); var fsSync = _interopRequireWildcard(_fs);
var _crypto = require('crypto'); var crypto = _interopRequireWildcard(_crypto);

// src/gitutil.ts
var _simplegit = require('simple-git');
var COMMON_BASE_BRANCHES = ["main", "master", "develop"];
async function currentRepo() {
  try {
    const git = _simplegit.simpleGit.call(void 0, );
    if (await git.checkIsRepo()) {
      return git;
    } else {
      return null;
    }
  } catch (e) {
    return null;
  }
}
var _baseBranch = null;
async function getBaseBranch(remote = void 0) {
  if (_baseBranch === null) {
    const git = await currentRepo();
    if (git === null) {
      throw new Error("Not in a git repo");
    }
    const remoteName = await _asyncNullishCoalesce(remote, async () => ( await _asyncOptionalChain([(await git.getRemotes()), 'access', async _116 => _116[0], 'optionalAccess', async _117 => _117.name])));
    if (!remoteName) {
      throw new Error("No remote found");
    }
    let branch = null;
    const repoBranches = new Set((await git.branchLocal()).all);
    const matchingBaseBranches = COMMON_BASE_BRANCHES.filter(
      (b) => repoBranches.has(b)
    );
    if (matchingBaseBranches.length === 1) {
      branch = matchingBaseBranches[0];
    } else {
      try {
        const remoteInfo = await git.remote(["show", remoteName]);
        if (!remoteInfo) {
          throw new Error(`Could not find remote ${remoteName}`);
        }
        const match = remoteInfo.match(/\s*HEAD branch:\s*(.*)$/m);
        if (!match) {
          throw new Error(`Could not find HEAD branch in remote ${remoteName}`);
        }
        branch = match[1];
      } catch (e10) {
        branch = "main";
      }
    }
    _baseBranch = { remote: remoteName, branch };
  }
  return _baseBranch;
}
async function getBaseBranchAncestor(remote = void 0) {
  const git = await currentRepo();
  if (git === null) {
    throw new Error("Not in a git repo");
  }
  const { remote: remoteName, branch: baseBranch } = await getBaseBranch(remote);
  const isDirty = (await git.diffSummary()).files.length > 0;
  const head = isDirty ? "HEAD" : "HEAD^";
  try {
    const ancestor = await git.raw([
      "merge-base",
      head,
      `${remoteName}/${baseBranch}`
    ]);
    return ancestor.trim();
  } catch (e) {
    return void 0;
  }
}
async function getPastNAncestors(n = 1e3, remote = void 0) {
  const git = await currentRepo();
  if (git === null) {
    return [];
  }
  let ancestor = void 0;
  try {
    ancestor = await getBaseBranchAncestor(remote);
  } catch (e) {
    console.warn(
      "Skipping git metadata. This is likely because the repository has not been published to a remote yet.",
      `${e}`
    );
  }
  if (!ancestor) {
    return [];
  }
  const commits = await git.log({ from: ancestor, to: "HEAD", maxCount: n });
  return commits.all.map((c) => c.hash);
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (e) {
    return void 0;
  }
}
function truncateToByteLimit(s, byteLimit = 65536) {
  const encoded = new TextEncoder().encode(s);
  if (encoded.length <= byteLimit) {
    return s;
  }
  const truncated = encoded.subarray(0, byteLimit);
  return new TextDecoder().decode(truncated);
}
async function getRepoInfo(settings) {
  if (settings && settings.collect === "none") {
    return void 0;
  }
  const repo = await repoInfo();
  if (!repo || !settings || settings.collect === "all") {
    return repo;
  }
  let sanitized = {};
  _optionalChain([settings, 'access', _118 => _118.fields, 'optionalAccess', _119 => _119.forEach, 'call', _120 => _120((field) => {
    sanitized = { ...sanitized, [field]: repo[field] };
  })]);
  return sanitized;
}
async function repoInfo() {
  const git = await currentRepo();
  if (git === null) {
    return void 0;
  }
  let commit = void 0;
  let commit_message = void 0;
  let commit_time = void 0;
  let author_name = void 0;
  let author_email = void 0;
  let tag = void 0;
  let branch = void 0;
  let git_diff = void 0;
  const dirty = (await git.diffSummary()).files.length > 0;
  commit = await attempt(async () => await git.revparse(["HEAD"]));
  commit_message = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%B"])).trim()
  );
  commit_time = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%cI"])).trim()
  );
  author_name = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%aN"])).trim()
  );
  author_email = await attempt(
    async () => (await git.raw(["log", "-1", "--pretty=%aE"])).trim()
  );
  tag = await attempt(
    async () => (await git.raw(["describe", "--tags", "--exact-match", "--always"])).trim()
  );
  branch = await attempt(
    async () => (await git.raw(["rev-parse", "--abbrev-ref", "HEAD"])).trim()
  );
  if (dirty) {
    git_diff = await attempt(
      async () => truncateToByteLimit(await git.raw(["--no-ext-diff", "diff", "HEAD"]))
    );
  }
  return {
    commit,
    branch,
    tag,
    dirty,
    author_name,
    author_email,
    commit_message,
    commit_time,
    git_diff
  };
}

// src/stackutil.ts
init_isomorph();
function getStackTrace() {
  const trace2 = new Error().stack;
  if (typeof trace2 !== "string") {
    return [];
  }
  const traceLines = trace2.split("\n");
  const out = [];
  const stackFrameRegex = /at(.*)\((.*):(\d+):(\d+)\)/;
  for (const traceLine of traceLines.slice(1)) {
    const matches = traceLine.match(stackFrameRegex);
    if (matches === null || matches.length !== 5) {
      continue;
    }
    const entry = {
      functionName: matches[1].trim(),
      fileName: matches[2],
      lineNo: parseInt(matches[3])
    };
    if (!isNaN(entry.lineNo)) {
      out.push(entry);
    }
  }
  return out;
}
function getCallerLocation() {
  let thisDir = void 0;
  const entries = getStackTrace();
  for (const frame of entries) {
    if (thisDir === void 0) {
      thisDir = _optionalChain([isomorph_default, 'access', _121 => _121.pathDirname, 'optionalCall', _122 => _122(frame.fileName)]);
    }
    if (_optionalChain([isomorph_default, 'access', _123 => _123.pathDirname, 'optionalCall', _124 => _124(frame.fileName)]) !== thisDir) {
      return {
        caller_functionname: frame.functionName,
        caller_filename: frame.fileName,
        caller_lineno: frame.lineNo
      };
    }
  }
  return void 0;
}

// src/node.ts
init_logger();
var _util = require('util');
var _zlib = require('zlib'); var zlib = _interopRequireWildcard(_zlib);
function configureNode() {
  isomorph_default.getRepoInfo = getRepoInfo;
  isomorph_default.getPastNAncestors = getPastNAncestors;
  isomorph_default.getEnv = (name) => process.env[name];
  isomorph_default.getCallerLocation = getCallerLocation;
  isomorph_default.newAsyncLocalStorage = () => new (0, _async_hooks.AsyncLocalStorage)();
  isomorph_default.processOn = (event, handler) => {
    process.on(event, handler);
  };
  isomorph_default.pathJoin = path.join;
  isomorph_default.pathDirname = path.dirname;
  isomorph_default.mkdir = fs.mkdir;
  isomorph_default.writeFile = fs.writeFile;
  isomorph_default.readFile = fs.readFile;
  isomorph_default.readdir = fs.readdir;
  isomorph_default.stat = fs.stat;
  isomorph_default.statSync = fsSync.statSync;
  isomorph_default.utimes = fs.utimes;
  isomorph_default.unlink = fs.unlink;
  isomorph_default.homedir = os.homedir;
  isomorph_default.gzip = _util.promisify.call(void 0, zlib.gzip);
  isomorph_default.gunzip = _util.promisify.call(void 0, zlib.gunzip);
  isomorph_default.hash = (data) => crypto.createHash("sha256").update(data).digest("hex");
  _internalSetInitialState();
}

// src/exports-node.ts
var exports_node_exports = {};
__export(exports_node_exports, {
  AISpanProcessor: () => AISpanProcessor,
  Attachment: () => Attachment,
  BaseAttachment: () => BaseAttachment,
  BaseExperiment: () => BaseExperiment,
  BraintrustExporter: () => BraintrustExporter,
  BraintrustMiddleware: () => BraintrustMiddleware,
  BraintrustSpanProcessor: () => BraintrustSpanProcessor,
  BraintrustState: () => BraintrustState,
  BraintrustStream: () => BraintrustStream,
  CodeFunction: () => CodeFunction,
  CodePrompt: () => CodePrompt,
  ContextManager: () => ContextManager,
  Dataset: () => Dataset2,
  ERR_PERMALINK: () => ERR_PERMALINK,
  Eval: () => Eval,
  EvalResultWithSummary: () => EvalResultWithSummary,
  Experiment: () => Experiment2,
  ExternalAttachment: () => ExternalAttachment,
  FailedHTTPResponse: () => FailedHTTPResponse,
  IDGenerator: () => IDGenerator,
  INTERNAL_BTQL_LIMIT: () => INTERNAL_BTQL_LIMIT,
  JSONAttachment: () => JSONAttachment,
  LEGACY_CACHED_HEADER: () => LEGACY_CACHED_HEADER,
  LazyValue: () => LazyValue,
  Logger: () => Logger,
  NOOP_SPAN: () => NOOP_SPAN,
  NOOP_SPAN_PERMALINK: () => NOOP_SPAN_PERMALINK,
  NoopSpan: () => NoopSpan,
  OTELIDGenerator: () => OTELIDGenerator,
  Project: () => Project2,
  ProjectNameIdMap: () => ProjectNameIdMap,
  Prompt: () => Prompt2,
  PromptBuilder: () => PromptBuilder,
  ReadonlyAttachment: () => ReadonlyAttachment,
  ReadonlyExperiment: () => ReadonlyExperiment,
  Reporter: () => Reporter,
  ScorerBuilder: () => ScorerBuilder,
  SpanImpl: () => SpanImpl,
  TestBackgroundLogger: () => TestBackgroundLogger,
  ToolBuilder: () => ToolBuilder,
  UUIDGenerator: () => UUIDGenerator,
  X_CACHED_HEADER: () => X_CACHED_HEADER,
  _exportsForTestingOnly: () => _exportsForTestingOnly,
  _internalGetGlobalState: () => _internalGetGlobalState,
  _internalSetInitialState: () => _internalSetInitialState,
  braintrustStreamChunkSchema: () => braintrustStreamChunkSchema,
  buildLocalSummary: () => buildLocalSummary,
  createFinalValuePassThroughStream: () => createFinalValuePassThroughStream,
  currentExperiment: () => currentExperiment,
  currentLogger: () => currentLogger,
  currentSpan: () => currentSpan,
  deepCopyEvent: () => deepCopyEvent,
  defaultErrorScoreHandler: () => defaultErrorScoreHandler,
  deserializePlainStringAsJSON: () => deserializePlainStringAsJSON,
  devNullWritableStream: () => devNullWritableStream,
  flush: () => flush,
  getContextManager: () => getContextManager,
  getIdGenerator: () => getIdGenerator,
  getPromptVersions: () => getPromptVersions,
  getSpanParentObject: () => getSpanParentObject,
  graph: () => graph_framework_exports,
  init: () => init,
  initDataset: () => initDataset,
  initExperiment: () => initExperiment,
  initFunction: () => initFunction,
  initLogger: () => initLogger,
  invoke: () => invoke,
  loadPrompt: () => loadPrompt,
  log: () => log,
  logError: () => logError,
  login: () => login,
  loginToState: () => loginToState,
  newId: () => newId,
  otel: () => otel,
  parseCachedHeader: () => parseCachedHeader,
  permalink: () => permalink,
  projects: () => projects,
  promptContentsSchema: () => promptContentsSchema,
  promptDefinitionSchema: () => promptDefinitionSchema,
  promptDefinitionToPromptData: () => promptDefinitionToPromptData,
  promptDefinitionWithToolsSchema: () => promptDefinitionWithToolsSchema,
  renderMessage: () => renderMessage,
  renderPromptParams: () => renderPromptParams,
  reportFailures: () => reportFailures,
  runEvaluator: () => runEvaluator,
  setFetch: () => setFetch,
  setMaskingFunction: () => setMaskingFunction,
  spanComponentsToObjectId: () => spanComponentsToObjectId,
  startSpan: () => startSpan,
  summarize: () => summarize,
  toolFunctionDefinitionSchema: () => ToolFunctionDefinition,
  traceable: () => traceable,
  traced: () => traced,
  updateSpan: () => updateSpan,
  withCurrent: () => withCurrent,
  withDataset: () => withDataset,
  withExperiment: () => withExperiment,
  withLogger: () => withLogger,
  withParent: () => withParent,
  wrapAISDK: () => wrapAISDK,
  wrapAISDKModel: () => wrapAISDKModel,
  wrapAnthropic: () => wrapAnthropic,
  wrapClaudeAgentSDK: () => wrapClaudeAgentSDK,
  wrapGoogleGenAI: () => wrapGoogleGenAI,
  wrapMastraAgent: () => wrapMastraAgent,
  wrapOpenAI: () => wrapOpenAI,
  wrapOpenAIv4: () => wrapOpenAIv4,
  wrapTraced: () => wrapTraced
});
init_logger();
init_stream();

// src/functions/invoke.ts
init_generated_types();
init_logger();
init_stream();
async function invoke(args) {
  const {
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2,
    input,
    messages,
    parent: parentArg,
    metadata,
    tags,
    state: stateArg,
    stream,
    mode,
    schema,
    strict,
    ...functionIdArgs
  } = args;
  const state = _nullishCoalesce(stateArg, () => ( _internalGetGlobalState()));
  await state.login({
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2
  });
  const parent = parentArg ? typeof parentArg === "string" ? parentArg : await parentArg.export() : await getSpanParentObject().export();
  const functionId = FunctionId.safeParse({
    function_id: functionIdArgs.function_id,
    project_name: functionIdArgs.projectName,
    slug: functionIdArgs.slug,
    global_function: functionIdArgs.globalFunction,
    prompt_session_id: functionIdArgs.promptSessionId,
    prompt_session_function_id: functionIdArgs.promptSessionFunctionId,
    version: functionIdArgs.version
  });
  if (!functionId.success) {
    throw new Error(
      `Invalid function ID arguments: ${functionId.error.message}`
    );
  }
  const request = {
    ...functionId.data,
    input,
    messages,
    parent,
    metadata,
    tags,
    stream,
    mode,
    strict
  };
  const resp = await state.proxyConn().post(`function/invoke`, request, {
    headers: {
      Accept: stream ? "text/event-stream" : "application/json"
    }
  });
  if (stream) {
    if (!resp.body) {
      throw new Error("Received empty stream body");
    }
    return new BraintrustStream(resp.body);
  } else {
    const data = await resp.json();
    return schema ? schema.parse(data) : data;
  }
}
function initFunction({
  projectName,
  slug,
  version
}) {
  const f = async (input) => {
    return await invoke({
      projectName,
      slug,
      version,
      input
    });
  };
  Object.defineProperty(f, "name", {
    value: `initFunction-${projectName}-${slug}-${_nullishCoalesce(version, () => ( "latest"))}`
  });
  return f;
}

// src/exports-node.ts
init_id_gen();

// src/framework.ts
init_util();

// ../node_modules/async/dist/async.mjs
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
var _defer$1;
if (hasQueueMicrotask) {
  _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
  _defer$1 = setImmediate;
} else if (hasNextTick) {
  _defer$1 = process.nextTick;
} else {
  _defer$1 = fallback;
}
var setImmediate$1 = wrap(_defer$1);
function asyncify(func) {
  if (isAsync(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise = func.apply(this, args);
      return handlePromise(promise, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise, callback) {
  return promise.then((value) => {
    invokeCallback(callback, null, value);
  }, (err) => {
    invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
  });
}
function invokeCallback(callback, error2, value) {
  try {
    callback(error2, value);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
function isAsync(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function") throw new Error("expected a function");
  return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity) {
  if (!arity) arity = asyncFn.length;
  if (!arity) throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve, reject2) => {
      args[arity - 1] = (err, ...cbArgs) => {
        if (err) return reject2(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  return awaitable;
}
function applyEach$1(eachfn) {
  return function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _, iterCb) => {
    var index = counter++;
    _iteratee(value, (err, v) => {
      results[index] = v;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
function isArrayLike(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
var breakLoop = {};
function once(fn) {
  function wrapper(...args) {
    if (fn === null) return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  Object.assign(wrapper, fn);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return function next() {
    return ++i < len ? { value: coll[i], key: i } : null;
  };
}
function createES2015Iterator(iterator) {
  var i = -1;
  return function next() {
    var item = iterator.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i];
    if (key === "__proto__") {
      return next();
    }
    return i < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike(coll)) {
    return createArrayIterator(coll);
  }
  var iterator = getIterator(coll);
  return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null) throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done) return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done) return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled) return;
    if (err) return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err) {
    if (canceled) return;
    awaiting = false;
    done = true;
    callback(err);
  }
  replenish();
}
var eachOfLimit$2 = (limit) => {
  return (obj, iteratee, callback) => {
    callback = once(callback);
    if (limit <= 0) {
      throw new RangeError("concurrency limit cannot be less than 1");
    }
    if (!obj) {
      return callback(null);
    }
    if (isAsyncGenerator(obj)) {
      return asyncEachOfLimit(obj, limit, iteratee, callback);
    }
    if (isAsyncIterable(obj)) {
      return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
    }
    var nextElem = createIterator(obj);
    var done = false;
    var canceled = false;
    var running = 0;
    var looping = false;
    function iterateeCallback(err, value) {
      if (canceled) return;
      running -= 1;
      if (err) {
        done = true;
        callback(err);
      } else if (err === false) {
        done = true;
        canceled = true;
      } else if (value === breakLoop || done && running <= 0) {
        done = true;
        return callback(null);
      } else if (!looping) {
        replenish();
      }
    }
    function replenish() {
      looping = true;
      while (running < limit && !done) {
        var elem = nextElem();
        if (elem === null) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
      }
      looping = false;
    }
    replenish();
  };
};
function eachOfLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}
var eachOfLimit$1 = awaitify(eachOfLimit, 4);
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once(callback);
  var index = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true) return;
    if (err) {
      callback(err);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  for (; index < length; index++) {
    iteratee(coll[index], index, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
var eachOf$1 = awaitify(eachOf, 3);
function map(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
var map$1 = awaitify(map, 3);
var applyEach = applyEach$1(map$1);
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$1(coll, 1, iteratee, callback);
}
var eachOfSeries$1 = awaitify(eachOfSeries, 3);
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
var mapSeries$1 = awaitify(mapSeries, 3);
var applyEachSeries = applyEach$1(mapSeries$1);
var PROMISE_SYMBOL = Symbol("promiseCallback");
var DLL = class {
  constructor() {
    this.head = this.tail = null;
    this.length = 0;
  }
  removeLink(node) {
    if (node.prev) node.prev.next = node.next;
    else this.head = node.next;
    if (node.next) node.next.prev = node.prev;
    else this.tail = node.prev;
    node.prev = node.next = null;
    this.length -= 1;
    return node;
  }
  empty() {
    while (this.head) this.shift();
    return this;
  }
  insertAfter(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;
    else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
  }
  insertBefore(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;
    else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
  }
  unshift(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
  }
  push(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
  }
  shift() {
    return this.head && this.removeLink(this.head);
  }
  pop() {
    return this.tail && this.removeLink(this.tail);
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    var cur = this.head;
    while (cur) {
      yield cur.data;
      cur = cur.next;
    }
  }
  remove(testFn) {
    var curr = this.head;
    while (curr) {
      var { next } = curr;
      if (testFn(curr)) {
        this.removeLink(curr);
      }
      curr = next;
    }
    return this;
  }
};
function setInitial(dll, node) {
  dll.length = 1;
  dll.head = dll.tail = node;
}
function queue$1(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on(event, handler) {
    events[event].push(handler);
  }
  function once2(event, handler) {
    const handleAndRemove = (...args) => {
      off(event, handleAndRemove);
      handler(...args);
    };
    events[event].push(handleAndRemove);
  }
  function off(event, handler) {
    if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
    if (!handler) return events[event] = [];
    events[event] = events[event].filter((ev) => ev !== handler);
  }
  function trigger(event, ...args) {
    events[event].forEach((handler) => handler(...args));
  }
  var processingScheduled = false;
  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback(err, ...args) {
      if (err) return rejectOnError ? rej(err) : res();
      if (args.length <= 1) return res(args[0]);
      res(args);
    }
    var item = q._createTaskItem(
      data,
      rejectOnError ? promiseCallback : callback || promiseCallback
    );
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve, reject2) => {
        res = resolve;
        rej = reject2;
      });
    }
  }
  function _createCB(tasks) {
    return function(err, ...args) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index = workersList.indexOf(task);
        if (index === 0) {
          workersList.shift();
        } else if (index > 0) {
          workersList.splice(index, 1);
        }
        task.callback(err, ...args);
        if (err != null) {
          trigger("error", err, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  const eventMethod = (name) => (handler) => {
    if (!handler) {
      return new Promise((resolve, reject2) => {
        once2(name, (err, data) => {
          if (err) return reject2(err);
          resolve(data);
        });
      });
    }
    off(name);
    on(name, handler);
  };
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    _createTaskItem(data, callback) {
      return {
        data,
        callback
      };
    },
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data, false, false, callback);
    },
    pushAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data, false, true, callback);
    },
    kill() {
      off();
      q._tasks.empty();
    },
    unshift(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data, true, false, callback);
    },
    unshiftAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data = [];
        var l = q._tasks.length;
        if (q.payload) l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node = q._tasks.shift();
          tasks.push(node);
          workersList.push(node);
          data.push(node.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
function reduce(coll, memo, iteratee, callback) {
  callback = once(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err, v) => {
      memo = v;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
var reduce$1 = awaitify(reduce, 4);
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
}
var mapLimit$1 = awaitify(mapLimit, 4);
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, ...args) => {
      if (err) return iterCb(err);
      return iterCb(err, args);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err, result);
  });
}
var concatLimit$1 = awaitify(concatLimit, 4);
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
var concat$1 = awaitify(concat, 3);
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
var concatSeries$1 = awaitify(concatSeries, 3);
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _, callback) => {
      iteratee(value, (err, result) => {
        if (err || err === false) return callback(err);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err) return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
var detect$1 = awaitify(detect, 3);
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var detectLimit$1 = awaitify(detectLimit, 4);
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
var detectSeries$1 = awaitify(detectSeries, 3);
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
var dir = consoleFunc("dir");
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next(err, ...args) {
    if (err) return callback(err);
    if (err === false) return;
    results = args;
    _test(...args, check);
  }
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return check(null, true);
}
var doWhilst$1 = awaitify(doWhilst, 3);
function _withoutIndex(iteratee) {
  return (value, index, callback) => iteratee(value, callback);
}
function eachLimit$2(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var each = awaitify(eachLimit$2, 3);
function eachLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var eachLimit$1 = awaitify(eachLimit, 4);
function eachSeries(coll, iteratee, callback) {
  return eachLimit$1(coll, 1, iteratee, callback);
}
var eachSeries$1 = awaitify(eachSeries, 3);
function ensureAsync(fn) {
  if (isAsync(fn)) return fn;
  return function(...args) {
    var callback = args.pop();
    var sync = true;
    args.push((...innerArgs) => {
      if (sync) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync = false;
  };
}
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
var every$1 = awaitify(every, 3);
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var everyLimit$1 = awaitify(everyLimit, 4);
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
var everySeries$1 = awaitify(everySeries, 3);
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index, iterCb) => {
    iteratee(x, (err, v) => {
      truthValues[index] = !!v;
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i]) results.push(arr[i]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index, iterCb) => {
    iteratee(x, (err, v) => {
      if (err) return iterCb(err);
      if (v) {
        results.push({ index, value: x });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
  return filter2(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
var filter$1 = awaitify(filter, 3);
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
}
var filterLimit$1 = awaitify(filterLimit, 4);
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
var filterSeries$1 = awaitify(filterSeries, 3);
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next(err) {
    if (err) return done(err);
    if (err === false) return;
    task(next);
  }
  return next();
}
var forever$1 = awaitify(forever, 2);
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err) return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
var groupByLimit$1 = awaitify(groupByLimit, 4);
var log2 = consoleFunc("log");
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit$2(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err, result) => {
      if (err) return next(err);
      newObj[key] = result;
      next(err);
    });
  }, (err) => callback(err, newObj));
}
var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
var _defer;
if (hasNextTick) {
  _defer = process.nextTick;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else {
  _defer = fallback;
}
var nextTick = wrap(_defer);
var _parallel = awaitify((eachfn, tasks, callback) => {
  var results = isArrayLike(tasks) ? [] : {};
  eachfn(tasks, (task, key, taskCb) => {
    wrapAsync(task)((err, ...result) => {
      if (result.length < 2) {
        [result] = result;
      }
      results[key] = result;
      taskCb(err);
    });
  }, (err) => callback(err, results));
}, 3);
function queue(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue$1((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
function race(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length) return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
var race$1 = awaitify(race, 2);
function reject$2(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err, v) => {
      cb(err, !v);
    });
  }, callback);
}
function reject(coll, iteratee, callback) {
  return reject$2(eachOf$1, coll, iteratee, callback);
}
var reject$1 = awaitify(reject, 3);
function rejectLimit(coll, limit, iteratee, callback) {
  return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
}
var rejectLimit$1 = awaitify(rejectLimit, 4);
function rejectSeries(coll, iteratee, callback) {
  return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
var rejectSeries$1 = awaitify(rejectSeries, 3);
function some(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
var some$1 = awaitify(some, 3);
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var someLimit$1 = awaitify(someLimit, 4);
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
var someSeries$1 = awaitify(someSeries, 3);
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1(coll, (x, iterCb) => {
    _iteratee(x, (err, criteria) => {
      if (err) return iterCb(err);
      iterCb(err, { value: x, criteria });
    });
  }, (err, results) => {
    if (err) return callback(err);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
var sortBy$1 = awaitify(sortBy, 3);
function tryEach(tasks, callback) {
  var error2 = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args) => {
      if (err === false) return taskCb(err);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error2 = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error2, result));
}
var tryEach$1 = awaitify(tryEach);
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next(err, ...rest) {
    if (err) return callback(err);
    results = rest;
    if (err === false) return;
    _test(check);
  }
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return _test(check);
}
var whilst$1 = awaitify(whilst, 3);
function waterfall(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length) return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next));
  }
  function next(err, ...args) {
    if (err === false) return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args);
    }
    nextTask(args);
  }
  nextTask([]);
}
var waterfall$1 = awaitify(waterfall);

// src/framework.ts
init_logger();
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);
var _pluralize = require('pluralize'); var _pluralize2 = _interopRequireDefault(_pluralize);

// src/progress.ts
var _cliprogress = require('cli-progress'); var cliProgress = _interopRequireWildcard(_cliprogress);
var MAX_NAME_LENGTH = 40;
function fitNameToSpaces(name, length) {
  const padded = name.padEnd(length);
  if (padded.length <= length) {
    return padded;
  }
  return padded.substring(0, length - 3) + "...";
}
var BarProgressReporter = (_class14 = class {
  
  __init47() {this.bars = {}}
  constructor() {;_class14.prototype.__init47.call(this);
    this.multiBar = new cliProgress.MultiBar(
      {
        clearOnComplete: false,
        format: " {bar} | {evaluator} | {percentage}% | {value}/{total} datapoints",
        autopadding: true
      },
      cliProgress.Presets.shades_grey
    );
  }
  start(name, total) {
    const bar = this.multiBar.create(total, 0);
    this.bars[name] = bar;
  }
  stop() {
    this.multiBar.stop();
  }
  increment(name) {
    this.bars[name].increment({
      evaluator: fitNameToSpaces(name, MAX_NAME_LENGTH)
    });
  }
}, _class14);

// src/framework.ts
init_util2();

// src/eval-parameters.ts
init_logger();


// src/framework2.ts

var _slugify = require('slugify'); var _slugify2 = _interopRequireDefault(_slugify);
init_generated_types();
init_util();
init_logger();

var ProjectBuilder = class {
  create(opts) {
    return new Project2(opts);
  }
};
var projects = new ProjectBuilder();
var Project2 = (_class15 = class {
  
  
  
  
  
  __init48() {this._publishableCodeFunctions = []}
  __init49() {this._publishablePrompts = []}
  constructor(args) {;_class15.prototype.__init48.call(this);_class15.prototype.__init49.call(this);
    _initializeSpanContext();
    this.name = "name" in args ? args.name : void 0;
    this.id = "id" in args ? args.id : void 0;
    this.tools = new ToolBuilder(this);
    this.prompts = new PromptBuilder(this);
    this.scorers = new ScorerBuilder(this);
  }
  addPrompt(prompt) {
    this._publishablePrompts.push(prompt);
    if (globalThis._lazy_load) {
      globalThis._evals.prompts.push(prompt);
    }
  }
  addCodeFunction(fn) {
    this._publishableCodeFunctions.push(fn);
    if (globalThis._lazy_load) {
      globalThis._evals.functions.push(fn);
    }
  }
  async publish() {
    if (globalThis._lazy_load) {
      console.warn("publish() is a no-op when running `braintrust push`.");
      return;
    }
    await login();
    const projectMap = new ProjectNameIdMap();
    const functionDefinitions = [];
    if (this._publishableCodeFunctions.length > 0) {
      console.warn(
        "Code functions cannot be published directly. Use `braintrust push` instead."
      );
    }
    if (this._publishablePrompts.length > 0) {
      for (const prompt of this._publishablePrompts) {
        const functionDefinition = await prompt.toFunctionDefinition(projectMap);
        functionDefinitions.push(functionDefinition);
      }
    }
    await _internalGetGlobalState().apiConn().post_json("insert-functions", {
      functions: functionDefinitions
    });
  }
}, _class15);
var ToolBuilder = (_class16 = class {
  constructor(project) {;_class16.prototype.__init50.call(this);
    this.project = project;
  }
  __init50() {this.taskCounter = 0}
  // This type definition is just a catch all so that the implementation can be
  // less specific than the two more specific declarations above.
  create(opts) {
    this.taskCounter++;
    opts = _nullishCoalesce(opts, () => ( {}));
    const { handler, name, slug, parameters, returns, ...rest } = opts;
    let resolvedName = _nullishCoalesce(name, () => ( handler.name));
    if (resolvedName.trim().length === 0) {
      resolvedName = `Tool ${path.default.basename(__filename)} ${this.taskCounter}`;
    }
    const tool = new CodeFunction(this.project, {
      handler,
      name: resolvedName,
      slug: _nullishCoalesce(slug, () => ( _slugify2.default.call(void 0, resolvedName, { lower: true, strict: true }))),
      type: "tool",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/consistent-type-assertions
      parameters,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/consistent-type-assertions
      returns,
      ...rest
    });
    this.project.addCodeFunction(tool);
    return tool;
  }
}, _class16);
var ScorerBuilder = (_class17 = class {
  constructor(project) {;_class17.prototype.__init51.call(this);
    this.project = project;
  }
  __init51() {this.taskCounter = 0}
  create(opts) {
    this.taskCounter++;
    let resolvedName = opts.name;
    if (!resolvedName && "handler" in opts) {
      resolvedName = opts.handler.name;
    }
    if (!resolvedName || resolvedName.trim().length === 0) {
      resolvedName = `Scorer ${path.default.basename(__filename)} ${this.taskCounter}`;
    }
    const slug = _nullishCoalesce(opts.slug, () => ( _slugify2.default.call(void 0, resolvedName, { lower: true, strict: true })));
    if ("handler" in opts) {
      const scorer = new CodeFunction(this.project, {
        ...opts,
        name: resolvedName,
        slug,
        type: "scorer"
      });
      this.project.addCodeFunction(scorer);
    } else {
      const promptBlock = "messages" in opts ? {
        type: "chat",
        messages: opts.messages
      } : {
        type: "completion",
        content: opts.prompt
      };
      const promptData = {
        prompt: promptBlock,
        options: {
          model: opts.model,
          params: opts.params
        },
        parser: {
          type: "llm_classifier",
          use_cot: opts.useCot,
          choice_scores: opts.choiceScores
        }
      };
      const codePrompt = new CodePrompt(
        this.project,
        promptData,
        [],
        {
          ...opts,
          name: resolvedName,
          slug
        },
        "scorer"
      );
      this.project.addPrompt(codePrompt);
    }
  }
}, _class17);
var CodeFunction = class {
  constructor(project, opts) {
    this.project = project;
    this.handler = opts.handler;
    this.name = opts.name;
    this.slug = opts.slug;
    this.description = opts.description;
    this.type = opts.type;
    this.ifExists = opts.ifExists;
    this.parameters = opts.parameters;
    this.returns = opts.returns;
    if (this.returns && !this.parameters) {
      throw new Error("parameters are required if return type is defined");
    }
  }
  
  
  
  
  
  
  
  
  key() {
    return JSON.stringify([
      _nullishCoalesce(this.project.id, () => ( "")),
      _nullishCoalesce(this.project.name, () => ( "")),
      this.slug
    ]);
  }
};
var CodePrompt = class {
  
  
  
  
  
  
  
  
  
  constructor(project, prompt, toolFunctions, opts, functionType) {
    this.project = project;
    this.name = opts.name;
    this.slug = opts.slug;
    this.prompt = prompt;
    this.toolFunctions = toolFunctions;
    this.ifExists = opts.ifExists;
    this.description = opts.description;
    this.id = opts.id;
    this.functionType = functionType;
  }
  async toFunctionDefinition(projectNameToId) {
    const prompt_data = {
      ...this.prompt
    };
    if (this.toolFunctions.length > 0) {
      const resolvableToolFunctions = await Promise.all(
        this.toolFunctions.map(async (fn) => {
          if ("slug" in fn) {
            return {
              type: "slug",
              project_id: await projectNameToId.resolve(fn.project),
              slug: fn.slug
            };
          } else {
            return fn;
          }
        })
      );
      prompt_data.tool_functions = // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      resolvableToolFunctions;
    }
    return {
      project_id: await projectNameToId.resolve(this.project),
      name: this.name,
      slug: this.slug,
      description: _nullishCoalesce(this.description, () => ( "")),
      function_data: {
        type: "prompt"
      },
      function_type: this.functionType,
      prompt_data,
      if_exists: this.ifExists
    };
  }
};
var promptContentsSchema = _v3.z.union([
  _v3.z.object({
    prompt: _v3.z.string()
  }),
  _v3.z.object({
    messages: _v3.z.array(ChatCompletionMessageParam)
  })
]);
var promptDefinitionSchema = promptContentsSchema.and(
  _v3.z.object({
    model: _v3.z.string(),
    params: ModelParams.optional()
  })
);
var promptDefinitionWithToolsSchema = promptDefinitionSchema.and(
  _v3.z.object({
    tools: _v3.z.array(ToolFunctionDefinition).optional()
  })
);
var PromptBuilder = class {
  constructor(project) {
    this.project = project;
  }
  create(opts) {
    const toolFunctions = [];
    const rawTools = [];
    for (const tool of _nullishCoalesce(opts.tools, () => ( []))) {
      if (tool instanceof CodeFunction) {
        toolFunctions.push(tool);
      } else if ("type" in tool && !("function" in tool)) {
        toolFunctions.push(tool);
      } else {
        rawTools.push(tool);
      }
    }
    const slug = _nullishCoalesce(opts.slug, () => ( _slugify2.default.call(void 0, opts.name, { lower: true, strict: true })));
    const promptData = promptDefinitionToPromptData(opts, rawTools);
    const promptRow = {
      id: opts.id,
      _xact_id: opts.version ? loadPrettyXact(opts.version) : void 0,
      name: opts.name,
      slug,
      prompt_data: promptData,
      ...this.project.id !== void 0 ? { project_id: this.project.id } : {}
    };
    const prompt = new Prompt2(
      promptRow,
      {},
      // It doesn't make sense to specify defaults here.
      _nullishCoalesce(opts.noTrace, () => ( false))
    );
    const codePrompt = new CodePrompt(this.project, promptData, toolFunctions, {
      ...opts,
      slug
    });
    this.project.addPrompt(codePrompt);
    return prompt;
  }
};
function promptDefinitionToPromptData(promptDefinition, rawTools) {
  const promptBlock = "messages" in promptDefinition ? {
    type: "chat",
    messages: promptDefinition.messages,
    tools: rawTools && rawTools.length > 0 ? JSON.stringify(rawTools) : void 0
  } : {
    type: "completion",
    content: promptDefinition.prompt
  };
  return {
    prompt: promptBlock,
    options: {
      model: promptDefinition.model,
      params: promptDefinition.params
    }
  };
}
var ProjectNameIdMap = (_class18 = class {constructor() { _class18.prototype.__init52.call(this);_class18.prototype.__init53.call(this); }
  __init52() {this.nameToId = {}}
  __init53() {this.idToName = {}}
  async getId(projectName) {
    if (!(projectName in this.nameToId)) {
      const response = await _internalGetGlobalState().appConn().post_json("api/project/register", {
        project_name: projectName
      });
      const result = _v3.z.object({
        project: Project
      }).parse(response);
      const projectId = result.project.id;
      this.nameToId[projectName] = projectId;
      this.idToName[projectId] = projectName;
    }
    return this.nameToId[projectName];
  }
  async getName(projectId) {
    if (!(projectId in this.idToName)) {
      const response = await _internalGetGlobalState().appConn().post_json("api/project/get", {
        id: projectId
      });
      const result = _v3.z.array(Project).nonempty().parse(response);
      const projectName = result[0].name;
      this.idToName[projectId] = projectName;
      this.nameToId[projectName] = projectId;
    }
    return this.idToName[projectId];
  }
  async resolve(project) {
    if (project.id) {
      return project.id;
    }
    return this.getId(project.name);
  }
}, _class18);

// src/eval-parameters.ts
init_generated_types();
var evalParametersSchema = _v3.z.record(
  _v3.z.string(),
  _v3.z.union([
    _v3.z.object({
      type: _v3.z.literal("prompt"),
      default: promptDefinitionWithToolsSchema.optional(),
      description: _v3.z.string().optional()
    }),
    _v3.z.instanceof(_v3.z.ZodType)
    // For Zod schemas
  ])
);
function validateParameters(parameters, parameterSchema) {
  return Object.fromEntries(
    Object.entries(parameterSchema).map(([name, schema]) => {
      const value = parameters[name];
      try {
        if ("type" in schema && schema.type === "prompt") {
          const promptData = value ? PromptData.parse(value) : schema.default ? promptDefinitionToPromptData(
            schema.default,
            schema.default.tools
          ) : void 0;
          if (!promptData) {
            throw new Error(`Parameter '${name}' is required`);
          }
          return [name, Prompt2.fromPromptData(name, promptData)];
        } else {
          const schemaCasted = schema;
          return [name, schemaCasted.parse(value)];
        }
      } catch (e) {
        console.error("Error validating parameter", name, e);
        throw Error(
          `Invalid parameter '${name}': ${e instanceof Error ? e.message : String(e)}`
        );
      }
    })
  );
}

// src/framework.ts
function BaseExperiment(options = {}) {
  return { _type: "BaseExperiment", ...options };
}
var EvalResultWithSummary = class {
  constructor(summary, results) {
    this.summary = summary;
    this.results = results;
  }
  toString() {
    return formatExperimentSummary(this.summary);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `EvalResultWithSummary(summary="...", results=[...])`;
  }
  toJSON() {
    return {
      summary: this.summary,
      results: this.results
    };
  }
};
function makeEvalName(projectName, experimentName) {
  let out = projectName;
  if (experimentName) {
    out += ` [experimentName=${experimentName}]`;
  }
  return out;
}
function initExperiment2(state, options = {}) {
  return init({
    state,
    ...options,
    setCurrent: false
  });
}
function callEvaluatorData(data) {
  const dataResult = typeof data === "function" ? data() : data;
  let baseExperiment = void 0;
  if ("_type" in dataResult && dataResult._type === "BaseExperiment") {
    baseExperiment = dataResult.name;
  }
  return {
    data: dataResult,
    baseExperiment
  };
}
globalThis._evals = {
  functions: [],
  prompts: [],
  evaluators: {},
  reporters: {}
};
function _initializeSpanContext() {
  globalThis._spanContext = { currentSpan, withCurrent, startSpan, NOOP_SPAN };
}
async function Eval(name, evaluator, reporterOrOpts) {
  const options = isEmpty(reporterOrOpts) ? {} : typeof reporterOrOpts === "string" ? { reporter: reporterOrOpts } : "name" in reporterOrOpts ? { reporter: reporterOrOpts } : reporterOrOpts;
  let evalName = makeEvalName(name, evaluator.experimentName);
  if (globalThis._evals.evaluators[evalName]) {
    evalName = `${evalName}_${Object.keys(_evals).length}`;
  }
  if (globalThis._lazy_load) {
    globalThis._evals.evaluators[evalName] = {
      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      evaluator: {
        evalName,
        projectName: name,
        ...evaluator
      },
      reporter: options.reporter
    };
    _initializeSpanContext();
    return new EvalResultWithSummary(
      {
        scores: {},
        metrics: {},
        projectName: "",
        experimentName: ""
      },
      []
    );
  }
  const progressReporter = _nullishCoalesce(options.progress, () => ( new BarProgressReporter()));
  if (typeof options.reporter === "string") {
    throw new Error(
      "Must specify a reporter object, not a name. Can only specify reporter names when running 'braintrust eval'"
    );
  }
  const resolvedReporter = options.reporter || defaultReporter;
  try {
    const { data, baseExperiment: defaultBaseExperiment } = callEvaluatorData(
      evaluator.data
    );
    const experiment = options.parent || options.noSendLogs ? null : initExperiment2(evaluator.state, {
      ...evaluator.projectId ? { projectId: evaluator.projectId } : { project: name },
      experiment: evaluator.experimentName,
      description: evaluator.description,
      metadata: evaluator.metadata,
      isPublic: evaluator.isPublic,
      update: evaluator.update,
      baseExperiment: _nullishCoalesce(evaluator.baseExperimentName, () => ( defaultBaseExperiment)),
      baseExperimentId: evaluator.baseExperimentId,
      gitMetadataSettings: evaluator.gitMetadataSettings,
      repoInfo: evaluator.repoInfo,
      dataset: Dataset2.isDataset(data) ? data : void 0
    });
    if (experiment && typeof process !== "undefined" && _optionalChain([process, 'access', _125 => _125.env, 'optionalAccess', _126 => _126.BRAINTRUST_OTEL_COMPAT, 'optionalAccess', _127 => _127.toLowerCase, 'call', _128 => _128()]) === "true") {
      await experiment._waitForId();
    }
    if (experiment && options.onStart) {
      const summary = await experiment.summarize({ summarizeScores: false });
      options.onStart(summary);
    }
    try {
      const evalDef = {
        evalName,
        projectName: name,
        ...evaluator,
        data
      };
      let ret;
      if (options.parent) {
        ret = await withParent(
          options.parent,
          () => runEvaluator(
            null,
            evalDef,
            progressReporter,
            [],
            options.stream,
            options.parameters
          ),
          evaluator.state
        );
      } else {
        ret = await runEvaluator(
          experiment,
          evalDef,
          progressReporter,
          [],
          options.stream,
          options.parameters
        );
      }
      progressReporter.stop();
      resolvedReporter.reportEval(evalDef, ret, {
        verbose: true,
        jsonl: false
      });
      return ret;
    } finally {
      if (experiment) {
        experiment.flush().catch(console.error);
      } else if (options.parent) {
        flush().catch(console.error);
      }
    }
  } finally {
    progressReporter.stop();
  }
}
function Reporter(name, reporter) {
  const ret = { name, ...reporter };
  if (_evals.reporters[name]) {
    throw new Error(`Reporter ${name} already exists`);
  }
  if (globalThis._lazy_load) {
    _evals.reporters[name] = ret;
  }
  return ret;
}
function serializeJSONWithPlainString(v) {
  if (typeof v === "string") {
    return v;
  } else {
    return JSON.stringify(v);
  }
}
function evaluateFilter(object, filter2) {
  const { path: path3, pattern } = filter2;
  const key = path3.reduce(
    (acc, p) => typeof acc === "object" && acc !== null ? (
      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      acc[p]
    ) : void 0,
    object
  );
  if (key === void 0) {
    return false;
  }
  return pattern.test(serializeJSONWithPlainString(key));
}
function scorerName(scorer, scorer_idx) {
  return scorer.name || `scorer_${scorer_idx}`;
}
async function runEvaluator(experiment, evaluator, progressReporter, filters, stream, parameters) {
  return await runEvaluatorInternal(
    experiment,
    evaluator,
    progressReporter,
    filters,
    stream,
    parameters
  );
}
var defaultErrorScoreHandler = ({
  rootSpan,
  data: _,
  unhandledScores
}) => {
  const scores = Object.fromEntries(unhandledScores.map((s) => [s, 0]));
  rootSpan.log({ scores });
  return scores;
};
async function runEvaluatorInternal(experiment, evaluator, progressReporter, filters, stream, parameters) {
  if (typeof evaluator.data === "string") {
    throw new Error("Unimplemented: string data paths");
  }
  let dataResult = typeof evaluator.data === "function" ? evaluator.data() : evaluator.data;
  parameters = validateParameters(_nullishCoalesce(parameters, () => ( {})), _nullishCoalesce(evaluator.parameters, () => ( {})));
  if ("_type" in dataResult) {
    if (dataResult._type !== "BaseExperiment") {
      throw new Error("Invalid _type");
    }
    if (!experiment) {
      throw new Error(
        "Cannot use BaseExperiment() without connecting to Braintrust (you most likely set --no-send-logs)"
      );
    }
    let name = dataResult.name;
    if (isEmpty(name)) {
      const baseExperiment = await experiment.fetchBaseExperiment();
      if (!baseExperiment) {
        throw new Error("BaseExperiment() failed to fetch base experiment");
      }
      name = baseExperiment.name;
    }
    dataResult = initExperiment2(evaluator.state, {
      ...evaluator.projectId ? { projectId: evaluator.projectId } : { project: evaluator.projectName },
      experiment: name,
      open: true
    }).asDataset();
  }
  let data = [];
  if (dataResult instanceof Promise) {
    data = await dataResult;
  } else if (Symbol.asyncIterator in dataResult) {
    data = [];
    for await (const d of dataResult) {
      data.push(d);
    }
  } else {
    data = dataResult;
  }
  const dataWithTrials = data.filter((d) => filters.every((f) => evaluateFilter(d, f))).flatMap(
    (datum) => [...Array(_nullishCoalesce(evaluator.trialCount, () => ( 1))).keys()].map((trialIndex) => ({
      datum,
      trialIndex
    }))
  );
  progressReporter.start(evaluator.evalName, dataWithTrials.length);
  const results = [];
  const q = queue(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async ({
      datum,
      trialIndex
    }) => {
      const eventDataset = experiment ? experiment.dataset : Dataset2.isDataset(evaluator.data) ? evaluator.data : void 0;
      const baseEvent = {
        name: "eval",
        spanAttributes: {
          type: "eval" /* EVAL */
        },
        event: {
          input: datum.input,
          expected: "expected" in datum ? datum.expected : void 0,
          tags: datum.tags,
          origin: eventDataset && datum.id && datum._xact_id ? {
            object_type: "dataset",
            object_id: await eventDataset.id,
            id: datum.id,
            created: datum.created,
            _xact_id: datum._xact_id
          } : void 0,
          ...datum.upsert_id ? { id: datum.upsert_id } : {}
        }
      };
      const callback = async (rootSpan) => {
        let metadata = {
          ..."metadata" in datum ? datum.metadata : {}
        };
        const expected = "expected" in datum ? datum.expected : void 0;
        let output = void 0;
        let error2 = void 0;
        let tags = [..._nullishCoalesce(datum.tags, () => ( []))];
        const scores = {};
        const scorerNames = evaluator.scores.map(scorerName);
        let unhandledScores = scorerNames;
        try {
          const meta = (o) => metadata = { ...metadata, ...o };
          await rootSpan.traced(
            async (span) => {
              const hooksForTask = {
                meta,
                metadata,
                expected,
                span,
                parameters: _nullishCoalesce(parameters, () => ( {})),
                reportProgress: (event) => {
                  _optionalChain([stream, 'optionalCall', _129 => _129({
                    ...event,
                    id: rootSpan.id,
                    origin: _optionalChain([baseEvent, 'access', _130 => _130.event, 'optionalAccess', _131 => _131.origin]),
                    name: evaluator.evalName,
                    object_type: "task"
                  })]);
                },
                trialIndex,
                tags
              };
              const outputResult = evaluator.task(datum.input, hooksForTask);
              if (outputResult instanceof Promise) {
                output = await outputResult;
              } else {
                output = outputResult;
              }
              tags = _nullishCoalesce(hooksForTask.tags, () => ( []));
              span.log({ output });
            },
            {
              name: "task",
              spanAttributes: { type: "task" /* TASK */ },
              event: { input: datum.input }
            }
          );
          if (tags.length) {
            rootSpan.log({ output, metadata, expected, tags });
          } else {
            rootSpan.log({ output, metadata, expected });
          }
          const scoringArgs = {
            input: datum.input,
            expected: "expected" in datum ? datum.expected : void 0,
            metadata,
            output
          };
          const scoreResults = await Promise.all(
            evaluator.scores.map(async (score, score_idx) => {
              try {
                const runScorer = async (span) => {
                  const scoreResult = score(scoringArgs);
                  const scoreValue = scoreResult instanceof Promise ? await scoreResult : scoreResult;
                  if (scoreValue === null) {
                    return null;
                  }
                  if (Array.isArray(scoreValue)) {
                    for (const s of scoreValue) {
                      if (!(typeof s === "object" && !isEmpty(s))) {
                        throw new Error(
                          `When returning an array of scores, each score must be a non-empty object. Got: ${JSON.stringify(
                            s
                          )}`
                        );
                      }
                    }
                  }
                  const results3 = Array.isArray(scoreValue) ? scoreValue : typeof scoreValue === "object" && !isEmpty(scoreValue) ? [scoreValue] : [
                    {
                      name: scorerNames[score_idx],
                      score: scoreValue
                    }
                  ];
                  const getOtherFields = (s) => {
                    const { metadata: _metadata, name: _name, ...rest } = s;
                    return rest;
                  };
                  const resultMetadata = results3.length === 1 ? results3[0].metadata : results3.reduce(
                    (prev, s) => mergeDicts(prev, {
                      [s.name]: s.metadata
                    }),
                    {}
                  );
                  const resultOutput = results3.length === 1 ? getOtherFields(results3[0]) : results3.reduce(
                    (prev, s) => mergeDicts(prev, { [s.name]: getOtherFields(s) }),
                    {}
                  );
                  const scores2 = results3.reduce(
                    (prev, s) => mergeDicts(prev, { [s.name]: s.score }),
                    {}
                  );
                  span.log({
                    output: resultOutput,
                    metadata: resultMetadata,
                    scores: scores2
                  });
                  return results3;
                };
                const results2 = await rootSpan.traced(runScorer, {
                  name: scorerNames[score_idx],
                  spanAttributes: {
                    type: "score" /* SCORE */
                  },
                  event: { input: scoringArgs }
                });
                return { kind: "score", value: results2 };
              } catch (e) {
                return { kind: "error", value: e };
              }
            })
          );
          const failingScorersAndResults = [];
          scoreResults.forEach((results2, i) => {
            const name = scorerNames[i];
            if (results2.kind === "score") {
              (results2.value || []).forEach((result) => {
                scores[result.name] = result.score;
              });
            } else {
              failingScorersAndResults.push({ name, error: results2.value });
            }
          });
          unhandledScores = null;
          if (failingScorersAndResults.length) {
            const scorerErrors = Object.fromEntries(
              failingScorersAndResults.map(({ name, error: error3 }) => [
                name,
                error3 instanceof Error ? error3.stack : `${error3}`
              ])
            );
            metadata["scorer_errors"] = scorerErrors;
            rootSpan.log({
              metadata: { scorer_errors: scorerErrors }
            });
            const names = Object.keys(scorerErrors).join(", ");
            const errors = failingScorersAndResults.map((item) => item.error);
            unhandledScores = Object.keys(scorerErrors);
            console.warn(
              `Found exceptions for the following scorers: ${names}`,
              errors
            );
          }
        } catch (e) {
          logError(rootSpan, e);
          error2 = e;
        } finally {
          progressReporter.increment(evaluator.evalName);
        }
        results.push({
          input: datum.input,
          ..."expected" in datum ? { expected: datum.expected } : {},
          output,
          tags: tags.length ? tags : void 0,
          metadata,
          scores: {
            ...evaluator.errorScoreHandler && unhandledScores ? evaluator.errorScoreHandler({
              rootSpan,
              data: datum,
              unhandledScores
            }) : void 0,
            ...scores
          },
          error: error2,
          origin: _optionalChain([baseEvent, 'access', _132 => _132.event, 'optionalAccess', _133 => _133.origin])
        });
      };
      if (!experiment) {
        return await traced(callback, {
          ...baseEvent,
          state: evaluator.state
        });
      } else {
        return await experiment.traced(callback, baseEvent);
      }
    },
    Math.max(_nullishCoalesce(evaluator.maxConcurrency, () => ( dataWithTrials.length)), 1)
  );
  q.push(dataWithTrials);
  const cancel = async () => {
    await new Promise((_, reject2) => {
      if (evaluator.timeout) {
        setTimeout(() => {
          reject2(new InternalAbortError("Evaluator timed out"));
        }, evaluator.timeout);
      }
      if (evaluator.signal) {
        evaluator.signal.addEventListener("abort", () => {
          reject2(new InternalAbortError("Evaluator aborted"));
        });
      }
    });
  };
  try {
    await Promise.race([q.drain(), cancel()]);
  } catch (e) {
    if (e instanceof InternalAbortError) {
      q.kill();
    }
    throw e;
  }
  const summary = experiment ? await experiment.summarize({ summarizeScores: evaluator.summarizeScores }) : buildLocalSummary(evaluator, results);
  return new EvalResultWithSummary(summary, results);
}
var error = _chalk2.default.bold.red;
var warning = _chalk2.default.hex("#FFA500");
function logError2(e, verbose) {
  if (!verbose) {
    console.error(`${e}`);
  } else {
    console.error(e);
  }
}
function buildLocalSummary(evaluator, results) {
  const scoresByName = {};
  for (const result of results) {
    for (const [name, score] of Object.entries(result.scores)) {
      const { total, count } = scoresByName[name] || { total: 0, count: 0 };
      if (score === null) {
        continue;
      }
      scoresByName[name] = { total: total + score, count: count + 1 };
    }
  }
  return {
    projectName: evaluator.projectName,
    experimentName: evaluator.evalName,
    scores: Object.fromEntries(
      Object.entries(scoresByName).map(([name, { total, count }]) => [
        name,
        {
          name,
          score: total / count,
          improvements: 0,
          regressions: 0
        }
      ])
    )
  };
}
function reportFailures(evaluator, failingResults, { verbose, jsonl }) {
  if (failingResults.length > 0) {
    console.error(
      warning(
        `Evaluator ${evaluator.evalName} failed with ${_pluralize2.default.call(void 0, 
          "error",
          failingResults.length,
          true
        )}. This evaluation ("${evaluator.evalName}") will not be fully logged.`
      )
    );
    if (jsonl) {
      console.log(
        JSON.stringify({
          evaluatorName: evaluator.evalName,
          errors: failingResults.map(
            (r) => `${r.error instanceof Error ? r.error.stack : r.error}`
          )
        })
      );
    } else {
      for (const result of failingResults) {
        logError2(result.error, verbose);
      }
    }
    if (!verbose && !jsonl) {
      console.error(warning("Add --verbose to see full stack traces."));
    }
  }
}
var defaultReporter = {
  name: "Braintrust default reporter",
  async reportEval(evaluator, result, { verbose, jsonl }) {
    const { results, summary } = result;
    const failingResults = results.filter(
      (r) => r.error !== void 0
    );
    if (failingResults.length > 0) {
      reportFailures(evaluator, failingResults, { verbose, jsonl });
    }
    process.stdout.write(
      jsonl ? JSON.stringify(summary) : formatExperimentSummary(summary)
    );
    process.stdout.write("\n");
    return failingResults.length === 0;
  },
  async reportRun(evalReports) {
    return evalReports.every((r) => r);
  }
};
function formatExperimentSummary(summary) {
  let comparisonLine = "";
  if (summary.comparisonExperimentName) {
    comparisonLine = `${summary.experimentName} compared to ${summary.comparisonExperimentName}:
`;
  }
  const longestScoreName = Math.max(
    ...Object.values(summary.scores).map((score) => score.name.length)
  );
  const longestMetricName = Math.max(
    ...Object.values(_nullishCoalesce(summary.metrics, () => ( {}))).map((metric) => metric.name.length)
  );
  return `
=========================SUMMARY=========================
${comparisonLine}` + Object.values(summary.scores).map((score) => formatScoreSummary(score, longestScoreName)).join("\n") + (Object.keys(summary.scores).length ? "\n\n" : "") + Object.values(_nullishCoalesce(summary.metrics, () => ( {}))).map((metric) => formatMetricSummary(metric, longestMetricName)).join("\n") + (Object.keys(_nullishCoalesce(summary.metrics, () => ( {}))).length ? "\n\n" : "") + (summary.experimentUrl ? `See results for ${summary.experimentName} at ${summary.experimentUrl}` : "");
}
function formatScoreSummary(summary, longestScoreName) {
  const diffString = isEmpty(summary.diff) ? "" : ` (${summary.diff > 0 ? "+" : ""}${(summary.diff * 100).toFixed(2)}%)`;
  const scoreName = `'${summary.name}'`.padEnd(longestScoreName + 2);
  return `${(summary.score * 100).toFixed(
    2
  )}%${diffString} ${scoreName} score	(${summary.improvements} improvements, ${summary.regressions} regressions)`;
}
function formatMetricSummary(summary, longestMetricName) {
  const fractionDigits = Number.isInteger(summary.metric) ? 0 : 2;
  const metricName = `'${summary.name}'`.padEnd(longestMetricName + 2);
  return `${summary.metric.toFixed(fractionDigits)}${summary.unit} ${metricName}	(${summary.improvements} improvements, ${summary.regressions} regressions)`;
}

// src/graph-framework.ts
var graph_framework_exports = {};
__export(graph_framework_exports, {
  AggregatorNode: () => AggregatorNode,
  GateNode: () => GateNode,
  GraphBuilder: () => GraphBuilder,
  InputNode: () => InputNode,
  LiteralNode: () => LiteralNode,
  OutputNode: () => OutputNode,
  PromptNode: () => PromptNode,
  PromptTemplateNode: () => PromptTemplateNode,
  createGraph: () => createGraph,
  default: () => graph_framework_default,
  escapePath: () => escapePath,
  unescapePath: () => unescapePath
});
init_logger();
var GraphBuilder = (_class19 = class {
  __init54() {this.nodes = /* @__PURE__ */ new Map()}
  __init55() {this.edges = {}}
  __init56() {this.nodeLikeNodes = /* @__PURE__ */ new Map()}
  // Maps node-like objects, like prompts, to their nodes
  // Special nodes
  
  
  constructor() {;_class19.prototype.__init54.call(this);_class19.prototype.__init55.call(this);_class19.prototype.__init56.call(this);
    this.IN = this.createInputNode();
    this.OUT = this.createOutputNode();
  }
  // Create the final GraphData object
  async build(context2) {
    const nodes = await Promise.all(
      Array.from(this.nodes.values()).map(async (node) => [
        node.id,
        await node.build(context2)
      ])
    );
    return {
      type: "graph",
      nodes: Object.fromEntries(nodes),
      // XXX Need to resolve the lazy nodes
      edges: this.edges
    };
  }
  addEdge({
    source,
    sourceVar,
    target,
    targetVar,
    expr,
    purpose
  }) {
    const [sourceNode, sourcePath] = this.resolveNode(source);
    if (sourcePath.length > 0) {
      throw new Error("Source path must be empty");
    }
    const [targetNode, targetPath] = this.resolveNode(target);
    if (targetPath.length > 0) {
      throw new Error("Target path must be empty");
    }
    const id = this.generateId();
    sourceVar = _nullishCoalesce(sourceVar, () => ( "output"));
    targetVar = _nullishCoalesce(targetVar, () => ( (purpose === "data" ? "input" : this.generateId("control"))));
    for (const edge of Object.values(this.edges)) {
      if (edge.target.node === targetNode.id && edge.target.variable === targetVar) {
        throw new Error(
          `Variable name ${targetVar} already set on ${targetNode.id}`
        );
      }
    }
    this.edges[id] = {
      source: { node: sourceNode.id, variable: sourceVar },
      target: { node: targetNode.id, variable: targetVar },
      purpose
    };
  }
  resolveNode(node) {
    if (node instanceof Prompt2) {
      const cached = this.nodeLikeNodes.get(node);
      if (cached) {
        return [cached, []];
      }
      const promptNode = this.createPromptNode(node);
      this.nodeLikeNodes.set(node, promptNode);
      return [promptNode, []];
    } else if (isProxyVariable(node)) {
      return proxyVariableToNode(node);
    } else {
      return [node, []];
    }
  }
  // Create a literal node
  literal(value) {
    const preview = (typeof value === "string" ? value : JSON.stringify(value)).slice(0, 16);
    const id = this.generateId(`literal-${preview}`);
    const literalNode = new LiteralNode(this, id, value);
    this.nodes.set(id, literalNode);
    return literalNode;
  }
  gate(options) {
    const id = this.generateId("gate");
    const gateNode = new GateNode(this, id, options.condition);
    this.nodes.set(id, gateNode);
    return gateNode;
  }
  aggregator() {
    const id = this.generateId("aggregator");
    const aggregatorNode = new AggregatorNode(this, id);
    this.nodes.set(id, aggregatorNode);
    return aggregatorNode;
  }
  promptTemplate(options) {
    const id = this.generateId("prompt-template");
    const promptTemplateNode = new PromptTemplateNode(this, id, options.prompt);
    this.nodes.set(id, promptTemplateNode);
    return promptTemplateNode;
  }
  // public call(node: NodeLike, input: CallArgs): Node {
  //   const [resolvedNode, path] = this.resolveNode(node);
  //   if (resolvedNode instanceof SingleInputNode) {
  //     return resolvedNode.call(input, path);
  //   } else {
  //     throw new Error("Node must be a SingleInputNode");
  //   }
  // }
  // Helper to generate node IDs
  generateId(name) {
    const uuid4 = newId();
    if (name) {
      return `${name}-${uuid4.slice(0, 8)}`;
    } else {
      return uuid4;
    }
  }
  // Create an input node
  createInputNode() {
    const id = this.generateId("input");
    const inputNode = new InputNode(this, id);
    this.nodes.set(id, inputNode);
    return inputNode;
  }
  // Create an output node
  createOutputNode() {
    const id = this.generateId("output");
    const outputNode = new OutputNode(this, id);
    this.nodes.set(id, outputNode);
    return outputNode;
  }
  // Create a prompt node from a CodePrompt
  createPromptNode(prompt) {
    const id = this.generateId(`prompt-${prompt.slug}`);
    const promptNode = new PromptNode(this, id, prompt);
    this.nodes.set(id, promptNode);
    return promptNode;
  }
}, _class19);
function isProxyVariable(node) {
  return typeof node === "object" && node !== null && "__type" in node && // @ts-ignore
  node.__type === "proxy-variable";
}
function proxyVariableToNode(proxy) {
  return [proxy.__node, proxy.__path];
}
var BaseNode = (_class20 = class {
  constructor(graph, id) {;_class20.prototype.__init57.call(this);_class20.prototype.__init58.call(this);
    this.graph = graph;
    this.id = id;
  }
  __init57() {this.__type = "node"}
  __init58() {this.dependencies = []}
  addDependency(dependency) {
    this.dependencies.push(dependency);
  }
}, _class20);
var InputNode = class extends BaseNode {
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context2) {
    return {
      type: "input",
      description: "Input to the graph"
    };
  }
};
var OutputNode = class extends BaseNode {
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context2) {
    return {
      type: "output",
      description: "Output of the graph"
    };
  }
};
var PromptNode = class extends BaseNode {
  constructor(graph, id, prompt) {
    super(graph, id);
    this.prompt = prompt;
  }
  async build(context2) {
    return {
      type: "function",
      function: await context2.getFunctionId(this.prompt)
    };
  }
};
var GateNode = class extends BaseNode {
  constructor(graph, id, condition) {
    super(graph, id);
    this.condition = condition;
  }
  async build(context2) {
    return {
      type: "gate",
      description: "Conditional gate",
      condition: this.condition
    };
  }
};
var AggregatorNode = class extends BaseNode {
  constructor(graph, id) {
    super(graph, id);
  }
  async build(context2) {
    return {
      type: "aggregator",
      description: "Aggregator"
    };
  }
};
var PromptTemplateNode = class extends BaseNode {
  constructor(graph, id, prompt) {
    super(graph, id);
    this.prompt = prompt;
  }
  async build(context2) {
    return {
      type: "prompt_template",
      prompt: this.prompt
    };
  }
};
var LiteralNode = class extends BaseNode {
  constructor(graph, id, value) {
    super(graph, id);
    this.value = value;
  }
  async build(context2) {
    return {
      type: "literal",
      value: this.value
    };
  }
};
function createGraph() {
  const graphBuilder = new GraphBuilder();
  return graphBuilder;
}
function escapePath(parts) {
  if (parts.length === 0) {
    return void 0;
  }
  return parts.map((part) => {
    if (/[^\w-]/.test(part)) {
      const escaped = part.replace(/["\\]/g, "\\$&");
      return `"${escaped}"`;
    }
    return part;
  }).join(".");
}
function unescapePath(path3) {
  const regex = /"((?:\\["\\]|[^"\\])*)"|([^\.]+)/g;
  const matches = path3.match(regex);
  return matches ? matches.map((match) => {
    if (match.startsWith('"')) {
      return match.slice(1, -1).replace(/\\(["\\])/g, "$1");
    }
    return match;
  }) : [];
}
var graph_framework_default = { createGraph };

// src/exports-node.ts
init_util2();

// src/wrappers/oai.ts
init_util();
init_logger();
init_util2();
init_util();

// src/wrappers/oai_responses.ts
init_util2();
init_logger();
init_util();
function responsesProxy(openai) {
  if (!openai.responses) {
    return openai;
  }
  return new Proxy(openai.responses, {
    get(target, name, receiver) {
      if (name === "create") {
        return responsesCreateProxy(target.create.bind(target));
      } else if (name === "stream") {
        return responsesStreamProxy(target.stream.bind(target));
      } else if (name === "parse") {
        return responsesParseProxy(target.parse.bind(target));
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
function responsesCreateProxy(target) {
  const hooks = {
    name: "openai.responses",
    toSpanFunc: parseSpanFromResponseCreateParams,
    resultToEventFunc: parseEventFromResponseCreateResult,
    traceStreamFunc: traceResponseCreateStream
  };
  return proxyCreate(target, hooks);
}
function parseSpanFromResponseCreateParams(params) {
  const spanArgs = {
    name: "openai.responses.create",
    spanAttributes: {
      type: "llm"
    },
    event: {
      input: params.input,
      metadata: {
        ...filterFrom(params, ["input"]),
        provider: "openai"
      }
    },
    startTime: getCurrentUnixTimestamp()
  };
  return {
    span: startSpan(spanArgs),
    start: spanArgs.startTime
  };
}
function parseEventFromResponseCreateResult(result) {
  const data = {};
  if (_optionalChain([result, 'optionalAccess', _134 => _134.output]) !== void 0) {
    data.output = processImagesInOutput(result.output);
  }
  if (result) {
    const { output, usage, ...metadata } = result;
    if (Object.keys(metadata).length > 0) {
      data.metadata = metadata;
    }
  }
  data.metrics = parseMetricsFromUsage(_optionalChain([result, 'optionalAccess', _135 => _135.usage]));
  return data;
}
function processImagesInOutput(output) {
  if (Array.isArray(output)) {
    return output.map(processImagesInOutput);
  }
  if (isObject(output)) {
    if (output.type === "image_generation_call" && output.result && typeof output.result === "string") {
      const fileExtension = output.output_format || "png";
      const contentType = `image/${fileExtension}`;
      const baseFilename = output.revised_prompt && typeof output.revised_prompt === "string" ? output.revised_prompt.slice(0, 50).replace(/[^a-zA-Z0-9]/g, "_") : "generated_image";
      const filename = `${baseFilename}.${fileExtension}`;
      const binaryString = atob(output.result);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const blob = new Blob([bytes], { type: contentType });
      const attachment = new Attachment({
        data: blob,
        filename,
        contentType
      });
      return {
        ...output,
        result: attachment
      };
    }
  }
  return output;
}
function parseSpanFromResponseParseParams(params) {
  const spanArgs = {
    name: "openai.responses.parse",
    spanAttributes: {
      type: "llm"
    },
    event: {
      input: params.input,
      metadata: {
        ...filterFrom(params, ["input"]),
        provider: "openai"
      }
    },
    startTime: getCurrentUnixTimestamp()
  };
  return {
    span: startSpan(spanArgs),
    start: spanArgs.startTime
  };
}
function parseEventFromResponseParseResult(result) {
  const data = {};
  if (_optionalChain([result, 'optionalAccess', _136 => _136.output]) !== void 0) {
    data.output = processImagesInOutput(result.output);
  }
  if (result) {
    const { output, usage, ...metadata } = result;
    if (Object.keys(metadata).length > 0) {
      data.metadata = metadata;
    }
  }
  data.metrics = parseMetricsFromUsage(_optionalChain([result, 'optionalAccess', _137 => _137.usage]));
  return data;
}
function traceResponseCreateStream(stream, timedSpan) {
  const span = timedSpan.span;
  let ttft = -1;
  return async function(...args) {
    const result = await stream.next(...args);
    if (ttft === -1) {
      ttft = getCurrentUnixTimestamp() - timedSpan.start;
      span.log({ metrics: { time_to_first_token: ttft } });
    }
    if (result.done) {
      span.end();
      return result;
    }
    const item = result.value;
    if (!item || !_optionalChain([item, 'optionalAccess', _138 => _138.type]) || !_optionalChain([item, 'optionalAccess', _139 => _139.response])) {
      return result;
    }
    const event = parseLogFromItem(item);
    if (!objectIsEmpty(event)) {
      span.log(event);
    }
    return result;
  };
}
function parseLogFromItem(item) {
  if (!item || !_optionalChain([item, 'optionalAccess', _140 => _140.type]) || !_optionalChain([item, 'optionalAccess', _141 => _141.response])) {
    return {};
  }
  const response = item.response;
  switch (item.type) {
    case "response.completed":
      const data = {};
      if (_optionalChain([response, 'optionalAccess', _142 => _142.output]) !== void 0) {
        data.output = processImagesInOutput(response.output);
      }
      if (response) {
        const { usage, output, ...metadata } = response;
        if (Object.keys(metadata).length > 0) {
          data.metadata = metadata;
        }
      }
      data.metrics = parseMetricsFromUsage(_optionalChain([response, 'optionalAccess', _143 => _143.usage]));
      return data;
    default:
      return {};
  }
}
function responsesStreamProxy(target) {
  return new Proxy(target, {
    apply(target2, thisArg, argArray) {
      const responseStream = Reflect.apply(target2, thisArg, argArray);
      if (!argArray || argArray.length === 0) {
        return responseStream;
      }
      const timedSpan = parseSpanFromResponseCreateParams(argArray[0]);
      const span = timedSpan.span;
      let ttft = -1;
      responseStream.on("event", (event) => {
        if (ttft === -1) {
          ttft = getCurrentUnixTimestamp() - timedSpan.start;
          span.log({ metrics: { time_to_first_token: ttft } });
        }
        const logEvent = parseLogFromItem(event);
        if (!objectIsEmpty(logEvent)) {
          span.log(logEvent);
        }
      });
      responseStream.on("end", () => {
        span.end();
      });
      return responseStream;
    }
  });
}
function responsesParseProxy(target) {
  const hooks = {
    name: "openai.responses.parse",
    toSpanFunc: parseSpanFromResponseParseParams,
    resultToEventFunc: parseEventFromResponseParseResult,
    traceStreamFunc: traceResponseCreateStream
    // Reuse the same stream tracing
  };
  return proxyCreate(target, hooks);
}
var TOKEN_NAME_MAP = {
  input_tokens: "prompt_tokens",
  output_tokens: "completion_tokens",
  total_tokens: "tokens"
};
var TOKEN_PREFIX_MAP = {
  input: "prompt",
  output: "completion"
};
function parseMetricsFromUsage(usage) {
  if (!usage) {
    return {};
  }
  const metrics2 = {};
  for (const [oai_name, value] of Object.entries(usage)) {
    if (typeof value === "number") {
      const metricName = TOKEN_NAME_MAP[oai_name] || oai_name;
      metrics2[metricName] = value;
    } else if (oai_name.endsWith("_tokens_details")) {
      if (!isObject(value)) {
        continue;
      }
      const rawPrefix = oai_name.slice(0, -"_tokens_details".length);
      const prefix = TOKEN_PREFIX_MAP[rawPrefix] || rawPrefix;
      for (const [key, n] of Object.entries(value)) {
        if (typeof n !== "number") {
          continue;
        }
        const metricName = `${prefix}_${key}`;
        metrics2[metricName] = n;
      }
    }
  }
  return metrics2;
}
function proxyCreate(target, hooks) {
  return new Proxy(target, {
    apply(target2, thisArg, argArray) {
      if (!argArray || argArray.length === 0) {
        return Reflect.apply(target2, thisArg, argArray);
      }
      const params = argArray[0];
      const timedSpan = hooks.toSpanFunc(params);
      const apiPromise = Reflect.apply(target2, thisArg, argArray);
      const onThen = function(result) {
        if (params.stream) {
          return proxyIterable(result, timedSpan, hooks.traceStreamFunc);
        } else {
          const event = hooks.resultToEventFunc(result);
          const span = timedSpan.span;
          const ttft = getCurrentUnixTimestamp() - timedSpan.start;
          if (!event.metrics) {
            event.metrics = {};
          }
          event.metrics.time_to_first_token = ttft;
          span.log(event);
          span.end();
          return result;
        }
      };
      return apiPromiseProxy(
        apiPromise,
        timedSpan,
        onThen,
        hooks.traceStreamFunc
      );
    }
  });
}
function apiPromiseProxy(apiPromise, span, onThen, traceStreamFunc) {
  return new Proxy(apiPromise, {
    get(target, name, receiver) {
      if (name === "then") {
        const thenFunc = Reflect.get(target, name, receiver);
        return function(onF, onR) {
          return thenFunc.call(
            target,
            async (result) => {
              const processed = onThen(result);
              return onF ? onF(processed) : processed;
            },
            onR
            // FIXME[matt] error handling?
          );
        };
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
function proxyIterable(stream, span, onNext) {
  return new Proxy(stream, {
    get(target, prop, receiver) {
      if (prop === Symbol.asyncIterator) {
        const original = Reflect.get(target, prop, receiver);
        return function() {
          const iterator = original.call(target);
          return new Proxy(iterator, {
            get(iterTarget, iterProp, iterReceiver) {
              if (iterProp === "next") {
                return onNext(iterator, span);
              }
              return Reflect.get(iterTarget, iterProp, iterReceiver);
            }
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}

// src/wrappers/oai.ts
function wrapOpenAI(openai) {
  const oai = openai;
  if (oai && typeof oai === "object" && "chat" in oai && typeof oai.chat === "object" && oai.chat && "completions" in oai.chat && typeof oai.chat.completions === "object" && oai.chat.completions && "create" in oai.chat.completions) {
    return wrapOpenAIv4(oai);
  } else {
    console.warn("Unsupported OpenAI library (potentially v3). Not wrapping.");
    return openai;
  }
}
globalThis.__inherited_braintrust_wrap_openai = wrapOpenAI;
function wrapOpenAIv4(openai) {
  const completionProxy = new Proxy(openai.chat.completions, {
    get(target, name, receiver) {
      const baseVal = Reflect.get(target, name, receiver);
      if (name === "create") {
        return wrapChatCompletion(baseVal.bind(target));
      } else if (name === "parse") {
        return wrapBetaChatCompletionParse(baseVal.bind(target));
      }
      return baseVal;
    }
  });
  const chatProxy = new Proxy(openai.chat, {
    get(target, name, receiver) {
      if (name === "completions") {
        return completionProxy;
      }
      return Reflect.get(target, name, receiver);
    }
  });
  const embeddingProxy = createEndpointProxy(openai.embeddings, wrapEmbeddings);
  const moderationProxy = createEndpointProxy(openai.moderations, wrapModerations);
  let betaProxy2;
  if (_optionalChain([openai, 'access', _144 => _144.beta, 'optionalAccess', _145 => _145.chat, 'optionalAccess', _146 => _146.completions, 'optionalAccess', _147 => _147.stream])) {
    const betaChatCompletionProxy = new Proxy(_optionalChain([openai, 'optionalAccess', _148 => _148.beta, 'optionalAccess', _149 => _149.chat, 'access', _150 => _150.completions]), {
      get(target, name, receiver) {
        const baseVal = Reflect.get(target, name, receiver);
        if (name === "parse") {
          return wrapBetaChatCompletionParse(baseVal.bind(target));
        } else if (name === "stream") {
          return wrapBetaChatCompletionStream(baseVal.bind(target));
        }
        return baseVal;
      }
    });
    const betaChatProxy = new Proxy(openai.beta.chat, {
      get(target, name, receiver) {
        if (name === "completions") {
          return betaChatCompletionProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
    betaProxy2 = new Proxy(openai.beta, {
      get(target, name, receiver) {
        if (name === "chat") {
          return betaChatProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
  }
  return new Proxy(openai, {
    get(target, name, receiver) {
      switch (name) {
        case "chat":
          return chatProxy;
        case "embeddings":
          return embeddingProxy;
        case "moderations":
          return moderationProxy;
        case "responses":
          return responsesProxy(openai);
      }
      if (name === "beta" && betaProxy2) {
        return betaProxy2;
      }
      return Reflect.get(target, name, receiver);
    }
  });
}
function logCompletionResponse(startTime, response, span) {
  const metrics2 = parseMetricsFromUsage(_optionalChain([response, 'optionalAccess', _151 => _151.usage]));
  metrics2.time_to_first_token = getCurrentUnixTimestamp() - startTime;
  span.log({
    output: response.choices,
    metrics: metrics2
  });
}
function wrapBetaChatCompletionParse(completion) {
  return async (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: "llm" /* LLM */
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = await completion(params);
    try {
      logCompletionResponse(startTime, ret, span);
      return ret;
    } finally {
      span.end();
    }
  };
}
function wrapBetaChatCompletionStream(completion) {
  return (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: "llm" /* LLM */
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = completion(params);
    let first = true;
    ret.on("chunk", (_chunk) => {
      if (first) {
        const now2 = getCurrentUnixTimestamp();
        span.log({
          metrics: {
            time_to_first_token: now2 - startTime
          }
        });
        first = false;
      }
    });
    ret.on("chatCompletion", (completion2) => {
      span.log({
        output: completion2.choices
      });
    });
    ret.on("end", () => {
      span.end();
    });
    return ret;
  };
}
var LEGACY_CACHED_HEADER = "x-cached";
var X_CACHED_HEADER = "x-bt-cached";
function parseCachedHeader(value) {
  return isEmpty(value) ? void 0 : ["true", "hit"].includes(value.toLowerCase()) ? 1 : 0;
}
function logHeaders(response, span) {
  const cachedHeader = response.headers.get(X_CACHED_HEADER);
  if (isEmpty(cachedHeader)) {
    const legacyCacheHeader = response.headers.get(LEGACY_CACHED_HEADER);
    if (!isEmpty(legacyCacheHeader)) {
      span.log({
        metrics: {
          cached: parseCachedHeader(legacyCacheHeader)
        }
      });
    }
  } else {
    span.log({
      metrics: {
        cached: parseCachedHeader(cachedHeader)
      }
    });
  }
}
function wrapChatCompletion(completion) {
  return (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    let executionPromise = null;
    let dataPromise = null;
    const ensureExecuted = () => {
      if (!executionPromise) {
        executionPromise = (async () => {
          const span = startSpan(
            mergeDicts(
              {
                name: "Chat Completion",
                spanAttributes: {
                  type: "llm" /* LLM */
                }
              },
              parseChatCompletionParams(allParams)
            )
          );
          const startTime = getCurrentUnixTimestamp();
          if (params.stream) {
            const { data: ret, response } = await completion(
              // We could get rid of this type coercion if we could somehow enforce
              // that `P extends ChatParams` BUT does not have the property
              // `span_info`.
              // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
              params,
              options
            ).withResponse();
            logHeaders(response, span);
            const wrapperStream = new WrapperStream(
              span,
              startTime,
              ret.iterator()
            );
            ret.iterator = () => wrapperStream[Symbol.asyncIterator]();
            return { data: ret, response };
          } else {
            try {
              const completionResponse = completion(
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                params,
                options
              );
              const { data: ret, response } = await completionResponse.withResponse();
              logHeaders(response, span);
              const { messages, ...rest } = params;
              span.log({
                input: messages,
                metadata: {
                  ...rest
                }
              });
              logCompletionResponse(startTime, ret, span);
              return { data: ret, response };
            } finally {
              span.end();
            }
          }
        })();
      }
      return executionPromise;
    };
    return new Proxy({}, {
      get(target, prop, receiver) {
        if (prop === "withResponse") {
          return () => ensureExecuted();
        }
        if (prop === "then" || prop === "catch" || prop === "finally" || prop in Promise.prototype) {
          if (!dataPromise) {
            dataPromise = ensureExecuted().then((result) => result.data);
          }
          const value = Reflect.get(dataPromise, prop, receiver);
          return typeof value === "function" ? value.bind(dataPromise) : value;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  };
}
function parseBaseParams(allParams, inputField) {
  const { span_info, ...params } = allParams;
  const { metadata: spanInfoMetadata, ...spanInfoRest } = _nullishCoalesce(span_info, () => ( {}));
  const ret = {
    ...spanInfoRest,
    event: {
      metadata: spanInfoMetadata
    }
  };
  const input = params[inputField];
  const paramsRest = { ...params, provider: "openai" };
  delete paramsRest[inputField];
  return mergeDicts(ret, { event: { input, metadata: paramsRest } });
}
function createApiWrapper(name, create, processResponse, parseParams) {
  return async (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    return traced(
      async (span) => {
        const { data: result, response } = await create(
          params,
          options
        ).withResponse();
        logHeaders(response, span);
        processResponse(result, span);
        return result;
      },
      mergeDicts(
        {
          name,
          spanAttributes: {
            type: "llm" /* LLM */
          }
        },
        parseParams(allParams)
      )
    );
  };
}
function createEndpointProxy(target, wrapperFn) {
  return new Proxy(target, {
    get(target2, name, receiver) {
      const baseVal = Reflect.get(target2, name, receiver);
      if (name === "create") {
        return wrapperFn(baseVal.bind(target2));
      }
      return baseVal;
    }
  });
}
function parseChatCompletionParams(params) {
  return parseBaseParams(params, "messages");
}
function processEmbeddingResponse(result, span) {
  span.log({
    output: { embedding_length: result.data[0].embedding.length },
    metrics: parseMetricsFromUsage(_optionalChain([result, 'optionalAccess', _152 => _152.usage]))
  });
}
function processModerationResponse(result, span) {
  span.log({
    output: result.results
  });
}
var wrapEmbeddings = (create) => createApiWrapper(
  "Embedding",
  create,
  processEmbeddingResponse,
  (params) => parseBaseParams(params, "input")
);
var wrapModerations = (create) => createApiWrapper(
  "Moderation",
  create,
  processModerationResponse,
  (params) => parseBaseParams(params, "input")
);
function postprocessStreamingResults(allResults) {
  let role = void 0;
  let content = void 0;
  let tool_calls = void 0;
  let finish_reason = void 0;
  let metrics2 = {};
  for (const result of allResults) {
    if (result.usage) {
      metrics2 = {
        ...metrics2,
        ...parseMetricsFromUsage(_optionalChain([result, 'optionalAccess', _153 => _153.usage]))
      };
    }
    const delta = _optionalChain([result, 'access', _154 => _154.choices, 'optionalAccess', _155 => _155[0], 'optionalAccess', _156 => _156.delta]);
    if (!delta) {
      continue;
    }
    if (!role && delta.role) {
      role = delta.role;
    }
    if (delta.finish_reason) {
      finish_reason = delta.finish_reason;
    }
    if (delta.content) {
      content = (content || "") + delta.content;
    }
    if (delta.tool_calls) {
      const toolDelta = delta.tool_calls[0];
      if (!tool_calls || toolDelta.id && tool_calls[tool_calls.length - 1].id !== toolDelta.id) {
        tool_calls = [
          ...tool_calls || [],
          {
            id: toolDelta.id,
            type: toolDelta.type,
            function: toolDelta.function
          }
        ];
      } else {
        tool_calls[tool_calls.length - 1].function.arguments += toolDelta.function.arguments;
      }
    }
  }
  return {
    metrics: metrics2,
    output: [
      {
        index: 0,
        message: {
          role,
          content,
          tool_calls
        },
        logprobs: null,
        finish_reason
      }
    ]
  };
}
var WrapperStream = class {
  
  
  
  constructor(span, startTime, iter) {
    this.span = span;
    this.iter = iter;
    this.startTime = startTime;
  }
  async *[Symbol.asyncIterator]() {
    let first = true;
    const allResults = [];
    try {
      for await (const item of this.iter) {
        if (first) {
          const now2 = getCurrentUnixTimestamp();
          this.span.log({
            metrics: {
              time_to_first_token: now2 - this.startTime
            }
          });
          first = false;
        }
        allResults.push(item);
        yield item;
      }
      this.span.log({
        ...postprocessStreamingResults(allResults)
      });
    } finally {
      this.span.end();
    }
  }
};

// src/wrappers/ai-sdk/ai-sdk.ts
init_logger();
init_util();

// src/wrappers/attachment-utils.ts
init_logger();
function getExtensionFromMediaType(mediaType) {
  const extensionMap = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/gif": "gif",
    "image/webp": "webp",
    "image/svg+xml": "svg",
    "audio/mpeg": "mp3",
    "audio/wav": "wav",
    "audio/ogg": "ogg",
    "video/mp4": "mp4",
    "video/webm": "webm",
    "application/pdf": "pdf",
    "application/json": "json",
    "text/plain": "txt",
    "text/html": "html",
    "text/csv": "csv"
  };
  return extensionMap[mediaType] || "bin";
}
function convertDataToBlob(data, mediaType) {
  try {
    if (typeof data === "string") {
      if (data.startsWith("data:")) {
        const base64Match = data.match(/^data:[^;]+;base64,(.+)$/);
        if (base64Match) {
          const base64 = base64Match[1];
          const binaryString = atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return new Blob([bytes], { type: mediaType });
        }
      } else if (data.startsWith("http://") || data.startsWith("https://")) {
        return null;
      } else {
        const binaryString = atob(data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return new Blob([bytes], { type: mediaType });
      }
    } else if (data instanceof Uint8Array) {
      return new Blob([data], { type: mediaType });
    } else if (data instanceof ArrayBuffer) {
      return new Blob([data], { type: mediaType });
    } else if (typeof Buffer !== "undefined" && data instanceof Buffer) {
      return new Blob([data], { type: mediaType });
    }
  } catch (error2) {
    return null;
  }
  return null;
}
function processInputAttachments(input) {
  if (!input) {
    return input;
  }
  let attachmentIndex = 0;
  const processContentPart2 = (part) => {
    if (!part || typeof part !== "object") {
      return part;
    }
    if (part.type === "image" && part.image) {
      let mediaType = "image/png";
      if (typeof part.image === "string" && part.image.startsWith("data:")) {
        const mediaTypeMatch = part.image.match(/^data:([^;]+);/);
        if (mediaTypeMatch) {
          mediaType = mediaTypeMatch[1];
        }
      } else if (part.mediaType) {
        mediaType = part.mediaType;
      }
      const blob = convertDataToBlob(part.image, mediaType);
      if (blob) {
        const filename = `input_image_${attachmentIndex}.${getExtensionFromMediaType(mediaType)}`;
        attachmentIndex++;
        const attachment = new Attachment({
          data: blob,
          filename,
          contentType: mediaType
        });
        return {
          ...part,
          image: attachment
        };
      }
    }
    if (part.type === "file" && part.data) {
      const mediaType = part.mediaType || "application/octet-stream";
      const blob = convertDataToBlob(part.data, mediaType);
      if (blob) {
        const filename = part.filename || `input_file_${attachmentIndex}.${getExtensionFromMediaType(mediaType)}`;
        attachmentIndex++;
        const attachment = new Attachment({
          data: blob,
          filename,
          contentType: mediaType
        });
        return {
          ...part,
          data: attachment
        };
      }
    }
    return part;
  };
  const processMessage2 = (message) => {
    if (!message || typeof message !== "object") {
      return message;
    }
    if (Array.isArray(message.content)) {
      return {
        ...message,
        content: message.content.map(processContentPart2)
      };
    }
    return message;
  };
  if (Array.isArray(input)) {
    return input.map(processMessage2);
  } else if (typeof input === "object" && input.content) {
    return processMessage2(input);
  }
  return input;
}

// src/wrappers/ai-sdk/ai-sdk.ts
var _zodtojsonschema = require('zod-to-json-schema');
var DENY_OUTPUT_PATHS = [
  // v3
  "roundtrips[].request.body",
  "roundtrips[].response.headers",
  "rawResponse.headers",
  "responseMessages",
  // v5
  "request.body",
  "response.body",
  "response.headers",
  "steps[].request.body",
  "steps[].response.body",
  "steps[].response.headers"
];
function wrapAISDK(aiSDK, options = {}) {
  return new Proxy(aiSDK, {
    get(target, prop, receiver) {
      const original = Reflect.get(target, prop, receiver);
      switch (prop) {
        case "generateText":
          return wrapGenerateText(original, options);
        case "streamText":
          return wrapStreamText(original, options);
        case "generateObject":
          return wrapGenerateObject(original, options);
        case "streamObject":
          return wrapStreamObject(original, options);
      }
      return original;
    }
  });
}
var wrapGenerateText = (generateText, options = {}) => {
  return async function wrappedGenerateText(params) {
    return traced(
      async (span) => {
        const result = await generateText({
          ...params,
          tools: wrapTools(params.tools)
        });
        span.log({
          output: await processOutput(result, options.denyOutputPaths),
          metrics: extractTokenMetrics(result)
        });
        return result;
      },
      {
        name: "generateText",
        spanAttributes: {
          type: "llm" /* LLM */
        },
        event: {
          input: processInputAttachments2(params),
          metadata: {
            model: serializeModel(params.model),
            braintrust: {
              integration_name: "ai-sdk",
              sdk_language: "typescript"
            }
          }
        }
      }
    );
  };
};
var wrapGenerateObject = (generateObject, options = {}) => {
  return async function wrappedGenerateObject(params) {
    return traced(
      async (span) => {
        const result = await generateObject({
          ...params,
          tools: wrapTools(params.tools)
        });
        span.log({
          output: processOutput(result, options.denyOutputPaths),
          metrics: extractTokenMetrics(result)
        });
        return result;
      },
      {
        name: "generateObject",
        spanAttributes: {
          type: "llm" /* LLM */
        },
        event: {
          input: processInputAttachments2(params),
          metadata: {
            model: serializeModel(params.model),
            braintrust: {
              integration_name: "ai-sdk",
              sdk_language: "typescript"
            }
          }
        }
      }
    );
  };
};
var wrapStreamText = (streamText, options = {}) => {
  return function wrappedStreamText(params) {
    const span = startSpan({
      name: "streamText",
      spanAttributes: {
        type: "llm" /* LLM */
      },
      event: {
        input: processInputAttachments2(params),
        metadata: {
          model: serializeModel(params.model),
          braintrust: {
            integration_name: "ai-sdk",
            sdk_language: "typescript"
          }
        }
      }
    });
    try {
      const startTime = Date.now();
      let receivedFirst = false;
      const result = withCurrent(
        span,
        () => streamText({
          ...params,
          tools: wrapTools(params.tools),
          onChunk: (chunk) => {
            if (!receivedFirst) {
              receivedFirst = true;
              span.log({
                metrics: {
                  time_to_first_token: (Date.now() - startTime) / 1e3
                }
              });
            }
            _optionalChain([params, 'access', _157 => _157.onChunk, 'optionalCall', _158 => _158(chunk)]);
          },
          onFinish: async (event) => {
            _optionalChain([params, 'access', _159 => _159.onFinish, 'optionalCall', _160 => _160(event)]);
            span.log({
              output: await processOutput(event, options.denyOutputPaths),
              metrics: extractTokenMetrics(event)
            });
            span.end();
          },
          onError: async (err) => {
            _optionalChain([params, 'access', _161 => _161.onError, 'optionalCall', _162 => _162(err)]);
            span.log({
              error: serializeError(err)
            });
            span.end();
          }
        })
      );
      const trackFirstToken = () => {
        if (!receivedFirst) {
          receivedFirst = true;
          span.log({
            metrics: {
              time_to_first_token: (Date.now() - startTime) / 1e3
            }
          });
        }
      };
      if (result && result.baseStream) {
        const [stream1, stream2] = result.baseStream.tee();
        result.baseStream = stream2;
        stream1.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              trackFirstToken();
              controller.enqueue(chunk);
            }
          })
        ).pipeTo(
          new WritableStream({
            write() {
            }
          })
        ).catch(() => {
        });
      }
      return result;
    } catch (error2) {
      span.log({
        error: serializeError(error2)
      });
      span.end();
      throw error2;
    }
  };
};
var wrapStreamObject = (streamObject, options = {}) => {
  return function wrappedStreamObject(params) {
    const span = startSpan({
      name: "streamObject",
      spanAttributes: {
        type: "llm" /* LLM */
      },
      event: {
        input: processInputAttachments2(params),
        metadata: {
          model: serializeModel(params.model),
          braintrust: {
            integration_name: "ai-sdk",
            sdk_language: "typescript"
          }
        }
      }
    });
    try {
      const startTime = Date.now();
      let receivedFirst = false;
      const result = withCurrent(
        span,
        () => streamObject({
          ...params,
          tools: wrapTools(params.tools),
          onChunk: (chunk) => {
            if (!receivedFirst) {
              receivedFirst = true;
              span.log({
                metrics: {
                  time_to_first_token: (Date.now() - startTime) / 1e3
                }
              });
            }
            _optionalChain([params, 'access', _163 => _163.onChunk, 'optionalCall', _164 => _164(chunk)]);
          },
          onFinish: async (event) => {
            _optionalChain([params, 'access', _165 => _165.onFinish, 'optionalCall', _166 => _166(event)]);
            span.log({
              output: await processOutput(event, options.denyOutputPaths),
              metrics: extractTokenMetrics(event)
            });
            span.end();
          },
          onError: async (err) => {
            _optionalChain([params, 'access', _167 => _167.onError, 'optionalCall', _168 => _168(err)]);
            span.log({
              error: serializeError(err)
            });
            span.end();
          }
        })
      );
      const trackFirstToken = () => {
        if (!receivedFirst) {
          receivedFirst = true;
          span.log({
            metrics: {
              time_to_first_token: (Date.now() - startTime) / 1e3
            }
          });
        }
      };
      if (result && result.baseStream) {
        const [stream1, stream2] = result.baseStream.tee();
        result.baseStream = stream2;
        stream1.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              trackFirstToken();
              controller.enqueue(chunk);
            }
          })
        ).pipeTo(
          new WritableStream({
            write() {
            }
          })
        ).catch(() => {
        });
      }
      return result;
    } catch (error2) {
      span.log({
        error: serializeError(error2)
      });
      span.end();
      throw error2;
    }
  };
};
var wrapTools = (tools) => {
  if (!tools) return tools;
  const inferName = (tool, fallback2) => tool && (tool.name || tool.toolName || tool.id) || fallback2;
  if (Array.isArray(tools)) {
    return tools.map((tool, idx) => {
      const name = inferName(tool, `tool[${idx}]`);
      return wrapToolExecute(tool, name);
    });
  }
  const wrappedTools = {};
  for (const [key, tool] of Object.entries(tools)) {
    wrappedTools[key] = wrapToolExecute(tool, key);
  }
  return wrappedTools;
};
var wrapToolExecute = (tool, name) => {
  if (tool != null && typeof tool === "object" && "execute" in tool && typeof tool.execute === "function") {
    const originalExecute = tool.execute;
    return new Proxy(tool, {
      get(target, prop) {
        if (prop === "execute") {
          return (...args) => traced(
            async (span) => {
              span.log({ input: args.length === 1 ? args[0] : args });
              const result = await originalExecute.apply(target, args);
              span.log({ output: result });
              return result;
            },
            {
              name,
              spanAttributes: {
                type: "tool" /* TOOL */
              }
            }
          );
        }
        return target[prop];
      },
      // Implement additional traps for full transparency
      has(target, prop) {
        return prop in target;
      },
      ownKeys(target) {
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(target, prop) {
        return Object.getOwnPropertyDescriptor(target, prop);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      deleteProperty(target, prop) {
        delete target[prop];
        return true;
      },
      defineProperty(target, prop, descriptor) {
        Object.defineProperty(target, prop, descriptor);
        return true;
      },
      getPrototypeOf(target) {
        return Object.getPrototypeOf(target);
      },
      setPrototypeOf(target, proto) {
        Object.setPrototypeOf(target, proto);
        return true;
      },
      isExtensible(target) {
        return Object.isExtensible(target);
      },
      preventExtensions(target) {
        Object.preventExtensions(target);
        return true;
      }
    });
  }
  return tool;
};
var serializeError = (error2) => {
  if (error2 instanceof Error) {
    return error2;
  }
  if (typeof error2 === "object" && error2 !== null) {
    try {
      return JSON.stringify(error2);
    } catch (e11) {
    }
  }
  return String(error2);
};
var serializeModel = (model) => {
  return typeof model === "string" ? model : _optionalChain([model, 'optionalAccess', _169 => _169.modelId]);
};
var isZodSchema = (value) => {
  return value != null && typeof value === "object" && "_def" in value && typeof value._def === "object";
};
var serializeZodSchema = (schema) => {
  try {
    return _zodtojsonschema.zodToJsonSchema.call(void 0, schema);
  } catch (e12) {
    return {
      type: "object",
      description: "Zod schema (conversion failed)"
    };
  }
};
var processTools = (tools) => {
  if (!tools || typeof tools !== "object") return tools;
  if (Array.isArray(tools)) {
    return tools.map(processTool);
  }
  const processed = {};
  for (const [key, tool] of Object.entries(tools)) {
    processed[key] = processTool(tool);
  }
  return processed;
};
var processTool = (tool) => {
  if (!tool || typeof tool !== "object") return tool;
  const processed = { ...tool };
  if (isZodSchema(processed.inputSchema)) {
    processed.inputSchema = serializeZodSchema(processed.inputSchema);
  }
  if (isZodSchema(processed.parameters)) {
    processed.parameters = serializeZodSchema(processed.parameters);
  }
  if ("execute" in processed) {
    processed.execute = "[Function]";
  }
  if ("render" in processed) {
    processed.render = "[Function]";
  }
  return processed;
};
var processInputAttachments2 = (input) => {
  if (!input) return input;
  const processed = { ...input };
  if (input.messages && Array.isArray(input.messages)) {
    processed.messages = input.messages.map(processMessage);
  }
  if (input.prompt && typeof input.prompt === "object" && !Array.isArray(input.prompt)) {
    processed.prompt = processPromptContent(input.prompt);
  }
  if (input.tools) {
    processed.tools = processTools(input.tools);
  }
  return processed;
};
var processMessage = (message) => {
  if (!message || typeof message !== "object") return message;
  if (Array.isArray(message.content)) {
    return {
      ...message,
      content: message.content.map(processContentPart)
    };
  }
  if (typeof message.content === "object" && message.content !== null) {
    return {
      ...message,
      content: processContentPart(message.content)
    };
  }
  return message;
};
var processPromptContent = (prompt) => {
  if (Array.isArray(prompt)) {
    return prompt.map(processContentPart);
  }
  if (prompt.content) {
    if (Array.isArray(prompt.content)) {
      return {
        ...prompt,
        content: prompt.content.map(processContentPart)
      };
    } else if (typeof prompt.content === "object") {
      return {
        ...prompt,
        content: processContentPart(prompt.content)
      };
    }
  }
  return prompt;
};
var processContentPart = (part) => {
  if (!part || typeof part !== "object") return part;
  try {
    if (part.type === "image" && part.image) {
      const imageAttachment = convertImageToAttachment(
        part.image,
        part.mimeType || part.mediaType
      );
      if (imageAttachment) {
        return {
          ...part,
          image: imageAttachment
        };
      }
    }
    if (part.type === "file" && part.data && (part.mimeType || part.mediaType)) {
      const fileAttachment = convertDataToAttachment(
        part.data,
        part.mimeType || part.mediaType,
        part.name || part.filename
      );
      if (fileAttachment) {
        return {
          ...part,
          data: fileAttachment
        };
      }
    }
    if (part.type === "image_url" && part.image_url) {
      if (typeof part.image_url === "object" && part.image_url.url) {
        const imageAttachment = convertImageToAttachment(part.image_url.url);
        if (imageAttachment) {
          return {
            ...part,
            image_url: {
              ...part.image_url,
              url: imageAttachment
            }
          };
        }
      }
    }
  } catch (error2) {
    console.warn("Error processing content part:", error2);
  }
  return part;
};
var convertImageToAttachment = (image, explicitMimeType) => {
  try {
    if (typeof image === "string" && image.startsWith("data:")) {
      const [mimeTypeSection, base64Data] = image.split(",");
      const mimeType = _optionalChain([mimeTypeSection, 'access', _170 => _170.match, 'call', _171 => _171(/data:(.*?);/), 'optionalAccess', _172 => _172[1]]);
      if (mimeType && base64Data) {
        const blob = convertDataToBlob(base64Data, mimeType);
        if (blob) {
          return new Attachment({
            data: blob,
            filename: `image.${getExtensionFromMediaType(mimeType)}`,
            contentType: mimeType
          });
        }
      }
    }
    if (explicitMimeType) {
      if (image instanceof Uint8Array) {
        return new Attachment({
          data: new Blob([image], { type: explicitMimeType }),
          filename: `image.${getExtensionFromMediaType(explicitMimeType)}`,
          contentType: explicitMimeType
        });
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(image)) {
        return new Attachment({
          data: new Blob([image], { type: explicitMimeType }),
          filename: `image.${getExtensionFromMediaType(explicitMimeType)}`,
          contentType: explicitMimeType
        });
      }
    }
    if (image instanceof Blob && image.type) {
      return new Attachment({
        data: image,
        filename: `image.${getExtensionFromMediaType(image.type)}`,
        contentType: image.type
      });
    }
    if (image instanceof Attachment) {
      return image;
    }
  } catch (error2) {
    console.warn("Error converting image to attachment:", error2);
  }
  return null;
};
var convertDataToAttachment = (data, mimeType, filename) => {
  if (!mimeType) return null;
  try {
    let blob = null;
    if (typeof data === "string" && data.startsWith("data:")) {
      const [, base64Data] = data.split(",");
      if (base64Data) {
        blob = convertDataToBlob(base64Data, mimeType);
      }
    } else if (typeof data === "string" && data.length > 0) {
      blob = convertDataToBlob(data, mimeType);
    } else if (data instanceof Uint8Array) {
      blob = new Blob([data], { type: mimeType });
    } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
      blob = new Blob([data], { type: mimeType });
    } else if (data instanceof Blob) {
      blob = data;
    }
    if (blob) {
      return new Attachment({
        data: blob,
        filename: filename || `file.${getExtensionFromMediaType(mimeType)}`,
        contentType: mimeType
      });
    }
  } catch (error2) {
    console.warn("Error converting data to attachment:", error2);
  }
  return null;
};
var extractGetterValues = (obj) => {
  const getterValues = {};
  const getterNames = [
    "text",
    "finishReason",
    "usage",
    "toolCalls",
    "toolResults",
    "warnings",
    "experimental_providerMetadata",
    "rawResponse",
    "response"
  ];
  for (const name of getterNames) {
    try {
      if (obj && name in obj && typeof obj[name] !== "function") {
        getterValues[name] = obj[name];
      }
    } catch (e13) {
    }
  }
  return getterValues;
};
var processOutput = async (output, denyOutputPaths) => {
  const getterValues = extractGetterValues(output);
  const processed = await processOutputAttachments(output);
  const merged = { ...processed, ...getterValues };
  return omit(merged, _nullishCoalesce(denyOutputPaths, () => ( DENY_OUTPUT_PATHS)));
};
var processOutputAttachments = async (output) => {
  try {
    return await doProcessOutputAttachments(output);
  } catch (error2) {
    console.error("Error processing output attachments:", error2);
    return output;
  }
};
var doProcessOutputAttachments = async (output) => {
  if (!output || !("files" in output)) {
    return output;
  }
  if (output.files && typeof output.files.then === "function") {
    return {
      ...output,
      files: output.files.then(async (files) => {
        if (!files || !Array.isArray(files) || files.length === 0) {
          return files;
        }
        return files.map(convertFileToAttachment);
      })
    };
  } else if (output.files && Array.isArray(output.files) && output.files.length > 0) {
    return {
      ...output,
      files: output.files.map(convertFileToAttachment)
    };
  }
  return output;
};
var convertFileToAttachment = (file, index) => {
  try {
    const mediaType = file.mediaType || "application/octet-stream";
    const filename = `generated_file_${index}.${getExtensionFromMediaType(mediaType)}`;
    let blob = null;
    if (file.base64) {
      blob = convertDataToBlob(file.base64, mediaType);
    } else if (file.uint8Array) {
      blob = new Blob([file.uint8Array], { type: mediaType });
    }
    if (!blob) {
      console.warn(`Failed to convert file at index ${index} to Blob`);
      return file;
    }
    return new Attachment({
      data: blob,
      filename,
      contentType: mediaType
    });
  } catch (error2) {
    console.warn(`Error processing file at index ${index}:`, error2);
    return file;
  }
};
function extractTokenMetrics(result) {
  const metrics2 = {};
  const usage = _optionalChain([result, 'optionalAccess', _173 => _173.usage]);
  if (!usage) {
    return metrics2;
  }
  if (usage.inputTokens !== void 0) {
    metrics2.prompt_tokens = usage.inputTokens;
  } else if (usage.promptTokens !== void 0) {
    metrics2.prompt_tokens = usage.promptTokens;
  } else if (usage.prompt_tokens !== void 0) {
    metrics2.prompt_tokens = usage.prompt_tokens;
  }
  if (usage.outputTokens !== void 0) {
    metrics2.completion_tokens = usage.outputTokens;
  } else if (usage.completionTokens !== void 0) {
    metrics2.completion_tokens = usage.completionTokens;
  } else if (usage.completion_tokens !== void 0) {
    metrics2.completion_tokens = usage.completion_tokens;
  }
  if (usage.totalTokens !== void 0) {
    metrics2.tokens = usage.totalTokens;
  } else if (usage.tokens !== void 0) {
    metrics2.tokens = usage.tokens;
  } else if (usage.total_tokens !== void 0) {
    metrics2.tokens = usage.total_tokens;
  }
  if (usage.cachedInputTokens !== void 0 || usage.promptCachedTokens !== void 0 || usage.prompt_cached_tokens !== void 0) {
    metrics2.prompt_cached_tokens = usage.cachedInputTokens || usage.promptCachedTokens || usage.prompt_cached_tokens;
  }
  if (usage.promptCacheCreationTokens !== void 0 || usage.prompt_cache_creation_tokens !== void 0) {
    metrics2.prompt_cache_creation_tokens = usage.promptCacheCreationTokens || usage.prompt_cache_creation_tokens;
  }
  if (usage.promptReasoningTokens !== void 0 || usage.prompt_reasoning_tokens !== void 0) {
    metrics2.prompt_reasoning_tokens = usage.promptReasoningTokens || usage.prompt_reasoning_tokens;
  }
  if (usage.completionCachedTokens !== void 0 || usage.completion_cached_tokens !== void 0) {
    metrics2.completion_cached_tokens = usage.completionCachedTokens || usage.completion_cached_tokens;
  }
  if (usage.reasoningTokens !== void 0 || usage.completionReasoningTokens !== void 0 || usage.completion_reasoning_tokens !== void 0 || usage.reasoning_tokens !== void 0 || usage.thinkingTokens !== void 0 || usage.thinking_tokens !== void 0) {
    const reasoningTokenCount = usage.reasoningTokens || usage.completionReasoningTokens || usage.completion_reasoning_tokens || usage.reasoning_tokens || usage.thinkingTokens || usage.thinking_tokens;
    metrics2.completion_reasoning_tokens = reasoningTokenCount;
    metrics2.reasoning_tokens = reasoningTokenCount;
  }
  if (usage.completionAudioTokens !== void 0 || usage.completion_audio_tokens !== void 0) {
    metrics2.completion_audio_tokens = usage.completionAudioTokens || usage.completion_audio_tokens;
  }
  return metrics2;
}
var deepCopy = (obj) => {
  return JSON.parse(JSON.stringify(obj));
};
var parsePath = (path3) => {
  const keys = [];
  let current = "";
  for (let i = 0; i < path3.length; i++) {
    const char = path3[i];
    if (char === ".") {
      if (current) {
        keys.push(current);
        current = "";
      }
    } else if (char === "[") {
      if (current) {
        keys.push(current);
        current = "";
      }
      let bracketContent = "";
      i++;
      while (i < path3.length && path3[i] !== "]") {
        bracketContent += path3[i];
        i++;
      }
      if (bracketContent === "") {
        keys.push("[]");
      } else {
        const index = parseInt(bracketContent, 10);
        keys.push(isNaN(index) ? bracketContent : index);
      }
    } else {
      current += char;
    }
  }
  if (current) {
    keys.push(current);
  }
  return keys;
};
var omitAtPath = (obj, keys) => {
  if (keys.length === 0) return;
  const firstKey = keys[0];
  const remainingKeys = keys.slice(1);
  if (firstKey === "[]") {
    if (Array.isArray(obj)) {
      obj.forEach((item) => {
        if (remainingKeys.length > 0) {
          omitAtPath(item, remainingKeys);
        }
      });
    }
  } else if (remainingKeys.length === 0) {
    if (obj && typeof obj === "object" && firstKey in obj) {
      obj[firstKey] = "<omitted>";
    }
  } else {
    if (obj && typeof obj === "object" && firstKey in obj) {
      omitAtPath(obj[firstKey], remainingKeys);
    }
  }
};
var omit = (obj, paths) => {
  const result = deepCopy(obj);
  for (const path3 of paths) {
    const keys = parsePath(path3);
    omitAtPath(result, keys);
  }
  return result;
};

// src/wrappers/ai-sdk/deprecated/wrapAISDKModel.ts
init_logger();
init_util2();
function wrapAISDKModel(model) {
  const m = model;
  if (_optionalChain([m, 'optionalAccess', _174 => _174.specificationVersion]) === "v1" && typeof _optionalChain([m, 'optionalAccess', _175 => _175.provider]) === "string" && typeof _optionalChain([m, 'optionalAccess', _176 => _176.modelId]) === "string") {
    return new BraintrustLanguageModelWrapper(m);
  } else {
    console.warn("Unsupported AI SDK model. Not wrapping.");
    return model;
  }
}
var BraintrustLanguageModelWrapper = class {
  constructor(model) {
    this.model = model;
    if (typeof this.model.supportsUrl === "function") {
      this.supportsUrl = (url) => this.model.supportsUrl(url);
    }
  }
  
  get specificationVersion() {
    return this.model.specificationVersion;
  }
  get provider() {
    return this.model.provider;
  }
  get modelId() {
    return this.model.modelId;
  }
  get defaultObjectGenerationMode() {
    return this.model.defaultObjectGenerationMode;
  }
  get supportsImageUrls() {
    return this.model.supportsImageUrls;
  }
  get supportsStructuredOutputs() {
    return this.model.supportsStructuredOutputs;
  }
  // For the first cut, do not support custom span_info arguments. We can
  // propagate those via async local storage
  async doGenerate(options) {
    const span = startSpan({
      name: "Chat Completion",
      spanAttributes: {
        type: "llm"
      }
    });
    const { prompt, mode, ...rest } = options;
    const startTime = getCurrentUnixTimestamp();
    try {
      const ret = await this.model.doGenerate(options);
      span.log({
        input: postProcessPrompt(prompt),
        metadata: {
          model: this.modelId,
          ...rest,
          ..."tools" in mode && mode.tools ? { tools: convertTools(mode.tools) } : "tool" in mode && mode.tool ? { tools: convertTools([mode.tool]) } : {}
        },
        output: postProcessOutput(ret.text, ret.toolCalls, ret.finishReason),
        metrics: {
          time_to_first_token: getCurrentUnixTimestamp() - startTime,
          tokens: !isEmpty(ret.usage) ? ret.usage.promptTokens + ret.usage.completionTokens : void 0,
          prompt_tokens: _optionalChain([ret, 'access', _177 => _177.usage, 'optionalAccess', _178 => _178.promptTokens]),
          completion_tokens: _optionalChain([ret, 'access', _179 => _179.usage, 'optionalAccess', _180 => _180.completionTokens]),
          cached: parseCachedHeader(
            _nullishCoalesce(_optionalChain([ret, 'access', _181 => _181.rawResponse, 'optionalAccess', _182 => _182.headers, 'optionalAccess', _183 => _183[X_CACHED_HEADER]]), () => ( _optionalChain([ret, 'access', _184 => _184.rawResponse, 'optionalAccess', _185 => _185.headers, 'optionalAccess', _186 => _186[LEGACY_CACHED_HEADER]])))
          )
        }
      });
      return ret;
    } finally {
      span.end();
    }
  }
  async doStream(options) {
    const { prompt, mode, ...rest } = options;
    const startTime = getCurrentUnixTimestamp();
    const span = startSpan({
      name: "Chat Completion",
      spanAttributes: {
        type: "llm"
      }
    });
    span.log({
      input: postProcessPrompt(prompt),
      metadata: {
        model: this.modelId,
        ...rest,
        ..."tools" in mode && mode.tools ? { tools: convertTools(mode.tools) } : "tool" in mode && mode.tool ? { tools: convertTools([mode.tool]) } : {}
      }
    });
    let ended = false;
    const end = () => {
      if (!ended) {
        span.end();
        ended = true;
      }
    };
    try {
      const ret = await this.model.doStream(options);
      let time_to_first_token = void 0;
      let usage = void 0;
      let fullText = void 0;
      const toolCalls = {};
      let finishReason = void 0;
      return {
        ...ret,
        stream: ret.stream.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              if (time_to_first_token === void 0) {
                time_to_first_token = getCurrentUnixTimestamp() - startTime;
                span.log({ metrics: { time_to_first_token } });
              }
              switch (chunk.type) {
                case "text-delta":
                  if (fullText === void 0) {
                    fullText = "";
                  }
                  fullText += chunk.textDelta;
                  break;
                case "tool-call":
                  toolCalls[chunk.toolCallId] = {
                    toolCallType: chunk.toolCallType,
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    args: chunk.args
                  };
                  break;
                case "tool-call-delta":
                  if (toolCalls[chunk.toolCallId] === void 0) {
                    toolCalls[chunk.toolCallId] = {
                      toolCallType: chunk.toolCallType,
                      toolCallId: chunk.toolCallId,
                      toolName: chunk.toolName,
                      args: ""
                    };
                  }
                  toolCalls[chunk.toolCallId].args += chunk.argsTextDelta;
                  break;
                case "finish":
                  usage = chunk.usage;
                  finishReason = chunk.finishReason;
                  break;
              }
              controller.enqueue(chunk);
            },
            async flush(controller) {
              span.log({
                output: postProcessOutput(
                  fullText,
                  Object.keys(toolCalls).length > 0 ? Object.values(toolCalls) : void 0,
                  finishReason
                ),
                metrics: {
                  time_to_first_token,
                  tokens: !isEmpty(usage) ? usage.promptTokens + usage.completionTokens : void 0,
                  prompt_tokens: _optionalChain([usage, 'optionalAccess', _187 => _187.promptTokens]),
                  completion_tokens: _optionalChain([usage, 'optionalAccess', _188 => _188.completionTokens]),
                  cached: parseCachedHeader(
                    _nullishCoalesce(_optionalChain([ret, 'access', _189 => _189.rawResponse, 'optionalAccess', _190 => _190.headers, 'optionalAccess', _191 => _191[X_CACHED_HEADER]]), () => ( _optionalChain([ret, 'access', _192 => _192.rawResponse, 'optionalAccess', _193 => _193.headers, 'optionalAccess', _194 => _194[LEGACY_CACHED_HEADER]])))
                  )
                }
              });
              end();
              controller.terminate();
            }
          })
        )
      };
    } finally {
      end();
    }
  }
};
function convertTools(tools) {
  return tools.map((tool) => {
    const { type: _, ...rest } = tool;
    return {
      type: tool.type,
      function: rest
    };
  });
}
function postProcessPrompt(prompt) {
  return prompt.flatMap((message) => {
    switch (message.role) {
      case "system":
        return [
          {
            role: "system",
            content: message.content
          }
        ];
      case "assistant":
        const textPart = message.content.find(
          (part) => part.type === "text"
        );
        const toolCallParts = message.content.filter(
          (part) => part.type === "tool-call"
        );
        return [
          {
            role: "assistant",
            content: _optionalChain([textPart, 'optionalAccess', _195 => _195.text]),
            ...toolCallParts.length > 0 ? {
              tool_calls: toolCallParts.map((part) => ({
                id: part.toolCallId,
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.args)
                },
                type: "function"
              }))
            } : {}
          }
        ];
      case "user":
        return [
          {
            role: "user",
            content: message.content.map((part) => {
              switch (part.type) {
                case "text":
                  return {
                    type: "text",
                    text: part.text,
                    ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
                  };
                case "image":
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.image.toString(),
                      ...part.providerMetadata ? { providerMetadata: part.providerMetadata } : {}
                    }
                  };
                default:
                  return part;
              }
            })
          }
        ];
      case "tool":
        return message.content.map((part) => ({
          role: "tool",
          tool_call_id: part.toolCallId,
          content: JSON.stringify(part.result)
        }));
    }
  });
}
function postProcessOutput(text, toolCalls, finishReason) {
  return [
    {
      index: 0,
      message: {
        role: "assistant",
        content: _nullishCoalesce(text, () => ( "")),
        ...toolCalls && toolCalls.length > 0 ? {
          tool_calls: toolCalls.map((toolCall) => ({
            id: toolCall.toolCallId,
            function: {
              name: toolCall.toolName,
              arguments: toolCall.args
            },
            type: "function"
          }))
        } : {}
      },
      finish_reason: finishReason
    }
  ];
}

// src/wrappers/ai-sdk/deprecated/BraintrustMiddleware.ts
init_util();
init_logger();

// src/wrappers/anthropic-tokens-util.ts
function finalizeAnthropicTokens(metrics2) {
  const prompt_tokens = (metrics2.prompt_tokens || 0) + (metrics2.prompt_cached_tokens || 0) + (metrics2.prompt_cache_creation_tokens || 0);
  return {
    ...metrics2,
    prompt_tokens,
    tokens: prompt_tokens + (metrics2.completion_tokens || 0)
  };
}
function extractAnthropicCacheTokens(cacheReadTokens = 0, cacheCreationTokens = 0) {
  const cacheTokens = {};
  if (cacheReadTokens > 0) {
    cacheTokens.prompt_cached_tokens = cacheReadTokens;
  }
  if (cacheCreationTokens > 0) {
    cacheTokens.prompt_cache_creation_tokens = cacheCreationTokens;
  }
  return cacheTokens;
}

// src/wrappers/ai-sdk/deprecated/BraintrustMiddleware.ts
function detectProviderFromResult(result) {
  if (!_optionalChain([result, 'optionalAccess', _196 => _196.providerMetadata])) {
    return void 0;
  }
  const keys = Object.keys(result.providerMetadata);
  return _optionalChain([keys, 'optionalAccess', _197 => _197.at, 'call', _198 => _198(0)]);
}
function extractModelFromResult(result) {
  if (_optionalChain([result, 'optionalAccess', _199 => _199.response, 'optionalAccess', _200 => _200.modelId])) {
    return result.response.modelId;
  }
  if (_optionalChain([result, 'optionalAccess', _201 => _201.request, 'optionalAccess', _202 => _202.body, 'optionalAccess', _203 => _203.model])) {
    return result.request.body.model;
  }
  return void 0;
}
function extractModelFromWrapGenerateCallback(model) {
  return _optionalChain([model, 'optionalAccess', _204 => _204.modelId]);
}
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function extractModelParameters(params, excludeKeys) {
  const modelParams = {};
  for (const [key, value] of Object.entries(params)) {
    if (value !== void 0 && !excludeKeys.has(key)) {
      const snakeKey = camelToSnake(key);
      modelParams[snakeKey] = value;
    }
  }
  return modelParams;
}
function getNumberProperty(obj, key) {
  if (!obj || typeof obj !== "object" || !(key in obj)) {
    return void 0;
  }
  const value = Reflect.get(obj, key);
  return typeof value === "number" ? value : void 0;
}
function normalizeUsageMetrics(usage, provider, providerMetadata) {
  const metrics2 = {};
  const inputTokens = getNumberProperty(usage, "inputTokens");
  if (inputTokens !== void 0) {
    metrics2.prompt_tokens = inputTokens;
  }
  const outputTokens = getNumberProperty(usage, "outputTokens");
  if (outputTokens !== void 0) {
    metrics2.completion_tokens = outputTokens;
  }
  const totalTokens = getNumberProperty(usage, "totalTokens");
  if (totalTokens !== void 0) {
    metrics2.tokens = totalTokens;
  }
  const reasoningTokens = getNumberProperty(usage, "reasoningTokens");
  if (reasoningTokens !== void 0) {
    metrics2.completion_reasoning_tokens = reasoningTokens;
  }
  const cachedInputTokens = getNumberProperty(usage, "cachedInputTokens");
  if (cachedInputTokens !== void 0) {
    metrics2.prompt_cached_tokens = cachedInputTokens;
  }
  if (provider === "anthropic") {
    const anthropicMetadata = _optionalChain([providerMetadata, 'optionalAccess', _205 => _205.anthropic]);
    if (anthropicMetadata) {
      const cacheReadTokens = getNumberProperty(anthropicMetadata.usage, "cache_read_input_tokens") || 0;
      const cacheCreationTokens = getNumberProperty(
        anthropicMetadata.usage,
        "cache_creation_input_tokens"
      ) || 0;
      const cacheTokens = extractAnthropicCacheTokens(
        cacheReadTokens,
        cacheCreationTokens
      );
      Object.assign(metrics2, cacheTokens);
      Object.assign(metrics2, finalizeAnthropicTokens(metrics2));
    }
  }
  return metrics2;
}
function normalizeFinishReason(reason) {
  if (typeof reason !== "string") return void 0;
  return reason.replace(/-/g, "_");
}
function buildAssistantOutputWithToolCalls(result, toolCalls) {
  return [
    {
      index: 0,
      logprobs: null,
      finish_reason: _nullishCoalesce(normalizeFinishReason(_optionalChain([result, 'optionalAccess', _206 => _206.finishReason])), () => ( (toolCalls.length ? "tool_calls" : void 0))),
      message: {
        role: "assistant",
        tool_calls: toolCalls.length > 0 ? toolCalls : void 0
      }
    }
  ];
}
function extractToolCallsFromSteps(steps) {
  const toolCalls = [];
  if (!Array.isArray(steps)) return toolCalls;
  let idx = 0;
  for (const step of steps) {
    const blocks = _optionalChain([step, 'optionalAccess', _207 => _207.content]);
    if (!Array.isArray(blocks)) continue;
    for (const block of blocks) {
      if (block && typeof block === "object" && block.type === "tool-call") {
        toolCalls.push({
          id: block.toolCallId,
          type: "function",
          index: idx++,
          function: {
            name: block.toolName,
            arguments: typeof block.input === "string" ? block.input : JSON.stringify(_nullishCoalesce(block.input, () => ( {})))
          }
        });
      }
    }
  }
  return toolCalls;
}
function extractToolCallsFromBlocks(blocks) {
  if (!Array.isArray(blocks)) return [];
  return extractToolCallsFromSteps([{ content: blocks }]);
}
function extractInput(params) {
  return _nullishCoalesce(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _208 => _208.prompt]), () => ( _optionalChain([params, 'optionalAccess', _209 => _209.messages]))), () => ( _optionalChain([params, 'optionalAccess', _210 => _210.system])));
}
var V2_EXCLUDE_KEYS = /* @__PURE__ */ new Set([
  "prompt",
  // Already captured as input
  "system",
  // Already captured as input
  "messages",
  // Already captured as input
  "model",
  // Already captured in metadata.model
  "providerOptions"
  // Internal AI SDK configuration
]);
function BraintrustMiddleware(config = {}) {
  return {
    wrapGenerate: async ({
      doGenerate,
      params,
      model: modelFromWrapGenerate
    }) => {
      const rawInput = extractInput(params);
      const processedInput = processInputAttachments(rawInput);
      const spanArgs = {
        name: _optionalChain([config, 'access', _211 => _211.spanInfo, 'optionalAccess', _212 => _212.name]) || "ai-sdk.doGenerate",
        spanAttributes: {
          type: "llm" /* LLM */,
          ..._optionalChain([config, 'access', _213 => _213.spanInfo, 'optionalAccess', _214 => _214.spanAttributes]) || {}
        },
        event: {
          input: processedInput,
          metadata: {
            ...extractModelParameters(params, V2_EXCLUDE_KEYS),
            ..._optionalChain([config, 'access', _215 => _215.spanInfo, 'optionalAccess', _216 => _216.metadata]) || {}
          }
        }
      };
      const span = startSpan(spanArgs);
      try {
        const result = await doGenerate();
        const metadata = {};
        const provider = detectProviderFromResult(result);
        if (provider !== void 0) {
          metadata.provider = provider;
        }
        if (result.finishReason !== void 0) {
          metadata.finish_reason = result.finishReason;
        }
        const model = extractModelFromResult(result);
        if (model !== void 0) {
          metadata.model = model;
        } else if (modelFromWrapGenerate) {
          const modelId = extractModelFromWrapGenerateCallback(
            modelFromWrapGenerate
          );
          if (modelId) {
            metadata.model = modelId;
          }
        }
        let toolCalls = extractToolCallsFromSteps(_optionalChain([result, 'optionalAccess', _217 => _217.steps]));
        if (!toolCalls || toolCalls.length === 0) {
          toolCalls = extractToolCallsFromBlocks(_optionalChain([result, 'optionalAccess', _218 => _218.content]));
        }
        span.log({
          output: toolCalls.length > 0 ? buildAssistantOutputWithToolCalls(result, toolCalls) : _optionalChain([result, 'optionalAccess', _219 => _219.content]),
          metadata,
          metrics: normalizeUsageMetrics(
            result.usage,
            provider,
            result.providerMetadata
          )
        });
        return result;
      } catch (error2) {
        span.log({
          error: error2 instanceof Error ? error2.message : String(error2)
        });
        throw error2;
      } finally {
        span.end();
      }
    },
    wrapStream: async ({ doStream, params }) => {
      const rawInput = extractInput(params);
      const processedInput = processInputAttachments(rawInput);
      const spanArgs = {
        name: _optionalChain([config, 'access', _220 => _220.spanInfo, 'optionalAccess', _221 => _221.name]) || "ai-sdk.doStream",
        spanAttributes: {
          type: "llm" /* LLM */,
          ..._optionalChain([config, 'access', _222 => _222.spanInfo, 'optionalAccess', _223 => _223.spanAttributes]) || {}
        },
        event: {
          input: processedInput,
          metadata: {
            ...extractModelParameters(params, V2_EXCLUDE_KEYS),
            ..._optionalChain([config, 'access', _224 => _224.spanInfo, 'optionalAccess', _225 => _225.metadata]) || {}
          }
        }
      };
      const span = startSpan(spanArgs);
      try {
        const { stream, ...rest } = await doStream();
        const textChunks = [];
        const toolBlocks = [];
        let finalUsage = {};
        let finalFinishReason = void 0;
        let providerMetadata = {};
        const transformStream = new TransformStream({
          transform(chunk, controller) {
            try {
              if (chunk.type === "text-delta" && chunk.delta) {
                textChunks.push(chunk.delta);
              }
              if (chunk.type === "tool-call" || chunk.type === "tool-result") {
                toolBlocks.push(chunk);
              }
              if (chunk.type === "finish") {
                finalFinishReason = chunk.finishReason;
                finalUsage = chunk.usage || {};
                providerMetadata = chunk.providerMetadata || {};
              }
              controller.enqueue(chunk);
            } catch (error2) {
              span.log({
                error: error2 instanceof Error ? error2.message : String(error2)
              });
              span.end();
              controller.error(error2);
            }
          },
          flush() {
            try {
              const generatedText = textChunks.join("");
              let output = generatedText ? [{ type: "text", text: generatedText }] : [];
              const resultForDetection = {
                providerMetadata,
                response: rest.response,
                ...rest,
                finishReason: finalFinishReason
              };
              const metadata = {};
              const provider = detectProviderFromResult(resultForDetection);
              if (provider !== void 0) {
                metadata.provider = provider;
              }
              if (finalFinishReason !== void 0) {
                metadata.finish_reason = finalFinishReason;
              }
              const model = extractModelFromResult(resultForDetection);
              if (model !== void 0) {
                metadata.model = model;
              }
              if (toolBlocks.length > 0) {
                const toolCalls = extractToolCallsFromSteps([
                  { content: toolBlocks }
                ]);
                if (toolCalls.length > 0) {
                  output = buildAssistantOutputWithToolCalls(
                    resultForDetection,
                    toolCalls
                  );
                }
              }
              span.log({
                output,
                metadata,
                metrics: normalizeUsageMetrics(
                  finalUsage,
                  provider,
                  providerMetadata
                )
              });
              span.end();
            } catch (error2) {
              span.log({
                error: error2 instanceof Error ? error2.message : String(error2)
              });
              span.end();
              throw error2;
            }
          }
        });
        return {
          stream: stream.pipeThrough(transformStream),
          ...rest
        };
      } catch (error2) {
        span.log({
          error: error2 instanceof Error ? error2.message : String(error2)
        });
        span.end();
        throw error2;
      }
    }
  };
}

// src/wrappers/mastra/mastra.ts
init_logger();
var aiSDKFormatWarning = false;
function wrapMastraAgent(agent, options) {
  const prefix = _nullishCoalesce(_nullishCoalesce(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _226 => _226.name]), () => ( _optionalChain([options, 'optionalAccess', _227 => _227.span_name]))), () => ( agent.name)), () => ( "Agent"));
  if (!hasAllMethods(agent)) {
    return agent;
  }
  if (agent.tools) {
    agent.__setTools(wrapTools2(agent.tools));
  }
  return new Proxy(agent, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver);
      if (prop === "generate" && typeof value === "function") {
        return wrapGenerate(value, target, prefix);
      }
      if (prop === "stream" && typeof value === "function") {
        return wrapStream(value, target, prefix);
      }
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
}
function hasAllMethods(a) {
  return typeof a.generate === "function" && typeof a.stream === "function";
}
function wrapGenerate(original, target, prefix) {
  return function(...args) {
    const input = args[0];
    return traced(
      async (span) => {
        const result = await original.apply(target, args);
        const provider = detectProviderFromResult2(result);
        const model = extractModelFromResult2(result);
        const finishReason = normalizeFinishReason2(_optionalChain([result, 'optionalAccess', _228 => _228.finishReason]));
        const metrics2 = _optionalChain([result, 'optionalAccess', _229 => _229.usage]) ? normalizeUsageMetrics2(
          result.usage,
          provider,
          result.providerMetadata
        ) : {};
        span.log({
          input,
          output: result,
          metadata: {
            agent_name: _nullishCoalesce(target.name, () => ( prefix)),
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          },
          metrics: metrics2
        });
        return result;
      },
      {
        name: `${prefix}.generate`
      }
    );
  };
}
function wrapStream(original, target, prefix) {
  return function(...args) {
    const input = args[0];
    const span = startSpan({
      name: `${prefix}.stream`,
      event: {
        input,
        metadata: {
          agent_name: _nullishCoalesce(target.name, () => ( prefix))
        }
      }
    });
    const baseOpts = typeof args[1] === "object" && args[1] !== null ? args[1] : {};
    if (baseOpts.format && baseOpts.format !== "aisdk" && !aiSDKFormatWarning) {
      aiSDKFormatWarning = true;
      console.warn(
        `Braintrust Mastra wrapper: For best compatibility, use { format: 'aisdk' } (AI SDK v5) instead of format: '${baseOpts.format}'. See https://mastra.ai/en/docs/frameworks/agentic-uis/ai-sdk for more details.`
      );
    }
    const wrappedOpts = {
      ...baseOpts,
      format: baseOpts.format || "aisdk"
      // Default to AI SDK v5 format if not specified
    };
    const userOnChunk = _optionalChain([baseOpts, 'optionalAccess', _230 => _230.onChunk]);
    const userOnFinish = _optionalChain([baseOpts, 'optionalAccess', _231 => _231.onFinish]);
    const userOnError = _optionalChain([baseOpts, 'optionalAccess', _232 => _232.onError]);
    const startTime = Date.now();
    let receivedFirst = false;
    wrappedOpts.onChunk = (chunk) => {
      try {
        _optionalChain([userOnChunk, 'optionalCall', _233 => _233(chunk)]);
      } finally {
        if (!receivedFirst) {
          receivedFirst = true;
          span.log({
            metrics: { time_to_first_token: (Date.now() - startTime) / 1e3 }
          });
        }
      }
    };
    wrappedOpts.onFinish = async (event) => {
      try {
        await _optionalChain([userOnFinish, 'optionalCall', _234 => _234(event)]);
      } finally {
        const e = event;
        const provider = detectProviderFromResult2(e);
        const model = extractModelFromResult2(e);
        const finishReason = normalizeFinishReason2(_optionalChain([e, 'optionalAccess', _235 => _235.finishReason]));
        const metrics2 = _optionalChain([e, 'optionalAccess', _236 => _236.usage]) ? normalizeUsageMetrics2(e.usage, provider, e.providerMetadata) : {};
        span.log({
          output: _nullishCoalesce(_nullishCoalesce(e.text, () => ( e.content)), () => ( e)),
          metadata: {
            agent_name: _nullishCoalesce(target.name, () => ( prefix)),
            ...provider ? { provider } : {},
            ...model ? { model } : {},
            ...finishReason ? { finish_reason: finishReason } : {}
          },
          metrics: metrics2
        });
        span.end();
      }
    };
    wrappedOpts.onError = async (err) => {
      try {
        await _optionalChain([userOnError, 'optionalCall', _237 => _237(err)]);
      } finally {
        logError(span, err);
        span.end();
      }
    };
    return withCurrent(
      span,
      () => original.apply(target, [args[0], wrappedOpts, ...args.slice(2)])
    );
  };
}
function detectProviderFromResult2(result) {
  if (!_optionalChain([result, 'optionalAccess', _238 => _238.providerMetadata])) {
    return void 0;
  }
  const keys = Object.keys(result.providerMetadata);
  return _optionalChain([keys, 'optionalAccess', _239 => _239.at, 'call', _240 => _240(0)]);
}
function extractModelFromResult2(result) {
  if (_optionalChain([result, 'optionalAccess', _241 => _241.response, 'optionalAccess', _242 => _242.modelId])) {
    return result.response.modelId;
  }
  if (_optionalChain([result, 'optionalAccess', _243 => _243.request, 'optionalAccess', _244 => _244.body, 'optionalAccess', _245 => _245.model])) {
    return result.request.body.model;
  }
  return void 0;
}
function normalizeFinishReason2(reason) {
  if (typeof reason !== "string") return void 0;
  return reason.replace(/-/g, "_");
}
function normalizeUsageMetrics2(usage, provider, providerMetadata) {
  const metrics2 = {};
  const inputTokens = getNumberProperty2(usage, "inputTokens");
  if (inputTokens !== void 0) {
    metrics2.prompt_tokens = inputTokens;
  }
  const outputTokens = getNumberProperty2(usage, "outputTokens");
  if (outputTokens !== void 0) {
    metrics2.completion_tokens = outputTokens;
  }
  const totalTokens = getNumberProperty2(usage, "totalTokens");
  if (totalTokens !== void 0) {
    metrics2.tokens = totalTokens;
  }
  const reasoningTokens = getNumberProperty2(usage, "reasoningTokens");
  if (reasoningTokens !== void 0) {
    metrics2.completion_reasoning_tokens = reasoningTokens;
  }
  const cachedInputTokens = getNumberProperty2(usage, "cachedInputTokens");
  if (cachedInputTokens !== void 0) {
    metrics2.prompt_cached_tokens = cachedInputTokens;
  }
  if (provider === "anthropic") {
    const anthropicMetadata = _optionalChain([providerMetadata, 'optionalAccess', _246 => _246.anthropic]);
    if (anthropicMetadata) {
      const cacheReadTokens = getNumberProperty2(anthropicMetadata.usage, "cache_read_input_tokens") || 0;
      const cacheCreationTokens = getNumberProperty2(
        anthropicMetadata.usage,
        "cache_creation_input_tokens"
      ) || 0;
      const cacheTokens = extractAnthropicCacheTokens(
        cacheReadTokens,
        cacheCreationTokens
      );
      Object.assign(metrics2, cacheTokens);
      Object.assign(metrics2, finalizeAnthropicTokens(metrics2));
    }
  }
  return metrics2;
}
function wrapTools2(tools) {
  if (!tools) return tools;
  const inferName = (tool, fallback2) => tool && (tool.name || tool.toolName || tool.id) || fallback2;
  if (Array.isArray(tools)) {
    const arr = tools;
    const out = arr.map((tool, idx) => {
      if (tool != null && typeof tool === "object" && "execute" in tool && typeof tool.execute === "function") {
        const name = inferName(tool, `tool[${idx}]`);
        return {
          ...tool,
          execute: wrapTraced(tool.execute.bind(tool), {
            name,
            type: "tool"
          })
        };
      }
      return tool;
    });
    return out;
  }
  const wrappedTools = {};
  for (const [key, tool] of Object.entries(tools)) {
    if (tool != null && typeof tool === "object" && "execute" in tool && typeof tool.execute === "function") {
      wrappedTools[key] = {
        ...tool,
        execute: wrapTraced(tool.execute.bind(tool), {
          name: key,
          type: "tool"
        })
      };
    } else {
      wrappedTools[key] = tool;
    }
  }
  return wrappedTools;
}
function getNumberProperty2(obj, key) {
  if (!obj || typeof obj !== "object" || !(key in obj)) {
    return void 0;
  }
  const value = Reflect.get(obj, key);
  return typeof value === "number" ? value : void 0;
}

// src/wrappers/anthropic.ts
init_logger();
init_util();
init_util2();
init_util();
function wrapAnthropic(anthropic) {
  const au = anthropic;
  if (au && typeof au === "object" && "messages" in au && typeof au.messages === "object" && au.messages && "create" in au.messages) {
    return anthropicProxy(au);
  } else {
    console.warn("Unsupported Anthropic library. Not wrapping.");
    return anthropic;
  }
}
function anthropicProxy(anthropic) {
  return new Proxy(anthropic, {
    get(target, prop, receiver) {
      switch (prop) {
        case "beta":
          return betaProxy(target.beta);
        case "messages":
          return messagesProxy(target.messages);
        default:
          return Reflect.get(target, prop, receiver);
      }
    }
  });
}
function betaProxy(beta) {
  return new Proxy(beta, {
    get(target, prop, receiver) {
      if (prop === "messages") {
        return messagesProxy(target.messages);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function messagesProxy(messages) {
  return new Proxy(messages, {
    get(target, prop, receiver) {
      switch (prop) {
        case "create":
          return createProxy(target.create);
        default:
          return Reflect.get(target, prop, receiver);
      }
    }
  });
}
function createProxy(create) {
  return new Proxy(create, {
    apply(target, thisArg, argArray) {
      if (argArray.length === 0) {
        return Reflect.apply(target, thisArg, argArray);
      }
      const args = argArray[0];
      const input = coalesceInput(args["messages"] || [], args["system"]);
      const metadata = filterFrom(args, ["messages", "system"]);
      const spanArgs = {
        name: "anthropic.messages.create",
        spanAttributes: {
          type: "llm" /* LLM */
        },
        event: {
          input: processAttachmentsInInput(input),
          metadata: { ...metadata, provider: "anthropic" }
        },
        startTime: getCurrentUnixTimestamp()
      };
      const span = startSpan(spanArgs);
      const sspan = { span, startTime: spanArgs.startTime };
      const apiPromise = Reflect.apply(target, thisArg, argArray);
      const onThen = function(msgOrStream) {
        if (!args["stream"]) {
          const event = parseEventFromMessage(msgOrStream);
          span.log({
            ...event,
            metrics: event.metrics ? finalizeAnthropicTokens(event.metrics) : void 0
          });
          span.end();
          return msgOrStream;
        }
        return streamProxy(msgOrStream, sspan);
      };
      return apiPromiseProxy2(apiPromise, sspan, onThen);
    }
  });
}
function apiPromiseProxy2(apiPromise, span, onThen) {
  return new Proxy(apiPromise, {
    get(target, prop, receiver) {
      if (prop === "then") {
        const thenFunc = Reflect.get(target, prop, receiver);
        return function(onFulfilled, onRejected) {
          return thenFunc.call(
            target,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            async (result) => {
              try {
                const processed = onThen(result);
                return onFulfilled ? onFulfilled(processed) : processed;
              } catch (error2) {
                return onRejected ? onRejected(error2) : Promise.reject(error2);
              }
            },
            onRejected
          );
        };
      } else if (prop === "withResponse") {
        const withResponseFunc = Reflect.get(target, prop, receiver);
        return () => {
          return withResponseFunc.call(target).then((withResponse) => {
            if (withResponse["data"]) {
              const { data: stream } = withResponse;
              withResponse.data = streamProxy(stream, span);
            }
            return Promise.resolve(withResponse);
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function streamProxy(stream, span) {
  return new Proxy(stream, {
    get(target, prop, receiver) {
      if (prop === Symbol.asyncIterator) {
        const original = Reflect.get(target, prop, receiver);
        return function() {
          const iterator = original.call(target);
          return new Proxy(iterator, {
            get(iterTarget, iterProp, iterReceiver) {
              if (iterProp === "next") {
                return streamNextProxy(iterator, span);
              }
              return Reflect.get(iterTarget, iterProp, iterReceiver);
            }
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function streamNextProxy(stream, sspan) {
  let ttft = -1;
  const deltas = [];
  let metadata = {};
  let totals = {};
  const span = sspan.span;
  const contentBlocks = [];
  return async function(...args) {
    const result = await stream.next(...args);
    if (ttft < 0) {
      ttft = getCurrentUnixTimestamp() - sspan.startTime;
      totals.time_to_first_token = ttft;
    }
    if (result.done) {
      const output = deltas.join("");
      span.log({
        output,
        metrics: finalizeAnthropicTokens(totals),
        metadata
      });
      span.end();
      return result;
    }
    const item = result.value;
    switch (_optionalChain([item, 'optionalAccess', _247 => _247.type])) {
      case "message_start":
        const msg = _optionalChain([item, 'optionalAccess', _248 => _248.message]);
        if (msg) {
          const event = parseEventFromMessage(msg);
          totals = { ...totals, ...event.metrics };
          span.log(event);
        }
        break;
      case "content_block_start":
        if (item.content_block) {
          contentBlocks[item.index] = item.content_block;
        }
        break;
      case "content_block_delta":
        if (_optionalChain([item, 'access', _249 => _249.delta, 'optionalAccess', _250 => _250.type]) === "text_delta") {
          const text = _optionalChain([item, 'optionalAccess', _251 => _251.delta, 'optionalAccess', _252 => _252.text]);
          if (text) {
            deltas.push(text);
          }
        }
        break;
      case "message_delta":
        const usage = _optionalChain([item, 'optionalAccess', _253 => _253.usage]);
        if (usage) {
          const metrics2 = parseMetricsFromUsage2(usage);
          totals = { ...totals, ...metrics2 };
        }
        const delta = _optionalChain([item, 'optionalAccess', _254 => _254.delta]);
        if (delta) {
          metadata = { ...metadata, ...delta };
        }
        break;
      case "message_stop":
        break;
    }
    return result;
  };
}
function parseEventFromMessage(message) {
  const output = message ? { role: message.role, content: message.content } : null;
  const metrics2 = parseMetricsFromUsage2(_optionalChain([message, 'optionalAccess', _255 => _255.usage]));
  const metas = ["stop_reason", "stop_sequence"];
  const metadata = {};
  for (const m of metas) {
    if (message[m] !== void 0) {
      metadata[m] = message[m];
    }
  }
  return {
    output,
    metrics: metrics2,
    metadata
  };
}
function parseMetricsFromUsage2(usage) {
  if (!usage) {
    return void 0;
  }
  const metrics2 = {};
  function saveIfExistsTo(source, target) {
    const value = usage[source];
    if (value !== void 0 && value !== null) {
      metrics2[target] = value;
    }
  }
  saveIfExistsTo("input_tokens", "prompt_tokens");
  saveIfExistsTo("output_tokens", "completion_tokens");
  saveIfExistsTo("cache_read_input_tokens", "prompt_cached_tokens");
  saveIfExistsTo("cache_creation_input_tokens", "prompt_cache_creation_tokens");
  return metrics2;
}
function convertBase64ToAttachment(source, contentType) {
  const mediaType = typeof source.media_type === "string" ? source.media_type : "image/png";
  const base64Data = source.data;
  if (base64Data && typeof base64Data === "string") {
    const binaryString = atob(base64Data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    const blob = new Blob([bytes], { type: mediaType });
    const extension = mediaType.split("/")[1] || "bin";
    const prefix = contentType === "document" ? "document" : "image";
    const filename = `${prefix}.${extension}`;
    const attachment = new Attachment({
      data: blob,
      filename,
      contentType: mediaType
    });
    return {
      ...source,
      data: attachment
    };
  }
  return source;
}
function processAttachmentsInInput(input) {
  if (Array.isArray(input)) {
    return input.map(processAttachmentsInInput);
  }
  if (isObject(input)) {
    if ((input.type === "image" || input.type === "document") && isObject(input.source) && input.source.type === "base64") {
      return {
        ...input,
        source: convertBase64ToAttachment(input.source, input.type)
      };
    }
    const processed = {};
    for (const [key, value] of Object.entries(input)) {
      processed[key] = processAttachmentsInInput(value);
    }
    return processed;
  }
  return input;
}
function coalesceInput(messages, system) {
  const input = (messages || []).slice();
  if (system) {
    input.push({ role: "system", content: system });
  }
  return input;
}

// src/wrappers/claude-agent-sdk/claude-agent-sdk.ts
init_logger();
init_util2();
init_util();
function filterSerializableOptions(options) {
  const allowedKeys = [
    "model",
    "maxTurns",
    "cwd",
    "continue",
    "allowedTools",
    "disallowedTools",
    "additionalDirectories",
    "permissionMode",
    "debug",
    "apiKey",
    "apiKeySource",
    "agentName",
    "instructions"
  ];
  const filtered = {};
  for (const key of allowedKeys) {
    if (options[key] !== void 0) {
      filtered[key] = options[key];
    }
  }
  return filtered;
}
function wrapClaudeAgentQuery(queryFn, defaultThis) {
  const proxy = new Proxy(queryFn, {
    apply(target, thisArg, argArray) {
      const params = _nullishCoalesce(argArray[0], () => ( {}));
      const { prompt, options = {} } = params;
      const span = startSpan({
        name: "Claude Agent",
        spanAttributes: {
          type: "task" /* TASK */
        },
        event: {
          input: typeof prompt === "string" ? prompt : { type: "streaming", description: "AsyncIterable<SDKMessage>" },
          metadata: filterSerializableOptions(options)
        }
      });
      const finalResults = [];
      let finalUsageMetrics;
      let accumulatedOutputTokens = 0;
      let currentMessageId;
      let currentMessageStartTime = getCurrentUnixTimestamp();
      const currentMessages = [];
      const createLLMSpan = async () => {
        const finalMessageContent = await _createLLMSpanForMessages(
          currentMessages,
          prompt,
          finalResults,
          options,
          currentMessageStartTime,
          await span.export()
        );
        if (finalMessageContent) {
          finalResults.push(finalMessageContent);
        }
        const lastMessage = currentMessages[currentMessages.length - 1];
        if (_optionalChain([lastMessage, 'optionalAccess', _256 => _256.message, 'optionalAccess', _257 => _257.usage])) {
          const outputTokens = getNumberProperty3(lastMessage.message.usage, "output_tokens") || 0;
          accumulatedOutputTokens += outputTokens;
        }
        currentMessages.length = 0;
      };
      const wrappedGenerator = (async function* () {
        try {
          const invocationTarget = thisArg === proxy || thisArg === void 0 ? _nullishCoalesce(defaultThis, () => ( thisArg)) : thisArg;
          const generator = withCurrent(
            span,
            () => Reflect.apply(target, invocationTarget, argArray)
          );
          for await (const message of generator) {
            const currentTime = getCurrentUnixTimestamp();
            const messageId = _optionalChain([message, 'access', _258 => _258.message, 'optionalAccess', _259 => _259.id]);
            if (messageId && messageId !== currentMessageId) {
              await createLLMSpan();
              currentMessageId = messageId;
              currentMessageStartTime = currentTime;
            }
            if (message.type === "assistant" && _optionalChain([message, 'access', _260 => _260.message, 'optionalAccess', _261 => _261.usage])) {
              currentMessages.push(message);
            }
            if (message.type === "result" && message.usage) {
              finalUsageMetrics = _extractUsageFromMessage(message);
              if (currentMessages.length > 0 && finalUsageMetrics.completion_tokens !== void 0) {
                const lastMessage = currentMessages[currentMessages.length - 1];
                if (_optionalChain([lastMessage, 'optionalAccess', _262 => _262.message, 'optionalAccess', _263 => _263.usage])) {
                  const adjustedTokens = finalUsageMetrics.completion_tokens - accumulatedOutputTokens;
                  if (adjustedTokens >= 0) {
                    lastMessage.message.usage.output_tokens = adjustedTokens;
                  }
                }
              }
              const result_metadata = {};
              if (message.num_turns !== void 0) {
                result_metadata.num_turns = message.num_turns;
              }
              if (message.session_id !== void 0) {
                result_metadata.session_id = message.session_id;
              }
              if (Object.keys(result_metadata).length > 0) {
                span.log({
                  metadata: result_metadata
                });
              }
            }
            yield message;
          }
          await createLLMSpan();
          span.log({
            output: finalResults.length > 0 ? finalResults[finalResults.length - 1] : void 0
          });
        } catch (error2) {
          span.log({
            error: error2 instanceof Error ? error2.message : String(error2)
          });
          throw error2;
        } finally {
          span.end();
        }
      })();
      return wrappedGenerator;
    }
  });
  return proxy;
}
function wrapClaudeAgentTool(toolDef) {
  const originalHandler = toolDef.handler;
  const wrappedHandler = (args, extra) => traced(
    async (span) => {
      span.log({
        input: args,
        metadata: {
          tool_name: toolDef.name,
          tool_description: toolDef.description
        }
      });
      const result = await originalHandler(args, extra);
      span.log({
        output: result
      });
      return result;
    },
    {
      name: `${toolDef.name}`,
      spanAttributes: {
        type: "tool" /* TOOL */
      }
    }
  );
  return {
    ...toolDef,
    handler: wrappedHandler
  };
}
function _buildLLMInput(prompt, conversationHistory) {
  const promptMessage = typeof prompt === "string" ? { content: prompt, role: "user" } : void 0;
  const inputParts = [
    ...promptMessage ? [promptMessage] : [],
    ...conversationHistory
  ];
  return inputParts.length > 0 ? inputParts : void 0;
}
function _extractUsageFromMessage(message) {
  const metrics2 = {};
  let usage;
  if (message.type === "assistant") {
    usage = _optionalChain([message, 'access', _264 => _264.message, 'optionalAccess', _265 => _265.usage]);
  } else if (message.type === "result") {
    usage = message.usage;
  }
  if (!usage || typeof usage !== "object") {
    return metrics2;
  }
  const inputTokens = getNumberProperty3(usage, "input_tokens");
  if (inputTokens !== void 0) {
    metrics2.prompt_tokens = inputTokens;
  }
  const outputTokens = getNumberProperty3(usage, "output_tokens");
  if (outputTokens !== void 0) {
    metrics2.completion_tokens = outputTokens;
  }
  const cacheReadTokens = getNumberProperty3(usage, "cache_read_input_tokens") || 0;
  const cacheCreationTokens = getNumberProperty3(usage, "cache_creation_input_tokens") || 0;
  if (cacheReadTokens > 0 || cacheCreationTokens > 0) {
    const cacheTokens = extractAnthropicCacheTokens(
      cacheReadTokens,
      cacheCreationTokens
    );
    Object.assign(metrics2, cacheTokens);
  }
  if (Object.keys(metrics2).length > 0) {
    Object.assign(metrics2, finalizeAnthropicTokens(metrics2));
  }
  return metrics2;
}
async function _createLLMSpanForMessages(messages, prompt, conversationHistory, options, startTime, parentSpan) {
  if (messages.length === 0) return void 0;
  const lastMessage = messages[messages.length - 1];
  if (lastMessage.type !== "assistant" || !_optionalChain([lastMessage, 'access', _266 => _266.message, 'optionalAccess', _267 => _267.usage])) {
    return void 0;
  }
  const model = lastMessage.message.model || options.model;
  const usage = _extractUsageFromMessage(lastMessage);
  const input = _buildLLMInput(prompt, conversationHistory);
  const outputs = messages.map(
    (m) => _optionalChain([m, 'access', _268 => _268.message, 'optionalAccess', _269 => _269.content]) && _optionalChain([m, 'access', _270 => _270.message, 'optionalAccess', _271 => _271.role]) ? { content: m.message.content, role: m.message.role } : void 0
  ).filter((c) => c !== void 0);
  await traced(
    (llmSpan) => {
      llmSpan.log({
        input,
        output: outputs,
        metadata: model ? { model } : void 0,
        metrics: usage
      });
    },
    {
      name: "anthropic.messages.create",
      spanAttributes: {
        type: "llm" /* LLM */
      },
      startTime,
      parent: parentSpan
    }
  );
  return _optionalChain([lastMessage, 'access', _272 => _272.message, 'optionalAccess', _273 => _273.content]) && _optionalChain([lastMessage, 'access', _274 => _274.message, 'optionalAccess', _275 => _275.role]) ? { content: lastMessage.message.content, role: lastMessage.message.role } : void 0;
}
function wrapClaudeAgentSDK(sdk) {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(sdk, {
    get(target, prop, receiver) {
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const value = Reflect.get(target, prop, receiver);
      if (prop === "query" && typeof value === "function") {
        const wrappedQuery = wrapClaudeAgentQuery(
          value,
          target
        );
        cache.set(prop, wrappedQuery);
        return wrappedQuery;
      }
      if (prop === "tool" && typeof value === "function") {
        const toolFn = value;
        const wrappedToolFactory = new Proxy(toolFn, {
          apply(toolTarget, thisArg, argArray) {
            const invocationTarget = thisArg === receiver || thisArg === void 0 ? target : thisArg;
            const toolDef = Reflect.apply(
              toolTarget,
              invocationTarget,
              argArray
            );
            if (toolDef && typeof toolDef === "object" && "handler" in toolDef) {
              return wrapClaudeAgentTool(
                toolDef
              );
            }
            return toolDef;
          }
        });
        cache.set(prop, wrappedToolFactory);
        return wrappedToolFactory;
      }
      if (typeof value === "function") {
        const bound = value.bind(target);
        cache.set(prop, bound);
        return bound;
      }
      return value;
    }
  });
}
function getNumberProperty3(obj, key) {
  if (!obj || typeof obj !== "object" || !(key in obj)) {
    return void 0;
  }
  const value = Reflect.get(obj, key);
  return typeof value === "number" ? value : void 0;
}

// src/wrappers/google-genai.ts
init_logger();
init_util();
init_util2();
function wrapGoogleGenAI(googleGenAI) {
  if (!googleGenAI || typeof googleGenAI !== "object") {
    console.warn("Invalid Google GenAI module. Not wrapping.");
    return googleGenAI;
  }
  if (!("GoogleGenAI" in googleGenAI)) {
    console.warn(
      "GoogleGenAI class not found in module. Not wrapping. Make sure you're passing the module itself (import * as googleGenAI from '@google/genai')."
    );
    return googleGenAI;
  }
  return new Proxy(googleGenAI, {
    get(target, prop, receiver) {
      if (prop === "GoogleGenAI") {
        const OriginalGoogleGenAI = Reflect.get(target, prop, receiver);
        return wrapGoogleGenAIClass(OriginalGoogleGenAI);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function wrapGoogleGenAIClass(OriginalGoogleGenAI) {
  return new Proxy(OriginalGoogleGenAI, {
    construct(target, args) {
      const instance = Reflect.construct(target, args);
      return wrapGoogleGenAIInstance(instance);
    }
  });
}
function wrapGoogleGenAIInstance(instance) {
  return new Proxy(instance, {
    get(target, prop, receiver) {
      if (prop === "models") {
        return wrapModels(Reflect.get(target, prop, receiver));
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function wrapModels(models) {
  return new Proxy(models, {
    get(target, prop, receiver) {
      if (prop === "generateContent") {
        return wrapGenerateContent(target.generateContent.bind(target));
      } else if (prop === "generateContentStream") {
        return wrapGenerateContentStream(
          target.generateContentStream.bind(target)
        );
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function wrapGenerateContent(original) {
  return async function(params) {
    const input = serializeInput(params);
    const metadata = extractMetadata(params);
    return traced(
      async (span) => {
        const start = getCurrentUnixTimestamp();
        try {
          const result = await original(params);
          const metrics2 = extractGenerateContentMetrics(result, start);
          span.log({
            output: result,
            metrics: cleanMetrics(metrics2)
          });
          return result;
        } catch (error2) {
          span.log({
            error: error2 instanceof Error ? error2.message : String(error2)
          });
          throw error2;
        }
      },
      {
        name: "generate_content",
        spanAttributes: {
          type: "llm" /* LLM */
        },
        event: {
          input,
          metadata
        }
      }
    );
  };
}
function wrapGenerateContentStream(original) {
  return async function(params) {
    const input = serializeInput(params);
    const metadata = extractMetadata(params);
    const streamGenerator = await original(params);
    return asyncGeneratorProxy(streamGenerator, input, metadata);
  };
}
function asyncGeneratorProxy(generator, input, metadata) {
  const chunks = [];
  const start = getCurrentUnixTimestamp();
  let firstTokenTime = null;
  let span = null;
  return new Proxy(generator, {
    get(target, prop, receiver) {
      if (prop === Symbol.asyncIterator) {
        const original = Reflect.get(target, prop, receiver);
        return function() {
          const iterator = original.call(target);
          return new Proxy(iterator, {
            get(iterTarget, iterProp, iterReceiver) {
              if (iterProp === "next") {
                const originalNext = Reflect.get(
                  iterTarget,
                  iterProp,
                  iterReceiver
                );
                return async function() {
                  if (span === null) {
                    span = traced((s) => s, {
                      name: "generate_content_stream",
                      spanAttributes: {
                        type: "llm" /* LLM */
                      },
                      event: {
                        input,
                        metadata
                      }
                    });
                  }
                  try {
                    const result = await originalNext.call(iterTarget);
                    if (!result.done && result.value) {
                      if (firstTokenTime === null) {
                        firstTokenTime = getCurrentUnixTimestamp();
                      }
                      chunks.push(result.value);
                    }
                    if (result.done && span) {
                      const { aggregated, metrics: metrics2 } = aggregateGenerateContentChunks(
                        chunks,
                        start,
                        firstTokenTime
                      );
                      span.log({
                        output: aggregated,
                        metrics: cleanMetrics(metrics2)
                      });
                      span.end();
                    }
                    return result;
                  } catch (error2) {
                    if (span) {
                      span.log({
                        error: error2 instanceof Error ? error2.message : String(error2)
                      });
                      span.end();
                    }
                    throw error2;
                  }
                };
              }
              return Reflect.get(iterTarget, iterProp, iterReceiver);
            }
          });
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function serializeInput(params) {
  const input = {
    model: params.model,
    contents: serializeContents(params.contents)
  };
  if (params.config) {
    const config = tryToDict(params.config);
    if (config) {
      const tools = serializeTools(params);
      if (tools) {
        config.tools = tools;
      }
      input.config = config;
    }
  }
  return input;
}
function serializeContents(contents) {
  if (contents === null || contents === void 0) {
    return null;
  }
  if (Array.isArray(contents)) {
    return contents.map((item) => serializeContentItem(item));
  }
  return serializeContentItem(contents);
}
function serializeContentItem(item) {
  if (typeof item === "object" && item !== null) {
    if (item.parts && Array.isArray(item.parts)) {
      return {
        ...item,
        parts: item.parts.map((part) => serializePart(part))
      };
    }
    return item;
  }
  if (typeof item === "string") {
    return { text: item };
  }
  return item;
}
function serializePart(part) {
  if (!part || typeof part !== "object") {
    return part;
  }
  if (part.inlineData && part.inlineData.data) {
    const { data, mimeType } = part.inlineData;
    if (data instanceof Uint8Array || Buffer.isBuffer(data) || typeof data === "string") {
      const extension = mimeType ? mimeType.split("/")[1] : "bin";
      const filename = `file.${extension}`;
      const buffer = typeof data === "string" ? Buffer.from(data, "base64") : Buffer.from(data);
      const attachment = new Attachment({
        data: buffer,
        filename,
        contentType: mimeType || "application/octet-stream"
      });
      return {
        image_url: { url: attachment }
      };
    }
  }
  return part;
}
function serializeTools(params) {
  if (!_optionalChain([params, 'access', _276 => _276.config, 'optionalAccess', _277 => _277.tools])) {
    return null;
  }
  try {
    return params.config.tools.map((tool) => {
      if (typeof tool === "object" && tool.functionDeclarations) {
        return tool;
      }
      return tool;
    });
  } catch (e14) {
    return null;
  }
}
function extractMetadata(params) {
  const metadata = {};
  if (params.model) {
    metadata.model = params.model;
  }
  if (params.config) {
    const config = tryToDict(params.config);
    if (config) {
      Object.keys(config).forEach((key) => {
        if (key !== "tools") {
          metadata[key] = config[key];
        }
      });
    }
  }
  return metadata;
}
function extractGenerateContentMetrics(response, start) {
  const end = getCurrentUnixTimestamp();
  const metrics2 = {
    start,
    end,
    duration: end - start
  };
  if (response.usageMetadata) {
    const usage = response.usageMetadata;
    if (usage.promptTokenCount !== void 0) {
      metrics2.prompt_tokens = usage.promptTokenCount;
    }
    if (usage.candidatesTokenCount !== void 0) {
      metrics2.completion_tokens = usage.candidatesTokenCount;
    }
    if (usage.totalTokenCount !== void 0) {
      metrics2.tokens = usage.totalTokenCount;
    }
    if (usage.cachedContentTokenCount !== void 0) {
      metrics2.prompt_cached_tokens = usage.cachedContentTokenCount;
    }
    if (usage.thoughtsTokenCount !== void 0) {
      metrics2.completion_reasoning_tokens = usage.thoughtsTokenCount;
    }
  }
  return metrics2;
}
function aggregateGenerateContentChunks(chunks, start, firstTokenTime) {
  const end = getCurrentUnixTimestamp();
  const metrics2 = {
    start,
    end,
    duration: end - start
  };
  if (firstTokenTime !== null) {
    metrics2.time_to_first_token = firstTokenTime - start;
  }
  if (chunks.length === 0) {
    return { aggregated: {}, metrics: metrics2 };
  }
  let text = "";
  let thoughtText = "";
  const otherParts = [];
  let usageMetadata = null;
  let lastResponse = null;
  for (const chunk of chunks) {
    lastResponse = chunk;
    if (chunk.usageMetadata) {
      usageMetadata = chunk.usageMetadata;
    }
    if (chunk.candidates && Array.isArray(chunk.candidates)) {
      for (const candidate of chunk.candidates) {
        if (_optionalChain([candidate, 'access', _278 => _278.content, 'optionalAccess', _279 => _279.parts])) {
          for (const part of candidate.content.parts) {
            if (part.text !== void 0) {
              if (part.thought) {
                thoughtText += part.text;
              } else {
                text += part.text;
              }
            } else if (part.functionCall) {
              otherParts.push({ functionCall: part.functionCall });
            } else if (part.codeExecutionResult) {
              otherParts.push({
                codeExecutionResult: part.codeExecutionResult
              });
            } else if (part.executableCode) {
              otherParts.push({ executableCode: part.executableCode });
            }
          }
        }
      }
    }
  }
  const aggregated = {};
  const parts = [];
  if (thoughtText) {
    parts.push({ text: thoughtText, thought: true });
  }
  if (text) {
    parts.push({ text });
  }
  parts.push(...otherParts);
  if (parts.length > 0 && _optionalChain([lastResponse, 'optionalAccess', _280 => _280.candidates])) {
    const candidates = [];
    for (const candidate of lastResponse.candidates) {
      const candidateDict = {
        content: {
          parts,
          role: "model"
        }
      };
      if (candidate.finishReason !== void 0) {
        candidateDict.finishReason = candidate.finishReason;
      }
      if (candidate.safetyRatings) {
        candidateDict.safetyRatings = candidate.safetyRatings;
      }
      candidates.push(candidateDict);
    }
    aggregated.candidates = candidates;
  }
  if (usageMetadata) {
    aggregated.usageMetadata = usageMetadata;
    if (usageMetadata.promptTokenCount !== void 0) {
      metrics2.prompt_tokens = usageMetadata.promptTokenCount;
    }
    if (usageMetadata.candidatesTokenCount !== void 0) {
      metrics2.completion_tokens = usageMetadata.candidatesTokenCount;
    }
    if (usageMetadata.totalTokenCount !== void 0) {
      metrics2.tokens = usageMetadata.totalTokenCount;
    }
    if (usageMetadata.cachedContentTokenCount !== void 0) {
      metrics2.prompt_cached_tokens = usageMetadata.cachedContentTokenCount;
    }
    if (usageMetadata.thoughtsTokenCount !== void 0) {
      metrics2.completion_reasoning_tokens = usageMetadata.thoughtsTokenCount;
    }
  }
  if (text) {
    aggregated.text = text;
  }
  return { aggregated, metrics: metrics2 };
}
function cleanMetrics(metrics2) {
  const cleaned = {};
  for (const [key, value] of Object.entries(metrics2)) {
    if (value !== null && value !== void 0) {
      cleaned[key] = value;
    }
  }
  return cleaned;
}
function tryToDict(obj) {
  if (obj === null || obj === void 0) {
    return null;
  }
  if (typeof obj === "object") {
    if (typeof obj.toJSON === "function") {
      return obj.toJSON();
    }
    return obj;
  }
  return null;
}

// src/otel.ts
init_span_identifier_v4();
init_span_identifier_v3();
var otelApi = null;
var otelSdk = null;
var OTEL_AVAILABLE2 = false;
try {
  otelApi = (init_esm(), __toCommonJS(esm_exports));
  otelSdk = __require("@opentelemetry/sdk-trace-base");
  OTEL_AVAILABLE2 = true;
} catch (e15) {
  console.warn(
    "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
  );
  OTEL_AVAILABLE2 = false;
}
var FILTER_PREFIXES = [
  "gen_ai.",
  "braintrust.",
  "llm.",
  "ai.",
  "traceloop."
];
var AISpanProcessor = class _AISpanProcessor {
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  
  
  /**
   * Initialize the filter span processor.
   *
   * @param processor - The wrapped span processor that will receive filtered spans
   * @param customFilter - Optional function that takes a span and returns:
   *                      true to keep, false to drop,
   *                      null/undefined to not influence the decision
   */
  constructor(processor, customFilter) {
    _AISpanProcessor.checkOtelAvailable();
    this.processor = processor;
    this.customFilter = customFilter;
  }
  /**
   * Forward span start events to the inner processor.
   */
  onStart(span, parentContext) {
    this.processor.onStart(span, parentContext);
  }
  /**
   * Apply filtering logic and conditionally forward span end events.
   */
  onEnd(span) {
    const shouldKeep = this.shouldKeepFilteredSpan(span);
    if (shouldKeep) {
      this.processor.onEnd(span);
    }
  }
  /**
   * Shutdown the inner processor.
   */
  shutdown() {
    return this.processor.shutdown();
  }
  /**
   * Force flush the inner processor.
   */
  forceFlush() {
    return this.processor.forceFlush();
  }
  /**
   * Determine if a span should be kept based on filtering criteria.
   *
   * Keep spans if:
   * 1. It's a root span (no parent)
   * 2. Custom filter returns true/false (if provided)
   * 3. Span name starts with 'gen_ai.', 'braintrust.', 'llm.', 'ai.', or 'traceloop.'
   * 4. Any attribute name starts with those prefixes
   */
  shouldKeepFilteredSpan(span) {
    if (!span) {
      return false;
    }
    if (!span.parentSpanContext && !span.parentSpanId) {
      return true;
    }
    if (this.customFilter) {
      const customResult = this.customFilter(span);
      if (customResult === true) {
        return true;
      } else if (customResult === false) {
        return false;
      }
    }
    if (FILTER_PREFIXES.some((prefix) => span.name.startsWith(prefix))) {
      return true;
    }
    const attributes = span.attributes;
    if (attributes) {
      const attributeNames = Object.keys(attributes);
      if (attributeNames.some(
        (name) => FILTER_PREFIXES.some((prefix) => name.startsWith(prefix))
      )) {
        return true;
      }
    }
    return false;
  }
};
var BraintrustSpanProcessor = class _BraintrustSpanProcessor {
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  
  
  constructor(options = {}) {
    _BraintrustSpanProcessor.checkOtelAvailable();
    const apiKey = options.apiKey || process.env.BRAINTRUST_API_KEY;
    if (!apiKey) {
      throw new Error(
        "Braintrust API key is required. Set BRAINTRUST_API_KEY environment variable or pass apiKey option."
      );
    }
    let apiUrl = options.apiUrl || process.env.BRAINTRUST_API_URL || "https://api.braintrust.dev";
    if (!apiUrl.endsWith("/")) {
      apiUrl += "/";
    }
    let parent = options.parent || process.env.BRAINTRUST_PARENT;
    if (!parent) {
      parent = "project_name:default-otel-project";
      console.info(
        `No parent specified, using default: ${parent}. Configure with BRAINTRUST_PARENT environment variable or parent parameter.`
      );
    }
    let exporter;
    try {
      const {
        OTLPTraceExporter
      } = __require("@opentelemetry/exporter-trace-otlp-http");
      const headers = {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "x-bt-parent": parent,
        ...options.headers
      };
      const baseExporter = new OTLPTraceExporter({
        url: new URL("otel/v1/traces", apiUrl).href,
        headers
      });
      exporter = new Proxy(baseExporter, {
        get(target, prop, receiver) {
          if (prop === "export") {
            return function(spans, resultCallback) {
              const fixedSpans = spans.map((span) => {
                if (!span.instrumentationScope && span.instrumentationLibrary) {
                  span.instrumentationScope = span.instrumentationLibrary;
                }
                if (!span.parentSpanContext && span.parentSpanId) {
                  const spanContext = _optionalChain([span, 'access', _281 => _281.spanContext, 'optionalCall', _282 => _282()]);
                  if (_optionalChain([spanContext, 'optionalAccess', _283 => _283.traceId])) {
                    span.parentSpanContext = {
                      spanId: span.parentSpanId,
                      traceId: spanContext.traceId
                    };
                  }
                }
                return span;
              });
              return Reflect.apply(
                target.export,
                target,
                [fixedSpans, resultCallback]
              );
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      });
    } catch (error2) {
      console.error(error2);
      throw new Error(
        "Failed to create OTLP exporter. Make sure @opentelemetry/exporter-trace-otlp-http is installed."
      );
    }
    if (!otelSdk) {
      throw new Error("OpenTelemetry SDK not available");
    }
    this.processor = new otelSdk.BatchSpanProcessor(exporter);
    if (options.filterAISpans === true) {
      this.aiSpanProcessor = new AISpanProcessor(
        this.processor,
        options.customFilter
      );
    } else {
      this.aiSpanProcessor = this.processor;
    }
  }
  onStart(span, parentContext) {
    try {
      let parentValue;
      if (otelApi && otelApi.context) {
        const currentContext = otelApi.context.active();
        const contextValue = _optionalChain([currentContext, 'access', _284 => _284.getValue, 'optionalCall', _285 => _285("braintrust.parent")]);
        if (typeof contextValue === "string") {
          parentValue = contextValue;
        }
        if (!parentValue && parentContext) {
          const parentContextValue = typeof parentContext.getValue === "function" ? parentContext.getValue("braintrust.parent") : void 0;
          if (typeof parentContextValue === "string") {
            parentValue = parentContextValue;
          }
        }
        if (!parentValue && parentContext) {
          parentValue = this._getParentOtelBraintrustParent(parentContext);
        }
        if (parentValue && typeof span.setAttributes === "function") {
          span.setAttributes({ "braintrust.parent": parentValue });
        }
      }
    } catch (e16) {
    }
    this.aiSpanProcessor.onStart(span, parentContext);
  }
  _getParentOtelBraintrustParent(parentContext) {
    try {
      if (!otelApi || !otelApi.trace) {
        return void 0;
      }
      const currentSpan2 = typeof otelApi.trace.getSpan === "function" ? otelApi.trace.getSpan(parentContext) : void 0;
      if (currentSpan2 && typeof currentSpan2 === "object" && "attributes" in currentSpan2 && typeof currentSpan2.attributes === "object") {
        const attributes = currentSpan2.attributes;
        const parentAttr = attributes["braintrust.parent"];
        return typeof parentAttr === "string" ? parentAttr : void 0;
      }
      return void 0;
    } catch (e17) {
      return void 0;
    }
  }
  onEnd(span) {
    this.aiSpanProcessor.onEnd(span);
  }
  shutdown() {
    return this.aiSpanProcessor.shutdown();
  }
  forceFlush() {
    return this.aiSpanProcessor.forceFlush();
  }
};
function otelContextFromSpanExport(exportStr) {
  if (!OTEL_AVAILABLE2 || !otelApi) {
    return void 0;
  }
  const components = SpanComponentsV4.fromStr(exportStr);
  const traceIdHex = components.data.root_span_id;
  const spanIdHex = components.data.span_id;
  if (!traceIdHex || !spanIdHex) {
    throw new Error(
      "Export string must contain root_span_id and span_id for distributed tracing"
    );
  }
  const otelTrace2 = otelApi.trace;
  const spanContext = {
    traceId: traceIdHex,
    spanId: spanIdHex,
    isRemote: true,
    traceFlags: _nullishCoalesce(_optionalChain([otelApi, 'access', _286 => _286.TraceFlags, 'optionalAccess', _287 => _287.SAMPLED]), () => ( 1))
    // SAMPLED flag
  };
  const nonRecordingSpan = otelTrace2.wrapSpanContext(spanContext);
  let ctx = otelTrace2.setSpan(otelApi.context.active(), nonRecordingSpan);
  const braintrustParent = getBraintrustParent(
    components.data.object_type,
    components.data.object_id,
    components.data.compute_object_metadata_args
  );
  if (braintrustParent) {
    try {
      const propagation2 = otelApi.propagation;
      if (propagation2) {
        const baggage = propagation2.getBaggage(ctx) || propagation2.createBaggage();
        ctx = propagation2.setBaggage(
          ctx,
          baggage.setEntry("braintrust.parent", { value: braintrustParent })
        );
      }
    } catch (error2) {
      console.error(
        "Failed to set braintrust.parent in baggage during context import:",
        error2
      );
    }
  }
  return ctx;
}
function getBraintrustParent(objectType, objectId, computeArgs) {
  if (!objectType) {
    return void 0;
  }
  if (objectType === 2 /* PROJECT_LOGS */) {
    if (objectId) {
      return `project_id:${objectId}`;
    } else if (computeArgs) {
      const projectId = computeArgs["project_id"];
      const projectName = computeArgs["project_name"];
      if (typeof projectId === "string") {
        return `project_id:${projectId}`;
      } else if (typeof projectName === "string") {
        return `project_name:${projectName}`;
      }
    }
  } else if (objectType === 1 /* EXPERIMENT */) {
    if (objectId) {
      return `experiment_id:${objectId}`;
    } else if (computeArgs) {
      const experimentId = computeArgs["experiment_id"];
      if (typeof experimentId === "string") {
        return `experiment_id:${experimentId}`;
      }
    }
  }
  return void 0;
}
var BraintrustExporter = (_class21 = class _BraintrustExporter {
  static checkOtelAvailable() {
    if (!OTEL_AVAILABLE2) {
      throw new Error(
        "OpenTelemetry packages are not installed. Install them with: npm install @opentelemetry/api @opentelemetry/sdk-trace-base @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions"
      );
    }
  }
  
  __init59() {this.spans = []}
  __init60() {this.callbacks = []}
  constructor(options = {}) {;_class21.prototype.__init59.call(this);_class21.prototype.__init60.call(this);
    _BraintrustExporter.checkOtelAvailable();
    this.processor = new BraintrustSpanProcessor(options);
  }
  /**
   * Export spans to Braintrust by simulating span processor behavior.
   */
  export(spans, resultCallback) {
    try {
      spans.forEach((span) => {
        this.processor.onEnd(span);
      });
      this.processor.forceFlush().then(() => {
        resultCallback({ code: 0 });
      }).catch((error2) => {
        resultCallback({ code: 1, error: error2 });
      });
    } catch (error2) {
      resultCallback({ code: 1, error: error2 });
    }
  }
  /**
   * Shutdown the exporter.
   */
  shutdown() {
    return this.processor.shutdown();
  }
  /**
   * Force flush the exporter.
   */
  forceFlush() {
    return this.processor.forceFlush();
  }
}, _class21);
function addParentToBaggage(parent, ctx) {
  if (!OTEL_AVAILABLE2 || !otelApi) {
    console.error("OpenTelemetry not available");
    return ctx || _optionalChain([otelApi, 'optionalAccess', _288 => _288.context, 'access', _289 => _289.active, 'call', _290 => _290()]);
  }
  try {
    const propagation2 = otelApi.propagation;
    if (!propagation2) {
      console.error("OTEL propagation API not available");
      return ctx || otelApi.context.active();
    }
    const currentCtx = ctx || otelApi.context.active();
    const baggage = propagation2.getBaggage(currentCtx) || propagation2.createBaggage();
    return propagation2.setBaggage(
      currentCtx,
      baggage.setEntry("braintrust.parent", { value: parent })
    );
  } catch (error2) {
    console.error("Failed to add braintrust.parent to baggage:", error2);
    return ctx || otelApi.context.active();
  }
}
function addSpanParentToBaggage(span, ctx) {
  if (!span || !span.attributes) {
    console.warn("addSpanParentToBaggage: span has no attributes");
    return void 0;
  }
  const parentValue = span.attributes["braintrust.parent"];
  if (!parentValue || typeof parentValue !== "string") {
    console.warn(
      "addSpanParentToBaggage: braintrust.parent attribute not found. Ensure BraintrustSpanProcessor is configured or span is created within Braintrust context."
    );
    return void 0;
  }
  return addParentToBaggage(parentValue, ctx);
}
function parentFromHeaders(headers) {
  if (!OTEL_AVAILABLE2 || !otelApi) {
    console.error("OpenTelemetry not available");
    return void 0;
  }
  try {
    const propagation2 = otelApi.propagation;
    if (!propagation2) {
      console.error("OTEL propagation API not available");
      return void 0;
    }
    const ctx = propagation2.extract(otelApi.context.active(), headers);
    const spanContext = otelApi.trace.getSpanContext(ctx);
    if (!spanContext) {
      console.error("parentFromHeaders: No valid span context in headers");
      return void 0;
    }
    const traceIdHex = spanContext.traceId;
    const spanIdHex = spanContext.spanId;
    if (!traceIdHex || typeof traceIdHex !== "string" || traceIdHex === "00000000000000000000000000000000") {
      console.error("parentFromHeaders: Invalid trace_id (all zeros)");
      return void 0;
    }
    if (!spanIdHex || typeof spanIdHex !== "string" || spanIdHex === "0000000000000000") {
      console.error("parentFromHeaders: Invalid span_id (all zeros)");
      return void 0;
    }
    const baggage = propagation2.getBaggage(ctx);
    const braintrustParent = _optionalChain([baggage, 'optionalAccess', _291 => _291.getEntry, 'call', _292 => _292("braintrust.parent"), 'optionalAccess', _293 => _293.value]);
    if (!braintrustParent) {
      console.warn(
        "parentFromHeaders: braintrust.parent not found in OTEL baggage. Cannot create Braintrust parent without project information. Ensure the OTEL span sets braintrust.parent in baggage before exporting headers."
      );
      return void 0;
    }
    let objectType;
    let objectId;
    let computeArgs;
    if (braintrustParent.startsWith("project_id:")) {
      objectType = 2 /* PROJECT_LOGS */;
      objectId = braintrustParent.substring("project_id:".length);
      if (!objectId) {
        console.error(
          `parentFromHeaders: Invalid braintrust.parent format (empty project_id): ${braintrustParent}`
        );
        return void 0;
      }
    } else if (braintrustParent.startsWith("project_name:")) {
      objectType = 2 /* PROJECT_LOGS */;
      const projectName = braintrustParent.substring("project_name:".length);
      if (!projectName) {
        console.error(
          `parentFromHeaders: Invalid braintrust.parent format (empty project_name): ${braintrustParent}`
        );
        return void 0;
      }
      computeArgs = { project_name: projectName };
    } else if (braintrustParent.startsWith("experiment_id:")) {
      objectType = 1 /* EXPERIMENT */;
      objectId = braintrustParent.substring("experiment_id:".length);
      if (!objectId) {
        console.error(
          `parentFromHeaders: Invalid braintrust.parent format (empty experiment_id): ${braintrustParent}`
        );
        return void 0;
      }
    } else {
      console.error(
        `parentFromHeaders: Invalid braintrust.parent format: ${braintrustParent}. Expected format: 'project_id:ID', 'project_name:NAME', or 'experiment_id:ID'`
      );
      return void 0;
    }
    const componentsData = {
      object_type: objectType,
      row_id: "otel",
      // Dummy row_id to enable span_id/root_span_id fields
      span_id: spanIdHex,
      root_span_id: traceIdHex
    };
    if (computeArgs) {
      componentsData.compute_object_metadata_args = computeArgs;
    } else {
      componentsData.object_id = objectId;
    }
    const components = new SpanComponentsV4(componentsData);
    return components.toStr();
  } catch (error2) {
    console.error("parentFromHeaders: Error parsing headers:", error2);
    return void 0;
  }
}
var otel = {
  contextFromSpanExport: otelContextFromSpanExport,
  getBraintrustParent,
  addParentToBaggage,
  addSpanParentToBaggage,
  parentFromHeaders
};

// dev/types.ts
init_generated_types();

var evalBodySchema = _v3.z.object({
  name: _v3.z.string(),
  parameters: _v3.z.record(_v3.z.string(), _v3.z.unknown()).nullish(),
  data: RunEval.shape.data,
  scores: _v3.z.array(
    _v3.z.object({
      function_id: FunctionId,
      name: _v3.z.string()
    })
  ).nullish(),
  experiment_name: _v3.z.string().nullish(),
  project_id: _v3.z.string().nullish(),
  parent: InvokeParent.optional(),
  stream: _v3.z.boolean().optional()
});
var evalParametersSerializedSchema = _v3.z.record(
  _v3.z.string(),
  _v3.z.union([
    _v3.z.object({
      type: _v3.z.literal("prompt"),
      default: PromptData.optional(),
      description: _v3.z.string().optional()
    }),
    _v3.z.object({
      type: _v3.z.literal("data"),
      schema: _v3.z.record(_v3.z.unknown()),
      // JSON Schema
      default: _v3.z.unknown().optional(),
      description: _v3.z.string().optional()
    })
  ])
);
var evaluatorDefinitionSchema = _v3.z.object({
  parameters: evalParametersSerializedSchema.optional()
});
var evaluatorDefinitionsSchema = _v3.z.record(
  _v3.z.string(),
  evaluatorDefinitionSchema
);

// src/index.ts
configureNode();
var index_default = exports_node_exports;
















































































































exports.AISpanProcessor = AISpanProcessor; exports.Attachment = Attachment; exports.BaseAttachment = BaseAttachment; exports.BaseExperiment = BaseExperiment; exports.BraintrustExporter = BraintrustExporter; exports.BraintrustMiddleware = BraintrustMiddleware; exports.BraintrustSpanProcessor = BraintrustSpanProcessor; exports.BraintrustState = BraintrustState; exports.BraintrustStream = BraintrustStream; exports.CodeFunction = CodeFunction; exports.CodePrompt = CodePrompt; exports.ContextManager = ContextManager; exports.Dataset = Dataset2; exports.ERR_PERMALINK = ERR_PERMALINK; exports.Eval = Eval; exports.EvalResultWithSummary = EvalResultWithSummary; exports.Experiment = Experiment2; exports.ExternalAttachment = ExternalAttachment; exports.FailedHTTPResponse = FailedHTTPResponse; exports.IDGenerator = IDGenerator; exports.INTERNAL_BTQL_LIMIT = INTERNAL_BTQL_LIMIT; exports.JSONAttachment = JSONAttachment; exports.LEGACY_CACHED_HEADER = LEGACY_CACHED_HEADER; exports.LazyValue = LazyValue; exports.Logger = Logger; exports.NOOP_SPAN = NOOP_SPAN; exports.NOOP_SPAN_PERMALINK = NOOP_SPAN_PERMALINK; exports.NoopSpan = NoopSpan; exports.OTELIDGenerator = OTELIDGenerator; exports.Project = Project2; exports.ProjectNameIdMap = ProjectNameIdMap; exports.Prompt = Prompt2; exports.PromptBuilder = PromptBuilder; exports.ReadonlyAttachment = ReadonlyAttachment; exports.ReadonlyExperiment = ReadonlyExperiment; exports.Reporter = Reporter; exports.ScorerBuilder = ScorerBuilder; exports.SpanImpl = SpanImpl; exports.TestBackgroundLogger = TestBackgroundLogger; exports.ToolBuilder = ToolBuilder; exports.UUIDGenerator = UUIDGenerator; exports.X_CACHED_HEADER = X_CACHED_HEADER; exports._exportsForTestingOnly = _exportsForTestingOnly; exports._internalGetGlobalState = _internalGetGlobalState; exports._internalSetInitialState = _internalSetInitialState; exports.braintrustStreamChunkSchema = braintrustStreamChunkSchema; exports.buildLocalSummary = buildLocalSummary; exports.createFinalValuePassThroughStream = createFinalValuePassThroughStream; exports.currentExperiment = currentExperiment; exports.currentLogger = currentLogger; exports.currentSpan = currentSpan; exports.deepCopyEvent = deepCopyEvent; exports.default = index_default; exports.defaultErrorScoreHandler = defaultErrorScoreHandler; exports.deserializePlainStringAsJSON = deserializePlainStringAsJSON; exports.devNullWritableStream = devNullWritableStream; exports.evaluatorDefinitionSchema = evaluatorDefinitionSchema; exports.evaluatorDefinitionsSchema = evaluatorDefinitionsSchema; exports.flush = flush; exports.getContextManager = getContextManager; exports.getIdGenerator = getIdGenerator; exports.getPromptVersions = getPromptVersions; exports.getSpanParentObject = getSpanParentObject; exports.graph = graph_framework_exports; exports.init = init; exports.initDataset = initDataset; exports.initExperiment = initExperiment; exports.initFunction = initFunction; exports.initLogger = initLogger; exports.invoke = invoke; exports.loadPrompt = loadPrompt; exports.log = log; exports.logError = logError; exports.login = login; exports.loginToState = loginToState; exports.newId = newId; exports.otel = otel; exports.parseCachedHeader = parseCachedHeader; exports.permalink = permalink; exports.projects = projects; exports.promptContentsSchema = promptContentsSchema; exports.promptDefinitionSchema = promptDefinitionSchema; exports.promptDefinitionToPromptData = promptDefinitionToPromptData; exports.promptDefinitionWithToolsSchema = promptDefinitionWithToolsSchema; exports.renderMessage = renderMessage; exports.renderPromptParams = renderPromptParams; exports.reportFailures = reportFailures; exports.runEvaluator = runEvaluator; exports.setFetch = setFetch; exports.setMaskingFunction = setMaskingFunction; exports.spanComponentsToObjectId = spanComponentsToObjectId; exports.startSpan = startSpan; exports.summarize = summarize; exports.toolFunctionDefinitionSchema = ToolFunctionDefinition; exports.traceable = traceable; exports.traced = traced; exports.updateSpan = updateSpan; exports.withCurrent = withCurrent; exports.withDataset = withDataset; exports.withExperiment = withExperiment; exports.withLogger = withLogger; exports.withParent = withParent; exports.wrapAISDK = wrapAISDK; exports.wrapAISDKModel = wrapAISDKModel; exports.wrapAnthropic = wrapAnthropic; exports.wrapClaudeAgentSDK = wrapClaudeAgentSDK; exports.wrapGoogleGenAI = wrapGoogleGenAI; exports.wrapMastraAgent = wrapMastraAgent; exports.wrapOpenAI = wrapOpenAI; exports.wrapOpenAIv4 = wrapOpenAIv4; exports.wrapTraced = wrapTraced;
