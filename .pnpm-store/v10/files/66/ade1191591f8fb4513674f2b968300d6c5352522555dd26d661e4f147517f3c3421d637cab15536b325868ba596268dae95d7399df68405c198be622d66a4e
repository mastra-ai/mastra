"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.audioFormatToMime = exports.mapVoice = exports.mapModel = exports.mapLanguage = exports.fetchJSON = exports.queryAPI = exports.SpeechifyError = void 0;
const version_js_1 = require("./version.js");
/**
 * Error class that represents Speechify API server errors.
 * @property statusCode - The HTTP status code of the error.
 */
class SpeechifyError extends Error {
    statusCode;
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
    }
}
exports.SpeechifyError = SpeechifyError;
const queryAPI = async ({ baseUrl, url, token, jsonPayload, options: initialOptions = {}, }) => {
    const options = { ...initialOptions };
    const headers = new Headers(options.headers);
    options.headers = headers;
    headers.set("Authorization", `Bearer ${token}`);
    headers.set("X-Speechify-SDK", "nodejs");
    headers.set("X-Speechify-SDK-Version", version_js_1.VERSION);
    // In the browser, enforce CORS
    if (typeof window !== "undefined") {
        options.mode = "cors";
    }
    if (jsonPayload) {
        options.body = JSON.stringify(jsonPayload);
        if (!headers.get("Content-Type")) {
            headers.set("Content-Type", "application/json");
        }
    }
    const fullUrl = new URL(url, baseUrl);
    const response = await fetch(fullUrl.toString(), options);
    if (!response.ok) {
        const error = await response.text();
        throw new SpeechifyError(`Speechify API Error ${response.statusText}: ${error || "Unknown error"}`, response.status);
    }
    return response;
};
exports.queryAPI = queryAPI;
const fetchJSON = async ({ baseUrl, url, token, jsonPayload, options = {}, }) => {
    const response = await (0, exports.queryAPI)({
        baseUrl,
        url,
        token,
        jsonPayload,
        options,
    });
    const contentType = response.headers.get("content-type");
    const parseJson = contentType?.includes("application/json");
    if (!parseJson) {
        throw new Error("Response is not JSON");
    }
    return response.json();
};
exports.fetchJSON = fetchJSON;
const mapLanguage = (lang) => {
    return {
        locale: lang.locale,
        previewAudio: lang.preview_audio,
    };
};
exports.mapLanguage = mapLanguage;
const mapModel = (model) => {
    return {
        name: model.name,
        languages: model.languages.map(exports.mapLanguage),
    };
};
exports.mapModel = mapModel;
const mapVoice = (voice) => {
    return {
        id: voice.id,
        type: voice.type,
        displayName: voice.display_name,
        models: voice.models.map(exports.mapModel),
        gender: voice.gender,
        avatarImage: voice.avatar_image,
        previewAudio: voice.preview_audio,
        tags: voice.tags,
    };
};
exports.mapVoice = mapVoice;
const audioFormatToMime = (format) => {
    switch (format) {
        case "mp3":
            return "audio/mpeg";
        case "wav":
            return "audio/wav";
        case "ogg":
            return "audio/ogg";
        case "aac":
            return "audio/aac";
        default:
            throw new Error(`Unsupported audio format: ${format}`);
    }
};
exports.audioFormatToMime = audioFormatToMime;
//# sourceMappingURL=fetch.js.map