import type { MastraDBMessage } from '../agent/index.js';
import type { ScoreRowData, ScoringSource } from '../evals/types.js';
import type { StorageThreadType } from '../memory/types.js';
import type { StepResult, WorkflowRunState } from '../workflows/types.js';
import { MastraStorage } from './base.js';
import type { StorageDomains } from './base.js';
import type { TABLE_NAMES } from './constants.js';
import type { SpanRecord, TraceRecord, PaginationInfo, StorageColumn, StoragePagination, StorageResourceType, WorkflowRun } from './types.js';
export declare class InMemoryStore extends MastraStorage {
    stores: StorageDomains;
    constructor({ id }?: {
        id?: string;
    });
    get supports(): {
        selectByIncludeResourceScope: boolean;
        resourceWorkingMemory: boolean;
        hasColumn: boolean;
        createTable: boolean;
        deleteMessages: boolean;
        observabilityInstance: boolean;
        indexManagement: boolean;
        listScoresBySpan: boolean;
    };
    persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot, }: {
        workflowName: string;
        runId: string;
        resourceId?: string;
        snapshot: WorkflowRunState;
    }): Promise<void>;
    loadWorkflowSnapshot({ workflowName, runId, }: {
        workflowName: string;
        runId: string;
    }): Promise<WorkflowRunState | null>;
    createTable({ tableName, schema, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
    }): Promise<void>;
    alterTable({ tableName, schema, ifNotExists, }: {
        tableName: TABLE_NAMES;
        schema: Record<string, StorageColumn>;
        ifNotExists: string[];
    }): Promise<void>;
    clearTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    dropTable({ tableName }: {
        tableName: TABLE_NAMES;
    }): Promise<void>;
    insert({ tableName, record }: {
        tableName: TABLE_NAMES;
        record: Record<string, any>;
    }): Promise<void>;
    updateWorkflowResults({ workflowName, runId, stepId, result, requestContext, }: {
        workflowName: string;
        runId: string;
        stepId: string;
        result: StepResult<any, any, any, any>;
        requestContext: Record<string, any>;
    }): Promise<Record<string, StepResult<any, any, any, any>>>;
    updateWorkflowState({ workflowName, runId, opts, }: {
        workflowName: string;
        runId: string;
        opts: {
            status: string;
            result?: StepResult<any, any, any, any>;
            error?: string;
            suspendedPaths?: Record<string, number[]>;
            waitingPaths?: Record<string, number[]>;
        };
    }): Promise<WorkflowRunState | undefined>;
    batchInsert({ tableName, records }: {
        tableName: TABLE_NAMES;
        records: Record<string, any>[];
    }): Promise<void>;
    load<R>({ tableName, keys }: {
        tableName: TABLE_NAMES;
        keys: Record<string, string>;
    }): Promise<R | null>;
    getThreadById({ threadId }: {
        threadId: string;
    }): Promise<StorageThreadType | null>;
    saveThread({ thread }: {
        thread: StorageThreadType;
    }): Promise<StorageThreadType>;
    updateThread({ id, title, metadata, }: {
        id: string;
        title: string;
        metadata: Record<string, unknown>;
    }): Promise<StorageThreadType>;
    deleteThread({ threadId }: {
        threadId: string;
    }): Promise<void>;
    getResourceById({ resourceId }: {
        resourceId: string;
    }): Promise<StorageResourceType | null>;
    saveResource({ resource }: {
        resource: StorageResourceType;
    }): Promise<StorageResourceType>;
    updateResource({ resourceId, workingMemory, metadata, }: {
        resourceId: string;
        workingMemory?: string;
        metadata?: Record<string, unknown>;
    }): Promise<StorageResourceType>;
    listMessagesById({ messageIds }: {
        messageIds: string[];
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    saveMessages(args: {
        messages: MastraDBMessage[];
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    updateMessages(args: {
        messages: (Partial<MastraDBMessage> & {
            id: string;
        })[];
    }): Promise<MastraDBMessage[]>;
    deleteMessages(messageIds: string[]): Promise<void>;
    getScoreById({ id }: {
        id: string;
    }): Promise<ScoreRowData | null>;
    saveScore(score: ScoreRowData): Promise<{
        score: ScoreRowData;
    }>;
    listScoresByScorerId({ scorerId, entityId, entityType, source, pagination, }: {
        scorerId: string;
        entityId?: string;
        entityType?: string;
        source?: ScoringSource;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    listScoresByRunId({ runId, pagination, }: {
        runId: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    listScoresByEntityId({ entityId, entityType, pagination, }: {
        entityId: string;
        entityType: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    listScoresBySpan({ traceId, spanId, pagination, }: {
        traceId: string;
        spanId: string;
        pagination: StoragePagination;
    }): Promise<{
        pagination: PaginationInfo;
        scores: ScoreRowData[];
    }>;
    getWorkflowRunById({ runId, workflowName, }: {
        runId: string;
        workflowName?: string;
    }): Promise<WorkflowRun | null>;
    createSpan(span: SpanRecord): Promise<void>;
    updateSpan(params: {
        spanId: string;
        traceId: string;
        updates: Partial<Omit<SpanRecord, 'spanId' | 'traceId'>>;
    }): Promise<void>;
    getTrace(traceId: string): Promise<TraceRecord | null>;
    batchCreateSpans(args: {
        records: SpanRecord[];
    }): Promise<void>;
    batchUpdateSpans(args: {
        records: {
            traceId: string;
            spanId: string;
            updates: Partial<Omit<SpanRecord, 'spanId' | 'traceId'>>;
        }[];
    }): Promise<void>;
    batchDeleteTraces(args: {
        traceIds: string[];
    }): Promise<void>;
}
export declare const MockStore: typeof InMemoryStore;
//# sourceMappingURL=mock.d.ts.map