'use strict';

var chunkXJQX54QP_cjs = require('../chunk-XJQX54QP.cjs');
var chunkV3VLOOSW_cjs = require('../chunk-V3VLOOSW.cjs');
var chunkDQIZ5FFX_cjs = require('../chunk-DQIZ5FFX.cjs');
var chunkNHP6ZIDG_cjs = require('../chunk-NHP6ZIDG.cjs');
var chunkRROQ46B6_cjs = require('../chunk-RROQ46B6.cjs');
var chunkKEXGB7FK_cjs = require('../chunk-KEXGB7FK.cjs');
var zodToJson = require('@mastra/schema-compat/zod-to-json');
var zod = require('zod');

// src/memory/memory.ts
var MemoryProcessor = class extends chunkKEXGB7FK_cjs.MastraBase {
  /**
   * Process a list of messages and return a filtered or transformed list.
   * @param messages The messages to process
   * @returns The processed messages
   */
  process(messages, _opts) {
    return messages;
  }
};
var memoryDefaultOptions = {
  lastMessages: 10,
  semanticRecall: false,
  generateTitle: false,
  workingMemory: {
    enabled: false,
    template: `
# User Information
- **First Name**: 
- **Last Name**: 
- **Location**: 
- **Occupation**: 
- **Interests**: 
- **Goals**: 
- **Events**: 
- **Facts**: 
- **Projects**: 
`
  }
};
var MastraMemory = class extends chunkKEXGB7FK_cjs.MastraBase {
  MAX_CONTEXT_TOKENS;
  _storage;
  vector;
  embedder;
  processors = [];
  threadConfig = { ...memoryDefaultOptions };
  #mastra;
  constructor(config) {
    super({ component: "MEMORY", name: config.name });
    if (config.options) this.threadConfig = this.getMergedThreadConfig(config.options);
    if (config.processors) this.processors = config.processors;
    if (config.storage) {
      this._storage = chunkV3VLOOSW_cjs.augmentWithInit(config.storage);
      this._hasOwnStorage = true;
    }
    if (this.threadConfig.semanticRecall) {
      if (!config.vector) {
        throw new Error(
          `Semantic recall requires a vector store to be configured.

https://mastra.ai/en/docs/memory/semantic-recall`
        );
      }
      this.vector = config.vector;
      if (!config.embedder) {
        throw new Error(
          `Semantic recall requires an embedder to be configured.

https://mastra.ai/en/docs/memory/semantic-recall`
        );
      }
      if (typeof config.embedder === "string") {
        this.embedder = new chunkNHP6ZIDG_cjs.ModelRouterEmbeddingModel(config.embedder);
      } else {
        this.embedder = config.embedder;
      }
    }
  }
  /**
   * Internal method used by Mastra to register itself with the memory.
   * @param mastra The Mastra instance.
   * @internal
   */
  __registerMastra(mastra) {
    this.#mastra = mastra;
  }
  _hasOwnStorage = false;
  get hasOwnStorage() {
    return this._hasOwnStorage;
  }
  get storage() {
    if (!this._storage) {
      throw new Error(
        `Memory requires a storage provider to function. Add a storage configuration to Memory or to your Mastra instance.

https://mastra.ai/en/docs/memory/overview`
      );
    }
    return this._storage;
  }
  setStorage(storage) {
    this._storage = chunkV3VLOOSW_cjs.augmentWithInit(storage);
  }
  setVector(vector) {
    this.vector = vector;
  }
  setEmbedder(embedder) {
    this.embedder = embedder;
  }
  /**
   * Get a system message to inject into the conversation.
   * This will be called before each conversation turn.
   * Implementations can override this to inject custom system messages.
   */
  async getSystemMessage(_input) {
    return null;
  }
  /**
   * Get tools that should be available to the agent.
   * This will be called when converting tools for the agent.
   * Implementations can override this to provide additional tools.
   */
  listTools(_config) {
    return {};
  }
  async createEmbeddingIndex(dimensions, config) {
    const defaultDimensions = 1536;
    const isDefault = dimensions === defaultDimensions;
    const usedDimensions = dimensions ?? defaultDimensions;
    const separator = this.vector?.indexSeparator ?? "_";
    const indexName = isDefault ? `memory${separator}messages` : `memory${separator}messages${separator}${usedDimensions}`;
    if (typeof this.vector === `undefined`) {
      throw new Error(`Tried to create embedding index but no vector db is attached to this Memory instance.`);
    }
    const semanticConfig = typeof config?.semanticRecall === "object" ? config.semanticRecall : void 0;
    const indexConfig = semanticConfig?.indexConfig;
    const createParams = {
      indexName,
      dimension: usedDimensions,
      ...indexConfig?.metric && { metric: indexConfig.metric }
    };
    if (indexConfig && (indexConfig.type || indexConfig.ivf || indexConfig.hnsw)) {
      createParams.indexConfig = {};
      if (indexConfig.type) createParams.indexConfig.type = indexConfig.type;
      if (indexConfig.ivf) createParams.indexConfig.ivf = indexConfig.ivf;
      if (indexConfig.hnsw) createParams.indexConfig.hnsw = indexConfig.hnsw;
    }
    await this.vector.createIndex(createParams);
    return { indexName };
  }
  getMergedThreadConfig(config) {
    if (config?.workingMemory && "use" in config.workingMemory) {
      throw new Error("The workingMemory.use option has been removed. Working memory always uses tool-call mode.");
    }
    if (config?.threads?.generateTitle !== void 0) {
      throw new Error(
        "The threads.generateTitle option has been moved. Use the top-level generateTitle option instead."
      );
    }
    const mergedConfig = chunkRROQ46B6_cjs.deepMerge(this.threadConfig, config || {});
    if (config?.workingMemory?.schema) {
      if (mergedConfig.workingMemory) {
        mergedConfig.workingMemory.schema = config.workingMemory.schema;
      }
    }
    return mergedConfig;
  }
  /**
   * Apply all configured message processors to a list of messages.
   * @param messages The messages to process
   * @returns The processed messages
   */
  async applyProcessors(messages, opts) {
    const processors = opts.processors || this.processors;
    if (!processors || processors.length === 0) {
      return messages;
    }
    let processedMessages = [...messages];
    for (const processor of processors) {
      processedMessages = await processor.process(processedMessages, {
        systemMessage: opts.systemMessage,
        newMessages: opts.newMessages,
        memorySystemMessage: opts.memorySystemMessage
      });
    }
    return processedMessages;
  }
  processMessages({
    messages,
    processors,
    ...opts
  }) {
    return this.applyProcessors(messages, { processors: processors || this.processors, ...opts });
  }
  estimateTokens(text) {
    return Math.ceil(text.split(" ").length * 1.3);
  }
  /**
   * Helper method to create a new thread
   * @param title - Optional title for the thread
   * @param metadata - Optional metadata for the thread
   * @returns Promise resolving to the created thread
   */
  async createThread({
    threadId,
    resourceId,
    title,
    metadata,
    memoryConfig,
    saveThread = true
  }) {
    const thread = {
      id: threadId || this.generateId(),
      title: title || `New Thread ${(/* @__PURE__ */ new Date()).toISOString()}`,
      resourceId,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      metadata
    };
    return saveThread ? this.saveThread({ thread, memoryConfig }) : thread;
  }
  /**
   * Helper method to add a single message to a thread
   * @param threadId - The thread to add the message to
   * @param content - The message content
   * @param role - The role of the message sender
   * @param type - The type of the message
   * @param toolNames - Optional array of tool names that were called
   * @param toolCallArgs - Optional array of tool call arguments
   * @param toolCallIds - Optional array of tool call ids
   * @returns Promise resolving to the saved message
   * @deprecated use saveMessages instead
   */
  async addMessage(_params) {
    throw new Error("addMessage is deprecated. Please use saveMessages instead.");
  }
  /**
   * Generates a unique identifier
   * @returns A unique string ID
   */
  generateId() {
    return this.#mastra?.generateId() || crypto.randomUUID();
  }
};
var isZodObject = (v) => v instanceof zod.ZodObject;
var MockMemory = class extends MastraMemory {
  constructor({ storage } = {}) {
    super({ name: "mock", storage: storage || new chunkXJQX54QP_cjs.InMemoryStore() });
    this._hasOwnStorage = true;
  }
  async getThreadById({ threadId }) {
    return this.storage.getThreadById({ threadId });
  }
  async saveThread({ thread }) {
    return this.storage.saveThread({ thread });
  }
  async saveMessages({
    messages
  }) {
    const dbMessages = new chunkDQIZ5FFX_cjs.MessageList({
      generateMessageId: () => this.generateId()
    }).add(messages, "memory").get.all.db();
    return this.storage.saveMessages({ messages: dbMessages });
  }
  async listThreadsByResourceId(args) {
    return this.storage.listThreadsByResourceId(args);
  }
  async recall(args) {
    const result = await this.storage.listMessages({
      threadId: args.threadId,
      resourceId: args.resourceId,
      perPage: args.perPage,
      page: args.page,
      orderBy: args.orderBy,
      filter: args.filter,
      include: args.include
    });
    return result;
  }
  async deleteThread(threadId) {
    return this.storage.deleteThread({ threadId });
  }
  async deleteMessages(messageIds) {
    const ids = Array.isArray(messageIds) ? messageIds?.map((item) => typeof item === "string" ? item : item.id) : [messageIds];
    return this.storage.deleteMessages(ids);
  }
  async getWorkingMemory({
    threadId,
    resourceId,
    memoryConfig
  }) {
    const mergedConfig = this.getMergedThreadConfig(memoryConfig);
    const workingMemoryConfig = mergedConfig.workingMemory;
    if (!workingMemoryConfig?.enabled) {
      return null;
    }
    const scope = workingMemoryConfig.scope || "resource";
    const id = scope === "resource" ? resourceId : threadId;
    if (!id) {
      return null;
    }
    const resource = await this.storage.getResourceById({ resourceId: id });
    return resource?.workingMemory || null;
  }
  async getWorkingMemoryTemplate({
    memoryConfig
  } = {}) {
    const mergedConfig = this.getMergedThreadConfig(memoryConfig);
    const workingMemoryConfig = mergedConfig.workingMemory;
    if (!workingMemoryConfig?.enabled) {
      return null;
    }
    if (workingMemoryConfig.template) {
      return {
        format: "markdown",
        content: workingMemoryConfig.template
      };
    }
    if (workingMemoryConfig.schema) {
      try {
        const schema = workingMemoryConfig.schema;
        let convertedSchema;
        if (isZodObject(schema)) {
          convertedSchema = zodToJson.zodToJsonSchema(schema);
        } else {
          convertedSchema = schema;
        }
        return { format: "json", content: JSON.stringify(convertedSchema) };
      } catch (error) {
        this.logger?.error?.("Error converting schema", error);
        throw error;
      }
    }
    return null;
  }
  async updateWorkingMemory({
    threadId,
    resourceId,
    workingMemory,
    memoryConfig
  }) {
    const mergedConfig = this.getMergedThreadConfig(memoryConfig);
    const workingMemoryConfig = mergedConfig.workingMemory;
    if (!workingMemoryConfig?.enabled) {
      return;
    }
    const scope = workingMemoryConfig.scope || "resource";
    const id = scope === "resource" ? resourceId : threadId;
    if (!id) {
      throw new Error(`Cannot update working memory: ${scope} ID is required`);
    }
    await this.storage.updateResource({
      resourceId: id,
      workingMemory
    });
  }
  async __experimental_updateWorkingMemoryVNext({
    threadId,
    resourceId,
    workingMemory,
    searchString: _searchString,
    memoryConfig
  }) {
    try {
      await this.updateWorkingMemory({
        threadId,
        resourceId,
        workingMemory,
        memoryConfig
      });
      return { success: true, reason: "Working memory updated successfully" };
    } catch (error) {
      return {
        success: false,
        reason: error instanceof Error ? error.message : "Failed to update working memory"
      };
    }
  }
};

exports.MastraMemory = MastraMemory;
exports.MemoryProcessor = MemoryProcessor;
exports.MockMemory = MockMemory;
exports.memoryDefaultOptions = memoryDefaultOptions;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map