{"version":3,"sources":["../src/config.ts","../src/exporters/base.ts","../src/exporters/cloud.ts","../src/exporters/console.ts","../src/exporters/default.ts","../src/model-tracing.ts","../src/spans/base.ts","../src/spans/default.ts","../src/spans/no-op.ts","../src/instances/base.ts","../src/instances/default.ts","../src/registry.ts","../src/span_processors/sensitive-data-filter.ts","../src/default.ts"],"names":["SamplingStrategyType","LogLevel","TracingEventType","SpanType","MastraError","MastraBase","RegisteredLogger","ErrorDomain","ErrorCategory"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Configuration types for Mastra Observability\n *\n * These types define the configuration structure for observability,\n * including tracing configs, sampling strategies, and registry setup.\n */\n\nimport type { RequestContext } from '@mastra/core/di';\nimport type {\n  ObservabilityInstance,\n  ObservabilityExporter,\n  SpanOutputProcessor,\n  ConfigSelector,\n} from '@mastra/core/observability';\nimport { z } from 'zod';\n\n// ============================================================================\n// Sampling Strategy Types\n// ============================================================================\n\n/**\n * Sampling strategy types\n */\nexport enum SamplingStrategyType {\n  ALWAYS = 'always',\n  NEVER = 'never',\n  RATIO = 'ratio',\n  CUSTOM = 'custom',\n}\n\n/**\n * Options passed when using a custom sampler strategy\n */\nexport interface CustomSamplerOptions {\n  requestContext?: RequestContext;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Sampling strategy configuration\n */\nexport type SamplingStrategy =\n  | { type: SamplingStrategyType.ALWAYS }\n  | { type: SamplingStrategyType.NEVER }\n  | { type: SamplingStrategyType.RATIO; probability: number }\n  | { type: SamplingStrategyType.CUSTOM; sampler: (options?: CustomSamplerOptions) => boolean };\n\n// ============================================================================\n// Observability Configuration Types\n// ============================================================================\n\n/**\n * Configuration for a single observability instance\n */\nexport interface ObservabilityInstanceConfig {\n  /** Unique identifier for this config in the tracing registry */\n  name: string;\n  /** Service name for tracing */\n  serviceName: string;\n  /** Sampling strategy - controls whether tracing is collected (defaults to ALWAYS) */\n  sampling?: SamplingStrategy;\n  /** Custom exporters */\n  exporters?: ObservabilityExporter[];\n  /** Custom span output processors */\n  spanOutputProcessors?: SpanOutputProcessor[];\n  /** Set to `true` if you want to see spans internal to the operation of mastra */\n  includeInternalSpans?: boolean;\n  /**\n   * RequestContext keys to automatically extract as metadata for all spans\n   * created with this tracing configuration.\n   * Supports dot notation for nested values.\n   */\n  requestContextKeys?: string[];\n}\n\n/**\n * Complete Observability registry configuration\n */\nexport interface ObservabilityRegistryConfig {\n  /** Enables default exporters, with sampling: always, and sensitive data filtering */\n  default?: {\n    enabled?: boolean;\n  };\n  /** Map of tracing instance names to their configurations or pre-instantiated instances */\n  configs?: Record<string, Omit<ObservabilityInstanceConfig, 'name'> | ObservabilityInstance>;\n  /** Optional selector function to choose which tracing instance to use */\n  configSelector?: ConfigSelector;\n}\n\n// ============================================================================\n// Zod Schemas for Validation\n// ============================================================================\n\n/**\n * Zod schema for SamplingStrategy\n */\nexport const samplingStrategySchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal(SamplingStrategyType.ALWAYS),\n  }),\n  z.object({\n    type: z.literal(SamplingStrategyType.NEVER),\n  }),\n  z.object({\n    type: z.literal(SamplingStrategyType.RATIO),\n    probability: z.number().min(0, 'Probability must be between 0 and 1').max(1, 'Probability must be between 0 and 1'),\n  }),\n  z.object({\n    type: z.literal(SamplingStrategyType.CUSTOM),\n    sampler: z.function().args(z.any().optional()).returns(z.boolean()),\n  }),\n]);\n\n/**\n * Zod schema for ObservabilityInstanceConfig\n * Note: exporters, spanOutputProcessors, and configSelector are validated as any\n * since they're complex runtime objects\n */\nexport const observabilityInstanceConfigSchema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  serviceName: z.string().min(1, 'Service name is required'),\n  sampling: samplingStrategySchema.optional(),\n  exporters: z.array(z.any()).optional(),\n  spanOutputProcessors: z.array(z.any()).optional(),\n  includeInternalSpans: z.boolean().optional(),\n  requestContextKeys: z.array(z.string()).optional(),\n});\n\n/**\n * Zod schema for config values in the configs map\n * This is the config object without the name field\n */\nexport const observabilityConfigValueSchema = z.object({\n  serviceName: z.string().min(1, 'Service name is required'),\n  sampling: samplingStrategySchema.optional(),\n  exporters: z.array(z.any()).optional(),\n  spanOutputProcessors: z.array(z.any()).optional(),\n  includeInternalSpans: z.boolean().optional(),\n  requestContextKeys: z.array(z.string()).optional(),\n});\n\n/**\n * Zod schema for ObservabilityRegistryConfig\n * Note: Individual configs are validated separately in the constructor to allow for\n * both plain config objects and pre-instantiated ObservabilityInstance objects.\n * The schema is permissive to handle edge cases gracefully (arrays, null values).\n */\nexport const observabilityRegistryConfigSchema = z\n  .object({\n    default: z\n      .object({\n        enabled: z.boolean().optional(),\n      })\n      .optional()\n      .nullable(),\n    configs: z.union([z.record(z.string(), z.any()), z.array(z.any()), z.null()]).optional(),\n    configSelector: z.function().optional(),\n  })\n  .passthrough() // Allow additional properties\n  .refine(\n    data => {\n      // Validate that default (when enabled) and configs are mutually exclusive\n      const isDefaultEnabled = data.default?.enabled === true;\n      // Check if configs has any entries (only if it's actually an object)\n      const hasConfigs =\n        data.configs && typeof data.configs === 'object' && !Array.isArray(data.configs)\n          ? Object.keys(data.configs).length > 0\n          : false;\n\n      // Cannot have both default enabled and any configs\n      return !(isDefaultEnabled && hasConfigs);\n    },\n    {\n      message:\n        'Cannot specify both \"default\" (when enabled) and \"configs\". Use either default observability or custom configs, but not both.',\n    },\n  )\n  .refine(\n    data => {\n      // Validate that configSelector is required when there are multiple configs\n      const configCount =\n        data.configs && typeof data.configs === 'object' && !Array.isArray(data.configs)\n          ? Object.keys(data.configs).length\n          : 0;\n\n      // If there are 2 or more configs, configSelector must be provided\n      if (configCount > 1 && !data.configSelector) {\n        return false;\n      }\n\n      return true;\n    },\n    {\n      message:\n        'A \"configSelector\" function is required when multiple configs are specified to determine which config to use.',\n    },\n  );\n","/**\n * Base Exporter for Observability\n *\n * Provides common functionality shared by all observability exporters:\n * - Logger initialization with proper Mastra logger support\n * - Disabled state management\n * - Graceful shutdown lifecycle\n */\n\nimport { ConsoleLogger, LogLevel } from '@mastra/core/logger';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { TracingEvent, ObservabilityExporter, InitExporterOptions } from '@mastra/core/observability';\n\n/**\n * Base configuration that all exporters should support\n */\nexport interface BaseExporterConfig {\n  /** Optional Mastra logger instance */\n  logger?: IMastraLogger;\n  /** Log level for the exporter (defaults to INFO) - accepts both enum and string */\n  logLevel?: LogLevel | 'debug' | 'info' | 'warn' | 'error';\n}\n\n/**\n * Abstract base class for observability exporters\n *\n * Handles common concerns:\n * - Logger setup with proper Mastra logger\n * - Disabled state management\n * - Basic lifecycle methods\n *\n * @example\n * ```typescript\n * class MyExporter extends BaseExporter {\n *   name = 'my-exporter';\n *\n *   constructor(config: MyExporterConfig) {\n *     super(config);\n *\n *     if (!config.apiKey) {\n *       this.setDisabled('Missing API key');\n *       return;\n *     }\n *\n *     // Initialize exporter-specific logic\n *   }\n *\n *   async _exportEvent(event: TracingEvent): Promise<void> {\n *     // Export logic\n *   }\n * }\n * ```\n */\nexport abstract class BaseExporter implements ObservabilityExporter {\n  /** Exporter name - must be implemented by subclasses */\n  abstract name: string;\n\n  /** Mastra logger instance */\n  protected logger: IMastraLogger;\n\n  /** Whether this exporter is disabled */\n  protected isDisabled: boolean = false;\n\n  /**\n   * Initialize the base exporter with logger\n   */\n  constructor(config: BaseExporterConfig = {}) {\n    // Map string log level to LogLevel enum if needed\n    const logLevel = this.resolveLogLevel(config.logLevel);\n    // Use constructor name as fallback since this.name isn't set yet (subclass initializes it)\n    this.logger = config.logger ?? new ConsoleLogger({ level: logLevel, name: this.constructor.name });\n  }\n\n  /**\n   * Set the logger for the exporter (called by Mastra/ObservabilityInstance during initialization)\n   */\n  __setLogger(logger: IMastraLogger): void {\n    this.logger = logger;\n    // Use this.name here since it's guaranteed to be set by the subclass at this point\n    this.logger.debug(`Logger updated for exporter [name=${this.name}]`);\n  }\n\n  /**\n   * Convert string log level to LogLevel enum\n   */\n  private resolveLogLevel(logLevel?: LogLevel | 'debug' | 'info' | 'warn' | 'error'): LogLevel {\n    if (!logLevel) {\n      return LogLevel.INFO;\n    }\n\n    // If already a LogLevel enum, return as-is\n    if (typeof logLevel === 'number') {\n      return logLevel;\n    }\n\n    // Map string to enum\n    const logLevelMap: Record<string, LogLevel> = {\n      debug: LogLevel.DEBUG,\n      info: LogLevel.INFO,\n      warn: LogLevel.WARN,\n      error: LogLevel.ERROR,\n    };\n\n    return logLevelMap[logLevel] ?? LogLevel.INFO;\n  }\n\n  /**\n   * Mark the exporter as disabled and log a message\n   *\n   * @param reason - Reason why the exporter is disabled\n   */\n  protected setDisabled(reason: string): void {\n    this.isDisabled = true;\n    this.logger.warn(`${this.name} disabled: ${reason}`);\n  }\n\n  /**\n   * Export a tracing event\n   *\n   * This method checks if the exporter is disabled before calling _exportEvent.\n   * Subclasses should implement _exportEvent instead of overriding this method.\n   */\n  async exportTracingEvent(event: TracingEvent): Promise<void> {\n    if (this.isDisabled) {\n      return;\n    }\n    await this._exportTracingEvent(event);\n  }\n\n  /**\n   * Export a tracing event - must be implemented by subclasses\n   *\n   * This method is called by exportTracingEvent after checking if the exporter is disabled.\n   */\n  protected abstract _exportTracingEvent(event: TracingEvent): Promise<void>;\n\n  /**\n   * Optional initialization hook called after Mastra is fully configured\n   */\n  init?(_options: InitExporterOptions): void;\n\n  /**\n   * Optional method to add scores to traces\n   */\n  addScoreToTrace?(_args: {\n    traceId: string;\n    spanId?: string;\n    score: number;\n    reason?: string;\n    scorerName: string;\n    metadata?: Record<string, any>;\n  }): Promise<void>;\n\n  /**\n   * Shutdown the exporter and clean up resources\n   *\n   * Default implementation just logs. Override to add custom cleanup.\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info(`${this.name} shutdown complete`);\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { LogLevel } from '@mastra/core/logger';\nimport { TracingEventType } from '@mastra/core/observability';\nimport type { TracingEvent, AnyExportedSpan } from '@mastra/core/observability';\nimport { fetchWithRetry } from '@mastra/core/utils';\nimport { BaseExporter } from './base';\nimport type { BaseExporterConfig } from './base';\n\nexport interface CloudExporterConfig extends BaseExporterConfig {\n  maxBatchSize?: number; // Default: 1000 spans\n  maxBatchWaitMs?: number; // Default: 5000ms\n  maxRetries?: number; // Default: 3\n\n  // Cloud-specific configuration\n  accessToken?: string; // Cloud access token (from env or config)\n  endpoint?: string; // Cloud observability endpoint\n}\n\ninterface MastraCloudBuffer {\n  spans: MastraCloudSpanRecord[];\n  firstEventTime?: Date;\n  totalSize: number;\n}\n\ninterface MastraCloudSpanRecord {\n  traceId: string;\n  spanId: string;\n  parentSpanId: string | null;\n  name: string;\n  spanType: string;\n  attributes: Record<string, any> | null;\n  metadata: Record<string, any> | null;\n  startedAt: Date;\n  endedAt: Date | null;\n  input: any;\n  output: any;\n  error: any;\n  isEvent: boolean;\n  createdAt: Date;\n  updatedAt: Date | null;\n}\n\nexport class CloudExporter extends BaseExporter {\n  name = 'mastra-cloud-observability-exporter';\n\n  private config: Required<CloudExporterConfig>;\n  private buffer: MastraCloudBuffer;\n  private flushTimer: NodeJS.Timeout | null = null;\n\n  constructor(config: CloudExporterConfig = {}) {\n    super(config);\n\n    const accessToken = config.accessToken ?? process.env.MASTRA_CLOUD_ACCESS_TOKEN;\n    if (!accessToken) {\n      this.setDisabled(\n        'MASTRA_CLOUD_ACCESS_TOKEN environment variable not set. ' +\n          ' Sign up for Mastra Cloud at https://cloud.mastra.ai to see your traces online and obtain your access token.',\n      );\n    }\n\n    const endpoint =\n      config.endpoint ?? process.env.MASTRA_CLOUD_TRACES_ENDPOINT ?? 'https://api.mastra.ai/ai/spans/publish';\n\n    this.config = {\n      logger: this.logger,\n      logLevel: config.logLevel ?? LogLevel.INFO,\n      maxBatchSize: config.maxBatchSize ?? 1000,\n      maxBatchWaitMs: config.maxBatchWaitMs ?? 5000,\n      maxRetries: config.maxRetries ?? 3,\n      accessToken: accessToken || '',\n      endpoint,\n    };\n\n    this.buffer = {\n      spans: [],\n      totalSize: 0,\n    };\n  }\n\n  protected async _exportTracingEvent(event: TracingEvent): Promise<void> {\n    // Cloud Observability only process SPAN_ENDED events\n    if (event.type !== TracingEventType.SPAN_ENDED) {\n      return;\n    }\n\n    this.addToBuffer(event);\n\n    if (this.shouldFlush()) {\n      this.flush().catch(error => {\n        this.logger.error('Batch flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    } else if (this.buffer.totalSize === 1) {\n      this.scheduleFlush();\n    }\n  }\n\n  private addToBuffer(event: TracingEvent): void {\n    // Set first event time if buffer is empty\n    if (this.buffer.totalSize === 0) {\n      this.buffer.firstEventTime = new Date();\n    }\n\n    const spanRecord = this.formatSpan(event.exportedSpan);\n    this.buffer.spans.push(spanRecord);\n    this.buffer.totalSize++;\n  }\n\n  private formatSpan(span: AnyExportedSpan): MastraCloudSpanRecord {\n    const spanRecord: MastraCloudSpanRecord = {\n      traceId: span.traceId,\n      spanId: span.id,\n      parentSpanId: span.parentSpanId ?? null,\n      name: span.name,\n      spanType: span.type,\n      attributes: span.attributes ?? null,\n      metadata: span.metadata ?? null,\n      startedAt: span.startTime,\n      endedAt: span.endTime ?? null,\n      input: span.input ?? null,\n      output: span.output ?? null,\n      error: span.errorInfo,\n      isEvent: span.isEvent,\n      createdAt: new Date(),\n      updatedAt: null,\n    };\n\n    return spanRecord;\n  }\n\n  private shouldFlush(): boolean {\n    // Size-based flush\n    if (this.buffer.totalSize >= this.config.maxBatchSize) {\n      return true;\n    }\n\n    // Time-based flush\n    if (this.buffer.firstEventTime && this.buffer.totalSize > 0) {\n      const elapsed = Date.now() - this.buffer.firstEventTime.getTime();\n      if (elapsed >= this.config.maxBatchWaitMs) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private scheduleFlush(): void {\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n    }\n    this.flushTimer = setTimeout(() => {\n      this.flush().catch(error => {\n        const mastraError = new MastraError(\n          {\n            id: `CLOUD_EXPORTER_FAILED_TO_SCHEDULE_FLUSH`,\n            domain: ErrorDomain.MASTRA_OBSERVABILITY,\n            category: ErrorCategory.USER,\n          },\n          error,\n        );\n        this.logger.trackException(mastraError);\n        this.logger.error('Scheduled flush failed', mastraError);\n      });\n    }, this.config.maxBatchWaitMs);\n  }\n\n  private async flush(): Promise<void> {\n    // Clear timer since we're flushing\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    if (this.buffer.totalSize === 0) {\n      return; // Nothing to flush\n    }\n\n    const startTime = Date.now();\n    const spansCopy = [...this.buffer.spans];\n    const flushReason = this.buffer.totalSize >= this.config.maxBatchSize ? 'size' : 'time';\n\n    // Reset buffer immediately to prevent blocking new events\n    this.resetBuffer();\n\n    try {\n      // Use fetchWithRetry for all retry logic\n      await this.batchUpload(spansCopy);\n\n      const elapsed = Date.now() - startTime;\n      this.logger.debug('Batch flushed successfully', {\n        batchSize: spansCopy.length,\n        flushReason,\n        durationMs: elapsed,\n      });\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: `CLOUD_EXPORTER_FAILED_TO_BATCH_UPLOAD`,\n          domain: ErrorDomain.MASTRA_OBSERVABILITY,\n          category: ErrorCategory.USER,\n          details: {\n            droppedBatchSize: spansCopy.length,\n          },\n        },\n        error,\n      );\n      this.logger.trackException(mastraError);\n      this.logger.error('Batch upload failed after all retries, dropping batch', mastraError);\n      // Don't re-throw - we want to continue processing new events\n    }\n  }\n\n  /**\n   * Uploads spans to cloud API using fetchWithRetry for all retry logic\n   */\n  private async batchUpload(spans: MastraCloudSpanRecord[]): Promise<void> {\n    const headers = {\n      Authorization: `Bearer ${this.config.accessToken}`,\n      'Content-Type': 'application/json',\n    };\n\n    const options: RequestInit = {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({ spans }),\n    };\n\n    await fetchWithRetry(this.config.endpoint, options, this.config.maxRetries);\n  }\n\n  private resetBuffer(): void {\n    this.buffer.spans = [];\n    this.buffer.firstEventTime = undefined;\n    this.buffer.totalSize = 0;\n  }\n\n  async shutdown(): Promise<void> {\n    // Skip if disabled\n    if (this.isDisabled) {\n      return;\n    }\n\n    // Clear any pending timer\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    // Flush any remaining events\n    if (this.buffer.totalSize > 0) {\n      this.logger.info('Flushing remaining events on shutdown', {\n        remainingEvents: this.buffer.totalSize,\n      });\n      try {\n        await this.flush();\n      } catch (error) {\n        const mastraError = new MastraError(\n          {\n            id: `CLOUD_EXPORTER_FAILED_TO_FLUSH_REMAINING_EVENTS_DURING_SHUTDOWN`,\n            domain: ErrorDomain.MASTRA_OBSERVABILITY,\n            category: ErrorCategory.USER,\n            details: {\n              remainingEvents: this.buffer.totalSize,\n            },\n          },\n          error,\n        );\n\n        this.logger.trackException(mastraError);\n        this.logger.error('Failed to flush remaining events during shutdown', mastraError);\n      }\n    }\n\n    this.logger.info('CloudExporter shutdown complete');\n  }\n}\n","import { TracingEventType } from '@mastra/core/observability';\nimport type { TracingEvent } from '@mastra/core/observability';\nimport { BaseExporter } from './base';\nimport type { BaseExporterConfig } from './base';\n\nexport class ConsoleExporter extends BaseExporter {\n  name = 'tracing-console-exporter';\n\n  constructor(config: BaseExporterConfig = {}) {\n    super(config);\n  }\n\n  protected async _exportTracingEvent(event: TracingEvent): Promise<void> {\n    const span = event.exportedSpan;\n\n    // Helper to safely stringify attributes (filtering already done by processor)\n    const formatAttributes = (attributes: any) => {\n      try {\n        return JSON.stringify(attributes, null, 2);\n      } catch (error) {\n        const errMsg = error instanceof Error ? error.message : 'Unknown formatting error';\n        return `[Unable to serialize attributes: ${errMsg}]`;\n      }\n    };\n\n    // Helper to format duration\n    const formatDuration = (startTime: Date, endTime?: Date) => {\n      if (!endTime) return 'N/A';\n      const duration = endTime.getTime() - startTime.getTime();\n      return `${duration}ms`;\n    };\n\n    switch (event.type) {\n      case TracingEventType.SPAN_STARTED:\n        this.logger.info(` SPAN_STARTED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        this.logger.info(`   Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info(''.repeat(80));\n        break;\n\n      case TracingEventType.SPAN_ENDED:\n        const duration = formatDuration(span.startTime, span.endTime);\n        this.logger.info(` SPAN_ENDED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Duration: ${duration}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        if (span.output !== undefined) {\n          this.logger.info(`   Output: ${formatAttributes(span.output)}`);\n        }\n        if (span.errorInfo) {\n          this.logger.info(`   Error: ${formatAttributes(span.errorInfo)}`);\n        }\n        this.logger.info(`   Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info(''.repeat(80));\n        break;\n\n      case TracingEventType.SPAN_UPDATED:\n        this.logger.info(` SPAN_UPDATED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        if (span.output !== undefined) {\n          this.logger.info(`   Output: ${formatAttributes(span.output)}`);\n        }\n        if (span.errorInfo) {\n          this.logger.info(`   Error: ${formatAttributes(span.errorInfo)}`);\n        }\n        this.logger.info(`   Updated Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info(''.repeat(80));\n        break;\n\n      default:\n        this.logger.warn(`Tracing event type not implemented: ${(event as any).type}`);\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('ConsoleExporter shutdown');\n  }\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport type {\n  TracingEvent,\n  AnyExportedSpan,\n  InitExporterOptions,\n  TracingStorageStrategy,\n} from '@mastra/core/observability';\nimport { TracingEventType } from '@mastra/core/observability';\nimport type { MastraStorage, CreateSpanRecord, UpdateSpanRecord } from '@mastra/core/storage';\nimport type { BaseExporterConfig } from './base';\nimport { BaseExporter } from './base';\n\ninterface DefaultExporterConfig extends BaseExporterConfig {\n  maxBatchSize?: number; // Default: 1000 spans\n  maxBufferSize?: number; // Default: 10000 spans\n  maxBatchWaitMs?: number; // Default: 5000ms\n  maxRetries?: number; // Default: 4\n  retryDelayMs?: number; // Default: 500ms (base delay for exponential backoff)\n\n  // Strategy selection (optional)\n  strategy?: TracingStorageStrategy | 'auto';\n}\n\ninterface BatchBuffer {\n  // For batch-with-updates strategy\n  creates: CreateSpanRecord[];\n  updates: UpdateRecord[];\n\n  // For insert-only strategy\n  insertOnly: CreateSpanRecord[];\n\n  // Ordering enforcement (batch-with-updates only)\n  seenSpans: Set<string>; // \"traceId:spanId\" combinations we've seen creates for\n  spanSequences: Map<string, number>; // \"traceId:spanId\" -> next sequence number\n\n  // Track completed spans for cleanup\n  completedSpans: Set<string>; // Spans that have received SPAN_ENDED\n\n  // Metrics\n  outOfOrderCount: number;\n\n  // Metadata\n  firstEventTime?: Date;\n  totalSize: number;\n}\n\ninterface UpdateRecord {\n  traceId: string;\n  spanId: string;\n  updates: Partial<UpdateSpanRecord>;\n  sequenceNumber: number; // For ordering updates to same span\n}\n\n/**\n * Resolves the final tracing storage strategy based on config and storage hints\n */\nfunction resolveTracingStorageStrategy(\n  config: DefaultExporterConfig,\n  storage: MastraStorage,\n  logger: IMastraLogger,\n): TracingStorageStrategy {\n  if (config.strategy && config.strategy !== 'auto') {\n    const hints = storage.tracingStrategy;\n    if (hints.supported.includes(config.strategy)) {\n      return config.strategy;\n    }\n    // Log warning and fall through to auto-selection\n    logger.warn('User-specified tracing strategy not supported by storage adapter, falling back to auto-selection', {\n      userStrategy: config.strategy,\n      storageAdapter: storage.constructor.name,\n      supportedStrategies: hints.supported,\n      fallbackStrategy: hints.preferred,\n    });\n  }\n  return storage.tracingStrategy.preferred;\n}\n\nexport class DefaultExporter extends BaseExporter {\n  name = 'mastra-default-observability-exporter';\n\n  #storage?: MastraStorage;\n  #config: DefaultExporterConfig;\n  #resolvedStrategy: TracingStorageStrategy;\n  private buffer: BatchBuffer;\n  #flushTimer: NodeJS.Timeout | null = null;\n\n  // Track all spans that have been created, persists across flushes\n  private allCreatedSpans: Set<string> = new Set();\n\n  constructor(config: DefaultExporterConfig = {}) {\n    super(config);\n\n    if (config === undefined) {\n      config = {};\n    }\n\n    // Set default configuration\n    this.#config = {\n      ...config,\n      maxBatchSize: config.maxBatchSize ?? 1000,\n      maxBufferSize: config.maxBufferSize ?? 10000,\n      maxBatchWaitMs: config.maxBatchWaitMs ?? 5000,\n      maxRetries: config.maxRetries ?? 4,\n      retryDelayMs: config.retryDelayMs ?? 500,\n      strategy: config.strategy ?? 'auto',\n    };\n\n    // Initialize buffer\n    this.buffer = {\n      creates: [],\n      updates: [],\n      insertOnly: [],\n      seenSpans: new Set(),\n      spanSequences: new Map(),\n      completedSpans: new Set(),\n      outOfOrderCount: 0,\n      totalSize: 0,\n    };\n\n    // Resolve strategy - we'll do this lazily on first export since we need storage\n    this.#resolvedStrategy = 'batch-with-updates'; // temporary default\n  }\n\n  #strategyInitialized = false;\n\n  /**\n   * Initialize the exporter (called after all dependencies are ready)\n   */\n  init(options: InitExporterOptions): void {\n    this.#storage = options.mastra?.getStorage();\n    if (!this.#storage) {\n      this.logger.warn('DefaultExporter disabled: Storage not available. Traces will not be persisted.');\n      return;\n    }\n\n    this.initializeStrategy(this.#storage);\n  }\n\n  /**\n   * Initialize the resolved strategy once storage is available\n   */\n  private initializeStrategy(storage: MastraStorage): void {\n    if (this.#strategyInitialized) return;\n\n    this.#resolvedStrategy = resolveTracingStorageStrategy(this.#config, storage, this.logger);\n    this.#strategyInitialized = true;\n\n    this.logger.debug('tracing storage exporter initialized', {\n      strategy: this.#resolvedStrategy,\n      source: this.#config.strategy !== 'auto' ? 'user' : 'auto',\n      storageAdapter: storage.constructor.name,\n      maxBatchSize: this.#config.maxBatchSize,\n      maxBatchWaitMs: this.#config.maxBatchWaitMs,\n    });\n  }\n\n  /**\n   * Builds a unique span key for tracking\n   */\n  private buildSpanKey(traceId: string, spanId: string): string {\n    return `${traceId}:${spanId}`;\n  }\n\n  /**\n   * Gets the next sequence number for a span\n   */\n  private getNextSequence(spanKey: string): number {\n    const current = this.buffer.spanSequences.get(spanKey) || 0;\n    const next = current + 1;\n    this.buffer.spanSequences.set(spanKey, next);\n    return next;\n  }\n\n  /**\n   * Handles out-of-order span updates by logging and skipping\n   */\n  private handleOutOfOrderUpdate(event: TracingEvent): void {\n    this.logger.warn('Out-of-order span update detected - skipping event', {\n      spanId: event.exportedSpan.id,\n      traceId: event.exportedSpan.traceId,\n      spanName: event.exportedSpan.name,\n      eventType: event.type,\n    });\n  }\n\n  /**\n   * Adds an event to the appropriate buffer based on strategy\n   */\n  private addToBuffer(event: TracingEvent): void {\n    const spanKey = this.buildSpanKey(event.exportedSpan.traceId, event.exportedSpan.id);\n\n    // Set first event time if buffer is empty\n    if (this.buffer.totalSize === 0) {\n      this.buffer.firstEventTime = new Date();\n    }\n\n    switch (event.type) {\n      case TracingEventType.SPAN_STARTED:\n        if (this.#resolvedStrategy === 'batch-with-updates') {\n          const createRecord = this.buildCreateRecord(event.exportedSpan);\n          this.buffer.creates.push(createRecord);\n          this.buffer.seenSpans.add(spanKey);\n          // Track this span as created persistently\n          this.allCreatedSpans.add(spanKey);\n        }\n        // insert-only ignores SPAN_STARTED\n        break;\n\n      case TracingEventType.SPAN_UPDATED:\n        if (this.#resolvedStrategy === 'batch-with-updates') {\n          if (this.allCreatedSpans.has(spanKey)) {\n            // Span was created previously (possibly in a prior batch)\n            this.buffer.updates.push({\n              traceId: event.exportedSpan.traceId,\n              spanId: event.exportedSpan.id,\n              updates: this.buildUpdateRecord(event.exportedSpan),\n              sequenceNumber: this.getNextSequence(spanKey),\n            });\n          } else {\n            // Out-of-order case: log and skip\n            this.handleOutOfOrderUpdate(event);\n            this.buffer.outOfOrderCount++;\n          }\n        }\n        // insert-only ignores SPAN_UPDATED\n        break;\n\n      case TracingEventType.SPAN_ENDED:\n        if (this.#resolvedStrategy === 'batch-with-updates') {\n          if (this.allCreatedSpans.has(spanKey)) {\n            // Span was created previously (possibly in a prior batch)\n            this.buffer.updates.push({\n              traceId: event.exportedSpan.traceId,\n              spanId: event.exportedSpan.id,\n              updates: this.buildUpdateRecord(event.exportedSpan),\n              sequenceNumber: this.getNextSequence(spanKey),\n            });\n            // Mark this span as completed\n            this.buffer.completedSpans.add(spanKey);\n          } else if (event.exportedSpan.isEvent) {\n            // Event-type spans only emit SPAN_ENDED (no prior SPAN_STARTED)\n            const createRecord = this.buildCreateRecord(event.exportedSpan);\n            this.buffer.creates.push(createRecord);\n            this.buffer.seenSpans.add(spanKey);\n            // Track this span as created persistently\n            this.allCreatedSpans.add(spanKey);\n            // Event spans are immediately complete\n            this.buffer.completedSpans.add(spanKey);\n          } else {\n            // Out-of-order case: log and skip\n            this.handleOutOfOrderUpdate(event);\n            this.buffer.outOfOrderCount++;\n          }\n        } else if (this.#resolvedStrategy === 'insert-only') {\n          // Only process SPAN_ENDED for insert-only strategy\n          const createRecord = this.buildCreateRecord(event.exportedSpan);\n          this.buffer.insertOnly.push(createRecord);\n          // Mark as completed for insert-only strategy\n          this.buffer.completedSpans.add(spanKey);\n          this.allCreatedSpans.add(spanKey);\n        }\n        break;\n    }\n\n    // Update total size\n    this.buffer.totalSize = this.buffer.creates.length + this.buffer.updates.length + this.buffer.insertOnly.length;\n  }\n\n  /**\n   * Checks if buffer should be flushed based on size or time triggers\n   */\n  private shouldFlush(): boolean {\n    // Emergency flush - buffer overflow\n    if (this.buffer.totalSize >= this.#config.maxBufferSize!) {\n      return true;\n    }\n\n    // Size-based flush\n    if (this.buffer.totalSize >= this.#config.maxBatchSize!) {\n      return true;\n    }\n\n    // Time-based flush\n    if (this.buffer.firstEventTime && this.buffer.totalSize > 0) {\n      const elapsed = Date.now() - this.buffer.firstEventTime.getTime();\n      if (elapsed >= this.#config.maxBatchWaitMs!) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Resets the buffer after successful flush\n   */\n  private resetBuffer(completedSpansToCleanup: Set<string> = new Set()): void {\n    this.buffer.creates = [];\n    this.buffer.updates = [];\n    this.buffer.insertOnly = [];\n    this.buffer.seenSpans.clear();\n    this.buffer.spanSequences.clear();\n    this.buffer.completedSpans.clear();\n    this.buffer.outOfOrderCount = 0;\n    this.buffer.firstEventTime = undefined;\n    this.buffer.totalSize = 0;\n\n    // Clean up completed spans from persistent tracking\n    for (const spanKey of completedSpansToCleanup) {\n      this.allCreatedSpans.delete(spanKey);\n    }\n  }\n\n  /**\n   * Schedules a flush using setTimeout\n   */\n  private scheduleFlush(): void {\n    if (this.#flushTimer) {\n      clearTimeout(this.#flushTimer);\n    }\n    this.#flushTimer = setTimeout(() => {\n      this.flush().catch(error => {\n        this.logger.error('Scheduled flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    }, this.#config.maxBatchWaitMs);\n  }\n\n  /**\n   * Serializes span attributes to storage record format\n   * Handles all Span types and their specific attributes\n   */\n  private serializeAttributes(span: AnyExportedSpan): Record<string, any> | null {\n    if (!span.attributes) {\n      return null;\n    }\n\n    try {\n      // Convert the typed attributes to a plain object\n      // This handles nested objects, dates, and other complex types\n      return JSON.parse(\n        JSON.stringify(span.attributes, (_key, value) => {\n          // Handle Date objects\n          if (value instanceof Date) {\n            return value.toISOString();\n          }\n          // Handle other objects that might not serialize properly\n          if (typeof value === 'object' && value !== null) {\n            // For arrays and plain objects, let JSON.stringify handle them\n            return value;\n          }\n          // For primitives, return as-is\n          return value;\n        }),\n      );\n    } catch (error) {\n      this.logger.warn('Failed to serialize span attributes, storing as null', {\n        spanId: span.id,\n        spanType: span.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      return null;\n    }\n  }\n\n  private buildCreateRecord(span: AnyExportedSpan): CreateSpanRecord {\n    return {\n      traceId: span.traceId,\n      spanId: span.id,\n      parentSpanId: span.parentSpanId ?? null,\n      name: span.name,\n      scope: null,\n      spanType: span.type,\n      attributes: this.serializeAttributes(span),\n      metadata: span.metadata ?? null,\n      links: null,\n      startedAt: span.startTime,\n      endedAt: span.endTime ?? null,\n      input: span.input,\n      output: span.output,\n      error: span.errorInfo,\n      isEvent: span.isEvent,\n    };\n  }\n\n  private buildUpdateRecord(span: AnyExportedSpan): Partial<UpdateSpanRecord> {\n    return {\n      name: span.name,\n      scope: null,\n      attributes: this.serializeAttributes(span),\n      metadata: span.metadata ?? null,\n      links: null,\n      endedAt: span.endTime ?? null,\n      input: span.input,\n      output: span.output,\n      error: span.errorInfo,\n    };\n  }\n\n  /**\n   * Handles realtime strategy - processes each event immediately\n   */\n  private async handleRealtimeEvent(event: TracingEvent, storage: MastraStorage): Promise<void> {\n    const span = event.exportedSpan;\n    const spanKey = this.buildSpanKey(span.traceId, span.id);\n\n    // Event spans only have an end event\n    if (span.isEvent) {\n      if (event.type === TracingEventType.SPAN_ENDED) {\n        await storage.createSpan(this.buildCreateRecord(event.exportedSpan));\n        // For event spans in realtime, we don't need to track them since they're immediately complete\n      } else {\n        this.logger.warn(`Tracing event type not implemented for event spans: ${event.type}`);\n      }\n    } else {\n      switch (event.type) {\n        case TracingEventType.SPAN_STARTED:\n          await storage.createSpan(this.buildCreateRecord(event.exportedSpan));\n          // Track this span as created persistently\n          this.allCreatedSpans.add(spanKey);\n          break;\n        case TracingEventType.SPAN_UPDATED:\n          await storage.updateSpan({\n            traceId: span.traceId,\n            spanId: span.id,\n            updates: this.buildUpdateRecord(span),\n          });\n          break;\n        case TracingEventType.SPAN_ENDED:\n          await storage.updateSpan({\n            traceId: span.traceId,\n            spanId: span.id,\n            updates: this.buildUpdateRecord(span),\n          });\n          // Clean up immediately for realtime strategy\n          this.allCreatedSpans.delete(spanKey);\n          break;\n        default:\n          this.logger.warn(`Tracing event type not implemented for span spans: ${(event as any).type}`);\n      }\n    }\n  }\n\n  /**\n   * Handles batch-with-updates strategy - buffers events and processes in batches\n   */\n  private handleBatchWithUpdatesEvent(event: TracingEvent): void {\n    this.addToBuffer(event);\n\n    if (this.shouldFlush()) {\n      // Immediate flush for size/emergency triggers\n      this.flush().catch(error => {\n        this.logger.error('Batch flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    } else if (this.buffer.totalSize === 1) {\n      // Schedule flush for the first event in buffer\n      this.scheduleFlush();\n    }\n  }\n\n  /**\n   * Handles insert-only strategy - only processes SPAN_ENDED events in batches\n   */\n  private handleInsertOnlyEvent(event: TracingEvent): void {\n    // Only process SPAN_ENDED events for insert-only strategy\n    if (event.type === TracingEventType.SPAN_ENDED) {\n      this.addToBuffer(event);\n\n      if (this.shouldFlush()) {\n        // Immediate flush for size/emergency triggers\n        this.flush().catch(error => {\n          this.logger.error('Batch flush failed', {\n            error: error instanceof Error ? error.message : String(error),\n          });\n        });\n      } else if (this.buffer.totalSize === 1) {\n        // Schedule flush for the first event in buffer\n        this.scheduleFlush();\n      }\n    }\n    // Ignore SPAN_STARTED and SPAN_UPDATED events\n  }\n\n  /**\n   * Calculates retry delay using exponential backoff\n   */\n  private calculateRetryDelay(attempt: number): number {\n    return this.#config.retryDelayMs! * Math.pow(2, attempt);\n  }\n\n  /**\n   * Flushes the current buffer to storage with retry logic\n   */\n  private async flush(): Promise<void> {\n    if (!this.#storage) {\n      this.logger.debug('Cannot flush traces. Mastra storage is not initialized');\n      return;\n    }\n\n    // Clear timer since we're flushing\n    if (this.#flushTimer) {\n      clearTimeout(this.#flushTimer);\n      this.#flushTimer = null;\n    }\n\n    if (this.buffer.totalSize === 0) {\n      return; // Nothing to flush\n    }\n\n    const startTime = Date.now();\n    const flushReason =\n      this.buffer.totalSize >= this.#config.maxBufferSize!\n        ? 'overflow'\n        : this.buffer.totalSize >= this.#config.maxBatchSize!\n          ? 'size'\n          : 'time';\n\n    // Create a copy of the buffer to work with\n    const bufferCopy: BatchBuffer = {\n      creates: [...this.buffer.creates],\n      updates: [...this.buffer.updates],\n      insertOnly: [...this.buffer.insertOnly],\n      seenSpans: new Set(this.buffer.seenSpans),\n      spanSequences: new Map(this.buffer.spanSequences),\n      completedSpans: new Set(this.buffer.completedSpans),\n      outOfOrderCount: this.buffer.outOfOrderCount,\n      firstEventTime: this.buffer.firstEventTime,\n      totalSize: this.buffer.totalSize,\n    };\n\n    // Reset buffer immediately to prevent blocking new events\n    // Note: We don't clean up completed spans yet - we'll do that after successful flush\n    this.resetBuffer();\n\n    // Attempt to flush with retry logic\n    await this.flushWithRetries(this.#storage, bufferCopy, 0);\n\n    const elapsed = Date.now() - startTime;\n    this.logger.debug('Batch flushed', {\n      strategy: this.#resolvedStrategy,\n      batchSize: bufferCopy.totalSize,\n      flushReason,\n      durationMs: elapsed,\n      outOfOrderCount: bufferCopy.outOfOrderCount > 0 ? bufferCopy.outOfOrderCount : undefined,\n    });\n  }\n\n  /**\n   * Attempts to flush with exponential backoff retry logic\n   */\n  private async flushWithRetries(storage: MastraStorage, buffer: BatchBuffer, attempt: number): Promise<void> {\n    try {\n      if (this.#resolvedStrategy === 'batch-with-updates') {\n        // Process creates first (always safe)\n        if (buffer.creates.length > 0) {\n          await storage.batchCreateSpans({ records: buffer.creates });\n        }\n\n        // Sort updates by span, then by sequence number\n        if (buffer.updates.length > 0) {\n          const sortedUpdates = buffer.updates.sort((a, b) => {\n            const spanCompare = this.buildSpanKey(a.traceId, a.spanId).localeCompare(\n              this.buildSpanKey(b.traceId, b.spanId),\n            );\n            if (spanCompare !== 0) return spanCompare;\n            return a.sequenceNumber - b.sequenceNumber;\n          });\n\n          await storage.batchUpdateSpans({ records: sortedUpdates });\n        }\n      } else if (this.#resolvedStrategy === 'insert-only') {\n        // Simple batch insert for insert-only strategy\n        if (buffer.insertOnly.length > 0) {\n          await storage.batchCreateSpans({ records: buffer.insertOnly });\n        }\n      }\n\n      // Success! Clean up completed spans from persistent tracking\n      for (const spanKey of buffer.completedSpans) {\n        this.allCreatedSpans.delete(spanKey);\n      }\n    } catch (error) {\n      if (attempt < this.#config.maxRetries!) {\n        const retryDelay = this.calculateRetryDelay(attempt);\n        this.logger.warn('Batch flush failed, retrying', {\n          attempt: attempt + 1,\n          maxRetries: this.#config.maxRetries,\n          nextRetryInMs: retryDelay,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return this.flushWithRetries(storage, buffer, attempt + 1);\n      } else {\n        this.logger.error('Batch flush failed after all retries, dropping batch', {\n          finalAttempt: attempt + 1,\n          maxRetries: this.#config.maxRetries,\n          droppedBatchSize: buffer.totalSize,\n          error: error instanceof Error ? error.message : String(error),\n        });\n        // Even on failure, we should clean up completed spans to avoid memory leak\n        // These spans will be lost but at least we prevent memory issues\n        for (const spanKey of buffer.completedSpans) {\n          this.allCreatedSpans.delete(spanKey);\n        }\n      }\n    }\n  }\n\n  async _exportTracingEvent(event: TracingEvent): Promise<void> {\n    if (!this.#storage) {\n      this.logger.debug('Cannot store traces. Mastra storage is not initialized');\n      return;\n    }\n\n    // Initialize strategy if not already done (fallback for edge cases)\n    if (!this.#strategyInitialized) {\n      this.initializeStrategy(this.#storage);\n    }\n\n    // Clear strategy routing - explicit and readable\n    switch (this.#resolvedStrategy) {\n      case 'realtime':\n        await this.handleRealtimeEvent(event, this.#storage);\n        break;\n      case 'batch-with-updates':\n        this.handleBatchWithUpdatesEvent(event);\n        break;\n      case 'insert-only':\n        this.handleInsertOnlyEvent(event);\n        break;\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    // Clear any pending timer\n    if (this.#flushTimer) {\n      clearTimeout(this.#flushTimer);\n      this.#flushTimer = null;\n    }\n\n    // Flush any remaining events\n    if (this.buffer.totalSize > 0) {\n      this.logger.info('Flushing remaining events on shutdown', {\n        remainingEvents: this.buffer.totalSize,\n      });\n      try {\n        await this.flush();\n      } catch (error) {\n        this.logger.error('Failed to flush remaining events during shutdown', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    this.logger.info('DefaultExporter shutdown complete');\n  }\n}\n","/**\n * Model Span Tracing\n *\n * Provides span tracking for Model generations, including:\n * - MODEL_STEP spans (one per Model API call)\n * - MODEL_CHUNK spans (individual streaming chunks within a step)\n *\n * Hierarchy: MODEL_GENERATION -> MODEL_STEP -> MODEL_CHUNK\n */\n\nimport { TransformStream } from 'stream/web';\nimport { SpanType } from '@mastra/core/observability';\nimport type {\n  Span,\n  EndSpanOptions,\n  ErrorSpanOptions,\n  TracingContext,\n  UpdateSpanOptions,\n} from '@mastra/core/observability';\nimport type { OutputSchema, ChunkType, StepStartPayload, StepFinishPayload } from '@mastra/core/stream';\n\n/**\n * Manages MODEL_STEP and MODEL_CHUNK span tracking for streaming Model responses.\n *\n * Should be instantiated once per MODEL_GENERATION span and shared across\n * all streaming steps (including after tool calls).\n */\nexport class ModelSpanTracker {\n  #modelSpan?: Span<SpanType.MODEL_GENERATION>;\n  #currentStepSpan?: Span<SpanType.MODEL_STEP>;\n  #currentChunkSpan?: Span<SpanType.MODEL_CHUNK>;\n  #accumulator: Record<string, any> = {};\n  #stepIndex: number = 0;\n  #chunkSequence: number = 0;\n\n  constructor(modelSpan?: Span<SpanType.MODEL_GENERATION>) {\n    this.#modelSpan = modelSpan;\n  }\n\n  /**\n   * Get the tracing context for creating child spans.\n   * Returns the current step span if active, otherwise the model span.\n   */\n  getTracingContext(): TracingContext {\n    return {\n      currentSpan: this.#currentStepSpan ?? this.#modelSpan,\n    };\n  }\n\n  /**\n   * Report an error on the generation span\n   */\n  reportGenerationError(options: ErrorSpanOptions<SpanType.MODEL_GENERATION>): void {\n    this.#modelSpan?.error(options);\n  }\n\n  /**\n   * End the generation span\n   */\n  endGeneration(options?: EndSpanOptions<SpanType.MODEL_GENERATION>): void {\n    this.#modelSpan?.end(options);\n  }\n\n  /**\n   * Update the generation span\n   */\n  updateGeneration(options: UpdateSpanOptions<SpanType.MODEL_GENERATION>): void {\n    this.#modelSpan?.update(options);\n  }\n\n  /**\n   * Start a new Model execution step\n   */\n  #startStepSpan(payload?: StepStartPayload) {\n    this.#currentStepSpan = this.#modelSpan?.createChildSpan({\n      name: `step: ${this.#stepIndex}`,\n      type: SpanType.MODEL_STEP,\n      attributes: {\n        stepIndex: this.#stepIndex,\n        ...(payload?.messageId ? { messageId: payload.messageId } : {}),\n        ...(payload?.warnings?.length ? { warnings: payload.warnings } : {}),\n      },\n      input: payload?.request,\n    });\n    // Reset chunk sequence for new step\n    this.#chunkSequence = 0;\n  }\n\n  /**\n   * End the current Model execution step with token usage, finish reason, output, and metadata\n   */\n  #endStepSpan<OUTPUT extends OutputSchema>(payload: StepFinishPayload<any, OUTPUT>) {\n    if (!this.#currentStepSpan) return;\n\n    // Extract all data from step-finish chunk\n    const output = payload.output;\n    const { usage, ...otherOutput } = output;\n    const stepResult = payload.stepResult;\n    const metadata = payload.metadata;\n\n    // Remove request object from metadata (too verbose)\n    const cleanMetadata = metadata ? { ...metadata } : undefined;\n    if (cleanMetadata?.request) {\n      delete cleanMetadata.request;\n    }\n\n    this.#currentStepSpan.end({\n      output: otherOutput,\n      attributes: {\n        usage,\n        isContinued: stepResult.isContinued,\n        finishReason: stepResult.reason,\n        warnings: stepResult.warnings,\n      },\n      metadata: {\n        ...cleanMetadata,\n      },\n    });\n    this.#currentStepSpan = undefined;\n    this.#stepIndex++;\n  }\n\n  /**\n   * Create a new chunk span (for multi-part chunks like text-start/delta/end)\n   */\n  #startChunkSpan(chunkType: string, initialData?: Record<string, any>) {\n    // Auto-create step if we see a chunk before step-start\n    if (!this.#currentStepSpan) {\n      this.#startStepSpan();\n    }\n\n    this.#currentChunkSpan = this.#currentStepSpan?.createChildSpan({\n      name: `chunk: '${chunkType}'`,\n      type: SpanType.MODEL_CHUNK,\n      attributes: {\n        chunkType,\n        sequenceNumber: this.#chunkSequence,\n      },\n    });\n    this.#accumulator = initialData || {};\n  }\n\n  /**\n   * Append string content to a specific field in the accumulator\n   */\n  #appendToAccumulator(field: string, text: string) {\n    if (this.#accumulator[field] === undefined) {\n      this.#accumulator[field] = text;\n    } else {\n      this.#accumulator[field] += text;\n    }\n  }\n\n  /**\n   * End the current chunk span.\n   * Safe to call multiple times - will no-op if span already ended.\n   */\n  #endChunkSpan(output?: any) {\n    if (!this.#currentChunkSpan) return;\n\n    this.#currentChunkSpan.end({\n      output: output !== undefined ? output : this.#accumulator,\n    });\n    this.#currentChunkSpan = undefined;\n    this.#accumulator = {};\n    this.#chunkSequence++;\n  }\n\n  /**\n   * Create an event span (for single chunks like tool-call)\n   */\n  #createEventSpan(chunkType: string, output: any) {\n    // Auto-create step if we see a chunk before step-start\n    if (!this.#currentStepSpan) {\n      this.#startStepSpan();\n    }\n\n    const span = this.#currentStepSpan?.createEventSpan({\n      name: `chunk: '${chunkType}'`,\n      type: SpanType.MODEL_CHUNK,\n      attributes: {\n        chunkType,\n        sequenceNumber: this.#chunkSequence,\n      },\n      output,\n    });\n\n    if (span) {\n      this.#chunkSequence++;\n    }\n  }\n\n  /**\n   * Check if there is currently an active chunk span\n   */\n  #hasActiveChunkSpan(): boolean {\n    return !!this.#currentChunkSpan;\n  }\n\n  /**\n   * Get the current accumulator value\n   */\n  #getAccumulator(): Record<string, any> {\n    return this.#accumulator;\n  }\n\n  /**\n   * Handle text chunk spans (text-start/delta/end)\n   */\n  #handleTextChunk<OUTPUT extends OutputSchema>(chunk: ChunkType<OUTPUT>) {\n    switch (chunk.type) {\n      case 'text-start':\n        this.#startChunkSpan('text');\n        break;\n\n      case 'text-delta':\n        this.#appendToAccumulator('text', chunk.payload.text);\n        break;\n\n      case 'text-end': {\n        this.#endChunkSpan();\n        break;\n      }\n    }\n  }\n\n  /**\n   * Handle reasoning chunk spans (reasoning-start/delta/end)\n   */\n  #handleReasoningChunk<OUTPUT extends OutputSchema>(chunk: ChunkType<OUTPUT>) {\n    switch (chunk.type) {\n      case 'reasoning-start':\n        this.#startChunkSpan('reasoning');\n        break;\n\n      case 'reasoning-delta':\n        this.#appendToAccumulator('text', chunk.payload.text);\n        break;\n\n      case 'reasoning-end': {\n        this.#endChunkSpan();\n        break;\n      }\n    }\n  }\n\n  /**\n   * Handle tool call chunk spans (tool-call-input-streaming-start/delta/end, tool-call)\n   */\n  #handleToolCallChunk<OUTPUT extends OutputSchema>(chunk: ChunkType<OUTPUT>) {\n    switch (chunk.type) {\n      case 'tool-call-input-streaming-start':\n        this.#startChunkSpan('tool-call', {\n          toolName: chunk.payload.toolName,\n          toolCallId: chunk.payload.toolCallId,\n        });\n        break;\n\n      case 'tool-call-delta':\n        this.#appendToAccumulator('toolInput', chunk.payload.argsTextDelta);\n        break;\n\n      case 'tool-call-input-streaming-end':\n      case 'tool-call': {\n        // Build output with toolName, toolCallId, and parsed toolInput\n        const acc = this.#getAccumulator();\n        let toolInput;\n        try {\n          toolInput = acc.toolInput ? JSON.parse(acc.toolInput) : {};\n        } catch {\n          toolInput = acc.toolInput; // Keep as string if parsing fails\n        }\n        this.#endChunkSpan({\n          toolName: acc.toolName,\n          toolCallId: acc.toolCallId,\n          toolInput,\n        });\n        break;\n      }\n    }\n  }\n\n  /**\n   * Handle object chunk spans (object, object-result)\n   */\n  #handleObjectChunk<OUTPUT extends OutputSchema>(chunk: ChunkType<OUTPUT>) {\n    switch (chunk.type) {\n      case 'object':\n        // Start span on first partial object chunk (only if not already started)\n        // Multiple object chunks may arrive as the object is being generated\n        if (!this.#hasActiveChunkSpan()) {\n          this.#startChunkSpan('object');\n        }\n        break;\n\n      case 'object-result':\n        // End the span with the final complete object as output\n        this.#endChunkSpan(chunk.object);\n        break;\n    }\n  }\n\n  /**\n   * Wraps a stream with model tracing transform to track MODEL_STEP and MODEL_CHUNK spans.\n   *\n   * This should be added to the stream pipeline to automatically\n   * create MODEL_STEP and MODEL_CHUNK spans for each semantic unit in the stream.\n   */\n  wrapStream<T extends { pipeThrough: Function }>(stream: T): T {\n    return stream.pipeThrough(\n      new TransformStream({\n        transform: (chunk, controller) => {\n          controller.enqueue(chunk);\n\n          // Handle chunk span tracking based on chunk type\n          switch (chunk.type) {\n            case 'text-start':\n            case 'text-delta':\n            case 'text-end':\n              this.#handleTextChunk(chunk);\n              break;\n\n            case 'tool-call-input-streaming-start':\n            case 'tool-call-delta':\n            case 'tool-call-input-streaming-end':\n            case 'tool-call':\n              this.#handleToolCallChunk(chunk);\n              break;\n\n            case 'reasoning-start':\n            case 'reasoning-delta':\n            case 'reasoning-end':\n              this.#handleReasoningChunk(chunk);\n              break;\n\n            case 'object':\n            case 'object-result':\n              this.#handleObjectChunk(chunk);\n              break;\n\n            case 'step-start':\n              this.#startStepSpan(chunk.payload);\n              break;\n\n            case 'step-finish':\n              this.#endStepSpan(chunk.payload);\n              break;\n\n            case 'raw': // Skip raw chunks as they're redundant\n            case 'start':\n            case 'finish':\n              // don't output these chunks that don't have helpful output\n              break;\n\n            // Default: auto-create event span for all other chunk types\n            default: {\n              let outputPayload = chunk.payload;\n\n              // Special handling: if payload has 'data' field, replace with size\n              if (outputPayload && typeof outputPayload === 'object' && 'data' in outputPayload) {\n                const typedPayload = outputPayload as any;\n                outputPayload = { ...typedPayload };\n                if (typedPayload.data) {\n                  (outputPayload as any).size =\n                    typeof typedPayload.data === 'string'\n                      ? typedPayload.data.length\n                      : typedPayload.data instanceof Uint8Array\n                        ? typedPayload.data.length\n                        : undefined;\n                  delete (outputPayload as any).data;\n                }\n              }\n\n              this.#createEventSpan(chunk.type, outputPayload);\n              break;\n            }\n          }\n        },\n      }),\n    ) as T;\n  }\n}\n","import type {\n  Span,\n  SpanTypeMap,\n  AnySpan,\n  ChildSpanOptions,\n  ChildEventOptions,\n  EndSpanOptions,\n  ErrorSpanOptions,\n  UpdateSpanOptions,\n  CreateSpanOptions,\n  ObservabilityInstance,\n  ExportedSpan,\n  TraceState,\n  IModelSpanTracker,\n  AIModelGenerationSpan,\n} from '@mastra/core/observability';\n\nimport { SpanType, InternalSpans } from '@mastra/core/observability';\nimport { ModelSpanTracker } from '../model-tracing';\n\n/**\n * Determines if a span type should be considered internal based on flags.\n * Returns false if flags are undefined.\n */\nfunction isSpanInternal(spanType: SpanType, flags?: InternalSpans): boolean {\n  if (flags === undefined || flags === InternalSpans.NONE) {\n    return false;\n  }\n\n  switch (spanType) {\n    // Workflow-related spans\n    case SpanType.WORKFLOW_RUN:\n    case SpanType.WORKFLOW_STEP:\n    case SpanType.WORKFLOW_CONDITIONAL:\n    case SpanType.WORKFLOW_CONDITIONAL_EVAL:\n    case SpanType.WORKFLOW_PARALLEL:\n    case SpanType.WORKFLOW_LOOP:\n    case SpanType.WORKFLOW_SLEEP:\n    case SpanType.WORKFLOW_WAIT_EVENT:\n      return (flags & InternalSpans.WORKFLOW) !== 0;\n\n    // Agent-related spans\n    case SpanType.AGENT_RUN:\n      return (flags & InternalSpans.AGENT) !== 0;\n\n    // Tool-related spans\n    case SpanType.TOOL_CALL:\n    case SpanType.MCP_TOOL_CALL:\n      return (flags & InternalSpans.TOOL) !== 0;\n\n    // Model-related spans\n    case SpanType.MODEL_GENERATION:\n    case SpanType.MODEL_STEP:\n    case SpanType.MODEL_CHUNK:\n      return (flags & InternalSpans.MODEL) !== 0;\n\n    // Default: never internal\n    default:\n      return false;\n  }\n}\n\nexport abstract class BaseSpan<TType extends SpanType = any> implements Span<TType> {\n  public abstract id: string;\n  public abstract traceId: string;\n\n  public name: string;\n  public type: TType;\n  public attributes: SpanTypeMap[TType];\n  public parent?: AnySpan;\n  public startTime: Date;\n  public endTime?: Date;\n  public isEvent: boolean;\n  public isInternal: boolean;\n  public observabilityInstance: ObservabilityInstance;\n  public input?: any;\n  public output?: any;\n  public errorInfo?: {\n    message: string;\n    id?: string;\n    domain?: string;\n    category?: string;\n    details?: Record<string, any>;\n  };\n  public metadata?: Record<string, any>;\n  public traceState?: TraceState;\n  /** Parent span ID (for root spans that are children of external spans) */\n  protected parentSpanId?: string;\n\n  constructor(options: CreateSpanOptions<TType>, observabilityInstance: ObservabilityInstance) {\n    this.name = options.name;\n    this.type = options.type;\n    this.attributes = deepClean(options.attributes) || ({} as SpanTypeMap[TType]);\n    this.metadata = deepClean(options.metadata);\n    this.parent = options.parent;\n    this.startTime = new Date();\n    this.observabilityInstance = observabilityInstance;\n    this.isEvent = options.isEvent ?? false;\n    this.isInternal = isSpanInternal(this.type, options.tracingPolicy?.internal);\n    this.traceState = options.traceState;\n\n    if (this.isEvent) {\n      // Event spans don't have endTime or input.\n      // Event spans are immediately emitted by the BaseObservability class via the end() event.\n      this.output = deepClean(options.output);\n    } else {\n      this.input = deepClean(options.input);\n    }\n  }\n\n  // Methods for span lifecycle\n  /** End the span */\n  abstract end(options?: EndSpanOptions<TType>): void;\n\n  /** Record an error for the span, optionally end the span as well */\n  abstract error(options: ErrorSpanOptions<TType>): void;\n\n  /** Update span attributes */\n  abstract update(options: UpdateSpanOptions<TType>): void;\n\n  createChildSpan(options: ChildSpanOptions<SpanType.MODEL_GENERATION>): AIModelGenerationSpan;\n  createChildSpan<TChildType extends SpanType>(options: ChildSpanOptions<TChildType>): Span<TChildType> {\n    return this.observabilityInstance.startSpan<TChildType>({ ...options, parent: this, isEvent: false });\n  }\n\n  createEventSpan<TChildType extends SpanType>(options: ChildEventOptions<TChildType>): Span<TChildType> {\n    return this.observabilityInstance.startSpan<TChildType>({ ...options, parent: this, isEvent: true });\n  }\n\n  /**\n   * Create a ModelSpanTracker for this span (only works if this is a MODEL_GENERATION span)\n   * Returns undefined for non-MODEL_GENERATION spans\n   */\n  createTracker(): IModelSpanTracker | undefined {\n    // Only create tracker for MODEL_GENERATION spans\n    if (this.type !== SpanType.MODEL_GENERATION) {\n      return undefined;\n    }\n\n    return new ModelSpanTracker(this as Span<SpanType.MODEL_GENERATION>);\n  }\n\n  /** Returns `TRUE` if the span is the root span of a trace */\n  get isRootSpan(): boolean {\n    return !this.parent;\n  }\n\n  /** Returns `TRUE` if the span is a valid span (not a NO-OP Span) */\n  abstract get isValid(): boolean;\n\n  /** Get the closest parent spanId that isn't an internal span */\n  public getParentSpanId(includeInternalSpans?: boolean): string | undefined {\n    if (!this.parent) {\n      // Return parent span ID if available, otherwise undefined\n      return this.parentSpanId;\n    }\n    if (includeInternalSpans) return this.parent.id;\n    if (this.parent.isInternal) return this.parent.getParentSpanId(includeInternalSpans);\n\n    return this.parent.id;\n  }\n\n  /** Find the closest parent span of a specific type by walking up the parent chain */\n  public findParent<T extends SpanType>(spanType: T): Span<T> | undefined {\n    let current: AnySpan | undefined = this.parent;\n\n    while (current) {\n      if (current.type === spanType) {\n        return current as Span<T>;\n      }\n      current = current.parent;\n    }\n\n    return undefined;\n  }\n\n  /** Returns a lightweight span ready for export */\n  public exportSpan(includeInternalSpans?: boolean): ExportedSpan<TType> {\n    return {\n      id: this.id,\n      traceId: this.traceId,\n      name: this.name,\n      type: this.type,\n      attributes: this.attributes,\n      metadata: this.metadata,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      input: this.input,\n      output: this.output,\n      errorInfo: this.errorInfo,\n      isEvent: this.isEvent,\n      isRootSpan: this.isRootSpan,\n      parentSpanId: this.getParentSpanId(includeInternalSpans),\n    };\n  }\n\n  get externalTraceId(): string | undefined {\n    return this.isValid ? this.traceId : undefined;\n  }\n}\n\nconst DEFAULT_KEYS_TO_STRIP = new Set([\n  'logger',\n  'experimental_providerMetadata',\n  'providerMetadata',\n  'steps',\n  'tracingContext',\n]);\nexport interface DeepCleanOptions {\n  keysToStrip?: Set<string>;\n  maxDepth?: number;\n}\n\n/**\n * Recursively cleans a value by removing circular references and stripping problematic or sensitive keys.\n * Circular references are replaced with \"[Circular]\". Unserializable values are replaced with error messages.\n * Keys like \"logger\" and \"tracingContext\" are stripped by default.\n * A maximum recursion depth is enforced to avoid stack overflow or excessive memory usage.\n *\n * @param value - The value to clean (object, array, primitive, etc.)\n * @param options - Optional configuration:\n *   - keysToStrip: Set of keys to remove from objects (default: logger, tracingContext)\n *   - maxDepth: Maximum recursion depth before values are replaced with \"[MaxDepth]\" (default: 10)\n * @returns A cleaned version of the input with circular references, specified keys, and overly deep values handled\n */\nexport function deepClean(\n  value: any,\n  options: DeepCleanOptions = {},\n  _seen: WeakSet<any> = new WeakSet(),\n  _depth: number = 0,\n): any {\n  const { keysToStrip = DEFAULT_KEYS_TO_STRIP, maxDepth = 10 } = options;\n\n  if (_depth > maxDepth) {\n    return '[MaxDepth]';\n  }\n\n  if (value === null || typeof value !== 'object') {\n    try {\n      JSON.stringify(value);\n      return value;\n    } catch (error) {\n      return `[${error instanceof Error ? error.message : String(error)}]`;\n    }\n  }\n\n  if (_seen.has(value)) {\n    return '[Circular]';\n  }\n\n  _seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClean(item, options, _seen, _depth + 1));\n  }\n\n  const cleaned: Record<string, any> = {};\n  for (const [key, val] of Object.entries(value)) {\n    if (keysToStrip.has(key)) {\n      continue;\n    }\n\n    try {\n      cleaned[key] = deepClean(val, options, _seen, _depth + 1);\n    } catch (error) {\n      cleaned[key] = `[${error instanceof Error ? error.message : String(error)}]`;\n    }\n  }\n\n  return cleaned;\n}\n","import { MastraError } from '@mastra/core/error';\nimport type {\n  SpanType,\n  ObservabilityInstance,\n  EndSpanOptions,\n  ErrorSpanOptions,\n  UpdateSpanOptions,\n  CreateSpanOptions,\n} from '@mastra/core/observability';\nimport { BaseSpan, deepClean } from './base';\n\nexport class DefaultSpan<TType extends SpanType> extends BaseSpan<TType> {\n  public id: string;\n  public traceId: string;\n\n  constructor(options: CreateSpanOptions<TType>, observabilityInstance: ObservabilityInstance) {\n    super(options, observabilityInstance);\n    this.id = generateSpanId();\n\n    // Set trace ID based on context:\n    if (options.parent) {\n      // Child span inherits trace ID from parent span\n      this.traceId = options.parent.traceId;\n    } else if (options.traceId) {\n      // Root span with provided trace ID\n      if (isValidTraceId(options.traceId)) {\n        this.traceId = options.traceId;\n      } else {\n        console.error(\n          `[Mastra Tracing] Invalid traceId: must be 1-32 hexadecimal characters, got \"${options.traceId}\". Generating new trace ID.`,\n        );\n        this.traceId = generateTraceId();\n      }\n    } else {\n      // Root span without provided trace ID - generate new\n      this.traceId = generateTraceId();\n    }\n\n    // Set parent span ID if provided\n    if (!options.parent && options.parentSpanId) {\n      if (isValidSpanId(options.parentSpanId)) {\n        this.parentSpanId = options.parentSpanId;\n      } else {\n        console.error(\n          `[Mastra Tracing] Invalid parentSpanId: must be 1-16 hexadecimal characters, got \"${options.parentSpanId}\". Ignoring parent span ID.`,\n        );\n      }\n    }\n  }\n\n  end(options?: EndSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n    this.endTime = new Date();\n    if (options?.output !== undefined) {\n      this.output = deepClean(options.output);\n    }\n    if (options?.attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(options.attributes) };\n    }\n    if (options?.metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(options.metadata) };\n    }\n    // Tracing events automatically handled by base class\n  }\n\n  error(options: ErrorSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n\n    const { error, endSpan = true, attributes, metadata } = options;\n\n    this.errorInfo =\n      error instanceof MastraError\n        ? {\n            id: error.id,\n            details: error.details,\n            category: error.category,\n            domain: error.domain,\n            message: error.message,\n          }\n        : {\n            message: error.message,\n          };\n\n    // Update attributes if provided\n    if (attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(attributes) };\n    }\n    if (metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(metadata) };\n    }\n\n    if (endSpan) {\n      this.end();\n    } else {\n      // Trigger span update event when not ending the span\n      this.update({});\n    }\n  }\n\n  update(options: UpdateSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n\n    if (options.input !== undefined) {\n      this.input = deepClean(options.input);\n    }\n    if (options.output !== undefined) {\n      this.output = deepClean(options.output);\n    }\n    if (options.attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(options.attributes) };\n    }\n    if (options.metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(options.metadata) };\n    }\n    // Tracing events automatically handled by base class\n  }\n\n  get isValid(): boolean {\n    return true;\n  }\n\n  async export(): Promise<string> {\n    return JSON.stringify({\n      spanId: this.id,\n      traceId: this.traceId,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      attributes: this.attributes,\n      metadata: this.metadata,\n    });\n  }\n}\n\n/**\n * Generate OpenTelemetry-compatible span ID (64-bit, 16 hex chars)\n */\nfunction generateSpanId(): string {\n  // Generate 8 random bytes (64 bits) in hex format\n  const bytes = new Uint8Array(8);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 8; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Generate OpenTelemetry-compatible trace ID (128-bit, 32 hex chars)\n */\nfunction generateTraceId(): string {\n  // Generate 16 random bytes (128 bits) in hex format\n  const bytes = new Uint8Array(16);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 16; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Validate OpenTelemetry-compatible trace ID (1-32 hex characters)\n */\nfunction isValidTraceId(traceId: string): boolean {\n  return /^[0-9a-f]{1,32}$/i.test(traceId);\n}\n\n/**\n * Validate OpenTelemetry-compatible span ID (1-16 hex characters)\n */\nfunction isValidSpanId(spanId: string): boolean {\n  return /^[0-9a-f]{1,16}$/i.test(spanId);\n}\n","/**\n * NoOpSpan Implementation for Mastra Observability\n */\n\nimport type {\n  ObservabilityInstance,\n  SpanType,\n  CreateSpanOptions,\n  EndSpanOptions,\n  UpdateSpanOptions,\n  ErrorSpanOptions,\n} from '@mastra/core/observability';\nimport { BaseSpan } from './base';\n\nexport class NoOpSpan<TType extends SpanType = any> extends BaseSpan<TType> {\n  public id: string;\n  public traceId: string;\n\n  constructor(options: CreateSpanOptions<TType>, observabilityInstance: ObservabilityInstance) {\n    super(options, observabilityInstance);\n    this.id = 'no-op';\n    this.traceId = 'no-op-trace';\n  }\n\n  end(_options?: EndSpanOptions<TType>): void {}\n\n  error(_options: ErrorSpanOptions<TType>): void {}\n\n  update(_options: UpdateSpanOptions<TType>): void {}\n\n  get isValid(): boolean {\n    return false;\n  }\n}\n","/**\n * BaseObservability - Abstract base class for Observability implementations\n */\n\nimport { MastraBase } from '@mastra/core/base';\nimport type { RequestContext } from '@mastra/core/di';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport { RegisteredLogger } from '@mastra/core/logger';\nimport type {\n  Span,\n  SpanType,\n  ObservabilityExporter,\n  SpanOutputProcessor,\n  TracingEvent,\n  AnySpan,\n  EndSpanOptions,\n  UpdateSpanOptions,\n  StartSpanOptions,\n  CreateSpanOptions,\n  ObservabilityInstance,\n  CustomSamplerOptions,\n  AnyExportedSpan,\n  TraceState,\n  TracingOptions,\n} from '@mastra/core/observability';\nimport { TracingEventType } from '@mastra/core/observability';\nimport { getNestedValue, setNestedValue } from '@mastra/core/utils';\nimport type { ObservabilityInstanceConfig } from '../config';\nimport { SamplingStrategyType } from '../config';\nimport { NoOpSpan } from '../spans';\n\n// ============================================================================\n// Abstract Base Class\n// ============================================================================\n\n/**\n * Abstract base class for all Observability implementations in Mastra.\n */\nexport abstract class BaseObservabilityInstance extends MastraBase implements ObservabilityInstance {\n  protected config: Required<ObservabilityInstanceConfig>;\n\n  constructor(config: ObservabilityInstanceConfig) {\n    super({ component: RegisteredLogger.OBSERVABILITY, name: config.serviceName });\n\n    // Apply defaults for optional fields\n    this.config = {\n      serviceName: config.serviceName,\n      name: config.name,\n      sampling: config.sampling ?? { type: SamplingStrategyType.ALWAYS },\n      exporters: config.exporters ?? [],\n      spanOutputProcessors: config.spanOutputProcessors ?? [],\n      includeInternalSpans: config.includeInternalSpans ?? false,\n      requestContextKeys: config.requestContextKeys ?? [],\n    };\n  }\n\n  /**\n   * Override setLogger to add Observability specific initialization log\n   * and propagate logger to exporters\n   */\n  __setLogger(logger: IMastraLogger) {\n    super.__setLogger(logger);\n\n    // Propagate logger to all exporters that support it\n    this.exporters.forEach(exporter => {\n      if (typeof exporter.__setLogger === 'function') {\n        exporter.__setLogger(logger);\n      }\n    });\n\n    // Log Observability initialization details after logger is properly set\n    this.logger.debug(\n      `[Observability] Initialized [service=${this.config.serviceName}] [instance=${this.config.name}] [sampling=${this.config.sampling.type}]`,\n    );\n  }\n\n  // ============================================================================\n  // Protected getters for clean config access\n  // ============================================================================\n\n  protected get exporters(): ObservabilityExporter[] {\n    return this.config.exporters || [];\n  }\n\n  protected get spanOutputProcessors(): SpanOutputProcessor[] {\n    return this.config.spanOutputProcessors || [];\n  }\n\n  // ============================================================================\n  // Public API - Single type-safe span creation method\n  // ============================================================================\n\n  /**\n   * Start a new span of a specific SpanType\n   */\n  startSpan<TType extends SpanType>(options: StartSpanOptions<TType>): Span<TType> {\n    const { customSamplerOptions, requestContext, metadata, tracingOptions, ...rest } = options;\n\n    if (!this.shouldSample(customSamplerOptions)) {\n      return new NoOpSpan<TType>({ ...rest, metadata }, this);\n    }\n\n    // Compute or inherit TraceState\n    let traceState: TraceState | undefined;\n\n    if (options.parent) {\n      // Child span: inherit from parent\n      traceState = options.parent.traceState;\n    } else {\n      // Root span: compute new TraceState\n      traceState = this.computeTraceState(tracingOptions);\n    }\n\n    // Extract metadata from RequestContext\n    const enrichedMetadata = this.extractMetadataFromRequestContext(requestContext, metadata, traceState);\n\n    const span = this.createSpan<TType>({\n      ...rest,\n      metadata: enrichedMetadata,\n      traceState,\n    });\n\n    if (span.isEvent) {\n      this.emitSpanEnded(span);\n    } else {\n      // Automatically wire up tracing lifecycle\n      this.wireSpanLifecycle(span);\n\n      // Emit span started event\n      this.emitSpanStarted(span);\n    }\n\n    return span;\n  }\n\n  // ============================================================================\n  // Abstract Methods - Must be implemented by concrete classes\n  // ============================================================================\n\n  /**\n   * Create a new span (called after sampling)\n   *\n   * Implementations should:\n   * 1. Create a plain span with the provided attributes\n   * 2. Return the span - base class handles all tracing lifecycle automatically\n   *\n   * The base class will automatically:\n   * - Set trace relationships\n   * - Wire span lifecycle callbacks\n   * - Emit span_started event\n   */\n  protected abstract createSpan<TType extends SpanType>(options: CreateSpanOptions<TType>): Span<TType>;\n\n  // ============================================================================\n  // Configuration Management\n  // ============================================================================\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<Required<ObservabilityInstanceConfig>> {\n    return { ...this.config };\n  }\n\n  // ============================================================================\n  // Plugin Access\n  // ============================================================================\n\n  /**\n   * Get all exporters\n   */\n  getExporters(): readonly ObservabilityExporter[] {\n    return [...this.exporters];\n  }\n\n  /**\n   * Get all span output processors\n   */\n  getSpanOutputProcessors(): readonly SpanOutputProcessor[] {\n    return [...this.spanOutputProcessors];\n  }\n\n  /**\n   * Get the logger instance (for exporters and other components)\n   */\n  getLogger() {\n    return this.logger;\n  }\n\n  // ============================================================================\n  // Span Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Automatically wires up Observability lifecycle events for any span\n   * This ensures all spans emit events regardless of implementation\n   */\n  private wireSpanLifecycle<TType extends SpanType>(span: Span<TType>): void {\n    // bypass wire up if internal span and not includeInternalSpans\n    if (!this.config.includeInternalSpans && span.isInternal) {\n      return;\n    }\n\n    // Store original methods\n    const originalEnd = span.end.bind(span);\n    const originalUpdate = span.update.bind(span);\n\n    // Wrap methods to automatically emit tracing events\n    span.end = (options?: EndSpanOptions<TType>) => {\n      if (span.isEvent) {\n        this.logger.warn(`End event is not available on event spans`);\n        return;\n      }\n      originalEnd(options);\n      this.emitSpanEnded(span);\n    };\n\n    span.update = (options: UpdateSpanOptions<TType>) => {\n      if (span.isEvent) {\n        this.logger.warn(`Update() is not available on event spans`);\n        return;\n      }\n      originalUpdate(options);\n      this.emitSpanUpdated(span);\n    };\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Check if a trace should be sampled\n   */\n  protected shouldSample(options?: CustomSamplerOptions): boolean {\n    // Check built-in sampling strategy\n    const { sampling } = this.config;\n\n    switch (sampling.type) {\n      case SamplingStrategyType.ALWAYS:\n        return true;\n      case SamplingStrategyType.NEVER:\n        return false;\n      case SamplingStrategyType.RATIO:\n        if (sampling.probability === undefined || sampling.probability < 0 || sampling.probability > 1) {\n          this.logger.warn(\n            `Invalid sampling probability: ${sampling.probability}. Expected value between 0 and 1. Defaulting to no sampling.`,\n          );\n          return false;\n        }\n        return Math.random() < sampling.probability;\n      case SamplingStrategyType.CUSTOM:\n        return sampling.sampler(options);\n      default:\n        throw new Error(`Sampling strategy type not implemented: ${(sampling as any).type}`);\n    }\n  }\n\n  /**\n   * Compute TraceState for a new trace based on configured and per-request keys\n   */\n  protected computeTraceState(tracingOptions?: TracingOptions): TraceState | undefined {\n    const configuredKeys = this.config.requestContextKeys ?? [];\n    const additionalKeys = tracingOptions?.requestContextKeys ?? [];\n\n    // Merge: configured + additional\n    const allKeys = [...configuredKeys, ...additionalKeys];\n\n    if (allKeys.length === 0) {\n      return undefined; // No metadata extraction needed\n    }\n\n    return {\n      requestContextKeys: allKeys,\n    };\n  }\n\n  /**\n   * Extract metadata from RequestContext using TraceState\n   */\n  protected extractMetadataFromRequestContext(\n    requestContext: RequestContext | undefined,\n    explicitMetadata: Record<string, any> | undefined,\n    traceState: TraceState | undefined,\n  ): Record<string, any> | undefined {\n    if (!requestContext || !traceState || traceState.requestContextKeys.length === 0) {\n      return explicitMetadata;\n    }\n\n    const extracted = this.extractKeys(requestContext, traceState.requestContextKeys);\n\n    // Only return an object if we have extracted or explicit metadata\n    if (Object.keys(extracted).length === 0 && !explicitMetadata) {\n      return undefined;\n    }\n\n    return {\n      ...extracted,\n      ...explicitMetadata, // Explicit metadata always wins\n    };\n  }\n\n  /**\n   * Extract specific keys from RequestContext\n   */\n  protected extractKeys(requestContext: RequestContext, keys: string[]): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    for (const key of keys) {\n      // Handle dot notation: get first part from RequestContext, then navigate nested properties\n      const parts = key.split('.');\n      const rootKey = parts[0]!; // parts[0] always exists since key is a non-empty string\n      const value = requestContext.get(rootKey);\n\n      if (value !== undefined) {\n        // If there are nested parts, extract them from the value\n        if (parts.length > 1) {\n          const nestedPath = parts.slice(1).join('.');\n          const nestedValue = getNestedValue(value, nestedPath);\n          if (nestedValue !== undefined) {\n            setNestedValue(result, key, nestedValue);\n          }\n        } else {\n          // Simple key, set directly\n          setNestedValue(result, key, value);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Process a span through all output processors\n   */\n  private processSpan(span?: AnySpan): AnySpan | undefined {\n    for (const processor of this.spanOutputProcessors) {\n      if (!span) {\n        break;\n      }\n\n      try {\n        span = processor.process(span);\n      } catch (error) {\n        this.logger.error(`[Observability] Processor error [name=${processor.name}]`, error);\n        // Continue with other processors\n      }\n    }\n\n    return span;\n  }\n\n  // ============================================================================\n  // Event-driven Export Methods\n  // ============================================================================\n\n  getSpanForExport(span: AnySpan): AnyExportedSpan | undefined {\n    if (!span.isValid) return undefined;\n    if (span.isInternal && !this.config.includeInternalSpans) return undefined;\n\n    const processedSpan = this.processSpan(span);\n    return processedSpan?.exportSpan(this.config.includeInternalSpans);\n  }\n\n  /**\n   * Emit a span started event\n   */\n  protected emitSpanStarted(span: AnySpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportTracingEvent({ type: TracingEventType.SPAN_STARTED, exportedSpan }).catch(error => {\n        this.logger.error('[Observability] Failed to export span_started event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span ended event (called automatically when spans end)\n   */\n  protected emitSpanEnded(span: AnySpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportTracingEvent({ type: TracingEventType.SPAN_ENDED, exportedSpan }).catch(error => {\n        this.logger.error('[Observability] Failed to export span_ended event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span updated event\n   */\n  protected emitSpanUpdated(span: AnySpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportTracingEvent({ type: TracingEventType.SPAN_UPDATED, exportedSpan }).catch(error => {\n        this.logger.error('[Observability] Failed to export span_updated event', error);\n      });\n    }\n  }\n\n  /**\n   * Export tracing event through all exporters (realtime mode)\n   */\n  protected async exportTracingEvent(event: TracingEvent): Promise<void> {\n    const exportPromises = this.exporters.map(async exporter => {\n      try {\n        if (exporter.exportTracingEvent) {\n          await exporter.exportTracingEvent(event);\n          this.logger.debug(`[Observability] Event exported [exporter=${exporter.name}] [type=${event.type}]`);\n        }\n      } catch (error) {\n        this.logger.error(`[Observability] Export error [exporter=${exporter.name}]`, error);\n        // Don't rethrow - continue with other exporters\n      }\n    });\n\n    await Promise.allSettled(exportPromises);\n  }\n\n  // ============================================================================\n  // Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Initialize Observability (called by Mastra during component registration)\n   */\n  init(): void {\n    this.logger.debug(`[Observability] Initialization started [name=${this.name}]`);\n\n    // Any initialization logic for the Observability system\n    // This could include setting up queues, starting background processes, etc.\n\n    this.logger.info(`[Observability] Initialized successfully [name=${this.name}]`);\n  }\n\n  /**\n   * Shutdown Observability and clean up resources\n   */\n  async shutdown(): Promise<void> {\n    this.logger.debug(`[Observability] Shutdown started [name=${this.name}]`);\n\n    // Shutdown all components\n    const shutdownPromises = [\n      ...this.exporters.map(e => e.shutdown()),\n      ...this.spanOutputProcessors.map(p => p.shutdown()),\n    ];\n\n    await Promise.allSettled(shutdownPromises);\n\n    this.logger.info(`[Observability] Shutdown completed [name=${this.name}]`);\n  }\n}\n","import type { SpanType, Span, CreateSpanOptions } from '@mastra/core/observability';\nimport type { ObservabilityInstanceConfig } from '../config';\nimport { DefaultSpan } from '../spans';\nimport { BaseObservabilityInstance } from './base';\n\nexport class DefaultObservabilityInstance extends BaseObservabilityInstance {\n  constructor(config: ObservabilityInstanceConfig) {\n    super(config);\n  }\n\n  protected createSpan<TType extends SpanType>(options: CreateSpanOptions<TType>): Span<TType> {\n    // Simple span creation - base class handles all tracing lifecycle automatically\n    return new DefaultSpan<TType>(options, this);\n  }\n}\n","/**\n * Observability Registry for Mastra\n *\n * Provides registry for Observability instances.\n */\n\nimport type { ObservabilityInstance, ConfigSelectorOptions, ConfigSelector } from '@mastra/core/observability';\n\n// ============================================================================\n// Observability Registry\n// ============================================================================\n\n/**\n * Registry for Observability instances.\n */\nexport class ObservabilityRegistry {\n  #instances = new Map<string, ObservabilityInstance>();\n  #defaultInstance?: ObservabilityInstance;\n  #configSelector?: ConfigSelector;\n\n  /**\n   * Register a tracing instance\n   */\n  register(name: string, instance: ObservabilityInstance, isDefault = false): void {\n    if (this.#instances.has(name)) {\n      throw new Error(`Tracing instance '${name}' already registered`);\n    }\n\n    this.#instances.set(name, instance);\n\n    // Set as default if explicitly marked or if it's the first instance\n    if (isDefault || !this.#defaultInstance) {\n      this.#defaultInstance = instance;\n    }\n  }\n\n  /**\n   * Get a tracing instance by name\n   */\n  get(name: string): ObservabilityInstance | undefined {\n    return this.#instances.get(name);\n  }\n\n  /**\n   * Get the default tracing instance\n   */\n  getDefault(): ObservabilityInstance | undefined {\n    return this.#defaultInstance;\n  }\n\n  /**\n   * Set the tracing selector function\n   */\n  setSelector(selector: ConfigSelector): void {\n    this.#configSelector = selector;\n  }\n\n  /**\n   * Get the selected tracing instance based on context\n   */\n  getSelected(options: ConfigSelectorOptions): ObservabilityInstance | undefined {\n    // 1. Try selector function if provided\n    if (this.#configSelector) {\n      const selected = this.#configSelector(options, this.#instances);\n      if (selected && this.#instances.has(selected)) {\n        return this.#instances.get(selected);\n      }\n    }\n\n    // 2. Fall back to default\n    return this.#defaultInstance;\n  }\n\n  /**\n   * Unregister a tracing instance\n   */\n  unregister(name: string): boolean {\n    const instance = this.#instances.get(name);\n    const deleted = this.#instances.delete(name);\n\n    if (deleted && instance === this.#defaultInstance) {\n      const next = this.#instances.values().next();\n      this.#defaultInstance = next.done ? undefined : next.value;\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Shutdown all instances and clear the registry\n   */\n  async shutdown(): Promise<void> {\n    const shutdownPromises = Array.from(this.#instances.values()).map(instance => instance.shutdown());\n\n    await Promise.allSettled(shutdownPromises);\n    this.#instances.clear();\n    this.#instances.clear();\n    this.#defaultInstance = undefined;\n    this.#configSelector = undefined;\n  }\n\n  /**\n   * Clear all instances without shutdown\n   */\n  clear(): void {\n    this.#instances.clear();\n    this.#defaultInstance = undefined;\n    this.#configSelector = undefined;\n  }\n\n  /**\n   * list all registered instances\n   */\n  list(): ReadonlyMap<string, ObservabilityInstance> {\n    return new Map(this.#instances);\n  }\n}\n","import type { SpanOutputProcessor, AnySpan } from '@mastra/core/observability';\n\nexport type RedactionStyle = 'full' | 'partial';\n\n/**\n * Options for configuring the SensitiveDataFilter.\n */\nexport interface SensitiveDataFilterOptions {\n  /**\n   * List of sensitive field names to redact.\n   * Matching is case-insensitive and normalizes separators (`api-key`, `api_key`, `Api Key`  `apikey`).\n   *\n   * Defaults include: password, token, secret, key, apikey, auth, authorization,\n   * bearer, bearertoken, jwt, credential, clientsecret, privatekey, refresh, ssn.\n   */\n  sensitiveFields?: string[];\n\n  /**\n   * The token used for full redaction.\n   * Default: \"[REDACTED]\"\n   */\n  redactionToken?: string;\n\n  /**\n   * Style of redaction to use:\n   * - \"full\": always replace with redactionToken.\n   * - \"partial\": show 3 characters from the start and end, redact the middle.\n   *\n   * Default: \"full\"\n   */\n  redactionStyle?: RedactionStyle;\n}\n\n/**\n * SensitiveDataFilter\n *\n * An SpanOutputProcessor that redacts sensitive information from span fields.\n *\n * - Sensitive keys are matched case-insensitively, normalized to remove separators.\n * - Sensitive values are redacted using either full or partial redaction.\n * - Partial redaction always keeps 3 chars at the start and end.\n * - If filtering a field fails, the field is replaced with:\n *   `{ error: { processor: \"sensitive-data-filter\" } }`\n */\nexport class SensitiveDataFilter implements SpanOutputProcessor {\n  name = 'sensitive-data-filter';\n  private sensitiveFields: string[];\n  private redactionToken: string;\n  private redactionStyle: RedactionStyle;\n\n  constructor(options: SensitiveDataFilterOptions = {}) {\n    this.sensitiveFields = (\n      options.sensitiveFields || [\n        'password',\n        'token',\n        'secret',\n        'key',\n        'apikey',\n        'auth',\n        'authorization',\n        'bearer',\n        'bearertoken',\n        'jwt',\n        'credential',\n        'clientsecret',\n        'privatekey',\n        'refresh',\n        'ssn',\n      ]\n    ).map(f => this.normalizeKey(f));\n\n    this.redactionToken = options.redactionToken ?? '[REDACTED]';\n    this.redactionStyle = options.redactionStyle ?? 'full';\n  }\n\n  /**\n   * Process a span by filtering sensitive data across its key fields.\n   * Fields processed: attributes, metadata, input, output, errorInfo.\n   *\n   * @param span - The input span to filter\n   * @returns A new span with sensitive values redacted\n   */\n  process(span: AnySpan): AnySpan {\n    span.attributes = this.tryFilter(span.attributes);\n    span.metadata = this.tryFilter(span.metadata);\n    span.input = this.tryFilter(span.input);\n    span.output = this.tryFilter(span.output);\n    span.errorInfo = this.tryFilter(span.errorInfo);\n    return span;\n  }\n\n  /**\n   * Recursively filter objects/arrays for sensitive keys.\n   * Handles circular references by replacing with a marker.\n   */\n  private deepFilter(obj: any, seen = new WeakSet()): any {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    if (seen.has(obj)) {\n      return '[Circular Reference]';\n    }\n    seen.add(obj);\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.deepFilter(item, seen));\n    }\n\n    const filtered: any = {};\n    for (const key of Object.keys(obj)) {\n      const normKey = this.normalizeKey(key);\n\n      if (this.isSensitive(normKey)) {\n        if (obj[key] && typeof obj[key] === 'object') {\n          filtered[key] = this.deepFilter(obj[key], seen);\n        } else {\n          filtered[key] = this.redactValue(obj[key]);\n        }\n      } else {\n        filtered[key] = this.deepFilter(obj[key], seen);\n      }\n    }\n\n    return filtered;\n  }\n\n  private tryFilter(value: any): any {\n    try {\n      return this.deepFilter(value);\n    } catch {\n      return { error: { processor: this.name } };\n    }\n  }\n\n  /**\n   * Normalize keys by lowercasing and stripping non-alphanumeric characters.\n   * Ensures consistent matching for variants like \"api-key\", \"api_key\", \"Api Key\".\n   */\n  private normalizeKey(key: string): string {\n    return key.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  /**\n   * Check whether a normalized key exactly matches any sensitive field.\n   * Both key and sensitive fields are normalized by removing all non-alphanumeric\n   * characters and converting to lowercase before comparison.\n   *\n   * Examples:\n   * - \"api_key\", \"api-key\", \"ApiKey\" all normalize to \"apikey\"  MATCHES \"apikey\"\n   * - \"promptTokens\", \"prompt_tokens\" normalize to \"prompttokens\"  DOES NOT MATCH \"token\"\n   */\n  private isSensitive(normalizedKey: string): boolean {\n    return this.sensitiveFields.some(sensitiveField => {\n      // Simple case-insensitive match after normalization\n      return normalizedKey === sensitiveField;\n    });\n  }\n\n  /**\n   * Redact a sensitive value.\n   * - Full style: replaces with a fixed token.\n   * - Partial style: shows 3 chars at start and end, hides the middle.\n   *\n   * Non-string values are converted to strings before partial redaction.\n   */\n  private redactValue(value: any): string {\n    if (this.redactionStyle === 'full') {\n      return this.redactionToken;\n    }\n\n    const str = String(value);\n    const len = str.length;\n    if (len <= 6) {\n      return this.redactionToken; // too short, redact fully\n    }\n    return str.slice(0, 3) + '' + str.slice(len - 3);\n  }\n\n  async shutdown(): Promise<void> {\n    // No cleanup needed\n  }\n}\n","import type { Mastra } from '@mastra/core';\nimport { MastraBase } from '@mastra/core/base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { RegisteredLogger } from '@mastra/core/logger';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type {\n  ConfigSelector,\n  ConfigSelectorOptions,\n  ObservabilityEntrypoint,\n  ObservabilityInstance,\n} from '@mastra/core/observability';\nimport { SamplingStrategyType, observabilityRegistryConfigSchema, observabilityConfigValueSchema } from './config';\nimport type { ObservabilityInstanceConfig, ObservabilityRegistryConfig } from './config';\nimport { CloudExporter, DefaultExporter } from './exporters';\nimport { BaseObservabilityInstance, DefaultObservabilityInstance } from './instances';\nimport { ObservabilityRegistry } from './registry';\nimport { SensitiveDataFilter } from './span_processors';\n\n/**\n * Type guard to check if an object is a BaseObservability instance\n */\nfunction isInstance(\n  obj: Omit<ObservabilityInstanceConfig, 'name'> | ObservabilityInstance,\n): obj is ObservabilityInstance {\n  return obj instanceof BaseObservabilityInstance;\n}\n\nexport class Observability extends MastraBase implements ObservabilityEntrypoint {\n  #registry = new ObservabilityRegistry();\n\n  constructor(config: ObservabilityRegistryConfig) {\n    super({\n      component: RegisteredLogger.OBSERVABILITY,\n      name: 'Observability',\n    });\n\n    if (config === undefined) {\n      config = {};\n    }\n\n    // Validate config with Zod\n    const validationResult = observabilityRegistryConfigSchema.safeParse(config);\n    if (!validationResult.success) {\n      const errorMessages = validationResult.error.errors\n        .map(err => `${err.path.join('.') || 'config'}: ${err.message}`)\n        .join('; ');\n      throw new MastraError({\n        id: 'OBSERVABILITY_INVALID_CONFIG',\n        text: `Invalid observability configuration: ${errorMessages}`,\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.USER,\n        details: {\n          validationErrors: errorMessages,\n        },\n      });\n    }\n\n    // Validate individual configs if they are plain objects (not instances)\n    if (config.configs) {\n      for (const [name, configValue] of Object.entries(config.configs)) {\n        if (!isInstance(configValue)) {\n          const configValidation = observabilityConfigValueSchema.safeParse(configValue);\n          if (!configValidation.success) {\n            const errorMessages = configValidation.error.errors\n              .map(err => `${err.path.join('.')}: ${err.message}`)\n              .join('; ');\n            throw new MastraError({\n              id: 'OBSERVABILITY_INVALID_INSTANCE_CONFIG',\n              text: `Invalid configuration for observability instance '${name}': ${errorMessages}`,\n              domain: ErrorDomain.MASTRA_OBSERVABILITY,\n              category: ErrorCategory.USER,\n              details: {\n                instanceName: name,\n                validationErrors: errorMessages,\n              },\n            });\n          }\n        }\n      }\n    }\n\n    // Setup default config if enabled\n    if (config.default?.enabled) {\n      const defaultInstance = new DefaultObservabilityInstance({\n        serviceName: 'mastra',\n        name: 'default',\n        sampling: { type: SamplingStrategyType.ALWAYS },\n        exporters: [new DefaultExporter(), new CloudExporter()],\n        spanOutputProcessors: [new SensitiveDataFilter()],\n      });\n\n      // Register as default with high priority\n      this.#registry.register('default', defaultInstance, true);\n    }\n\n    if (config.configs) {\n      // Process user-provided configs\n      const instances = Object.entries(config.configs);\n\n      instances.forEach(([name, tracingDef], index) => {\n        const instance = isInstance(tracingDef)\n          ? tracingDef // Pre-instantiated custom implementation\n          : new DefaultObservabilityInstance({ ...tracingDef, name }); // Config -> Observability with instance name\n\n        // First user-provided instance becomes default only if no default config\n        const isDefault = !config.default?.enabled && index === 0;\n        this.#registry.register(name, instance, isDefault);\n      });\n    }\n\n    // Set selector function if provided\n    if (config.configSelector) {\n      this.#registry.setSelector(config.configSelector);\n    }\n  }\n\n  setMastraContext(options: { mastra: Mastra }): void {\n    const instances = this.listInstances();\n    const { mastra } = options;\n\n    instances.forEach(instance => {\n      const config = instance.getConfig();\n      const exporters = instance.getExporters();\n      exporters.forEach(exporter => {\n        // Initialize exporter if it has an init method\n        if ('init' in exporter && typeof exporter.init === 'function') {\n          try {\n            exporter.init({ mastra, config });\n          } catch (error) {\n            this.logger?.warn('Failed to initialize observability exporter', {\n              exporterName: exporter.name,\n              error: error instanceof Error ? error.message : String(error),\n            });\n          }\n        }\n      });\n    });\n  }\n\n  setLogger(options: { logger: IMastraLogger }): void {\n    super.__setLogger(options.logger);\n    this.listInstances().forEach(instance => {\n      instance.__setLogger(options.logger);\n    });\n  }\n\n  getSelectedInstance(options: ConfigSelectorOptions): ObservabilityInstance | undefined {\n    return this.#registry.getSelected(options);\n  }\n\n  /**\n   * Registry management methods\n   */\n\n  registerInstance(name: string, instance: ObservabilityInstance, isDefault = false): void {\n    this.#registry.register(name, instance, isDefault);\n  }\n\n  getInstance(name: string): ObservabilityInstance | undefined {\n    return this.#registry.get(name);\n  }\n\n  getDefaultInstance(): ObservabilityInstance | undefined {\n    return this.#registry.getDefault();\n  }\n\n  listInstances(): ReadonlyMap<string, ObservabilityInstance> {\n    return this.#registry.list();\n  }\n\n  unregisterInstance(name: string): boolean {\n    return this.#registry.unregister(name);\n  }\n\n  hasInstance(name: string): boolean {\n    return !!this.#registry.get(name);\n  }\n\n  setConfigSelector(selector: ConfigSelector): void {\n    this.#registry.setSelector(selector);\n  }\n\n  clear(): void {\n    this.#registry.clear();\n  }\n\n  async shutdown(): Promise<void> {\n    await this.#registry.shutdown();\n  }\n}\n"]}