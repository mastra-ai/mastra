{"version":3,"sources":["../src/storage/constants.ts","../src/storage/base.ts","../src/storage/utils.ts","../src/storage/domains/memory/base.ts","../src/storage/domains/memory/inmemory.ts","../src/storage/domains/observability/base.ts","../src/storage/domains/observability/inmemory.ts","../src/storage/domains/operations/base.ts","../src/storage/domains/operations/inmemory.ts","../src/storage/domains/scores/base.ts","../src/storage/domains/scores/inmemory.ts","../src/storage/domains/workflows/base.ts","../src/storage/domains/workflows/inmemory.ts","../src/storage/mock.ts"],"names":[],"mappings":"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","file":"chunk-ZTTMSCLU.js","sourcesContent":["import type { StorageColumn } from './types';\n\nexport const TABLE_WORKFLOW_SNAPSHOT = 'mastra_workflow_snapshot';\nexport const TABLE_MESSAGES = 'mastra_messages';\nexport const TABLE_THREADS = 'mastra_threads';\nexport const TABLE_TRACES = 'mastra_traces';\nexport const TABLE_RESOURCES = 'mastra_resources';\nexport const TABLE_SCORERS = 'mastra_scorers';\nexport const TABLE_SPANS = 'mastra_ai_spans';\n\nexport type TABLE_NAMES =\n  | typeof TABLE_WORKFLOW_SNAPSHOT\n  | typeof TABLE_MESSAGES\n  | typeof TABLE_THREADS\n  | typeof TABLE_TRACES\n  | typeof TABLE_RESOURCES\n  | typeof TABLE_SCORERS\n  | typeof TABLE_SPANS;\n\nexport const SCORERS_SCHEMA: Record<string, StorageColumn> = {\n  id: { type: 'text', nullable: false, primaryKey: true },\n  scorerId: { type: 'text' },\n  traceId: { type: 'text', nullable: true },\n  spanId: { type: 'text', nullable: true },\n  runId: { type: 'text' },\n  scorer: { type: 'jsonb' },\n  preprocessStepResult: { type: 'jsonb', nullable: true },\n  extractStepResult: { type: 'jsonb', nullable: true },\n  analyzeStepResult: { type: 'jsonb', nullable: true },\n  score: { type: 'float' },\n  reason: { type: 'text', nullable: true },\n  metadata: { type: 'jsonb', nullable: true },\n  preprocessPrompt: { type: 'text', nullable: true },\n  extractPrompt: { type: 'text', nullable: true },\n  generateScorePrompt: { type: 'text', nullable: true },\n  generateReasonPrompt: { type: 'text', nullable: true },\n  analyzePrompt: { type: 'text', nullable: true },\n\n  // Deprecated\n  reasonPrompt: { type: 'text', nullable: true },\n  input: { type: 'jsonb' },\n  output: { type: 'jsonb' }, // MESSAGE OUTPUT\n  additionalContext: { type: 'jsonb', nullable: true }, // DATA FROM THE CONTEXT PARAM ON AN AGENT\n  requestContext: { type: 'jsonb', nullable: true }, // THE EVALUATE Request Context FOR THE RUN\n  /**\n   * Things you can evaluate\n   */\n  entityType: { type: 'text', nullable: true }, // WORKFLOW, AGENT, TOOL, STEP, NETWORK\n  entity: { type: 'jsonb', nullable: true }, // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK\n  entityId: { type: 'text', nullable: true },\n  source: { type: 'text' },\n  resourceId: { type: 'text', nullable: true },\n  threadId: { type: 'text', nullable: true },\n  createdAt: { type: 'timestamp' },\n  updatedAt: { type: 'timestamp' },\n};\n\nexport const SPAN_SCHEMA: Record<string, StorageColumn> = {\n  // Composite primary key of traceId and spanId\n  traceId: { type: 'text', nullable: false },\n  spanId: { type: 'text', nullable: false },\n  parentSpanId: { type: 'text', nullable: true },\n  name: { type: 'text', nullable: false },\n  scope: { type: 'jsonb', nullable: true }, // Mastra package info {\"core-version\": \"0.1.0\"}\n  spanType: { type: 'text', nullable: false }, // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.\n  attributes: { type: 'jsonb', nullable: true },\n  metadata: { type: 'jsonb', nullable: true },\n  links: { type: 'jsonb', nullable: true },\n  input: { type: 'jsonb', nullable: true },\n  output: { type: 'jsonb', nullable: true },\n  error: { type: 'jsonb', nullable: true },\n  startedAt: { type: 'timestamp', nullable: false }, // When the span started\n  endedAt: { type: 'timestamp', nullable: true }, // When the span ended\n  createdAt: { type: 'timestamp', nullable: false }, // The time the database record was created\n  updatedAt: { type: 'timestamp', nullable: true }, // The time the database record was last updated\n  isEvent: { type: 'boolean', nullable: false },\n};\n\nexport const TABLE_SCHEMAS: Record<TABLE_NAMES, Record<string, StorageColumn>> = {\n  [TABLE_WORKFLOW_SNAPSHOT]: {\n    workflow_name: {\n      type: 'text',\n    },\n    run_id: {\n      type: 'text',\n    },\n    resourceId: { type: 'text', nullable: true },\n    snapshot: {\n      type: 'text',\n    },\n    createdAt: {\n      type: 'timestamp',\n    },\n    updatedAt: {\n      type: 'timestamp',\n    },\n  },\n  [TABLE_SCORERS]: SCORERS_SCHEMA,\n  [TABLE_THREADS]: {\n    id: { type: 'text', nullable: false, primaryKey: true },\n    resourceId: { type: 'text', nullable: false },\n    title: { type: 'text', nullable: false },\n    metadata: { type: 'text', nullable: true },\n    createdAt: { type: 'timestamp', nullable: false },\n    updatedAt: { type: 'timestamp', nullable: false },\n  },\n  [TABLE_MESSAGES]: {\n    id: { type: 'text', nullable: false, primaryKey: true },\n    thread_id: { type: 'text', nullable: false },\n    content: { type: 'text', nullable: false },\n    role: { type: 'text', nullable: false },\n    type: { type: 'text', nullable: false },\n    createdAt: { type: 'timestamp', nullable: false },\n    resourceId: { type: 'text', nullable: true },\n  },\n  [TABLE_SPANS]: SPAN_SCHEMA,\n  [TABLE_TRACES]: {\n    id: { type: 'text', nullable: false, primaryKey: true },\n    parentSpanId: { type: 'text', nullable: true },\n    name: { type: 'text', nullable: false },\n    traceId: { type: 'text', nullable: false },\n    scope: { type: 'text', nullable: false },\n    kind: { type: 'integer', nullable: false },\n    attributes: { type: 'jsonb', nullable: true },\n    status: { type: 'jsonb', nullable: true },\n    events: { type: 'jsonb', nullable: true },\n    links: { type: 'jsonb', nullable: true },\n    other: { type: 'text', nullable: true },\n    startTime: { type: 'bigint', nullable: false },\n    endTime: { type: 'bigint', nullable: false },\n    createdAt: { type: 'timestamp', nullable: false },\n  },\n  [TABLE_RESOURCES]: {\n    id: { type: 'text', nullable: false, primaryKey: true },\n    workingMemory: { type: 'text', nullable: true },\n    metadata: { type: 'jsonb', nullable: true },\n    createdAt: { type: 'timestamp', nullable: false },\n    updatedAt: { type: 'timestamp', nullable: false },\n  },\n};\n","import type { MastraMessageContentV2, MastraDBMessage } from '../agent';\nimport { MastraBase } from '../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../error';\nimport type { ScoreRowData, ScoringSource, ValidatedSaveScorePayload } from '../evals';\nimport type { StorageThreadType } from '../memory/types';\nimport type { TracingStorageStrategy } from '../observability';\nimport type { StepResult, WorkflowRunState } from '../workflows/types';\n\nimport {\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_MESSAGES,\n  TABLE_THREADS,\n  TABLE_TRACES,\n  TABLE_RESOURCES,\n  TABLE_SCORERS,\n  TABLE_SCHEMAS,\n  TABLE_SPANS,\n} from './constants';\nimport type { TABLE_NAMES } from './constants';\nimport type { ScoresStorage, StoreOperations, WorkflowsStorage, MemoryStorage, ObservabilityStorage } from './domains';\nimport type {\n  PaginationInfo,\n  StorageColumn,\n  StorageResourceType,\n  StoragePagination,\n  WorkflowRun,\n  WorkflowRuns,\n  SpanRecord,\n  TraceRecord,\n  TracesPaginatedArg,\n  CreateIndexOptions,\n  IndexInfo,\n  StorageIndexStats,\n  UpdateSpanRecord,\n  CreateSpanRecord,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListWorkflowRunsInput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n} from './types';\n\nexport type StorageDomains = {\n  operations: StoreOperations;\n  workflows: WorkflowsStorage;\n  scores: ScoresStorage;\n  memory: MemoryStorage;\n  observability?: ObservabilityStorage;\n};\n\nexport function ensureDate(date: Date | string | undefined): Date | undefined {\n  if (!date) return undefined;\n  return date instanceof Date ? date : new Date(date);\n}\n\nexport function serializeDate(date: Date | string | undefined): string | undefined {\n  if (!date) return undefined;\n  const dateObj = ensureDate(date);\n  return dateObj?.toISOString();\n}\n\n/**\n * Normalizes perPage input for pagination queries.\n *\n * @param perPageInput - The raw perPage value from the user\n * @param defaultValue - The default perPage value to use when undefined (typically 40 for messages, 100 for threads)\n * @returns A numeric perPage value suitable for queries (false becomes MAX_SAFE_INTEGER, negative values fall back to default)\n */\nexport function normalizePerPage(perPageInput: number | false | undefined, defaultValue: number): number {\n  if (perPageInput === false) {\n    return Number.MAX_SAFE_INTEGER; // Get all results\n  } else if (perPageInput === 0) {\n    return 0; // Return zero results\n  } else if (typeof perPageInput === 'number' && perPageInput > 0) {\n    return perPageInput; // Valid positive number\n  }\n  // For undefined, negative, or other invalid values, use default\n  return defaultValue;\n}\n\n/**\n * Calculates pagination offset and prepares perPage value for response.\n * When perPage is false (fetch all), offset is always 0 regardless of page.\n *\n * @param page - The page number (0-indexed)\n * @param perPageInput - The original perPage input (number, false for all, or undefined)\n * @param normalizedPerPage - The normalized perPage value (from normalizePerPage)\n * @returns Object with offset for query and perPage for response\n */\nexport function calculatePagination(\n  page: number,\n  perPageInput: number | false | undefined,\n  normalizedPerPage: number,\n): { offset: number; perPage: number | false } {\n  return {\n    offset: perPageInput === false ? 0 : page * normalizedPerPage,\n    perPage: perPageInput === false ? false : normalizedPerPage,\n  };\n}\n\nexport abstract class MastraStorage extends MastraBase {\n  protected hasInitialized: null | Promise<boolean> = null;\n  protected shouldCacheInit = true;\n\n  id: string;\n  stores?: StorageDomains;\n\n  constructor({ id, name }: { id: string; name: string }) {\n    if (!id || typeof id !== 'string' || id.trim() === '') {\n      throw new Error(`${name}: id must be provided and cannot be empty.`);\n    }\n    super({\n      component: 'STORAGE',\n      name,\n    });\n    this.id = id;\n  }\n\n  public get supports(): {\n    selectByIncludeResourceScope: boolean;\n    resourceWorkingMemory: boolean;\n    hasColumn: boolean;\n    createTable: boolean;\n    deleteMessages: boolean;\n    observabilityInstance?: boolean;\n    indexManagement?: boolean;\n    listScoresBySpan?: boolean;\n  } {\n    return {\n      selectByIncludeResourceScope: false,\n      resourceWorkingMemory: false,\n      hasColumn: false,\n      createTable: false,\n      deleteMessages: false,\n      observabilityInstance: false,\n      indexManagement: false,\n      listScoresBySpan: false,\n    };\n  }\n\n  protected ensureDate(date: Date | string | undefined): Date | undefined {\n    return ensureDate(date);\n  }\n\n  protected serializeDate(date: Date | string | undefined): string | undefined {\n    return serializeDate(date);\n  }\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'float':\n      case 'bigint':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  abstract saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  async listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    if (this.stores?.memory) {\n      return this.stores.memory.listMessages(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_MESSAGES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Listing messages is not implemented by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  async listWorkflowRuns(args?: StorageListWorkflowRunsInput): Promise<WorkflowRuns> {\n    if (this.stores?.workflows) {\n      return this.stores.workflows.listWorkflowRuns(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_WORKFLOW_RUNS_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Listing workflow runs is not implemented by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    if (this.stores?.memory) {\n      return this.stores.memory.listThreadsByResourceId(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_THREADS_BY_RESOURCE_ID_PAGINATED_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Listing threads by resource ID paginated is not implemented by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    if (this.stores?.memory) {\n      const result = await this.stores.memory.listMessagesById({ messageIds });\n      return result;\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_MESSAGES_BY_ID_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Listing messages by ID is not implemented by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  abstract updateMessages(args: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: Partial<MastraMessageContentV2>;\n    })[];\n  }): Promise<MastraDBMessage[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  async init(): Promise<void> {\n    // to prevent race conditions, await any current init\n    if (this.shouldCacheInit && (await this.hasInitialized)) {\n      return;\n    }\n\n    const tableCreationTasks = [\n      this.createTable({\n        tableName: TABLE_WORKFLOW_SNAPSHOT,\n        schema: TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT],\n      }),\n\n      this.createTable({\n        tableName: TABLE_THREADS,\n        schema: TABLE_SCHEMAS[TABLE_THREADS],\n      }),\n\n      this.createTable({\n        tableName: TABLE_MESSAGES,\n        schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      }),\n\n      this.createTable({\n        tableName: TABLE_TRACES,\n        schema: TABLE_SCHEMAS[TABLE_TRACES],\n      }),\n\n      this.createTable({\n        tableName: TABLE_SCORERS,\n        schema: TABLE_SCHEMAS[TABLE_SCORERS],\n      }),\n    ];\n\n    // Only create resources table for storage adapters that support it\n    if (this.supports.resourceWorkingMemory) {\n      tableCreationTasks.push(\n        this.createTable({\n          tableName: TABLE_RESOURCES,\n          schema: TABLE_SCHEMAS[TABLE_RESOURCES],\n        }),\n      );\n    }\n\n    if (this.supports.observabilityInstance) {\n      tableCreationTasks.push(\n        this.createTable({\n          tableName: TABLE_SPANS,\n          schema: TABLE_SCHEMAS[TABLE_SPANS],\n        }),\n      );\n    }\n\n    this.hasInitialized = Promise.all(tableCreationTasks).then(() => true);\n\n    await this.hasInitialized;\n\n    await this?.alterTable?.({\n      tableName: TABLE_MESSAGES,\n      schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      ifNotExists: ['resourceId'],\n    });\n    await this?.alterTable?.({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      schema: TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT],\n      ifNotExists: ['resourceId'],\n    });\n    await this?.alterTable?.({\n      tableName: TABLE_SCORERS,\n      schema: TABLE_SCHEMAS[TABLE_SCORERS],\n      ifNotExists: ['spanId', 'requestContext'],\n    });\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    await this.init();\n\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    this.logger.debug('Persisting workflow snapshot', { workflowName, runId, data });\n    await this.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined>;\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    if (!this.hasInitialized) {\n      await this.init();\n    }\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.load<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    return d ? d.snapshot : null;\n  }\n\n  /**\n   * SCORERS\n   */\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: ValidatedSaveScorePayload): Promise<{ score: ScoreRowData }>;\n\n  abstract listScoresByScorerId({\n    scorerId,\n    source,\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n\n  /**\n   * OBSERVABILITY\n   */\n\n  /**\n   * Provides hints for tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    if (this.stores?.observability) {\n      return this.stores.observability.tracingStrategy;\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_TRACING_STRATEGY_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Creates a single Span record in the storage provider.\n   */\n  async createSpan(span: CreateSpanRecord): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.createSpan(span);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_AI_SPAN_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Updates a single Span with partial data. Primarily used for realtime trace creation.\n   */\n  async updateSpan(params: { spanId: string; traceId: string; updates: Partial<UpdateSpanRecord> }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.updateSpan(params);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_UPDATE_AI_SPAN_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Retrieves a single trace with all its associated spans.\n   */\n  async getTrace(traceId: string): Promise<TraceRecord | null> {\n    if (this.stores?.observability) {\n      return this.stores.observability.getTrace(traceId);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_GET_TRACE_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Retrieves a paginated list of traces with optional filtering.\n   */\n  async getTracesPaginated(args: TracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    if (this.stores?.observability) {\n      return this.stores.observability.getTracesPaginated(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_GET_TRACES_PAGINATED_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Creates multiple Spans in a single batch.\n   */\n  async batchCreateSpans(args: { records: CreateSpanRecord[] }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchCreateSpans(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_CREATE_AI_SPANS_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Updates multiple Spans in a single batch.\n   */\n  async batchUpdateSpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateSpanRecord>;\n    }[];\n  }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchUpdateSpans(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_UPDATE_AI_SPANS_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Deletes multiple traces and all their associated spans in a single batch operation.\n   */\n  async batchDeleteTraces(args: { traceIds: string[] }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchDeleteTraces(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_DELETE_TRACES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * These methods delegate to the operations store for index management.\n   * Storage adapters that support indexes should implement these in their operations class.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(options: CreateIndexOptions): Promise<void> {\n    if (this.stores?.operations) {\n      return this.stores.operations.createIndex(options);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(indexName: string): Promise<void> {\n    if (this.stores?.operations) {\n      return this.stores.operations.dropIndex(indexName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(tableName?: string): Promise<IndexInfo[]> {\n    if (this.stores?.operations) {\n      return this.stores.operations.listIndexes(tableName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(indexName: string): Promise<StorageIndexStats> {\n    if (this.stores?.operations) {\n      return this.stores.operations.describeIndex(indexName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n}\n","export function safelyParseJSON(input: any): any {\n  // If already an object (and not null), return as-is\n  if (input && typeof input === 'object') return input;\n  if (input == null) return {};\n  // If it's a string, try to parse\n  if (typeof input === 'string') {\n    try {\n      return JSON.parse(input);\n    } catch {\n      return input;\n    }\n  }\n  // For anything else (number, boolean, etc.), return empty object\n  return {};\n}\n","import type { MastraMessageContentV2 } from '../../../agent';\nimport { MastraBase } from '../../../base';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport type {\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n  StorageOrderBy,\n} from '../../types';\n\nexport abstract class MemoryStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'MEMORY',\n    });\n  }\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  abstract listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput>;\n\n  abstract listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract updateMessages(args: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraDBMessage[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  abstract listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput>;\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  protected parseOrderBy(\n    orderBy?: StorageOrderBy,\n    defaultDirection: ThreadSortDirection = 'DESC',\n  ): { field: ThreadOrderBy; direction: ThreadSortDirection } {\n    return {\n      field: orderBy?.field && orderBy.field in THREAD_ORDER_BY_SET ? orderBy.field : 'createdAt',\n      direction:\n        orderBy?.direction && orderBy.direction in THREAD_THREAD_SORT_DIRECTION_SET\n          ? orderBy.direction\n          : defaultDirection,\n    };\n  }\n}\n\nconst THREAD_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst THREAD_THREAD_SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n","import { MessageList } from '../../../agent/message-list';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageMessageType,\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesOutput,\n  StorageListThreadsByResourceIdInput,\n  StorageListThreadsByResourceIdOutput,\n} from '../../types';\nimport { safelyParseJSON } from '../../utils';\nimport type { StoreOperations } from '../operations';\nimport { MemoryStorage } from './base';\n\nexport type InMemoryThreads = Map<string, StorageThreadType>;\nexport type InMemoryResources = Map<string, StorageResourceType>;\nexport type InMemoryMessages = Map<string, StorageMessageType>;\n\nexport class InMemoryMemory extends MemoryStorage {\n  private collection: {\n    threads: InMemoryThreads;\n    resources: InMemoryResources;\n    messages: InMemoryMessages;\n  };\n  private operations: StoreOperations;\n  constructor({\n    collection,\n    operations,\n  }: {\n    collection: {\n      threads: InMemoryThreads;\n      resources: InMemoryResources;\n      messages: InMemoryMessages;\n    };\n    operations: StoreOperations;\n  }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    this.logger.debug(`MockStore: getThreadById called for ${threadId}`);\n    const thread = this.collection.threads.get(threadId);\n    return thread ? { ...thread, metadata: thread.metadata ? { ...thread.metadata } : thread.metadata } : null;\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    this.logger.debug(`MockStore: saveThread called for ${thread.id}`);\n    const key = thread.id;\n    this.collection.threads.set(key, thread);\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    this.logger.debug(`MockStore: updateThread called for ${id}`);\n    const thread = this.collection.threads.get(id);\n\n    if (!thread) {\n      throw new Error(`Thread with id ${id} not found`);\n    }\n\n    if (thread) {\n      thread.title = title;\n      thread.metadata = { ...thread.metadata, ...metadata };\n      thread.updatedAt = new Date();\n    }\n    return thread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    this.logger.debug(`MockStore: deleteThread called for ${threadId}`);\n    this.collection.threads.delete(threadId);\n\n    this.collection.messages.forEach((msg, key) => {\n      if (msg.thread_id === threadId) {\n        this.collection.messages.delete(key);\n      }\n    });\n  }\n\n  async listMessages({\n    threadId,\n    resourceId,\n    include,\n    filter,\n    perPage: perPageInput,\n    page = 0,\n    orderBy,\n  }: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    this.logger.debug(`MockStore: listMessages called for thread ${threadId}`);\n\n    if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n    const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  40)\n    const perPage = normalizePerPage(perPageInput, 40);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Calculate offset from page\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    // Step 1: Get regular paginated messages from the thread first\n    let threadMessages = Array.from(this.collection.messages.values()).filter((msg: any) => {\n      if (msg.thread_id !== threadId) return false;\n      if (resourceId && msg.resourceId !== resourceId) return false;\n      return true;\n    });\n\n    // Apply date filtering\n    if (filter?.dateRange) {\n      const { start: from, end: to } = filter.dateRange;\n      threadMessages = threadMessages.filter((msg: any) => {\n        const msgDate = new Date(msg.createdAt);\n        const fromDate = from ? new Date(from) : null;\n        const toDate = to ? new Date(to) : null;\n\n        if (fromDate && msgDate < fromDate) return false;\n        if (toDate && msgDate > toDate) return false;\n        return true;\n      });\n    }\n\n    // Sort thread messages before pagination\n    threadMessages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Get total count of thread messages (for pagination metadata)\n    const totalThreadMessages = threadMessages.length;\n\n    // Apply pagination to thread messages\n    const start = offset;\n    const end = start + perPage;\n    const paginatedThreadMessages = threadMessages.slice(start, end);\n\n    // Convert paginated thread messages to MastraDBMessage\n    const messages: MastraDBMessage[] = [];\n    const messageIds = new Set<string>();\n\n    for (const msg of paginatedThreadMessages) {\n      const convertedMessage = this.parseStoredMessage(msg);\n      messages.push(convertedMessage);\n      messageIds.add(msg.id);\n    }\n\n    // Step 2: Add included messages with context (if any), excluding duplicates\n    if (include && include.length > 0) {\n      for (const includeItem of include) {\n        const targetMessage = this.collection.messages.get(includeItem.id);\n        if (targetMessage) {\n          // Convert StorageMessageType to MastraDBMessage\n          const convertedMessage = {\n            id: targetMessage.id,\n            threadId: targetMessage.thread_id,\n            content: safelyParseJSON(targetMessage.content),\n            role: targetMessage.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: targetMessage.type,\n            createdAt: targetMessage.createdAt,\n            resourceId: targetMessage.resourceId,\n          } as MastraDBMessage;\n\n          // Only add if not already in messages array (deduplication)\n          if (!messageIds.has(convertedMessage.id)) {\n            messages.push(convertedMessage);\n            messageIds.add(convertedMessage.id);\n          }\n\n          // Add previous messages if requested\n          if (includeItem.withPreviousMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));\n              for (let i = startIndex; i < targetIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedPrevMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedPrevMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n\n          // Add next messages if requested\n          if (includeItem.withNextMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const endIndex = Math.min(\n                allThreadMessages.length,\n                targetIndex + (includeItem.withNextMessages || 0) + 1,\n              );\n              for (let i = targetIndex + 1; i < endIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedNextMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedNextMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Sort all messages (paginated + included) for final output\n    messages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Calculate hasMore\n    let hasMore;\n    if (include && include.length > 0) {\n      // When using include, check if we've returned all messages from the thread\n      // because include might bring in messages beyond the pagination window\n      const returnedThreadMessageIds = new Set(messages.filter(m => m.threadId === threadId).map(m => m.id));\n      hasMore = returnedThreadMessageIds.size < totalThreadMessages;\n    } else {\n      // Standard pagination: check if there are more pages\n      hasMore = end < totalThreadMessages;\n    }\n\n    return {\n      messages,\n      total: totalThreadMessages,\n      page,\n      perPage: perPageForResponse,\n      hasMore,\n    };\n  }\n\n  protected parseStoredMessage(message: StorageMessageType): MastraDBMessage {\n    const { resourceId, content, role, thread_id, ...rest } = message;\n\n    // Parse content using safelyParseJSON utility\n    let parsedContent = safelyParseJSON(content);\n\n    // If the result is a plain string (V1 format), wrap it in V2 structure\n    if (typeof parsedContent === 'string') {\n      parsedContent = {\n        format: 2,\n        content: parsedContent,\n        parts: [{ type: 'text', text: parsedContent }],\n      };\n    }\n\n    return {\n      ...rest,\n      threadId: thread_id,\n      ...(message.resourceId && { resourceId: message.resourceId }),\n      content: parsedContent,\n      role: role as MastraDBMessage['role'],\n    } satisfies MastraDBMessage;\n  }\n\n  async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    this.logger.debug(`MockStore: listMessagesById called`);\n\n    const rawMessages = messageIds.map(id => this.collection.messages.get(id)).filter(message => !!message);\n\n    const list = new MessageList().add(rawMessages.map(this.parseStoredMessage), 'memory');\n    return { messages: list.get.all.db() };\n  }\n\n  async saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    const { messages } = args;\n    this.logger.debug(`MockStore: saveMessages called with ${messages.length} messages`);\n    // Simulate error handling for testing - check before saving\n    if (messages.some(msg => msg.id === 'error-message' || msg.resourceId === null)) {\n      throw new Error('Simulated error for testing');\n    }\n\n    // Update thread timestamps for each unique threadId\n    const threadIds = new Set(messages.map(msg => msg.threadId).filter((id): id is string => Boolean(id)));\n    for (const threadId of threadIds) {\n      const thread = this.collection.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = new Date();\n      }\n    }\n\n    for (const message of messages) {\n      const key = message.id;\n      // Convert MastraDBMessage to StorageMessageType\n      const storageMessage: StorageMessageType = {\n        id: message.id,\n        thread_id: message.threadId || '',\n        content: JSON.stringify(message.content),\n        role: message.role || 'user',\n        type: message.type || 'text',\n        createdAt: message.createdAt,\n        resourceId: message.resourceId || null,\n      };\n      this.collection.messages.set(key, storageMessage);\n    }\n\n    const list = new MessageList().add(messages, 'memory');\n    return { messages: list.get.all.db() };\n  }\n\n  async updateMessages(args: { messages: (Partial<MastraDBMessage> & { id: string })[] }): Promise<MastraDBMessage[]> {\n    const updatedMessages: MastraDBMessage[] = [];\n    for (const update of args.messages) {\n      const storageMsg = this.collection.messages.get(update.id);\n      if (!storageMsg) continue;\n\n      // Track old threadId for possible move\n      const oldThreadId = storageMsg.thread_id;\n      const newThreadId = update.threadId || oldThreadId;\n      let threadIdChanged = false;\n      if (update.threadId && update.threadId !== oldThreadId) {\n        threadIdChanged = true;\n      }\n\n      // Update fields\n      if (update.role !== undefined) storageMsg.role = update.role;\n      if (update.type !== undefined) storageMsg.type = update.type;\n      if (update.createdAt !== undefined) storageMsg.createdAt = update.createdAt;\n      if (update.resourceId !== undefined) storageMsg.resourceId = update.resourceId;\n      // Deep merge content if present\n      if (update.content !== undefined) {\n        let oldContent = safelyParseJSON(storageMsg.content);\n        let newContent = update.content;\n        if (typeof newContent === 'object' && typeof oldContent === 'object') {\n          // Deep merge for metadata/content fields\n          newContent = { ...oldContent, ...newContent };\n          if (oldContent.metadata && newContent.metadata) {\n            newContent.metadata = { ...oldContent.metadata, ...newContent.metadata };\n          }\n        }\n        storageMsg.content = JSON.stringify(newContent);\n      }\n      // Handle threadId change\n      if (threadIdChanged) {\n        storageMsg.thread_id = newThreadId;\n        // Update updatedAt for both threads, ensuring strictly greater and not equal\n        const base = Date.now();\n        let oldThreadNewTime: number | undefined;\n        const oldThread = this.collection.threads.get(oldThreadId);\n        if (oldThread) {\n          const prev = new Date(oldThread.updatedAt).getTime();\n          oldThreadNewTime = Math.max(base, prev + 1);\n          oldThread.updatedAt = new Date(oldThreadNewTime);\n        }\n        const newThread = this.collection.threads.get(newThreadId);\n        if (newThread) {\n          const prev = new Date(newThread.updatedAt).getTime();\n          let newThreadNewTime = Math.max(base + 1, prev + 1);\n          if (oldThreadNewTime !== undefined && newThreadNewTime <= oldThreadNewTime) {\n            newThreadNewTime = oldThreadNewTime + 1;\n          }\n          newThread.updatedAt = new Date(newThreadNewTime);\n        }\n      } else {\n        // Only update the thread's updatedAt if not a move\n        const thread = this.collection.threads.get(oldThreadId);\n        if (thread) {\n          const prev = new Date(thread.updatedAt).getTime();\n          let newTime = Date.now();\n          if (newTime <= prev) newTime = prev + 1;\n          thread.updatedAt = new Date(newTime);\n        }\n      }\n      // Save the updated message\n      this.collection.messages.set(update.id, storageMsg);\n      // Return as MastraDBMessage\n      updatedMessages.push({\n        id: storageMsg.id,\n        threadId: storageMsg.thread_id,\n        content: safelyParseJSON(storageMsg.content),\n        role: storageMsg.role === 'user' || storageMsg.role === 'assistant' ? storageMsg.role : 'user',\n        type: storageMsg.type,\n        createdAt: storageMsg.createdAt,\n        resourceId: storageMsg.resourceId === null ? undefined : storageMsg.resourceId,\n      });\n    }\n    return updatedMessages;\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    this.logger.debug(`MockStore: deleteMessages called for ${messageIds.length} messages`);\n\n    // Collect thread IDs to update\n    const threadIds = new Set<string>();\n\n    for (const messageId of messageIds) {\n      const message = this.collection.messages.get(messageId);\n      if (message && message.thread_id) {\n        threadIds.add(message.thread_id);\n      }\n      // Delete the message\n      this.collection.messages.delete(messageId);\n    }\n\n    // Update thread timestamps\n    const now = new Date();\n    for (const threadId of threadIds) {\n      const thread = this.collection.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = now;\n      }\n    }\n  }\n\n  async listThreadsByResourceId(\n    args: StorageListThreadsByResourceIdInput,\n  ): Promise<StorageListThreadsByResourceIdOutput> {\n    const { resourceId, page = 0, perPage: perPageInput, orderBy } = args;\n    const { field, direction } = this.parseOrderBy(orderBy);\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    this.logger.debug(`MockStore: listThreadsByResourceId called for ${resourceId}`);\n    // Mock implementation - find threads by resourceId\n    const threads = Array.from(this.collection.threads.values()).filter((t: any) => t.resourceId === resourceId);\n    const sortedThreads = this.sortThreads(threads, field, direction);\n    const clonedThreads = sortedThreads.map(thread => ({\n      ...thread,\n      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata,\n    })) as StorageThreadType[];\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    return {\n      threads: clonedThreads.slice(offset, offset + perPage),\n      total: clonedThreads.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedThreads.length,\n    };\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    this.logger.debug(`MockStore: getResourceById called for ${resourceId}`);\n    const resource = this.collection.resources.get(resourceId);\n    return resource\n      ? { ...resource, metadata: resource.metadata ? { ...resource.metadata } : resource.metadata }\n      : null;\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    this.logger.debug(`MockStore: saveResource called for ${resource.id}`);\n    this.collection.resources.set(resource.id, resource);\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    this.logger.debug(`MockStore: updateResource called for ${resourceId}`);\n    let resource = this.collection.resources.get(resourceId);\n\n    if (!resource) {\n      // Create new resource if it doesn't exist\n      resource = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    } else {\n      resource = {\n        ...resource,\n        workingMemory: workingMemory !== undefined ? workingMemory : resource.workingMemory,\n        metadata: {\n          ...resource.metadata,\n          ...metadata,\n        },\n        updatedAt: new Date(),\n      };\n    }\n\n    this.collection.resources.set(resourceId, resource);\n    return resource;\n  }\n\n  private sortThreads(threads: any[], field: ThreadOrderBy, direction: ThreadSortDirection): any[] {\n    return threads.sort((a, b) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        if (direction === 'ASC') {\n          return aValue - bValue;\n        } else {\n          return bValue - aValue;\n        }\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n  }\n}\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TracingStorageStrategy } from '../../../observability';\nimport type {\n  SpanRecord,\n  TraceRecord,\n  TracesPaginatedArg,\n  CreateSpanRecord,\n  PaginationInfo,\n  UpdateSpanRecord,\n} from '../../types';\n\nexport class ObservabilityStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OBSERVABILITY',\n    });\n  }\n\n  /**\n   * Provides hints for tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates', // Default for most SQL stores\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  /**\n   * Creates a single Span record in the storage provider.\n   */\n  createSpan(_span: CreateSpanRecord): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support creating spans',\n    });\n  }\n\n  /**\n   * Updates a single Span with partial data. Primarily used for realtime trace creation.\n   */\n  updateSpan(_params: { spanId: string; traceId: string; updates: Partial<UpdateSpanRecord> }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_UPDATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support updating spans',\n    });\n  }\n\n  /**\n   * Retrieves a single trace with all its associated spans.\n   */\n  getTrace(_traceId: string): Promise<TraceRecord | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_TRACE_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting traces',\n    });\n  }\n\n  /**\n   * Retrieves a paginated list of traces with optional filtering.\n   */\n  getTracesPaginated(_args: TracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_TRACES_PAGINATED_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting traces paginated',\n    });\n  }\n\n  /**\n   * Creates multiple Spans in a single batch.\n   */\n  batchCreateSpans(_args: { records: CreateSpanRecord[] }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch creating spans',\n    });\n  }\n\n  /**\n   * Updates multiple Spans in a single batch.\n   */\n  batchUpdateSpans(_args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateSpanRecord>;\n    }[];\n  }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_UPDATE_SPANS_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch updating spans',\n    });\n  }\n\n  /**\n   * Deletes multiple traces and all their associated spans in a single batch operation.\n   */\n  batchDeleteTraces(_args: { traceIds: string[] }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_DELETE_TRACES_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch deleting traces',\n    });\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TracingStorageStrategy } from '../../../observability';\nimport type {\n  SpanRecord,\n  TraceRecord,\n  TracesPaginatedArg,\n  CreateSpanRecord,\n  PaginationInfo,\n  UpdateSpanRecord,\n} from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { ObservabilityStorage } from './base';\n\nexport type InMemoryObservability = Map<string, SpanRecord>;\nexport class ObservabilityInMemory extends ObservabilityStorage {\n  operations: StoreOperations;\n  collection: InMemoryObservability;\n\n  constructor({ collection, operations }: { collection: InMemoryObservability; operations: StoreOperations }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'realtime',\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createSpan(span: CreateSpanRecord): Promise<void> {\n    this.validateCreateSpan(span);\n    const id = this.generateId(span);\n    const record = span as SpanRecord;\n    record.createdAt = new Date();\n    record.updatedAt = record.createdAt;\n    this.collection.set(id, record);\n  }\n\n  async batchCreateSpans(args: { records: CreateSpanRecord[] }): Promise<void> {\n    for (const record of args.records) {\n      await this.createSpan(record);\n    }\n  }\n\n  private validateCreateSpan(record: CreateSpanRecord): void {\n    if (!record.spanId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_SPAN_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span ID is required for creating a span',\n      });\n    }\n\n    if (!record.traceId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_TRACE_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace ID is required for creating a span',\n      });\n    }\n  }\n\n  private generateId({ traceId, spanId }: { traceId: string; spanId: string }): string {\n    return `${traceId}-${spanId}`;\n  }\n\n  async getTrace(traceId: string): Promise<TraceRecord | null> {\n    const spans = Array.from(this.collection.values()).filter(span => span.traceId === traceId);\n    if (spans.length === 0) {\n      return null;\n    }\n    spans.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());\n\n    return {\n      traceId,\n      spans,\n    };\n  }\n\n  async getTracesPaginated({\n    filters,\n    pagination,\n  }: TracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: SpanRecord[] }> {\n    const allRootSpans = this.filterForRootSpans(Array.from(this.collection.values()));\n    const filteredRootSpans = this.filterSpansByFilter(allRootSpans, filters);\n\n    const startDate = pagination?.dateRange?.start;\n    const endDate = pagination?.dateRange?.end;\n    const filteredRootSpansByDate = this.filterSpansByDate(filteredRootSpans, startDate, endDate);\n\n    const total = filteredRootSpansByDate.length;\n    const page = pagination?.page ?? 0;\n    const perPage = pagination?.perPage ?? 10;\n\n    const start = page * perPage;\n    const end = start + perPage;\n    const paged = this.filterSpansByPagination(filteredRootSpansByDate, pagination);\n\n    return {\n      spans: paged,\n      pagination: { total, page, perPage, hasMore: end < total },\n    };\n  }\n\n  private filterForRootSpans(spans: SpanRecord[]): SpanRecord[] {\n    return spans.filter(span => span.parentSpanId === null);\n  }\n\n  private filterSpansByDate(spans: SpanRecord[], startDate: Date | undefined, endDate: Date | undefined): SpanRecord[] {\n    return spans.filter(span => {\n      if (startDate && span.startedAt < startDate) return false;\n      if (endDate && span.startedAt > endDate) return false;\n      return true;\n    });\n  }\n\n  private filterSpansByFilter(spans: SpanRecord[], filter: TracesPaginatedArg['filters']): SpanRecord[] {\n    return spans.filter(span => {\n      if (filter?.name && span.name !== filter.name) return false;\n      if (filter?.spanType && span.spanType !== filter.spanType) return false;\n\n      if (filter?.entityType === 'agent' && filter.entityId !== span.attributes?.agentId) return false;\n\n      if (filter?.entityType === 'workflow' && filter.entityId !== span.attributes?.workflowId) return false;\n\n      return true;\n    });\n  }\n\n  private filterSpansByPagination(spans: SpanRecord[], pagination: TracesPaginatedArg['pagination']): SpanRecord[] {\n    const page = pagination?.page ?? 0;\n    const perPage = pagination?.perPage ?? 10;\n    const start = page * perPage;\n    const end = start + perPage;\n    return spans.slice(start, end);\n  }\n\n  async updateSpan(params: { spanId: string; traceId: string; updates: Partial<UpdateSpanRecord> }): Promise<void> {\n    const id = this.generateId(params);\n    const span = this.collection.get(id);\n\n    if (!span) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span not found for update',\n      });\n    }\n\n    this.collection.set(id, { ...span, ...params.updates, updatedAt: new Date() });\n  }\n\n  async batchUpdateSpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateSpanRecord>;\n    }[];\n  }): Promise<void> {\n    for (const record of args.records) {\n      await this.updateSpan(record);\n    }\n  }\n\n  async batchDeleteTraces(args: { traceIds: string[] }): Promise<void> {\n    for (const traceId of args.traceIds) {\n      const spans = Array.from(this.collection.values()).filter(span => span.traceId === traceId);\n      for (const span of spans) {\n        this.collection.delete(this.generateId(span));\n      }\n    }\n  }\n}\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn, CreateIndexOptions, IndexInfo, StorageIndexStats } from '../../types';\n\nexport abstract class StoreOperations extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OPERATIONS',\n    });\n  }\n\n  abstract hasColumn(table: string, column: string): Promise<boolean>;\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * Optional methods for database index management.\n   * Storage adapters can override these to provide index management capabilities.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(_options: CreateIndexOptions): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(_indexName: string): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(_tableName?: string): Promise<IndexInfo[]> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(_indexName: string): Promise<StorageIndexStats> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Returns definitions for automatic performance indexes\n   * Storage adapters can override this to define indexes that should be created during initialization\n   * @returns Array of index definitions to create automatically\n   */\n  protected getAutomaticIndexDefinitions(): CreateIndexOptions[] {\n    return [];\n  }\n}\n","import { TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn } from '../../types';\nimport { StoreOperations } from './base';\n\nexport class StoreOperationsInMemory extends StoreOperations {\n  data: Record<TABLE_NAMES, Map<string, Record<string, any>>>;\n\n  constructor() {\n    super();\n    this.data = {\n      mastra_workflow_snapshot: new Map(),\n      mastra_messages: new Map(),\n      mastra_threads: new Map(),\n      mastra_traces: new Map(),\n      mastra_resources: new Map(),\n      mastra_scorers: new Map(),\n      mastra_ai_spans: new Map(),\n    };\n  }\n\n  getDatabase() {\n    return this.data;\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    const table = this.data[tableName];\n    let key = record.id;\n    if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n      key = record.workflow_name ? `${record.workflow_name}-${record.run_id}` : record.run_id;\n      record.id = key;\n    } else if (!record.id) {\n      key = `auto-${Date.now()}-${Math.random()}`;\n      record.id = key;\n    }\n    table.set(key, record);\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    const table = this.data[tableName];\n    for (const record of records) {\n      let key = record.id;\n      if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n        key = record.run_id;\n        record.id = key;\n      } else if (!record.id) {\n        key = `auto-${Date.now()}-${Math.random()}`;\n        record.id = key;\n      }\n      table.set(key, record);\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);\n\n    const table = this.data[tableName];\n\n    const records = Array.from(table.values());\n\n    return records.filter(record => Object.keys(keys).every(key => record[key] === keys[key]))?.[0] as R | null;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);\n\n    this.data[tableName] = new Map();\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: clearTable called for ${tableName}`);\n\n    this.data[tableName].clear();\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: dropTable called for ${tableName}`);\n    this.data[tableName].clear();\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);\n    return true;\n  }\n}\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { ScoreRowData, ScoringSource } from '../../../evals/types';\nimport type { PaginationInfo, StoragePagination } from '../../types';\n\nexport abstract class ScoresStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'SCORES',\n    });\n  }\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }>;\n\n  abstract listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n}\n","import type { ScoreRowData, ScoringSource } from '../../../evals/types';\nimport { calculatePagination, normalizePerPage } from '../../base';\nimport type { PaginationInfo, StoragePagination } from '../../types';\nimport { ScoresStorage } from './base';\n\nexport type InMemoryScores = Map<string, ScoreRowData>;\n\nexport class ScoresInMemory extends ScoresStorage {\n  scores: InMemoryScores;\n\n  constructor({ collection }: { collection: InMemoryScores }) {\n    super();\n    this.scores = collection;\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.scores.get(id) ?? null;\n  }\n\n  async saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }> {\n    const newScore = { id: crypto.randomUUID(), createdAt: new Date(), updatedAt: new Date(), ...score };\n    this.scores.set(newScore.id, newScore);\n    return { score: newScore };\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => {\n      let baseFilter = score.scorerId === scorerId;\n\n      if (entityId) {\n        baseFilter = baseFilter && score.entityId === entityId;\n      }\n\n      if (entityType) {\n        baseFilter = baseFilter && score.entityType === entityType;\n      }\n\n      if (source) {\n        baseFilter = baseFilter && score.source === source;\n      }\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => score.runId === runId);\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER); // false  MAX_SAFE_INTEGER\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => {\n      const baseFilter = score.entityId === entityId && score.entityType === entityType;\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(\n      score => score.traceId === traceId && score.spanId === spanId,\n    );\n    scores.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n}\n","import { MastraBase } from '../../../base';\nimport type { StepResult, WorkflowRunState } from '../../../workflows';\nimport type { WorkflowRun, WorkflowRuns, StorageListWorkflowRunsInput } from '../../types';\n\nexport abstract class WorkflowsStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'WORKFLOWS',\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined>;\n\n  abstract persistWorkflowSnapshot(_: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void>;\n\n  abstract loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null>;\n\n  abstract listWorkflowRuns(args?: StorageListWorkflowRunsInput): Promise<WorkflowRuns>;\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport { normalizePerPage } from '../../base';\nimport { TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { StorageWorkflowRun, WorkflowRun, WorkflowRuns, StorageListWorkflowRunsInput } from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { WorkflowsStorage } from './base';\n\nexport type InMemoryWorkflows = Map<string, StorageWorkflowRun>;\n\nexport class WorkflowsInMemory extends WorkflowsStorage {\n  operations: StoreOperations;\n  collection: InMemoryWorkflows;\n\n  constructor({ collection, operations }: { collection: InMemoryWorkflows; operations: StoreOperations }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    this.logger.debug(`MockStore: updateWorkflowResults called for ${workflowName} ${runId} ${stepId}`, result);\n    const run = this.collection.get(`${workflowName}-${runId}`);\n\n    if (!run) {\n      return {};\n    }\n\n    let snapshot;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.collection.set(`${workflowName}-${runId}`, {\n        ...run,\n        snapshot,\n      });\n    }\n\n    snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot.context[stepId] = result;\n    snapshot.requestContext = { ...snapshot.requestContext, ...requestContext };\n\n    this.collection.set(`${workflowName}-${runId}`, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return JSON.parse(JSON.stringify(snapshot.context));\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined> {\n    const run = this.collection.get(`${workflowName}-${runId}`);\n\n    if (!run) {\n      return;\n    }\n\n    let snapshot;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.collection.set(`${workflowName}-${runId}`, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot = { ...snapshot, ...opts };\n    this.collection.set(`${workflowName}-${runId}`, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return snapshot;\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }) {\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.operations.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.operations.load<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    // Return a deep copy to prevent mutation\n    return d ? JSON.parse(JSON.stringify(d.snapshot)) : null;\n  }\n\n  async listWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    perPage,\n    page,\n    resourceId,\n    status,\n  }: StorageListWorkflowRunsInput = {}): Promise<WorkflowRuns> {\n    if (page !== undefined && page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    let runs = Array.from(this.collection.values());\n\n    if (workflowName) runs = runs.filter((run: any) => run.workflow_name === workflowName);\n    if (status) {\n      runs = runs.filter((run: any) => {\n        let snapshot: WorkflowRunState | string = run?.snapshot!;\n\n        if (!snapshot) {\n          return false;\n        }\n\n        if (typeof snapshot === 'string') {\n          try {\n            snapshot = JSON.parse(snapshot) as WorkflowRunState;\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          } catch (error) {\n            return false;\n          }\n        } else {\n          snapshot = JSON.parse(JSON.stringify(snapshot)) as WorkflowRunState;\n        }\n\n        return snapshot.status === status;\n      });\n    }\n\n    if (fromDate && toDate) {\n      runs = runs.filter(\n        (run: any) =>\n          new Date(run.createdAt).getTime() >= fromDate.getTime() &&\n          new Date(run.createdAt).getTime() <= toDate.getTime(),\n      );\n    } else if (fromDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() >= fromDate.getTime());\n    } else if (toDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() <= toDate.getTime());\n    }\n    if (resourceId) runs = runs.filter((run: any) => run.resourceId === resourceId);\n\n    const total = runs.length;\n\n    // Sort by createdAt\n    runs.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Apply pagination\n    if (perPage !== undefined && page !== undefined) {\n      // Use MAX_SAFE_INTEGER as default to maintain \"no pagination\" behavior when undefined\n      const normalizedPerPage = normalizePerPage(perPage, Number.MAX_SAFE_INTEGER);\n      const offset = page * normalizedPerPage;\n      const start = offset;\n      const end = start + normalizedPerPage;\n      runs = runs.slice(start, end);\n    }\n\n    // Deserialize snapshot if it's a string\n    const parsedRuns = runs.map((run: any) => ({\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    }));\n\n    return { runs: parsedRuns as WorkflowRun[], total };\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const runs = Array.from(this.collection.values()).filter((r: any) => r.run_id === runId);\n    let run = runs.find((r: any) => r.workflow_name === workflowName);\n\n    if (!run) return null;\n\n    // Return a deep copy to prevent mutation\n    const parsedRun = {\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    };\n\n    return parsedRun as WorkflowRun;\n  }\n}\n","import type { MastraDBMessage } from '../agent';\nimport type { ScoreRowData, ScoringSource } from '../evals/types';\nimport type { StorageThreadType } from '../memory/types';\nimport type { StepResult, WorkflowRunState } from '../workflows/types';\nimport { MastraStorage } from './base';\nimport type { StorageDomains } from './base';\nimport type { TABLE_NAMES } from './constants';\nimport { InMemoryMemory } from './domains/memory/inmemory';\nimport type { InMemoryThreads, InMemoryResources, InMemoryMessages } from './domains/memory/inmemory';\nimport { ObservabilityInMemory } from './domains/observability/inmemory';\nimport type { InMemoryObservability } from './domains/observability/inmemory';\nimport { StoreOperationsInMemory } from './domains/operations/inmemory';\nimport { ScoresInMemory } from './domains/scores/inmemory';\nimport type { InMemoryScores } from './domains/scores/inmemory';\nimport { WorkflowsInMemory } from './domains/workflows';\nimport type { InMemoryWorkflows } from './domains/workflows/inmemory';\n\nimport type {\n  SpanRecord,\n  TraceRecord,\n  PaginationInfo,\n  StorageColumn,\n  StoragePagination,\n  StorageResourceType,\n  WorkflowRun,\n} from './types';\n\nexport class InMemoryStore extends MastraStorage {\n  stores: StorageDomains;\n\n  constructor({ id = 'in-memory' }: { id?: string } = {}) {\n    super({ id, name: 'InMemoryStorage' });\n    // MockStore doesn't need async initialization\n    this.hasInitialized = Promise.resolve(true);\n\n    const operationsStorage = new StoreOperationsInMemory();\n\n    const database = operationsStorage.getDatabase();\n\n    const scoresStorage = new ScoresInMemory({\n      collection: database.mastra_scorers as InMemoryScores,\n    });\n\n    const workflowsStorage = new WorkflowsInMemory({\n      collection: database.mastra_workflow_snapshot as InMemoryWorkflows,\n      operations: operationsStorage,\n    });\n\n    const memoryStorage = new InMemoryMemory({\n      collection: {\n        threads: database.mastra_threads as InMemoryThreads,\n        resources: database.mastra_resources as InMemoryResources,\n        messages: database.mastra_messages as InMemoryMessages,\n      },\n      operations: operationsStorage,\n    });\n\n    const observabilityStorage = new ObservabilityInMemory({\n      collection: database.mastra_ai_spans as InMemoryObservability,\n      operations: operationsStorage,\n    });\n\n    this.stores = {\n      operations: operationsStorage,\n      workflows: workflowsStorage,\n      scores: scoresStorage,\n      memory: memoryStorage,\n      observability: observabilityStorage,\n    };\n  }\n\n  public get supports() {\n    return {\n      selectByIncludeResourceScope: false,\n      resourceWorkingMemory: false,\n      hasColumn: false,\n      createTable: false,\n      deleteMessages: true,\n      observabilityInstance: true,\n      indexManagement: false,\n      listScoresBySpan: true,\n    };\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    await this.stores.workflows.persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    return this.stores.workflows.loadWorkflowSnapshot({ workflowName, runId });\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    await this.stores.operations.createTable({ tableName, schema });\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    await this.stores.operations.alterTable({ tableName, schema, ifNotExists });\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.clearTable({ tableName });\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.dropTable({ tableName });\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    await this.stores.operations.insert({ tableName, record });\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    return this.stores.workflows.updateWorkflowResults({ workflowName, runId, stepId, result, requestContext });\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined> {\n    return this.stores.workflows.updateWorkflowState({ workflowName, runId, opts });\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    await this.stores.operations.batchInsert({ tableName, records });\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    return this.stores.operations.load({ tableName, keys });\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.stores.memory.getThreadById({ threadId });\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    return this.stores.memory.saveThread({ thread });\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    return this.stores.memory.updateThread({ id, title, metadata });\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    return this.stores.memory.deleteThread({ threadId });\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    return this.stores.memory.getResourceById({ resourceId });\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    return this.stores.memory.saveResource({ resource });\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    return this.stores.memory.updateResource({ resourceId, workingMemory, metadata });\n  }\n\n  async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    return this.stores.memory.listMessagesById({ messageIds });\n  }\n\n  async saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    return this.stores.memory.saveMessages(args);\n  }\n\n  async updateMessages(args: { messages: (Partial<MastraDBMessage> & { id: string })[] }): Promise<MastraDBMessage[]> {\n    return this.stores.memory.updateMessages(args);\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    return this.stores.memory.deleteMessages(messageIds);\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.stores.scores.getScoreById({ id });\n  }\n\n  async saveScore(score: ScoreRowData): Promise<{ score: ScoreRowData }> {\n    return this.stores.scores.saveScore(score);\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    source,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.listScoresByScorerId({ scorerId, entityId, entityType, source, pagination });\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.listScoresByRunId({ runId, pagination });\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.listScoresByEntityId({ entityId, entityType, pagination });\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.listScoresBySpan({ traceId, spanId, pagination });\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    return this.stores.workflows.getWorkflowRunById({ runId, workflowName });\n  }\n\n  async createSpan(span: SpanRecord): Promise<void> {\n    return this.stores.observability!.createSpan(span);\n  }\n\n  async updateSpan(params: {\n    spanId: string;\n    traceId: string;\n    updates: Partial<Omit<SpanRecord, 'spanId' | 'traceId'>>;\n  }): Promise<void> {\n    return this.stores.observability!.updateSpan(params);\n  }\n\n  async getTrace(traceId: string): Promise<TraceRecord | null> {\n    return this.stores.observability!.getTrace(traceId);\n  }\n\n  async batchCreateSpans(args: { records: SpanRecord[] }): Promise<void> {\n    return this.stores.observability!.batchCreateSpans(args);\n  }\n\n  async batchUpdateSpans(args: {\n    records: { traceId: string; spanId: string; updates: Partial<Omit<SpanRecord, 'spanId' | 'traceId'>> }[];\n  }): Promise<void> {\n    return this.stores.observability!.batchUpdateSpans(args);\n  }\n\n  async batchDeleteTraces(args: { traceIds: string[] }): Promise<void> {\n    return this.stores.observability!.batchDeleteTraces(args);\n  }\n}\n\nexport const MockStore = InMemoryStore;\n"]}