// src/label.ts
function getLabel(field) {
  return field.fieldConfig?.label || field.description || beautifyLabel(field.key);
}
function beautifyLabel(label) {
  if (!label) {
    return "";
  }
  let output = label.replace(/([A-Z])/g, " $1");
  output = output.charAt(0).toUpperCase() + output.slice(1);
  if (!isNaN(Number(output))) {
    return "";
  }
  if (output === "*") {
    return "";
  }
  return output;
}

// src/logic.ts
function parseSchema(schemaProvider) {
  const schema = schemaProvider.parseSchema();
  return {
    ...schema,
    fields: sortFieldsByOrder(schema.fields)
  };
}
function validateSchema(schemaProvider, values) {
  return schemaProvider.validateSchema(values);
}
function getDefaultValues(schemaProvider) {
  return schemaProvider.getDefaultValues();
}
function removeEmptyValues(values) {
  const result = {};
  for (const key in values) {
    const value = values[key];
    if ([null, void 0, "", [], {}].includes(value)) {
      continue;
    }
    if (Array.isArray(value)) {
      const newArray = value.map((item) => {
        if (typeof item === "object") {
          return removeEmptyValues(item);
        }
        return item;
      });
      result[key] = newArray.filter((item) => item !== null);
    } else if (typeof value === "object") {
      result[key] = removeEmptyValues(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function sortFieldsByOrder(fields) {
  if (!fields) return [];
  const sortedFields = fields.map((field) => {
    if (field.schema) {
      return {
        ...field,
        schema: sortFieldsByOrder(field.schema)
      };
    }
    return field;
  }).sort((a, b) => {
    const fieldA = a.fieldConfig?.order ?? 0;
    const fieldB = b.fieldConfig?.order ?? 0;
    return fieldA - fieldB;
  });
  return sortedFields;
}
export {
  getDefaultValues,
  getLabel,
  parseSchema,
  removeEmptyValues,
  sortFieldsByOrder,
  validateSchema
};
