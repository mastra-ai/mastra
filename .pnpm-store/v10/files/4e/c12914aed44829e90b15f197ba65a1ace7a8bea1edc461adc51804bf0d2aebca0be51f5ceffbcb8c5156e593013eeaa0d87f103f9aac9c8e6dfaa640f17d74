{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":["RequestContext","resumeData"],"mappings":";;;;;AAeA,SAAS,kBAAA,CAAmB,IAAA,EAAe,SAAA,GAAoB,GAAA,EAAa;AAC1E,EAAA,IAAI;AACF,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,SAAA,CAAU,IAAA,EAAM,MAAM,CAAC,CAAA;AAChD,IAAA,IAAI,WAAA,CAAY,UAAU,SAAA,EAAW;AACnC,MAAA,OAAO,WAAA;AAAA,IACT;AACA,IAAA,OAAO,WAAA,CAAY,KAAA,CAAM,CAAA,EAAG,SAAS,CAAA,GAAI,iBAAA;AAAA,EAC3C,CAAA,CAAA,MAAQ;AACN,IAAA,OAAO,4BAAA;AAAA,EACT;AACF;AAUO,SAAS,uBAAA,CACd,MAAA,EACA,WAAA,EACA,MAAA,EACmD;AAEnD,EAAA,IAAI,CAAC,MAAA,IAAU,EAAE,WAAA,IAAe,MAAA,CAAA,EAAS;AACvC,IAAA,OAAO,EAAE,MAAM,WAAA,EAAY;AAAA,EAC7B;AAGA,EAAA,MAAM,UAAA,GAAa,MAAA,CAAO,SAAA,CAAU,WAAW,CAAA;AAE/C,EAAA,IAAI,WAAW,OAAA,EAAS;AACtB,IAAA,OAAO,EAAE,IAAA,EAAM,UAAA,CAAW,IAAA,EAAK;AAAA,EACjC;AAGA,EAAA,MAAM,aAAA,GAAgB,WAAW,KAAA,CAAM,MAAA,CACpC,IAAI,CAAC,CAAA,KAAkB,KAAK,CAAA,CAAE,IAAA,EAAM,KAAK,GAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK,CAAA,CAAE,OAAO,CAAA,CAAE,CAAA,CACvE,KAAK,IAAI,CAAA;AAEZ,EAAA,MAAM,KAAA,GAA4B;AAAA,IAChC,KAAA,EAAO,IAAA;AAAA,IACP,SAAS,CAAA,sCAAA,EAAyC,MAAA,GAAS,CAAA,KAAA,EAAQ,MAAM,KAAK,EAAE,CAAA;AAAA,EAAqD,aAAa;;AAAA,oBAAA,EAA2B,kBAAA,CAAmB,WAAW,CAAC,CAAA,CAAA;AAAA,IAC5M,gBAAA,EAAkB,UAAA,CAAW,KAAA,CAAM,MAAA;AAAO,GAC5C;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,WAAA,EAAa,KAAA,EAAM;AACpC;AAUO,SAAS,iBAAA,CACd,MAAA,EACA,KAAA,EACA,MAAA,EACmD;AAEnD,EAAA,IAAI,CAAC,MAAA,IAAU,EAAE,WAAA,IAAe,MAAA,CAAA,EAAS;AACvC,IAAA,OAAO,EAAE,MAAM,KAAA,EAAM;AAAA,EACvB;AAGA,EAAA,MAAM,UAAA,GAAa,MAAA,CAAO,SAAA,CAAU,KAAK,CAAA;AAEzC,EAAA,IAAI,WAAW,OAAA,EAAS;AACtB,IAAA,OAAO,EAAE,IAAA,EAAM,UAAA,CAAW,IAAA,EAAK;AAAA,EACjC;AAGA,EAAA,MAAM,aAAA,GAAgB,WAAW,KAAA,CAAM,MAAA,CACpC,IAAI,CAAC,CAAA,KAAkB,KAAK,CAAA,CAAE,IAAA,EAAM,KAAK,GAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK,CAAA,CAAE,OAAO,CAAA,CAAE,CAAA,CACvE,KAAK,IAAI,CAAA;AAEZ,EAAA,MAAM,KAAA,GAA4B;AAAA,IAChC,KAAA,EAAO,IAAA;AAAA,IACP,SAAS,CAAA,sBAAA,EAAyB,MAAA,GAAS,CAAA,KAAA,EAAQ,MAAM,KAAK,EAAE,CAAA;AAAA,EAAqD,aAAa;;AAAA,oBAAA,EAA2B,kBAAA,CAAmB,KAAK,CAAC,CAAA,CAAA;AAAA,IACtL,gBAAA,EAAkB,UAAA,CAAW,KAAA,CAAM,MAAA;AAAO,GAC5C;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,KAAA,EAAO,KAAA,EAAM;AAC9B;AAUO,SAAS,kBAAA,CACd,MAAA,EACA,MAAA,EACA,MAAA,EACA,aAAA,EACmD;AAEnD,EAAA,IAAI,CAAC,MAAA,IAAU,EAAE,WAAA,IAAe,WAAW,aAAA,EAAe;AACxD,IAAA,OAAO,EAAE,MAAM,MAAA,EAAO;AAAA,EACxB;AAGA,EAAA,MAAM,UAAA,GAAa,MAAA,CAAO,SAAA,CAAU,MAAM,CAAA;AAE1C,EAAA,IAAI,WAAW,OAAA,EAAS;AACtB,IAAA,OAAO,EAAE,IAAA,EAAM,UAAA,CAAW,IAAA,EAAK;AAAA,EACjC;AAGA,EAAA,MAAM,aAAA,GAAgB,WAAW,KAAA,CAAM,MAAA,CACpC,IAAI,CAAC,CAAA,KAAkB,KAAK,CAAA,CAAE,IAAA,EAAM,KAAK,GAAG,CAAA,IAAK,MAAM,CAAA,EAAA,EAAK,CAAA,CAAE,OAAO,CAAA,CAAE,CAAA,CACvE,KAAK,IAAI,CAAA;AAEZ,EAAA,MAAM,KAAA,GAA4B;AAAA,IAChC,KAAA,EAAO,IAAA;AAAA,IACP,SAAS,CAAA,6BAAA,EAAgC,MAAA,GAAS,CAAA,KAAA,EAAQ,MAAM,KAAK,EAAE,CAAA;AAAA,EAAwC,aAAa;;AAAA,iBAAA,EAAwB,kBAAA,CAAmB,MAAM,CAAC,CAAA,CAAA;AAAA,IAC9K,gBAAA,EAAkB,UAAA,CAAW,KAAA,CAAM,MAAA;AAAO,GAC5C;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,MAAA,EAAQ,KAAA,EAAM;AAC/B;;;ACrFO,IAAM,OAAN,MAWP;AAAA;AAAA,EAEE,EAAA;AAAA;AAAA,EAGA,WAAA;AAAA;AAAA,EAGA,WAAA;AAAA;AAAA,EAGA,YAAA;AAAA;AAAA,EAGA,aAAA;AAAA;AAAA,EAGA,YAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAA;AAAA;AAAA,EAGA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,YAAY,IAAA,EAAuF;AACjG,IAAA,IAAA,CAAK,KAAK,IAAA,CAAK,EAAA;AACf,IAAA,IAAA,CAAK,cAAc,IAAA,CAAK,WAAA;AACxB,IAAA,IAAA,CAAK,cAAc,IAAA,CAAK,WAAA;AACxB,IAAA,IAAA,CAAK,eAAe,IAAA,CAAK,YAAA;AACzB,IAAA,IAAA,CAAK,gBAAgB,IAAA,CAAK,aAAA;AAC1B,IAAA,IAAA,CAAK,eAAe,IAAA,CAAK,YAAA;AACzB,IAAA,IAAA,CAAK,SAAS,IAAA,CAAK,MAAA;AACnB,IAAA,IAAA,CAAK,eAAA,GAAkB,KAAK,eAAA,IAAmB,KAAA;AAK/C,IAAA,IAAI,KAAK,OAAA,EAAS;AAChB,MAAA,MAAM,kBAAkB,IAAA,CAAK,OAAA;AAC7B,MAAA,IAAA,CAAK,OAAA,GAAU,OAAO,SAAA,EAAoB,OAAA,KAAkB;AAE1D,QAAA,MAAM,EAAE,MAAM,KAAA,EAAM,GAAI,kBAAkB,IAAA,CAAK,WAAA,EAAa,SAAA,EAAW,IAAA,CAAK,EAAE,CAAA;AAC9E,QAAA,IAAI,KAAA,EAAO;AACT,UAAA,OAAO,KAAA;AAAA,QACT;AAEA,QAAA,IAAI,WAAA,GAAc,IAAA;AAElB,QAAA,MAAM,cAAc,OAAA,GAChB;AAAA,UACE,GAAG,OAAA;AAAA,UACH,GAAI,QAAQ,OAAA,GACR;AAAA,YACE,OAAA,EAAS,CAAC,IAAA,KAAc;AACtB,cAAA,WAAA,GAAc,IAAA;AACd,cAAA,OAAO,OAAA,CAAQ,UAAU,IAAI,CAAA;AAAA,YAC/B;AAAA,cAEF;AAAC,YAEP,EAAC;AAGL,QAAA,IAAI,gBAAA,GAAmB,WAAA;AACvB,QAAA,IAAI,CAAC,OAAA,EAAS;AAEZ,UAAA,gBAAA,GAAmB;AAAA,YACjB,cAAA,EAAgB,IAAIA,gCAAA,EAAe;AAAA,YACnC,MAAA,EAAQ;AAAA,WACV;AAAA,QACF,CAAA,MAAO;AAEL,UAAA,MAAM,gBAAA,GAAmB,WAAA,CAAY,UAAA,IAAc,WAAA,CAAY,QAAA;AAI/D,UAAA,MAAM,mBAAA,GAAsB,CAAC,gBAAA,KAAqB,WAAA,CAAY,YAAY,WAAA,CAAY,UAAA,CAAA;AAEtF,UAAA,IAAI,gBAAA,IAAoB,CAAC,WAAA,CAAY,KAAA,EAAO;AAE1C,YAAA,MAAM,EAAE,UAAA,EAAY,QAAA,EAAU,OAAA,EAAS,UAAA,EAAAC,WAAAA,EAAY,QAAA,EAAU,UAAA,EAAY,cAAA,EAAgB,GAAG,IAAA,EAAK,GAC/F,WAAA;AACF,YAAA,gBAAA,GAAmB;AAAA,cACjB,GAAG,IAAA;AAAA,cACH,KAAA,EAAO;AAAA,gBACL,UAAA;AAAA,gBACA,QAAA;AAAA,gBACA,OAAA;AAAA,gBACA,UAAA,EAAAA,WAAAA;AAAA,gBACA,QAAA;AAAA,gBACA,UAAA;AAAA,gBACA;AAAA,eACF;AAAA;AAAA,cAEA,cAAA,EAAgB,IAAA,CAAK,cAAA,IAAkB,IAAID,gCAAA;AAAe,aAC5D;AAAA,UACF,CAAA,MAAA,IAAW,mBAAA,IAAuB,CAAC,WAAA,CAAY,QAAA,EAAU;AAEvD,YAAA,MAAM,EAAE,UAAA,EAAY,KAAA,EAAO,KAAA,EAAO,QAAA,EAAU,SAAS,UAAA,EAAAC,WAAAA,EAAY,GAAG,IAAA,EAAK,GAAI,WAAA;AAC7E,YAAA,gBAAA,GAAmB;AAAA,cACjB,GAAG,IAAA;AAAA,cACH,QAAA,EAAU;AAAA,gBACR,UAAA;AAAA,gBACA,KAAA;AAAA,gBACA,KAAA;AAAA,gBACA,QAAA;AAAA,gBACA,OAAA;AAAA,gBACA,UAAA,EAAAA;AAAA,eACF;AAAA;AAAA,cAEA,cAAA,EAAgB,IAAA,CAAK,cAAA,IAAkB,IAAID,gCAAA;AAAe,aAC5D;AAAA,UACF,CAAA,MAAO;AAEL,YAAA,gBAAA,GAAmB;AAAA,cACjB,GAAG,WAAA;AAAA,cACH,KAAA,EAAO,YAAY,KAAA,GACf;AAAA,gBACE,GAAG,WAAA,CAAY,KAAA;AAAA,gBACf,OAAA,EAAS,CAAC,IAAA,KAAc;AACtB,kBAAA,WAAA,GAAc,IAAA;AACd,kBAAA,OAAO,WAAA,CAAY,KAAA,EAAO,OAAA,GAAU,IAAI,CAAA;AAAA,gBAC1C;AAAA,kBAEF,WAAA,CAAY,KAAA;AAAA,cAChB,QAAA,EAAU,YAAY,QAAA,GAClB;AAAA,gBACE,GAAG,WAAA,CAAY,QAAA;AAAA,gBACf,OAAA,EAAS,CAAC,IAAA,KAAc;AACtB,kBAAA,WAAA,GAAc,IAAA;AACd,kBAAA,OAAO,WAAA,CAAY,QAAA,EAAU,OAAA,GAAU,IAAI,CAAA;AAAA,gBAC7C;AAAA,kBAEF,WAAA,CAAY,QAAA;AAAA,cAChB,cAAA,EAAgB,WAAA,CAAY,cAAA,IAAkB,IAAIA,gCAAA;AAAe,aACnE;AAAA,UACF;AAAA,QACF;AAEA,QAAA,MAAM,aACJ,gBAAA,CAAiB,KAAA,EAAO,cAAc,gBAAA,CAAiB,QAAA,EAAU,cAAc,gBAAA,EAAkB,UAAA;AAEnG,QAAA,IAAI,UAAA,EAAY;AACd,UAAA,MAAM,mBAAmB,iBAAA,CAAkB,IAAA,CAAK,YAAA,EAAc,UAAA,EAAY,KAAK,EAAE,CAAA;AACjF,UAAA,IAAI,iBAAiB,KAAA,EAAO;AAC1B,YAAA,OAAO,gBAAA,CAAiB,KAAA;AAAA,UAC1B;AAAA,QACF;AAGA,QAAA,MAAM,MAAA,GAAS,MAAM,eAAA,CAAgB,IAAA,EAAa,gBAAgB,CAAA;AAElE,QAAA,IAAI,WAAA,EAAa;AACf,UAAA,MAAM,oBAAoB,uBAAA,CAAwB,IAAA,CAAK,aAAA,EAAe,WAAA,EAAa,KAAK,EAAE,CAAA;AAC1F,UAAA,IAAI,kBAAkB,KAAA,EAAO;AAC3B,YAAA,OAAO,iBAAA,CAAkB,KAAA;AAAA,UAC3B;AAAA,QACF;AAEA,QAAA,MAAM,qBAAA,GAAwB,CAAC,EAAE,OAAO,WAAW,WAAA,IAAe,WAAA,CAAA;AAGlE,QAAA,MAAM,mBAAmB,kBAAA,CAAmB,IAAA,CAAK,cAAc,MAAA,EAAQ,IAAA,CAAK,IAAI,qBAAqB,CAAA;AACrG,QAAA,IAAI,iBAAiB,KAAA,EAAO;AAC1B,UAAA,OAAO,gBAAA,CAAiB,KAAA;AAAA,QAC1B;AAEA,QAAA,OAAO,gBAAA,CAAiB,IAAA;AAAA,MAC1B,CAAA;AAAA,IACF;AAAA,EACF;AACF;AA8EO,SAAS,WAmBd,IAAA,EAY4E;AAC5E,EAAA,OAAO,IAAI,KAAK,IAAI,CAAA;AACtB;;;ACpXO,SAAS,aAAa,IAAA,EAA0C;AAErE,EAAA,OAAO,CAAC,EAAE,IAAA,IAAQ,EAAE,IAAA,YAAgB,SAAS,YAAA,IAAgB,IAAA,CAAA;AAC/D","file":"chunk-V537VSV4.cjs","sourcesContent":["import type { z } from 'zod';\nimport type { ZodLikeSchema } from '../types/zod-compat';\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Safely truncates data for error messages to avoid exposing sensitive information.\n * @param data The data to truncate\n * @param maxLength Maximum length of the truncated string (default: 200)\n * @returns Truncated string representation\n */\nfunction truncateForLogging(data: unknown, maxLength: number = 200): string {\n  try {\n    const stringified = JSON.stringify(data, null, 2);\n    if (stringified.length <= maxLength) {\n      return stringified;\n    }\n    return stringified.slice(0, maxLength) + '... (truncated)';\n  } catch {\n    return '[Unable to serialize data]';\n  }\n}\n\n/**\n * Validates raw suspend data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param suspendData The raw suspend data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolSuspendData<T = any>(\n  schema: ZodLikeSchema | undefined,\n  suspendData: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return suspend data as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: suspendData };\n  }\n\n  // Validate the input directly - no unwrapping needed in v1.0\n  const validation = schema.safeParse(suspendData);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues\n    .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n    .join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(suspendData)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: suspendData, error };\n}\n\n/**\n * Validates raw input data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param input The raw input data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolInput<T = any>(\n  schema: ZodLikeSchema | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return input as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Validate the input directly - no unwrapping needed in v1.0\n  const validation = schema.safeParse(input);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues\n    .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n    .join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(input)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: input, error };\n}\n\n/**\n * Validates tool output data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param output The output data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolOutput<T = any>(\n  schema: ZodLikeSchema | undefined,\n  output: unknown,\n  toolId?: string,\n  suspendCalled?: boolean,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return output as-is\n  if (!schema || !('safeParse' in schema) || suspendCalled) {\n    return { data: output };\n  }\n\n  // Validate the output\n  const validation = schema.safeParse(output);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues\n    .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n    .join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool output validation failed${toolId ? ` for ${toolId}` : ''}. The tool returned invalid output:\\n${errorMessages}\\n\\nReturned output: ${truncateForLogging(output)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: output, error };\n}\n","import type { Mastra } from '../mastra';\nimport { RequestContext } from '../request-context';\nimport type { ZodLikeSchema, InferZodLikeSchema } from '../types/zod-compat';\nimport type { ToolAction, ToolExecutionContext } from './types';\nimport { validateToolInput, validateToolOutput, validateToolSuspendData } from './validation';\n\n/**\n * A type-safe tool that agents and workflows can call to perform specific actions.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n *\n * @example Basic tool with validation\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'get-weather',\n *   description: 'Get weather for a location',\n *   inputSchema: z.object({\n *     location: z.string(),\n *     units: z.enum(['celsius', 'fahrenheit']).optional()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchWeather(inputData.location, inputData.units);\n *   }\n * });\n * ```\n *\n * @example Tool requiring approval\n * ```typescript\n * const deleteFileTool = createTool({\n *   id: 'delete-file',\n *   description: 'Delete a file',\n *   requireApproval: true,\n *   inputSchema: z.object({ filepath: z.string() }),\n *   execute: async (inputData) => {\n *     await fs.unlink(inputData.filepath);\n *     return { deleted: true };\n *   }\n * });\n * ```\n *\n * @example Tool with Mastra integration\n * ```typescript\n * const saveTool = createTool({\n *   id: 'save-data',\n *   description: 'Save data to storage',\n *   inputSchema: z.object({ key: z.string(), value: z.any() }),\n *   execute: async (inputData, context) => {\n *     const storage = context?.mastra?.getStorage();\n *     await storage?.set(inputData.key, inputData.value);\n *     return { saved: true };\n *   }\n * });\n * ```\n */\nexport class Tool<\n  TSchemaIn extends ZodLikeSchema | undefined = undefined,\n  TSchemaOut extends ZodLikeSchema | undefined = undefined,\n  TSuspendSchema extends ZodLikeSchema = any,\n  TResumeSchema extends ZodLikeSchema = any,\n  TContext extends ToolExecutionContext<TSuspendSchema, TResumeSchema> = ToolExecutionContext<\n    TSuspendSchema,\n    TResumeSchema\n  >,\n  TId extends string = string,\n> implements ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId>\n{\n  /** Unique identifier for the tool */\n  id: TId;\n\n  /** Description of what the tool does */\n  description: string;\n\n  /** Schema for validating input parameters */\n  inputSchema?: TSchemaIn;\n\n  /** Schema for validating output structure */\n  outputSchema?: TSchemaOut;\n\n  /** Schema for suspend operation data */\n  suspendSchema?: TSuspendSchema;\n\n  /** Schema for resume operation data */\n  resumeSchema?: TResumeSchema;\n\n  /**\n   * Tool execution function\n   * @param inputData - The raw, validated input data\n   * @param context - Optional execution context with metadata\n   * @returns Promise resolving to tool output or a ValidationError if input validation fails\n   */\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>['execute'];\n\n  /** Parent Mastra instance for accessing shared resources */\n  mastra?: Mastra;\n\n  /**\n   * Whether the tool requires explicit user approval before execution\n   * @example\n   * ```typescript\n   * // For destructive operations\n   * requireApproval: true\n   * ```\n   */\n  requireApproval?: boolean;\n\n  /**\n   * Creates a new Tool instance with input validation wrapper.\n   *\n   * @param opts - Tool configuration and execute function\n   * @example\n   * ```typescript\n   * const tool = new Tool({\n   *   id: 'my-tool',\n   *   description: 'Does something useful',\n   *   inputSchema: z.object({ name: z.string() }),\n   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })\n   * });\n   * ```\n   */\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.suspendSchema = opts.suspendSchema;\n    this.resumeSchema = opts.resumeSchema;\n    this.mastra = opts.mastra;\n    this.requireApproval = opts.requireApproval || false;\n\n    // Tools receive two parameters:\n    // 1. input - The raw, validated input data\n    // 2. context - Execution metadata (mastra, suspend, etc.)\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (inputData: unknown, context?: any) => {\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        let suspendData = null;\n\n        const baseContext = context\n          ? {\n              ...context,\n              ...(context.suspend\n                ? {\n                    suspend: (args: any) => {\n                      suspendData = args;\n                      return context.suspend?.(args);\n                    },\n                  }\n                : {}),\n            }\n          : {};\n\n        // Organize context based on execution source\n        let organizedContext = baseContext;\n        if (!context) {\n          // No context provided - create a minimal context with requestContext\n          organizedContext = {\n            requestContext: new RequestContext(),\n            mastra: undefined,\n          };\n        } else {\n          // Check if this is agent execution (has toolCallId and messages)\n          const isAgentExecution = baseContext.toolCallId && baseContext.messages;\n\n          // Check if this is workflow execution (has workflow properties)\n          // Agent execution takes precedence - don't treat as workflow if it's an agent call\n          const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);\n\n          if (isAgentExecution && !baseContext.agent) {\n            // Reorganize agent context - nest agent-specific properties under 'agent' key\n            const { toolCallId, messages, suspend, resumeData, threadId, resourceId, writableStream, ...rest } =\n              baseContext;\n            organizedContext = {\n              ...rest,\n              agent: {\n                toolCallId,\n                messages,\n                suspend,\n                resumeData,\n                threadId,\n                resourceId,\n                writableStream,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else if (isWorkflowExecution && !baseContext.workflow) {\n            // Reorganize workflow context - nest workflow-specific properties under 'workflow' key\n            const { workflowId, runId, state, setState, suspend, resumeData, ...rest } = baseContext;\n            organizedContext = {\n              ...rest,\n              workflow: {\n                workflowId,\n                runId,\n                state,\n                setState,\n                suspend,\n                resumeData,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else {\n            // Ensure requestContext is always present even for direct execution\n            organizedContext = {\n              ...baseContext,\n              agent: baseContext.agent\n                ? {\n                    ...baseContext.agent,\n                    suspend: (args: any) => {\n                      suspendData = args;\n                      return baseContext.agent?.suspend?.(args);\n                    },\n                  }\n                : baseContext.agent,\n              workflow: baseContext.workflow\n                ? {\n                    ...baseContext.workflow,\n                    suspend: (args: any) => {\n                      suspendData = args;\n                      return baseContext.workflow?.suspend?.(args);\n                    },\n                  }\n                : baseContext.workflow,\n              requestContext: baseContext.requestContext || new RequestContext(),\n            };\n          }\n        }\n\n        const resumeData =\n          organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;\n\n        if (resumeData) {\n          const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);\n          if (resumeValidation.error) {\n            return resumeValidation.error as any;\n          }\n        }\n\n        // Call the original execute with validated input and organized context\n        const output = await originalExecute(data as any, organizedContext);\n\n        if (suspendData) {\n          const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);\n          if (suspendValidation.error) {\n            return suspendValidation.error as any;\n          }\n        }\n\n        const skiptOutputValidation = !!(typeof output === 'undefined' && suspendData);\n\n        // Validate output if schema exists\n        const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);\n        if (outputValidation.error) {\n          return outputValidation.error as any;\n        }\n\n        return outputValidation.data;\n      };\n    }\n  }\n}\n\n/**\n * Creates a type-safe tool with automatic input validation.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n * @template TExecute - Execute function type\n *\n * @param opts - Tool configuration including schemas and execute function\n * @returns Type-safe Tool instance with conditional typing based on schemas\n *\n * @example Simple tool\n * ```typescript\n * const greetTool = createTool({\n *   id: 'greet',\n *   description: 'Say hello',\n *   execute: async () => ({ message: 'Hello!' })\n * });\n * ```\n *\n * @example Tool with input validation\n * ```typescript\n * const calculateTool = createTool({\n *   id: 'calculate',\n *   description: 'Perform calculations',\n *   inputSchema: z.object({\n *     operation: z.enum(['add', 'subtract']),\n *     a: z.number(),\n *     b: z.number()\n *   }),\n *   execute: async (inputData) => {\n *     const result = inputData.operation === 'add'\n *       ? inputData.a + inputData.b\n *       : inputData.a - inputData.b;\n *     return { result };\n *   }\n * });\n * ```\n *\n * @example Tool with output schema\n * ```typescript\n * const userTool = createTool({\n *   id: 'get-user',\n *   description: 'Get user data',\n *   inputSchema: z.object({ userId: z.string() }),\n *   outputSchema: z.object({\n *     id: z.string(),\n *     name: z.string(),\n *     email: z.string()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchUser(inputData.userId);\n *   }\n * });\n * ```\n *\n * @example Tool with external API\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'weather',\n *   description: 'Get weather data',\n *   inputSchema: z.object({\n *     city: z.string(),\n *     units: z.enum(['metric', 'imperial']).default('metric')\n *   }),\n *   execute: async (inputData) => {\n *     const response = await fetch(\n *       `https://api.weather.com/v1/weather?q=${inputData.city}&units=${inputData.units}`\n *     );\n *     return response.json();\n *   }\n * });\n * ```\n */\nexport function createTool<\n  TId extends string = string,\n  TSchemaIn extends ZodLikeSchema | undefined = undefined,\n  TSchemaOut extends ZodLikeSchema | undefined = undefined,\n  TSuspendSchema extends ZodLikeSchema = any,\n  TResumeSchema extends ZodLikeSchema = any,\n  TContext extends ToolExecutionContext<TSuspendSchema, TResumeSchema> = ToolExecutionContext<\n    TSuspendSchema,\n    TResumeSchema\n  >,\n  TExecute extends ToolAction<\n    TSchemaIn,\n    TSchemaOut,\n    TSuspendSchema,\n    TResumeSchema,\n    TContext,\n    TId\n  >['execute'] = ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId>['execute'],\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId> & {\n    execute?: TExecute;\n  },\n): [TSchemaIn, TSchemaOut, TExecute] extends [ZodLikeSchema, ZodLikeSchema, Function]\n  ? Tool<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId> & {\n      inputSchema: TSchemaIn;\n      outputSchema: TSchemaOut;\n      execute: (\n        inputData: TSchemaIn extends ZodLikeSchema ? InferZodLikeSchema<TSchemaIn> : unknown,\n        context?: TContext,\n      ) => Promise<TSchemaOut extends ZodLikeSchema ? InferZodLikeSchema<TSchemaOut> : unknown>;\n    }\n  : Tool<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId> {\n  return new Tool(opts) as any;\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !!(tool && !(tool instanceof Tool) && 'parameters' in tool);\n}\n"]}