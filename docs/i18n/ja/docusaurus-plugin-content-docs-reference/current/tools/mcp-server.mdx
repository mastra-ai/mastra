---
title: "リファレンス: MCPServer | Tools & MCP | Mastra ドキュメント"
description: MCPServer の API リファレンス — Mastra のツールや機能を Model Context Protocol サーバーとして公開するクラス。
---

# MCPServer

`MCPServer` クラスは、既存の Mastra のツールやエージェントを Model Context Protocol（MCP）サーバーとして公開する機能を提供します。これにより、任意の MCP クライアント（Cursor、Windsurf、Claude Desktop など）がこれらの機能に接続し、エージェントで利用できるようになります。

ツールやエージェントを Mastra アプリケーション内で直接使うだけでよい場合は、必ずしも MCP サーバーを作成する必要はありません。この API は、Mastra のツールやエージェントを外部の MCP クライアントに公開するためのものです。

[stdio（サブプロセス）および SSE（HTTP）の MCP トランスポート](https://modelcontextprotocol.io/docs/concepts/transports) の両方をサポートしています。

## コンストラクタ

新しい `MCPServer` を作成するには、サーバーの基本情報、提供するツール、そして必要に応じてツールとして公開するエージェントを指定します。

```typescript
import { openai } from "@ai-sdk/openai";
import { Agent } from "@mastra/core/agent";
import { createTool } from "@mastra/core/tools";
import { MCPServer } from "@mastra/mcp";
import { z } from "zod";
import { dataProcessingWorkflow } from "../workflows/dataProcessingWorkflow";

const myAgent = new Agent({
  name: "MyExampleAgent",
  description: "基本的な質問に対応できる汎用アシスタントです。"
  instructions: "あなたは役に立つアシスタントです。",
  model: openai("gpt-4o-mini"),
});

const weatherTool = createTool({
  id: "getWeather",
  description: "指定した場所の現在の天気を取得します。",
  inputSchema: z.object({ location: z.string() }),
  execute: async ({ context }) => `${context.location}の天気は晴れです。`,
});

const server = new MCPServer({
  name: "カスタムサーバー",
  version: "1.0.0",
  tools: { weatherTool },
  agents: { myAgent }, // this agent will become tool "ask_myAgent"
  workflows: {
    dataProcessingWorkflow, // this workflow will become tool "run_dataProcessingWorkflow"
  }
});
```


### 構成プロパティ

コンストラクタは、以下のプロパティを持つ `MCPServerConfig` オブジェクトを受け取ります:

<PropertiesTable
  content={[
    {
      name: "name",
      type: "string",
      isOptional: false,
      description:
        "サーバーのわかりやすい名前（例: 'My Weather and Agent Server'）。",
    },
    {
      name: "version",
      type: "string",
      isOptional: false,
      description: "サーバーのセマンティックバージョン（例: '1.0.0'）。",
    },
    {
      name: "tools",
      type: "ToolsInput",
      isOptional: false,
      description:
        "キーがツール名、値が Mastra のツール定義（`createTool` または Vercel AI SDK で作成）のオブジェクト。これらのツールはそのまま公開されます。",
    },
    {
      name: "agents",
      type: "Record<string, Agent>",
      isOptional: true,
      description:
        "キーがエージェント識別子、値が Mastra Agent インスタンスのオブジェクト。各エージェントは自動的に `ask_<agentIdentifier>` という名前のツールに変換されます。エージェントはコンストラクタの設定で空でない `description` 文字列プロパティを定義している必要があります。この説明はツールの説明として使用されます。エージェントの説明が欠落している、または空の場合、MCPServer の初期化時にエラーがスローされます。",
    },
    {
      name: "workflows",
      type: "Record<string, Workflow>",
      isOptional: true,
      description:
        "キーがワークフロー識別子、値が Mastra Workflow インスタンスのオブジェクト。各ワークフローは `run_<workflowKey>` という名前のツールに変換されます。ワークフローの `inputSchema` はツールの入力スキーマになります。ワークフローは空でない `description` 文字列プロパティを持っている必要があり、これはツールの説明に使用されます。ワークフローの説明が欠落している、または空の場合、エラーがスローされます。ツールは `workflow.createRunAsync()` を呼び出し、その後 `run.start({ inputData: <tool_input> })` を実行してワークフローを起動します。エージェントやワークフローから派生したツール名（例: `ask_myAgent` や `run_myWorkflow`）が、明示的に定義されたツール名や他の派生名と衝突した場合は、明示的に定義されたツールが優先され、警告がログに記録されます。以降の衝突を引き起こすエージェント／ワークフローはスキップされます。",
    },
    {
      name: "id",
      type: "string",
      isOptional: true,
      description:
        "サーバーの任意の一意な識別子。指定しない場合は UUID が生成されます。この ID は確定値とみなされ、指定された場合は Mastra によって変更されません。",
    },
    {
      name: "description",
      type: "string",
      isOptional: true,
      description: "MCP サーバーの役割・機能に関する任意の説明。",
    },
    {
      name: "repository",
      type: "Repository", // { url: string; source: string; id: string; }
      isOptional: true,
      description:
        "サーバーのソースコードに関する任意のリポジトリ情報。",
    },
    {
      name: "releaseDate",
      type: "string", // ISO 8601
      isOptional: true,
      description:
        "このサーバーバージョンの任意のリリース日（ISO 8601 文字列）。指定しない場合はインスタンス化時刻が既定になります。",
    },
    {
      name: "isLatest",
      type: "boolean",
      isOptional: true,
      description:
        "これが最新バージョンであるかを示す任意のフラグ。指定しない場合は true が既定です。",
    },
    {
      name: "packageCanonical",
      type: "'npm' | 'docker' | 'pypi' | 'crates' | string",
      isOptional: true,
      description:
        "サーバーをパッケージとして配布する場合の正準パッケージ形式（例: 'npm', 'docker'）。",
    },
    {
      name: "packages",
      type: "PackageInfo[]",
      isOptional: true,
      description: "このサーバーのインストール可能なパッケージ一覧（任意）。",
    },
    {
      name: "remotes",
      type: "RemoteInfo[]",
      isOptional: true,
      description: "このサーバーのリモートアクセスポイント一覧（任意）。",
    },
    {
      name: "resources",
      type: "MCPServerResources",
      isOptional: true,
      description:
        "サーバーが MCP リソースをどのように扱うかを定義するオブジェクト。詳細は「Resource Handling」のセクションを参照してください。",
    },
    {
      name: "prompts",
      type: "MCPServerPrompts",
      isOptional: true,
      description:
        "サーバーが MCP プロンプトをどのように扱うかを定義するオブジェクト。詳細は「Prompt Handling」のセクションを参照してください。",
    },
  ]}
/>

## エージェントをツールとして公開する

`MCPServer` の強力な機能のひとつは、Mastra エージェントを自動的に呼び出し可能なツールとして公開できることです。設定の `agents` プロパティにエージェントを指定すると次のようになります。

- **ツールの命名**: 各エージェントは `ask_<agentKey>` という名前のツールに変換されます。ここで `<agentKey>` は `agents` オブジェクトでそのエージェントに付けたキーです。たとえば、`agents: { myAgentKey: myAgentInstance }` と設定すると、`ask_myAgentKey` という名前のツールが作成されます。

- **ツールの機能**:
  - **説明**: 生成されるツールの説明は次の形式になります: "エージェント `<AgentName>` に質問します。元のエージェントの指示: `<agent description>`"。
  - **入力**: ツールは `message` プロパティ（文字列）を持つ単一のオブジェクト引数を受け取ります: `{ message: "エージェントへの質問" }`。
  - **実行**: このツールが呼び出されると、対応するエージェントの `generate()` メソッドが、与えられた `query` を渡して実行されます。
  - **出力**: エージェントの `generate()` メソッドの戻り値が、そのままツールの出力として返されます。

- **名前の衝突**: `tools` 設定で明示的に定義したツールが、エージェント由来のツールと同名の場合（例: `ask_myAgentKey` というツールがあり、同時にキー `myAgentKey` のエージェントがある）、_明示的に定義されたツールが優先されます_。この衝突がある場合、そのエージェントはツールに変換されず、警告がログに記録されます。

これにより、MCP クライアントは他のツールと同様に、自然言語のクエリでエージェントとやり取りできるようになります。

### エージェントからツールへの変換

`agents` 構成プロパティでエージェントを指定すると、`MCPServer` は各エージェントに対応するツールを自動的に作成します。ツール名は `ask_<agentIdentifier>` で、`<agentIdentifier>` は `agents` オブジェクトで使用したキーです。

生成されたツールの説明は次のとおりです: "エージェント `<agent.name>` に質問します。エージェントの説明: `<agent.description>`"

**重要**: エージェントをツールに変換するには、インスタンス化時の構成で空でない `description` 文字列プロパティが**必ず**設定されている必要があります（例: `new Agent({ name: 'myAgent', description: 'This agent does X.', ... })`）。`description` が欠落している、または空のエージェントが `MCPServer` に渡された場合、`MCPServer` のインスタンス化時にエラーがスローされ、サーバーのセットアップは失敗します。

これにより、MCP を通じてエージェントの生成機能を素早く公開でき、クライアントはエージェントへ直接「質問」できるようになります。

## メソッド

`MCPServer` インスタンスに対して呼び出し、動作を制御したり情報を取得したりできる関数です。

### startStdio()

標準入力・標準出力（stdio）で通信するサーバーを起動するには、このメソッドを使用します。コマンドラインのプログラムとしてサーバーを実行する場合によく使われます。

```typescript
async startStdio(): Promise<void>
```

stdio を使ってサーバーを起動する方法は次のとおりです：

```typescript
const server = new MCPServer({
  // 上記は設定例です
});
await server.startStdio();
```


### startSSE()

このメソッドは、既存のウェブサーバーと MCP サーバーを統合し、通信に Server-Sent Events（SSE）を使用できるようにするためのものです。SSE 用またはメッセージ用のパスへのリクエストを受け取った際に、ウェブサーバー側のコードから呼び出してください。

```typescript
async startSSE({
  url,
  ssePath,
  messagePath,
  req,
  res,
}: {
  url: URL;
  ssePath: string;
  messagePath: string;
  req: any;
  res: any;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startSSE` を使用する方法の一例です。この例では、MCP クライアントは `http://localhost:1234/sse` にあるあなたの MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startSSE({
    url: new URL(req.url || "", `http://localhost:1234`),
    ssePath: "/sse",
    messagePath: "/message",
    req,
    res,
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTP サーバーがポート ${PORT} で待ち受け中`);
});
```

`startSSE` メソッドに必要な値の詳細は次のとおりです:

<PropertiesTable
  content={[
{
  name: "url",
  type: "URL",
  description: "ユーザーが要求しているウェブアドレス。",
},
{
  name: "ssePath",
  type: "string",
  description:
    "クライアントが SSE に接続するための URL の特定のパス（例: '/sse'）。",
},
{
  name: "messagePath",
  type: "string",
  description:
    "クライアントがメッセージを送信するための URL の特定のパス（例: '/message'）。",
},
{
  name: "req",
  type: "any",
  description: "ウェブサーバーから受け取るリクエストオブジェクト。",
},
{
  name: "res",
  type: "any",
  description:
    "データを返送するために使用する、ウェブサーバーのレスポンスオブジェクト。",
},
]}
/>


### startHonoSSE()

このメソッドは、既存のWebサーバーにMCPサーバーを統合し、通信にServer-Sent Events（SSE）を使えるようにします。SSE用またはメッセージ用のパスへのリクエストを受け取ったときに、Webサーバー側のコードから呼び出します。

```typescript
async startHonoSSE({
  url,
  ssePath,
  messagePath,
  req,
  res,
}: {
  url: URL;
  ssePath: string;
  messagePath: string;
  req: any;
  res: any;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startHonoSSE` を使用する方法を示しています。この例では、MCP クライアントが `http://localhost:1234/hono-sse` にあるあなたの MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startHonoSSE({
    url: new URL(req.url || "", `http://localhost:1234`),
    ssePath: "/hono-sse",
    messagePath: "/message",
    req,
    res,
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTP サーバーがポート ${PORT} で待機中`);
});
```

`startHonoSSE` メソッドに必要な値の詳細は次のとおりです。

<PropertiesTable
  content={[
{
  name: "url",
  type: "URL",
  description: "ユーザーがリクエストしているウェブアドレス。",
},
{
  name: "ssePath",
  type: "string",
  description:
    "クライアントがSSEに接続するURLの特定のパス（例: '/hono-sse'）。",
},
{
  name: "messagePath",
  type: "string",
  description:
    "クライアントがメッセージを送信するURLの特定のパス（例: '/message'）。",
},
{
  name: "req",
  type: "any",
  description: "Webサーバーに届いたリクエストオブジェクト。",
},
{
  name: "res",
  type: "any",
  description:
    "データを返すために使用されるWebサーバーのレスポンスオブジェクト。",
},
]}
/>


### startHTTP()

このメソッドは、通信にストリーミング対応の HTTP を使うために、既存のWebサーバーとMCPサーバーを統合する際に役立ちます。WebサーバーがHTTPリクエストを受け取ったときに、その処理コードから呼び出します。

```typescript
async startHTTP({
  url,
  httpPath,
  req,
  res,
  options = { sessionIdGenerator: () => randomUUID() },
}: {
  url: URL;
  httpPath: string;
  req: http.IncomingMessage;
  res: http.ServerResponse<http.IncomingMessage>;
  options?: StreamableHTTPServerTransportOptions;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startHTTP` を使用する方法を示しています。この例では、MCP クライアントは `http://localhost:1234/http` にあるあなたの MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startHTTP({
    url: new URL(req.url || "", "http://localhost:1234"),
    httpPath: `/mcp`,
    req,
    res,
    options: {
      sessionIdGenerator: undefined,
    },
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTPサーバーがポート${PORT}で待機しています`);
});
```

`startHTTP` メソッドに必要な値の詳細は次のとおりです。

<PropertiesTable
  content={[
{
  name: "url",
  type: "URL",
  description: "ユーザーがリクエストしている Web アドレス。",
},
{
  name: "httpPath",
  type: "string",
  description:
    "MCP サーバーが HTTP リクエストを処理する URL のパス部分（例: '/mcp'）。",
},
{
  name: "req",
  type: "http.IncomingMessage",
  description: "Web サーバーから受信したリクエストオブジェクト。",
},
{
  name: "res",
  type: "http.ServerResponse",
  description:
    "レスポンスの送信に使用する Web サーバーのレスポンスオブジェクト。",
},
{
  name: "options",
  type: "StreamableHTTPServerTransportOptions",
  description:
    "HTTP トランスポートのオプション設定。詳しくは以下のオプション表を参照してください。",
  optional: true,
},
]}
/>

`StreamableHTTPServerTransportOptions` オブジェクトを使用すると、HTTP トランスポートの動作をカスタマイズできます。利用可能なオプションは次のとおりです。

<PropertiesTable
  content={[
{
  name: "sessionIdGenerator",
  type: "(() => string) | undefined",
  description:
    "一意のセッション ID を生成する関数。暗号学的に安全で、全球的に一意な文字列である必要があります。セッション管理を無効化する場合は `undefined` を返します。",
},
{
  name: "onsessioninitialized",
  type: "(sessionId: string) => void",
  description:
    "新しいセッションが初期化された際に呼び出されるコールバック。アクティブな MCP セッションの追跡に有用です。",
  optional: true,
},
{
  name: "enableJsonResponse",
  type: "boolean",
  description:
    "`true` の場合、サーバーはストリーミングに Server-Sent Events (SSE) を使用せず、プレーンな JSON レスポンスを返します。デフォルトは `false` です。",
  optional: true,
},
{
  name: "eventStore",
  type: "EventStore",
  description:
    "メッセージの再開を可能にするイベントストア。これを提供すると、クライアントは再接続してメッセージストリームを再開できます。",
  optional: true,
},
]}
/>


### close()

このメソッドはサーバーを停止し、すべてのリソースを解放します。

```typescript
async close(): Promise<void>
```


### getServerInfo()

このメソッドでサーバーの基本情報を確認できます。

```typescript
getServerInfo(): ServerInfo
```


### getServerDetail()

このメソッドは、サーバー情報の詳細を取得できます。

```typescript
getServerDetail(): ServerDetail
```


### getToolListInfo()

このメソッドでは、サーバー作成時に設定されたツールの一覧を参照できます。読み取り専用のリストで、デバッグに有用です。

```typescript
getToolListInfo(): ToolListInfo
```


### getToolInfo()

このメソッドは、特定のツールの詳細情報を返します。

```typescript
getToolInfo(toolName: string): ToolInfo
```


### executeTool()

このメソッドは指定したツールを実行し、その結果を返します。

```typescript
executeTool(toolName: string, input: any): Promise<any>
```


### getStdioTransport()

`startStdio()` でサーバーを起動した場合、stdio 通信を管理するオブジェクトを取得できます。これは主に内部的な確認やテストのために使用します。

```typescript
getStdioTransport(): StdioServerTransport | undefined
```


### getSseTransport()

サーバーを `startSSE()` で起動している場合、SSE 通信を管理するオブジェクトを取得できます。`getStdioTransport` と同様に、主に内部確認やテスト用途向けです。

```typescript
getSseTransport(): SSEサーバートランスポート | undefined
```


### getSseHonoTransport()

サーバーを `startHonoSSE()` で起動した場合、SSE 通信を管理するオブジェクトを取得するために使用できます。`getSseTransport` と同様に、主に内部的な確認やテストのために使います。

```typescript
getSseHonoTransport(): SSETransport | undefined
```


### getStreamableHTTPTransport()

`startHTTP()` でサーバーを起動した場合、HTTP 通信を管理するオブジェクトを取得するためにこれを使用できます。`getSseTransport` と同様、主に内部チェックやテストのために使用します。

```typescript
getStreamableHTTPTransport(): StreamableHTTPServerTransport | undefined
```


### tools()

この MCP サーバーが提供する特定のツールを実行します。

```typescript
async executeTool(
  toolId: string,
  args: any,
  executionContext?: { messages?: any[]; toolCallId?: string },
): Promise<any>
```

<PropertiesTable
  content={[
{
  name: "toolId",
  type: "string",
  description: "実行するツールのIDまたは名前。",
},
{
  name: "args",
  type: "any",
  description: "ツールのexecute関数に渡す引数。",
},
{
  name: "executionContext",
  type: "object",
  isOptional: true,
  description:
    "メッセージやtoolCallIdなど、ツール実行時の任意のコンテキスト。",
},
]}
/>


## リソースの扱い

### MCP リソースとは？

リソースは Model Context Protocol（MCP）における基本的な概念で、サーバーがクライアントに対して読み取り可能なデータやコンテンツを公開し、LLM とのやり取りにおけるコンテキストとして利用できるようにするものです。これは、MCP サーバーが提供したいあらゆる種類のデータを表し、例えば次のようなものがあります:

- ファイルの内容
- データベースのレコード
- API レスポンス
- ライブなシステムデータ
- スクリーンショットや画像
- ログファイル

リソースは固有の URI（例: `file:///home/user/documents/report.pdf`, `postgres://database/customers/schema`）で識別され、テキスト（UTF-8 エンコード）またはバイナリデータ（base64 エンコード）を含むことができます。

クライアントは次の方法でリソースを発見できます:

1.  **ダイレクトリソース**: サーバーは `resources/list` エンドポイントを通じて具体的なリソースの一覧を公開します。
2.  **リソーステンプレート**: 動的なリソースに対して、サーバーはクライアントがリソース URI を構築するために使用する URI テンプレート（RFC 6570）を公開できます。

リソースを読み取るには、クライアントはその URI を指定して `resources/read` リクエストを送信します。クライアントがそのリソースを購読している場合、サーバーはリソース一覧の変更（`notifications/resources/list_changed`）や特定リソースの内容更新（`notifications/resources/updated`）を通知することもできます。

より詳しい情報は、[Resources に関する公式 MCP ドキュメント](https://modelcontextprotocol.io/docs/concepts/resources)を参照してください。

### `MCPServerResources` 型

`resources` オプションには `MCPServerResources` 型のオブジェクトを指定します。この型は、サーバーがリソース要求を処理するために使用するコールバック群を定義します。

```typescript
export type MCPServerResources = {
  // 利用可能なリソースを一覧するコールバック
  listResources: () => Promise<Resource[]>;

  // 特定のリソースのコンテンツを取得するコールバック
  getResourceContent: ({
    uri,
  }: {
    uri: string;
  }) => Promise<MCPServerResourceContent | MCPServerResourceContent[]>;

  // 利用可能なリソーステンプレートを一覧する任意のコールバック
  resourceTemplates?: () => Promise<ResourceTemplate[]>;
};

export type MCPServerResourceContent = { text?: string } | { blob?: string };
```

例：

```typescript
import { MCPServer } from "@mastra/mcp";
import type {
  MCPServerResourceContent,
  Resource,
  ResourceTemplate,
} from "@mastra/mcp";

// リソース／リソーステンプレートは通常、動的にフェッチされます。
const myResources: Resource[] = [
  { uri: "file://data/123.txt", name: "データファイル", mimeType: "text/plain" },
];

const myResourceContents: Record<string, MCPServerResourceContent> = {
  "file://data.txt/123": { text: "これはデータファイルの内容です。" },
};

const myResourceTemplates: ResourceTemplate[] = [
  {
    uriTemplate: "file://data/{id}",
    name: "データファイル",
    description: "データを含むファイルです。",
    mimeType: "text/plain",
  },
];

const myResourceHandlers: MCPServerResources = {
  listResources: async () => myResources,
  getResourceContent: async ({ uri }) => {
    if (myResourceContents[uri]) {
      return myResourceContents[uri];
    }
    throw new Error(`Resource content not found for ${uri}`);
  },
  resourceTemplates: async () => myResourceTemplates,
};

const serverWithResources = new MCPServer({
  name: "Resourceful Server",
  version: "1.0.0",
  tools: {
    /* ... your tools ... */
  },
  resources: myResourceHandlers,
});
```


### リソース変更のクライアントへの通知

利用可能なリソースやその内容が変更された場合、サーバーは特定のリソースを購読している接続中のクライアントに通知できます。

#### `server.resources.notifyUpdated({ uri: string })`

特定のリソース（`uri` で識別される）の内容が更新されたときにこのメソッドを呼び出します。この URI を購読しているクライアントがいる場合、`notifications/resources/updated` メッセージが送信されます。

```typescript
async server.resources.notifyUpdated({ uri: string }): Promise<void>
```

例：

```typescript
// 'file://data.txt' の内容を更新した後
await serverWithResources.resources.notifyUpdated({ uri: "file://data.txt" });
```


#### `server.resources.notifyListChanged()`

利用可能なリソースの一覧に変更があったとき（例：リソースが追加・削除されたとき）に、このメソッドを呼び出します。これにより、クライアントに `notifications/resources/list_changed` メッセージが送信され、リソース一覧の再取得を促します。

```typescript
async server.resources.notifyListChanged(): Promise<void>
```

例：

```typescript
// 'myResourceHandlers.listResources' で管理されているリストに新しいリソースを追加したあと
await serverWithResources.resources.notifyListChanged();
```


## プロンプトの取り扱い

### MCPプロンプトとは？

プロンプトは、MCPサーバーがクライアントに公開する再利用可能なテンプレートまたはワークフローです。引数を受け取り、リソースのコンテキストを含め、バージョン管理をサポートし、LLMとのやり取りの標準化に利用できます。

プロンプトは固有の名前（および任意のバージョン）で識別され、動的にも静的にもなり得ます。

### `MCPServerPrompts` 型

`prompts` オプションには、`MCPServerPrompts` 型のオブジェクトを指定します。この型は、サーバーがプロンプトリクエストを処理するために使用するコールバックを定義します。

```typescript
export type MCPServerPrompts = {
  // 利用可能なプロンプト一覧を取得するコールバック
  listPrompts: () => Promise<Prompt[]>;

  // 特定のプロンプトのメッセージ/コンテンツを取得するコールバック
  getPromptMessages?: ({
    name,
    version,
    args,
  }: {
    name: string;
    version?: string;
    args?: any;
  }) => Promise<{ prompt: Prompt; messages: PromptMessage[] }>;
};
```

例：

```typescript
import { MCPServer } from "@mastra/mcp";
import type { Prompt, PromptMessage, MCPServerPrompts } from "@mastra/mcp";

const prompts: Prompt[] = [
  {
    name: "analyze-code",
    description: "コードを分析して改善点を見つける",
    version: "v1",
  },
  {
    name: "analyze-code",
    description: "コードを分析して改善点を見つける（新しいロジック）",
    version: "v2",
  },
];

const myPromptHandlers: MCPServerPrompts = {
  listPrompts: async () => prompts,
  getPromptMessages: async ({ name, version, args }) => {
    if (name === "analyze-code") {
      if (version === "v2") {
        const prompt = prompts.find(
          (p) => p.name === name && p.version === "v2",
        );
        if (!prompt) throw new Error("プロンプトのバージョンが見つかりません");
        return {
          prompt,
          messages: [
            {
              role: "user",
              content: {
                type: "text",
                text: `新しいロジックでこのコードを分析してください: ${args.code}`,
              },
            },
          ],
        };
      }
      // Default or v1
      const prompt = prompts.find((p) => p.name === name && p.version === "v1");
      if (!prompt) throw new Error("プロンプトのバージョンが見つかりません");
      return {
        prompt,
        messages: [
          {
            role: "user",
            content: { type: "text", text: `このコードを分析してください: ${args.code}` },
          },
        ],
      };
    }
    throw new Error("プロンプトが見つかりません");
  },
};

const serverWithPrompts = new MCPServer({
  name: "Promptful Server",
  version: "1.0.0",
  tools: {
    /* ... */
  },
  prompts: myPromptHandlers,
});
```


### プロンプト変更のクライアントへの通知

利用可能なプロンプトに変更があった場合、サーバーは接続中のクライアントに通知できます。

#### `server.prompts.notifyListChanged()`

利用可能なプロンプトの一覧に変更があった場合（例：プロンプトが追加・削除された場合）に、このメソッドを呼び出します。これにより、クライアントに `notifications/prompts/list_changed` メッセージが送信され、プロンプト一覧の再取得が促されます。

```typescript
await serverWithPrompts.prompts.notifyListChanged();
```


### プロンプト処理のベストプラクティス

- 明確で具体的なプロンプト名と説明を使用する。
- `getPromptMessages` で必須引数をすべて検証する。
- 破壊的変更の可能性がある場合は `version` フィールドを含める。
- 適切なプロンプトのロジックを選択するために `version` パラメータを使用する。
- プロンプトのリストに変更があった場合はクライアントに通知する。
- 分かりやすいメッセージでエラーを処理する。
- 引数の要件と利用可能なバージョンをドキュメント化する。

---

## 例

MCPServer のセットアップとデプロイの実践的な例については、[Deploying an MCPServer Example](/examples/agents/deploying-mcp-server) を参照してください。

このページ冒頭の例では、ツールとエージェントの両方を用いて `MCPServer` をインスタンス化する方法も示しています。

## エリシテーション

### Elicitation とは？

Elicitation は Model Context Protocol（MCP）の機能で、サーバーがユーザーに対して構造化された情報の提供を求められるようにするものです。これにより、サーバーが動的に追加データを収集できるインタラクティブなワークフローが実現します。

`MCPServer` クラスには、Elicitation 機能が自動的に組み込まれています。ツールは `execute` 関数で、ユーザー入力を要求するための `elicitation.sendRequest()` メソッドを含む `options` パラメータを受け取ります。

### ツール実行シグネチャ

ツールが MCP サーバーのコンテキスト内で実行される場合、追加の `options` パラメータを受け取ります：

```typescript
execute: async ({ context }, options) => {
  // context にはツールの入力パラメータが含まれます
  // options には elicitation や認証情報などのサーバー機能が含まれます

  // 認証情報へのアクセス(利用可能な場合)
  if (options.extra?.authInfo) {
    console.log("認証済みリクエスト送信元:", options.extra.authInfo.clientId);
  }

  // elicitation 機能の使用
  const result = await options.elicitation.sendRequest({
    message: "情報を提供してください",
    requestedSchema: {
      /* schema */
    },
  });

  return result;
};
```


### Elicitation の仕組み

一般的なユースケースはツールの実行中です。ツールがユーザー入力を必要とする場合、ツールの実行オプションで提供される elicitation 機能を使用できます:

1. ツールはメッセージとスキーマを指定して `options.elicitation.sendRequest()` を呼び出します
2. リクエストは接続されている MCP クライアントに送信されます
3. クライアントはユーザーにリクエストを提示します（UI、コマンドラインなど）
4. ユーザーは入力する、拒否する、またはリクエストをキャンセルします
5. クライアントはレスポンスをサーバーに返送します
6. ツールはレスポンスを受け取り、実行を続行します

### ツールにおけるエリシテーションの活用

以下は、エリシテーションを使ってユーザーの連絡先情報を収集するツールの例です。

```typescript
import { MCPServer } from "@mastra/mcp";
import { createTool } from "@mastra/core/tools";
import { z } from "zod";

const server = new MCPServer({
  name: "インタラクティブサーバー",
  version: "1.0.0",
  tools: {
    collectContactInfo: createTool({
      id: "collectContactInfo",
      description: "対話を通じてユーザーの連絡先情報を収集します",
      inputSchema: z.object({
        reason: z
          .string()
          .optional()
          .describe("連絡先情報を収集する理由"),
      }),
      execute: async ({ context }, options) => {
        const { reason } = context;

        // セッション情報が利用可能な場合はログに記録
        console.log("セッションからのリクエスト:", options.extra?.sessionId);

        try {
          // 対話を介してユーザー入力をリクエスト
          const result = await options.elicitation.sendRequest({
            message: reason
              ? `連絡先情報をご入力ください。${reason}`
              : "連絡先情報をご入力ください",
            requestedSchema: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  title: "氏名",
                  description: "お名前",
                },
                email: {
                  type: "string",
                  title: "メールアドレス",
                  description: "メールアドレス",
                  format: "email",
                },
                phone: {
                  type: "string",
                  title: "電話番号",
                  description: "電話番号(任意)",
                },
              },
              required: ["name", "email"],
            },
          });

          // ユーザーの応答を処理
          if (result.action === "accept") {
            return `連絡先情報を収集しました: ${JSON.stringify(result.content, null, 2)}`;
          } else if (result.action === "decline") {
            return "連絡先情報の収集がユーザーによって拒否されました。";
          } else {
            return "連絡先情報の収集がユーザーによってキャンセルされました。";
          }
        } catch (error) {
          return `連絡先情報の収集中にエラーが発生しました: ${error}`;
        }
      },
    }),
  },
});
```


### 要求スキーマの定義

`requestedSchema` は、プリミティブなプロパティのみを持つフラットなオブジェクトである必要があります。サポートされる型は次のとおりです：

* **String**: `{ type: 'string', title: 'Display Name', description: 'Help text' }`
* **Number**: `{ type: 'number', minimum: 0, maximum: 100 }`
* **Boolean**: `{ type: 'boolean', default: false }`
* **Enum**: `{ type: 'string', enum: ['option1', 'option2'] }`

スキーマ例：

```typescript
{
  type: 'object',
  properties: {
    name: {
      type: 'string',
      title: '氏名',
      description: 'フルネーム',
    },
    age: {
      type: 'number',
      title: '年齢',
      minimum: 18,
      maximum: 120,
    },
    newsletter: {
      type: 'boolean',
      title: 'ニュースレターを購読する',
      default: false,
    },
  },
  required: ['name'],
}
```


### 応答アクション

ユーザーは、情報提示（エリシテーション）リクエストに対して次の3通りに応答できます:

1. **Accept** (`action: 'accept'`): ユーザーがデータを提供し、送信を確定
   - 提供されたデータを含む `content` フィールドがある
2. **Decline** (`action: 'decline'`): ユーザーが情報提供を明確に拒否
   - `content` フィールドはない
3. **Cancel** (`action: 'cancel'`): ユーザーが判断せずにリクエストをキャンセル
   - `content` フィールドはない

ツールは、この3種類すべての応答タイプを適切に処理する必要があります。

### セキュリティに関する注意事項

- **パスワード、社会保障番号（SSN）、クレジットカード番号**などの機密情報を決して求めない
- 提供されたスキーマに照らして、すべてのユーザー入力を検証する
- 辞退やキャンセルを丁寧に処理する
- データ収集の目的を明確に説明する
- ユーザーのプライバシーと設定・選好を尊重する

### ツール実行 API

エリシテーション機能は、ツール実行時の `options` パラメータから利用できます。

```typescript
// ツールの execute 関数内
execute: async ({ context }, options) => {
  // ユーザー入力を取得するために elicitation を使用
  const result = await options.elicitation.sendRequest({
    message: string,           // ユーザーに表示するメッセージ
    requestedSchema: object    // 期待されるレスポンス構造を定義する JSON スキーマ
  }): Promise<ElicitResult>

  // 必要に応じて認証情報にアクセス
  if (options.extra?.authInfo) {
    // options.extra.authInfo.token などを使用
  }
}
```

HTTP ベースのトランスポート（SSE または HTTP）を使用する場合、elicitation は**セッション認識**であることに注意してください。つまり、複数のクライアントが同じサーバーに接続しているとき、ツール実行を開始した正しいクライアントセッションに elicitation リクエストがルーティングされます。

`ElicitResult` 型:

```typescript
type ElicitResult = {
  action: "accept" | "decline" | "cancel";
  content?: any; // action が 'accept' の時のみ存在
};
```


## 認証コンテキスト

HTTP ベースのトランスポートを使用する場合、ツールは `options.extra` からリクエストのメタデータにアクセスできます。

```typescript
execute: async ({ context }, options) => {
  if (!options.extra?.authInfo?.token) {
    return "認証が必要です";
  }

  // 認証トークンを使用
  const response = await fetch("/api/data", {
    headers: { Authorization: `Bearer ${options.extra.authInfo.token}` },
    signal: options.extra.signal,
  });

  return response.json();
};
```

`extra` オブジェクトには以下が含まれます:

* `authInfo`: 認証情報（サーバーミドルウェアで提供される場合）
* `sessionId`: セッション ID
* `signal`: キャンセル用の AbortSignal
* `sendNotification`/`sendRequest`: MCP プロトコルの関数

> 注意: 認証を有効にするには、`server.startHTTP()` を呼び出す前に `req.auth` を設定するミドルウェアを HTTP サーバーに組み込む必要があります。例:
>
> ```typescript
> httpServer.createServer((req, res) => {
>   // 認証ミドルウェアを追加
>   req.auth = validateAuthToken(req.headers.authorization);
>
>   // MCP サーバーに渡す
>   await server.startHTTP({ url, httpPath, req, res });
> });
> ```


## 関連情報

- Mastra で MCP サーバーに接続する方法については、[MCPClient のドキュメント](./mcp-client)をご覧ください。
- Model Context Protocol について詳しくは、[@modelcontextprotocol/sdk のドキュメント](https://github.com/modelcontextprotocol/typescript-sdk)をご覧ください。