---
title: "リファレンス: MastraMCPClient（非推奨） | Tools & MCP | Mastra ドキュメント"
description: MastraMCPClient の API リファレンス — Model Context Protocol 用のクライアント実装。
---

<div id="mastramcpclient-deprecated">
  # MastraMCPClient（非推奨）
</div>

`MastraMCPClient` クラスは、Model Context Protocol（MCP）サーバーとやり取りするためのクライアント実装を提供します。MCP プロトコルを介して、接続の管理、リソースの検出、およびツールの実行を行います。

<div id="deprecation-notice">
  ## 廃止予定のお知らせ
</div>

`MastraMCPClient` は、今後は [`MCPClient`](./mcp-client) の利用を推奨する方針に伴い、廃止予定です。単一の MCP サーバーと複数の MCP サーバーを管理するために別々のインターフェースを用意するのではなく、単一の MCP サーバーを使用する場合でも、複数を管理できるインターフェースの利用を推奨します。

<div id="constructor">
  ## コンストラクター
</div>

MastraMCPClient の新しいインスタンスを生成します。

```typescript
constructor({
    name,
    version = '1.0.0',
    server,
    capabilities = {},
    timeout = 60000,
}: {
    name: string;
    server: MastraMCPServerDefinition;
    capabilities?: ClientCapabilities;
    version?: string;
    timeout?: number;
})
```


<div id="parameters">
  ### パラメータ
</div>

<br />

<PropertiesTable
  content={[
    {
      name: "name",
      type: "string",
      description: "このクライアントインスタンスの名称識別子。",
    },
    {
      name: "version",
      type: "string",
      isOptional: true,
      defaultValue: "1.0.0",
      description: "クライアントのバージョン。",
    },
    {
      name: "server",
      type: "MastraMCPServerDefinition",
      description:
        "stdio 接続または SSE 接続のためのサーバー設定パラメータ。ログハンドラーやサーバーログの設定を含めることができます。",
    },
    {
      name: "capabilities",
      type: "ClientCapabilities",
      isOptional: true,
      defaultValue: "{}",
      description: "クライアントのオプション機能設定。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      defaultValue: 60000,
      description:
        "クライアントのツール呼び出しに対するタイムアウト（ミリ秒）。",
    },
  ]}
/>

<div id="mastramcpserverdefinition">
  ### MastraMCPServerDefinition
</div>

この定義を使用して MCP サーバーを構成できます。クライアントは、指定されたパラメータに基づいて自動的にトランスポート種別を判別します：

- `command` が指定されている場合は Stdio トランスポートを使用します。
- `url` が指定されている場合は、まず Streamable HTTP トランスポートを試み、初回の接続に失敗した場合は従来の SSE トランスポートにフォールバックします。

<br />

<PropertiesTable
  content={[
    {
      name: "command",
      type: "string",
      isOptional: true,
      description: "Stdio サーバー向け: 実行するコマンド。",
    },
    {
      name: "args",
      type: "string[]",
      isOptional: true,
      description: "Stdio サーバー向け: コマンドに渡す引数。",
    },
    {
      name: "env",
      type: "Record<string, string>",
      isOptional: true,
      description:
        "Stdio サーバー向け: コマンドに設定する環境変数。",
    },
    {
      name: "url",
      type: "URL",
      isOptional: true,
      description:
        "HTTP サーバー（Streamable HTTP または SSE）向け: サーバーの URL。",
    },
    {
      name: "requestInit",
      type: "RequestInit",
      isOptional: true,
      description: "HTTP サーバー向け: fetch API のリクエスト設定。",
    },
    {
      name: "eventSourceInit",
      type: "EventSourceInit",
      isOptional: true,
      description:
        "SSE フォールバック向け: SSE 接続用のカスタム fetch 設定。SSE でカスタムヘッダーを使用する場合に必須。",
    },
    {
      name: "logger",
      type: "LogHandler",
      isOptional: true,
      description: "追加のログハンドラー（任意）。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      description: "サーバー固有のタイムアウト（ミリ秒）。",
    },
    {
      name: "capabilities",
      type: "ClientCapabilities",
      isOptional: true,
      description: "サーバー固有の機能設定。",
    },
    {
      name: "enableServerLogs",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "このサーバーのログを有効にするかどうか。",
    },
  ]}
/>

<div id="loghandler">
  ### LogHandler
</div>

`LogHandler` 関数は引数に `LogMessage` オブジェクトを取り、戻り値は void です。`LogMessage` オブジェクトには次のプロパティがあります。`LoggingLevel` 型は `debug`、`info`、`warn`、`error` の文字列列挙型です。

<br />

<PropertiesTable
  content={[
    {
      name: "level",
      type: "LoggingLevel",
      description: "ログレベル（debug、info、warn、error）",
    },
    {
      name: "message",
      type: "string",
      description: "ログメッセージの内容",
    },
    {
      name: "timestamp",
      type: "Date",
      description: "ログの生成時刻",
    },
    {
      name: "serverName",
      type: "string",
      description: "ログを生成したサーバー名",
    },
    {
      name: "details",
      type: "Record<string, any>",
      isOptional: true,
      description: "任意の追加情報（オプション）",
    },
  ]}
/>

<div id="methods">
  ## メソッド
</div>

<div id="connect">
  ### connect()
</div>

MCP サーバーに接続します。

```typescript
async connect(): Promise<void>
```


<div id="disconnect">
  ### disconnect()
</div>

MCP サーバーとの接続を切断します。

```typescript
async disconnect(): Promise<void>
```


<div id="resources">
  ### resources()
</div>

サーバーから利用可能なリソースの一覧を取得します。

```typescript
async resources(): Promise<ListResourcesResult>
```


<div id="tools">
  ### tools()
</div>

サーバーから利用可能なツールを取得して初期化し、Mastra 互換のツール形式に変換します。

```typescript
async tools(): Promise<Record<string, Tool>>
```

ツール名を対応する Mastra のツール実装へマッピングするオブジェクトを返します。


<div id="examples">
  ## 例
</div>

<div id="using-with-mastra-agent">
  ### Mastra Agent と併用する
</div>

<div id="example-with-stdio-server">
  #### Stdio サーバーの例
</div>

```typescript
import { Agent } from "@mastra/core/agent";
import { MastraMCPClient } from "@mastra/mcp";
import { openai } from "@ai-sdk/openai";

// 例として mcp/fetch を使って MCP クライアントを初期化します https://hub.docker.com/r/mcp/fetch
// 他の参考用の Docker MCP サーバーは https://github.com/docker/mcp-servers を参照してください
const fetchClient = new MastraMCPClient({
  name: "fetch",
  server: {
    command: "docker",
    args: ["run", "-i", "--rm", "mcp/fetch"],
    logger: (logMessage) => {
      console.log(`[${logMessage.level}] ${logMessage.message}`);
    },
  },
});

// Mastra エージェントを作成
const agent = new Agent({
  name: "Fetch agent",
  name: "Fetch エージェント",
    "必要に応じて URL からデータを取得し、応答データについてユーザーとやり取りできます。",
  model: openai("gpt-4o-mini"),
});

try {
  // MCP サーバーに接続
  await fetchClient.connect();

  // プロセス終了を適切に処理し、Docker のサブプロセスをクリーンアップします
  process.on("exit", () => {
    fetchClient.disconnect();
  });

  // 利用可能なツールを取得
  const tools = await fetchClient.tools();

  // MCP ツールと併用してエージェントを実行
  const response = await agent.generate(
    "mastra.ai/docs について教えてください。このページの概要と掲載内容を教えてください。",
    {
      toolsets: {
        fetch: tools,
      },
    },
  );

  console.log("\n\n" + response.text);
} catch (error) {
  console.error("エラー:", error);
} finally {
  // 作業完了後は必ず切断
  await fetchClient.disconnect();
}
```


<div id="example-with-sse-server">
  ### SSE サーバーの例
</div>

```typescript
// SSE サーバーを使用して MCP クライアントを初期化する
const sseClient = new MastraMCPClient({
  name: "sse-client",
  server: {
    url: new URL("https://your-mcp-server.com/sse"),
    // 任意の fetch リクエスト設定 - 注意: requestInit だけでは SSE に対応できない
    requestInit: {
      headers: {
        Authorization: "Bearer your-token",
      },
    },
    // カスタムヘッダーを伴う SSE 接続では必須
    eventSourceInit: {
      fetch(input: Request | URL | string, init?: RequestInit) {
        const headers = new Headers(init?.headers || {});
        headers.set("Authorization", "Bearer your-token");
        return fetch(input, {
          ...init,
          headers,
        });
      },
    },
    // 任意の追加ロギング設定
    logger: (logMessage) => {
      console.log(
        `[${logMessage.level}] ${logMessage.serverName}: ${logMessage.message}`,
      );
    },
    // サーバー側のログを無効化
    enableServerLogs: false,
  },
});

// 以降の使い方は stdio の例と同じ
```


<div id="important-note-about-sse-authentication">
  ### SSE 認証に関する重要な注意事項
</div>

認証やカスタムヘッダーを伴う SSE 接続を使用する場合は、`requestInit` と `eventSourceInit` の両方を設定する必要があります。これは、SSE 接続がブラウザの EventSource API を利用しており、カスタムヘッダーを直接はサポートしていないためです。

`eventSourceInit` を設定すると、SSE 接続で使用される基盤となる fetch リクエストをカスタマイズでき、認証ヘッダーを確実に含められます。
`eventSourceInit` を設定しない場合、`requestInit` で指定した認証ヘッダーは接続リクエストに含まれず、401 Unauthorized エラーの原因になります。

<div id="related-information">
  ## 関連情報
</div>

- アプリケーションで複数の MCP サーバーを管理する方法については、[MCPClient のドキュメント](./mcp-client)をご参照ください。
- Model Context Protocol の詳細については、[@modelcontextprotocol/sdk のドキュメント](https://github.com/modelcontextprotocol/typescript-sdk)をご覧ください。