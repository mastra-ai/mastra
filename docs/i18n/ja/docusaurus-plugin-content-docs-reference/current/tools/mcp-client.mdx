---
title: "リファレンス: MCPClient | Tools & MCP | Mastraドキュメント"
description: MCPClient のAPIリファレンス—複数のModel Context Protocolサーバーとそのツールを管理するクラス。
---

<div id="mcpclient">
  # MCPClient
</div>

`MCPClient` クラスは、Mastra アプリケーションで複数の MCP サーバー接続とそれらのツールを一元的に管理するためのクラスです。接続のライフサイクル管理やツールの名前空間化を行い、設定済みのすべてのサーバーにまたがるツールへのアクセスを提供します。

このクラスは、非推奨となった [`MastraMCPClient`](/reference/tools/client) の後継です。

<div id="constructor">
  ## コンストラクター
</div>

MCPClient クラスの新しいインスタンスを生成します。

```typescript
constructor({
  id?: string;
  servers: Record<string, MastraMCPServerDefinition>;
  timeout?: number;
}: MCPClientOptions)
```


<div id="mcpclientoptions">
  ### MCPClientOptions
</div>

<br />

<PropertiesTable
  content={[
    {
      name: "id",
      type: "string",
      isOptional: true,
      description:
        "構成インスタンスの任意の一意の識別子。同一構成で複数のインスタンスを作成する際のメモリリークを防ぐために使用します。",
    },
    {
      name: "servers",
      type: "Record<string, MastraMCPServerDefinition>",
      description:
        "サーバー構成のマップ。各キーは一意のサーバー識別子で、値はそのサーバーの構成です。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      defaultValue: "60000",
      description:
        "個別のサーバー構成で上書きされない限り、すべてのサーバーに適用される（ミリ秒単位の）グローバルタイムアウト値。",
    },
  ]}
/>

<div id="mastramcpserverdefinition">
  ### MastraMCPServerDefinition
</div>

`servers` マップ内の各サーバーは `MastraMCPServerDefinition` 型で構成します。トランスポート種別は、指定されたパラメータに基づいて自動判別されます。

- `command` が指定されている場合は Stdio トランスポートを使用します。
- `url` が指定されている場合は、まず Streamable HTTP トランスポートを試し、初回の接続に失敗した場合はレガシーな SSE トランスポートにフォールバックします。

<br />

<PropertiesTable
  content={[
    {
      name: "command",
      type: "string",
      isOptional: true,
      description: "Stdio サーバー向け: 実行するコマンド。",
    },
    {
      name: "args",
      type: "string[]",
      isOptional: true,
      description: "Stdio サーバー向け: コマンドに渡す引数。",
    },
    {
      name: "env",
      type: "Record<string, string>",
      isOptional: true,
      description:
        "Stdio サーバー向け: コマンドに設定する環境変数。",
    },
    {
      name: "url",
      type: "URL",
      isOptional: true,
      description:
        "HTTP サーバー（Streamable HTTP または SSE）向け: サーバーの URL。",
    },
    {
      name: "requestInit",
      type: "RequestInit",
      isOptional: true,
      description: "HTTP サーバー向け: fetch API のリクエスト設定。",
    },
    {
      name: "eventSourceInit",
      type: "EventSourceInit",
      isOptional: true,
      description:
        "SSE フォールバック向け: SSE 接続用のカスタム fetch 設定。SSE でカスタムヘッダーを使用する場合は必須。",
    },
    {
      name: "logger",
      type: "LogHandler",
      isOptional: true,
      description: "追加のロギング用ハンドラー（任意）。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      description: "サーバー固有のタイムアウト（ミリ秒）。",
    },
    {
      name: "capabilities",
      type: "ClientCapabilities",
      isOptional: true,
      description: "サーバー固有の機能設定。",
    },
    {
      name: "enableServerLogs",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "このサーバーのログを有効にするかどうか。",
    },
  ]}
/>

<div id="methods">
  ## 手法
</div>

<div id="gettools">
  ### getTools()
</div>

構成済みのすべてのサーバーからツールを取得します。ツール名は競合を防ぐため、サーバー名で名前空間化されます（形式は `serverName_toolName`）。\
Agent の定義に渡すことを想定しています。

```ts
new Agent({ tools: await mcp.getTools() });
```


<div id="gettoolsets">
  ### getToolsets()
</div>

名前空間付きのツール名（`serverName.toolName` の形式）を、それぞれのツール実装に対応付けたオブジェクトを返します。
generate または stream メソッドに動的に渡すことを想定しています。

```typescript
const res = await agent.stream(prompt, {
  toolsets: await mcp.getToolsets(),
});
```


<div id="disconnect">
  ### disconnect()
</div>

すべての MCP サーバーから切断し、リソースを解放します。

```typescript
async disconnect(): Promise<void>
```


<div id="resources-property">
  ### `resources` プロパティ
</div>

`MCPClient` インスタンスには、リソース関連の操作にアクセスするための `resources` プロパティがあります。

```typescript
const mcpClient = new MCPClient({
  /* …サーバー構成… */
});

// mcpClient.resources 経由でリソース関連のメソッドにアクセスします
const allResourcesByServer = await mcpClient.resources.list();
const templatesByServer = await mcpClient.resources.templates();
// …他のリソース関連のメソッドも同様です
```


<div id="resourceslist">
  #### `resources.list()`
</div>

接続されているすべての MCP サーバーから、利用可能なリソースをサーバー名ごとにグループ化して取得します。

```typescript
async list(): Promise<Record<string, Resource[]>>
```

例：

```typescript
const resourcesByServer = await mcpClient.resources.list();
for (const serverName in resourcesByServer) {
  console.log(`${serverName} からのリソース:`, resourcesByServer[serverName]);
}
```


<div id="resourcestemplates">
  #### `resources.templates()`
</div>

接続中のすべての MCP サーバーから利用可能なリソーステンプレートを取得し、サーバー名ごとにグループ化します。

```typescript
async templates(): Promise<Record<string, ResourceTemplate[]>>
```

例：

```typescript
const templatesByServer = await mcpClient.resources.templates();
for (const serverName in templatesByServer) {
  console.log(`${serverName} のテンプレート:`, templatesByServer[serverName]);
}
```


<div id="resourcesreadservername-string-uri-string">
  #### `resources.read(serverName: string, uri: string)`
</div>

指定したサーバーから、特定のリソースの内容を読み込みます。

```typescript
async read(serverName: string, uri: string): Promise<ReadResourceResult>
```

* `serverName`: サーバーの識別子（`servers` のコンストラクターオプションで使用するキー）。
* `uri`: 読み取り対象のリソースの URI。

例:

```typescript
const content = await mcpClient.resources.read(
  "myWeatherServer",
  "weather://current",
);
console.log("現在の天気：", content.contents[0].text);
```


<div id="resourcessubscribeservername-string-uri-string">
  #### `resources.subscribe(serverName: string, uri: string)`
</div>

指定された名前のサーバー上にある特定のリソースの更新を購読します。

```typescript
async subscribe(serverName: string, uri: string): Promise<object>
```

例：

```typescript
await mcpClient.resources.subscribe("myWeatherServer", "weather://current");
```


<div id="resourcesunsubscribeservername-string-uri-string">
  #### `resources.unsubscribe(serverName: string, uri: string)`
</div>

指定したサーバー上の特定のリソースに対する更新の購読を解除します。

```typescript
async unsubscribe(serverName: string, uri: string): Promise<object>
```

例：

```typescript
await mcpClient.resources.unsubscribe("myWeatherServer", "weather://current");
```


<div id="resourcesonupdatedservername-string-handler-params-uri-string-void">
  #### `resources.onUpdated(serverName: string, handler: (params: { uri: string }) => void)`
</div>

特定のサーバーで購読中のリソースが更新された際に呼び出される通知ハンドラーを設定します。

```typescript
async onUpdated(serverName: string, handler: (params: { uri: string }) => void): Promise<void>
```

例：

```typescript
mcpClient.resources.onUpdated("myWeatherServer", (params) => {
  console.log(`myWeatherServer のリソースが更新されました: ${params.uri}`);
  // ここでリソースの内容を再取得することもできます
  // await mcpClient.resources.read("myWeatherServer", params.uri);
});
```


<div id="resourcesonlistchangedservername-string-handler-void">
  #### `resources.onListChanged(serverName: string, handler: () => void)`
</div>

特定のサーバー上で利用可能なリソースの一覧に変更があった際に呼び出される通知ハンドラを設定します。

```typescript
async onListChanged(serverName: string, handler: () => void): Promise<void>
```

例：

```typescript
mcpClient.resources.onListChanged("myWeatherServer", () => {
  console.log("myWeatherServer のリソース一覧が更新されました。");
  // リソース一覧を再取得してください
  // await mcpClient.resources.list();
});
```


<div id="prompts-property">
  ### `prompts` プロパティ
</div>

`MCPClient` インスタンスには、プロンプト関連の操作にアクセスできる `prompts` プロパティがあります。

```typescript
const mcpClient = new MCPClient({
  /* ...servers configuration... */
});

// mcpClient.prompts からプロンプト関連のメソッドにアクセスする
const allPromptsByServer = await mcpClient.prompts.list();
const { prompt, messages } = await mcpClient.prompts.get({
  serverName: "myWeatherServer",
  name: "current",
});
```


<div id="elicitation-property">
  ### `elicitation` プロパティ
</div>

`MCPClient` インスタンスには、エリシテーション（elicitation）に関連する操作へアクセスできる `elicitation` プロパティがあります。エリシテーションにより、MCP サーバーはユーザーから構造化された情報を要求できます。

```typescript
const mcpClient = new MCPClient({
  /* ...サーバー設定... */
});

// エリシテーションハンドラーを設定
mcpClient.elicitation.onRequest("serverName", async (request) => {
  // サーバーからのエリシテーションリクエストを処理
  console.log("サーバーリクエスト:", request.message);
  console.log("スキーマ:", request.requestedSchema);

  // ユーザーレスポンスを返す
  return {
    action: "accept",
    content: { name: "John Doe", email: "john@example.com" },
  };
});
```


<div id="elicitationonrequestservername-string-handler-elicitationhandler">
  #### `elicitation.onRequest(serverName: string, handler: ElicitationHandler)`
</div>

接続中のいずれかの MCP サーバーがエリシテーションリクエストを送信した際に呼び出されるハンドラー関数を設定します。ハンドラーはリクエストを受け取り、レスポンスを返す必要があります。

**ElicitationHandler 関数:**

ハンドラー関数は次のプロパティを持つリクエストオブジェクトを受け取ります:

* `message`: 必要な情報を説明する人間可読なメッセージ
* `requestedSchema`: 期待されるレスポンスの構造を定義する JSON スキーマ

ハンドラーは次の内容を持つ `ElicitResult` を返す必要があります:

* `action`: `'accept'`、`'decline'`、`'cancel'` のいずれか
* `content`: ユーザーのデータ（`action` が `'accept'` の場合のみ）

**例:**

```typescript
mcpClient.elicitation.onRequest("serverName", async (request) => {
  console.log(`サーバーのリクエスト: ${request.message}`);

  // 例: シンプルなユーザー入力の収集
  if (request.requestedSchema.properties.name) {
    // ユーザーが承諾してデータを提供するシミュレーション
    return {
      action: "accept",
      content: {
        name: "Alice Smith",
        email: "alice@example.com",
      },
    };
  }

  // ユーザーがリクエストを拒否するシミュレーション
  return { action: "decline" };
});
```

**完全なインタラクティブな例:**

```typescript
import { MCPClient } from "@mastra/mcp";
import { createInterface } from "readline";

const readline = createInterface({
  input: process.stdin,
  output: process.stdout,
});

function askQuestion(question: string): Promise<string> {
  return new Promise((resolve) => {
    readline.question(question, (answer) => resolve(answer.trim()));
  });
}

const mcpClient = new MCPClient({
  servers: {
    interactiveServer: {
      url: new URL("http://localhost:3000/mcp"),
    },
  },
});

// インタラクティブな情報要求ハンドラーを設定
await mcpClient.elicitation.onRequest("interactiveServer", async (request) => {
  console.log(`\n📋 サーバーリクエスト: ${request.message}`);
  console.log("必要な情報:");

  const schema = request.requestedSchema;
  const properties = schema.properties || {};
  const required = schema.required || [];
  const content: Record<string, any> = {};

  // 各フィールドの入力を収集
  for (const [fieldName, fieldSchema] of Object.entries(properties)) {
    const field = fieldSchema as any;
    const isRequired = required.includes(fieldName);

    let prompt = `${field.title || fieldName}`;
    if (field.description) prompt += ` (${field.description})`;
    if (isRequired) prompt += " *必須*";
    prompt += ": ";

    const answer = await askQuestion(prompt);

    // キャンセル処理
    if (answer.toLowerCase() === "cancel") {
      return { action: "cancel" };
    }

    // 必須フィールドの検証
    if (answer === "" && isRequired) {
      console.log(`❌ ${fieldName} は必須項目です`);
      return { action: "decline" };
    }

    if (answer !== "") {
      content[fieldName] = answer;
    }
  }

  // 送信の確認
  console.log("\n📝 入力内容:");
  console.log(JSON.stringify(content, null, 2));

  const confirm = await askQuestion(
    "\nこの情報を送信しますか? (yes/no/cancel): ",
  );

  if (confirm.toLowerCase() === "yes" || confirm.toLowerCase() === "y") {
    return { action: "accept", content };
  } else if (confirm.toLowerCase() === "cancel") {
    return { action: "cancel" };
  } else {
    return { action: "decline" };
  }
});
```


<div id="promptslist">
  #### `prompts.list()`
</div>

接続中のすべての MCP サーバーから利用可能なプロンプトを取得し、サーバー名ごとにグループ化します。

```typescript
async list(): Promise<Record<string, Prompt[]>>
```

例：

```typescript
const promptsByServer = await mcpClient.prompts.list();
for (const serverName in promptsByServer) {
  console.log(`${serverName} のプロンプト:`, promptsByServer[serverName]);
}
```


<div id="promptsget-servername-name-args-version">
  #### `prompts.get({ serverName, name, args?, version? })`
</div>

サーバーから特定のプロンプトとそのメッセージを取得します。

```typescript
async get({
  serverName,
  name,
  args?,
  version?,
}: {
  serverName: string;
  name: string;
  args?: Record<string, any>;
  version?: string;
}): Promise<{ prompt: Prompt; messages: PromptMessage[] }>
```

例：

```typescript
const { prompt, messages } = await mcpClient.prompts.get({
  serverName: "myWeatherServer",
  name: "current",
  args: { location: "ロンドン" },
});
console.log(prompt);
console.log(messages);
```


<div id="promptsonlistchangedservername-string-handler-void">
  #### `prompts.onListChanged(serverName: string, handler: () => void)`
</div>

指定したサーバーで利用可能なプロンプトの一覧が変更された際に呼び出される通知ハンドラーを設定します。

```typescript
async onListChanged(serverName: string, handler: () => void): Promise<void>
```

例：

```typescript
mcpClient.prompts.onListChanged("myWeatherServer", () => {
  console.log("myWeatherServer でプロンプト一覧が変更されました。");
  // プロンプト一覧を再取得してください
  // await mcpClient.prompts.list();
});
```


<div id="elicitation">
  ## Elicitation（情報引き出し）
</div>

Elicitation は、MCP サーバーがユーザーに対して構造化された情報の提供を求められる機能です。サーバーが追加のデータを必要とする場合、クライアントがユーザーに質問（プロンプト）して処理する elicitation リクエストを送信できます。代表的な例として、ツールの呼び出し時があります。

<div id="how-elicitation-works">
  ### Elicitation の仕組み
</div>

1. **サーバーリクエスト**: MCP サーバーツールがメッセージとスキーマを指定して `server.elicitation.sendRequest()` を呼び出します
2. **クライアントハンドラー**: あなたの elicitation ハンドラー関数がそのリクエストで呼び出されます
3. **ユーザー操作**: ハンドラーがユーザー入力（UI や CLI など経由）を収集します
4. **レスポンス**: ハンドラーがユーザーの応答（accept/decline/cancel）を返します
5. **ツールの継続**: サーバーツールは応答を受け取り、処理を続行します

<div id="setting-up-elicitation">
  ### エリシテーションの設定
</div>

エリシテーションを利用するツールを呼び出す前に、エリシテーションハンドラーを設定する必要があります。

```typescript
import { MCPClient } from "@mastra/mcp";

const mcpClient = new MCPClient({
  servers: {
    interactiveServer: {
      url: new URL("http://localhost:3000/mcp"),
    },
  },
});

// エリシテーションハンドラーを設定
mcpClient.elicitation.onRequest("interactiveServer", async (request) => {
  // サーバーからのユーザー入力リクエストを処理
  console.log(`サーバーが必要としています: ${request.message}`);

  // ユーザー入力を収集するロジック
  const userData = await collectUserInput(request.requestedSchema);

  return {
    action: "accept",
    content: userData,
  };
});
```


<div id="response-types">
  ### レスポンスの種類
</div>

elicitation ハンドラーは、次の3つのレスポンスのいずれかを返す必要があります:

- **Accept**: ユーザーがデータを提供し、送信を確定した

  ```typescript
  return {
    action: "accept",
    content: { name: "John Doe", email: "john@example.com" },
  };
  ```

- **Decline**: ユーザーが情報の提供を明確に拒否した

  ```typescript
  return { action: "decline" };
  ```

- **Cancel**: ユーザーがリクエストを閉じる、または取り消した
  ```typescript
  return { action: "cancel" };
  ```

<div id="schema-based-input-collection">
  ### スキーマベースの入力収集
</div>

`requestedSchema` は、サーバーが必要とするデータの構造を定義します。

```typescript
await mcpClient.elicitation.onRequest("interactiveServer", async (request) => {
  const { properties, required = [] } = request.requestedSchema;
  const content: Record<string, any> = {};

  for (const [fieldName, fieldSchema] of Object.entries(properties || {})) {
    const field = fieldSchema as any;
    const isRequired = required.includes(fieldName);

    // フィールドの型と要件に基づいて入力を収集
    const value = await promptUser({
      name: fieldName,
      title: field.title,
      description: field.description,
      type: field.type,
      required: isRequired,
      format: field.format,
      enum: field.enum,
    });

    if (value !== null) {
      content[fieldName] = value;
    }
  }

  return { action: "accept", content };
});
```


<div id="best-practices">
  ### ベストプラクティス
</div>

- **常にエリシテーションに対応する**: エリシテーションを利用する可能性のあるツールを呼び出す前にハンドラーを用意する
- **入力を検証する**: 必須項目が入力されているか確認する
- **ユーザーの選択を尊重する**: 辞退やキャンセルの応答を丁寧に扱う
- **わかりやすいUI**: 何の情報を、なぜ求めているのかを明確に示す
- **セキュリティ**: 機密情報の要求を自動承認しない

<div id="examples">
  ## 例
</div>

<div id="static-tool-configuration">
  ### 静的ツール構成
</div>

アプリ全体で MCP サーバーへの接続が 1 つだけのツールの場合は、`getTools()` を使い、取得したツールをエージェントに渡します:

```typescript
import { MCPClient } from "@mastra/mcp";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

const mcp = new MCPClient({
  servers: {
    stockPrice: {
      command: "npx",
      args: ["tsx", "stock-price.ts"],
      env: {
        API_KEY: "your-api-key",
      },
      log: (logMessage) => {
        console.log(`[${logMessage.level}] ${logMessage.message}`);
      },
    },
    weather: {
      url: new URL("http://localhost:8080/sse"),
    },
  },
  timeout: 30000, // グローバル30秒タイムアウト
});

// すべてのツールにアクセス可能なエージェントを作成
const agent = new Agent({
  name: "Multi-tool Agent",
  instructions: "複数のツールサーバーにアクセスできます。",
  model: openai("gpt-4"),
  tools: await mcp.getTools(),
});

// リソースメソッドの使用例
async function checkWeatherResource() {
  try {
    const weatherResources = await mcp.resources.list();
    if (weatherResources.weather && weatherResources.weather.length > 0) {
      const currentWeatherURI = weatherResources.weather[0].uri;
      const weatherData = await mcp.resources.read(
        "weather",
        currentWeatherURI,
      );
      console.log("Weather data:", weatherData.contents[0].text);
    }
  } catch (error) {
    console.error("Error fetching weather resource:", error);
  }
}
checkWeatherResource();

// プロンプトメソッドの使用例
async function checkWeatherPrompt() {
  try {
    const weatherPrompts = await mcp.prompts.list();
    if (weatherPrompts.weather && weatherPrompts.weather.length > 0) {
      const currentWeatherPrompt = weatherPrompts.weather.find(
        (p) => p.name === "current",
      );
      if (currentWeatherPrompt) {
        console.log("Weather prompt:", currentWeatherPrompt);
      } else {
        console.log("Current weather prompt not found");
      }
    }
  } catch (error) {
    console.error("Error fetching weather prompt:", error);
  }
}
checkWeatherPrompt();
```


<div id="dynamic-toolsets">
  ### 動的ツールセット
</div>

ユーザーごとに新しい MCP 接続が必要な場合は、`getToolsets()` を使用し、stream または generate を呼び出すときにツールを追加します。

```typescript
import { Agent } from "@mastra/core/agent";
import { MCPClient } from "@mastra/mcp";
import { openai } from "@ai-sdk/openai";

// まずはツールなしでエージェントを作成します
const agent = new Agent({
  name: "マルチツールエージェント",
  instructions: "ユーザーの株価と天気の確認を手伝います。",
  model: openai("gpt-4"),
});

// 後で、ユーザー固有の設定で MCP を設定します
const mcp = new MCPClient({
  servers: {
    stockPrice: {
      command: "npx",
      args: ["tsx", "stock-price.ts"],
      env: {
        API_KEY: "user-123-api-key",
      },
      timeout: 20000, // サーバーごとのタイムアウト
    },
    weather: {
      url: new URL("http://localhost:8080/sse"),
      requestInit: {
        headers: {
          Authorization: `Bearer user-123-token`,
        },
      },
    },
  },
});

// すべてのツールセットを stream() または generate() に渡します
const response = await agent.stream(
  "AAPLの状況と天気を教えて",
  {
    toolsets: await mcp.getToolsets(),
  },
);
```


<div id="instance-management">
  ## インスタンス管理
</div>

`MCPClient` クラスには、複数インスタンスの管理におけるメモリリーク防止機能が組み込まれています:

1. `id` を指定せずに同じ構成で複数のインスタンスを作成しようとすると、メモリリーク防止のためにエラーがスローされます
2. 同一構成で複数のインスタンスが必要な場合は、各インスタンスに固有の `id` を指定してください
3. 同じ構成でインスタンスを再作成する前に、`await configuration.disconnect()` を呼び出してください
4. 単一のインスタンスで足りる場合は、再作成を避けるために構成をより上位のスコープに移動することを検討してください

たとえば、`id` を指定せずに同じ構成で複数のインスタンスを作成しようとすると:

```typescript
// 最初のインスタンス - OK
const mcp1 = new MCPClient({
  servers: {
    /* ... */
  },
});

// 同一設定で2つ目のインスタンスを作成するとエラーになります
const mcp2 = new MCPClient({
  servers: {
    /* ... */
  },
});

// 解決方法はいずれか:
// 1. 一意のIDを付与する
const mcp3 = new MCPClient({
  id: "instance-1",
  servers: {
    /* ... */
  },
});

// 2. もしくは再作成前に切断する
await mcp1.disconnect();
const mcp4 = new MCPClient({
  servers: {
    /* ... */
  },
});
```


<div id="server-lifecycle">
  ## サーバーのライフサイクル
</div>

MCPClient はサーバー接続を適切に処理します:

1. 複数サーバーに対する自動的な接続管理
2. 開発中のエラーメッセージを防ぐための、落ち着いた（グレースフルな）サーバーシャットダウン
3. 切断時のリソースの適切なクリーンアップ

<div id="using-sse-request-headers">
  ## SSE リクエストヘッダーの使用
</div>

レガシーな SSE MCP トランスポートを使用する場合、MCP SDK の不具合により、`requestInit` と `eventSourceInit` の両方を設定する必要があります。

```ts
const sseClient = new MCPClient({
  servers: {
    exampleServer: {
      url: new URL("https://your-mcp-server.com/sse"),
      // 注意: SSE では requestInit だけでは不十分です
      requestInit: {
        headers: {
          Authorization: "Bearer your-token",
        },
      },
      // カスタムヘッダーを伴う SSE 接続では、これも必須です
      eventSourceInit: {
        fetch(input: Request | URL | string, init?: RequestInit) {
          const headers = new Headers(init?.headers || {});
          headers.set("Authorization", "Bearer your-token");
          return fetch(input, {
            ...init,
            headers,
          });
        },
      },
    },
  },
});
```


<div id="related-information">
  ## 関連情報
</div>

- MCP サーバーの作成については、[MCPServer ドキュメント](./mcp-server)を参照してください。
- Model Context Protocol の詳細については、[@modelcontextprotocol/sdk ドキュメント](https://github.com/modelcontextprotocol/typescript-sdk)を参照してください。