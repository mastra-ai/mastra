---
title: "リファレンス: .chunk() | RAG | Mastra ドキュメント"
description: Mastra における chunk 関数のドキュメント。さまざまな手法を用いてドキュメントを小さなセグメントに分割します。
---

<div id="reference-chunk">
  # リファレンス: .chunk()
</div>

`.chunk()` 関数は、さまざまな戦略やオプションを用いてドキュメントを小さなセグメントに分割します。

<div id="example">
  ## 例
</div>

```typescript
import { MDocument } from "@mastra/rag";

const doc = MDocument.fromMarkdown(`
# はじめに
これは、チャンクに分割したいサンプルドキュメントです。

## セクション 1
ここは、いくつかの内容を含む最初のセクションです。

## セクション 2 
ここは、異なる内容を含む別のセクションです。
`);

// デフォルト設定での基本的なチャンク分割
const chunks = await doc.chunk();

// 見出し抽出を伴う Markdown 向けのチャンク分割
const chunksWithMetadata = await doc.chunk({
  strategy: "markdown",
  headers: [
    ["#", "title"],
    ["##", "section"],
  ],
  extract: {
    summary: true, // デフォルト設定で要約を抽出
    keywords: true, // デフォルト設定でキーワードを抽出
  },
});
```


<div id="parameters">
  ## パラメータ
</div>

以下のパラメータは、すべてのチャンク化戦略で利用できます。
**重要:** 各戦略では、用途に応じてこれらのパラメータの一部のみが使用されます。

<PropertiesTable
  content={[
    {
      name: "strategy",
      type: "'recursive' | 'character' | 'token' | 'markdown' | 'semantic-markdown' | 'html' | 'json' | 'latex' | 'sentence'",
      isOptional: true,
      description:
        "使用するチャンク化戦略。指定しない場合はドキュメント種別に応じたデフォルトが適用されます。戦略によっては追加の任意パラメータがあります。デフォルト: .md ファイル → 'markdown', .html/.htm → 'html', .json → 'json', .tex → 'latex', その他 → 'recursive'",
    },
    {
      name: "maxSize",
      type: "number",
      isOptional: true,
      defaultValue: "4000",
      description:
        "各チャンクの最大サイズ。**注:** 一部の戦略設定（ヘッダー付きの Markdown、ヘッダー付きの HTML）ではこのパラメータは無視されます。",
    },
    {
      name: "size",
      type: "number",
      isOptional: true,
      description:
        "**非推奨:** 代わりに `maxSize` を使用してください。このパラメータは次回のメジャーバージョンで削除されます。",
    },
    {
      name: "overlap",
      type: "number",
      isOptional: true,
      defaultValue: "50",
      description: "チャンク間で重複させる文字数/トークン数。",
    },
    {
      name: "lengthFunction",
      type: "(text: string) => number",
      isOptional: true,
      description:
        "テキスト長を計算する関数。デフォルトは文字数です。",
    },
    {
      name: "keepSeparator",
      type: "boolean | 'start' | 'end'",
      isOptional: true,
      description:
        "セパレーターをチャンクの先頭または末尾に保持するかどうか。",
    },
    {
      name: "addStartIndex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "チャンクに開始インデックスのメタデータを付与するかどうか。",
    },
    {
      name: "stripWhitespace",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "チャンクから空白文字を削除するかどうか。",
    },
    {
      name: "extract",
      type: "ExtractParams",
      isOptional: true,
      description: "メタデータ抽出の設定。",
    },
  ]}
/>

`extract` パラメータの詳細は [ExtractParams リファレンス](/reference/rag/extract-params) を参照してください。

<div id="strategy-specific-options">
  ## 戦略固有のオプション
</div>

戦略固有のオプションは、strategy パラメータと同じ階層のトップレベルパラメータとして渡します。例:

```typescript showLineNumbers copy
// 文字ベース戦略の例
const chunks = await doc.chunk({
  strategy: "character",
  separator: ".", // 文字ベース固有のオプション
  isSeparatorRegex: false, // 文字ベース固有のオプション
  maxSize: 300, // 共通オプション
});

// 再帰的戦略の例
const chunks = await doc.chunk({
  strategy: "recursive",
  separators: ["\n\n", "\n", " "], // 再帰的戦略固有のオプション
  language: "markdown", // 再帰的戦略固有のオプション
  maxSize: 500, // 共通オプション
});

// 文単位戦略の例
const chunks = await doc.chunk({
  strategy: "sentence",
  maxSize: 450, // 文単位戦略では必須
  minSize: 50, // 文単位戦略固有のオプション
  sentenceEnders: ["."], // 文単位戦略固有のオプション
  fallbackToCharacters: false, // 文単位戦略固有のオプション
  keepSeparator: true, // 共通オプション
});

// HTML 戦略の例
const chunks = await doc.chunk({
  strategy: "html",
  headers: [
    ["h1", "title"],
    ["h2", "subtitle"],
  ], // HTML 戦略固有のオプション
});

// Markdown 戦略の例
const chunks = await doc.chunk({
  strategy: "markdown",
  headers: [
    ["#", "title"],
    ["##", "section"],
  ], // Markdown 戦略固有のオプション
  stripHeaders: true, // Markdown 戦略固有のオプション
});

// セマンティック Markdown 戦略の例
const chunks = await doc.chunk({
  strategy: "semantic-markdown",
  joinThreshold: 500, // セマンティック Markdown 固有のオプション
  modelName: "gpt-3.5-turbo", // セマンティック Markdown 固有のオプション
});

// トークン戦略の例
const chunks = await doc.chunk({
  strategy: "token",
  encodingName: "gpt2", // トークン戦略固有のオプション
  modelName: "gpt-3.5-turbo", // トークン戦略固有のオプション
  maxSize: 1000, // 共通オプション
});
```

以下に記載のオプションは、設定オブジェクトのトップレベルに直接渡され、別個の options オブジェクト内にネストされることはありません。


<div id="character">
  ### 文字列
</div>

<PropertiesTable
  content={[
    {
      name: "separators",
      type: "string[]",
      isOptional: true,
      description:
        "優先順に試す区切りの配列。まず最初の区切りで分割を試み、できなければ次以降にフォールバックします。",
    },
    {
      name: "isSeparatorRegex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "区切りが正規表現パターンかどうか",
    },
  ]}
/>

<div id="recursive">
  ### 再帰
</div>

<PropertiesTable
  content={[
    {
      name: "separators",
      type: "string[]",
      isOptional: true,
      description:
        "優先順で試すセパレーターの配列。まず最初のセパレーターで分割を試み、できない場合は順に次のセパレーターへ切り替えます。",
    },
    {
      name: "isSeparatorRegex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "セパレーターを正規表現として扱うかどうか",
    },
    {
      name: "language",
      type: "Language",
      isOptional: true,
      description:
        "言語固有の分割動作に用いるプログラミング言語またはマークアップ言語。対応する値は Language 列挙型を参照してください。",
    },
  ]}
/>

<div id="sentence">
  ### 文単位
</div>

<PropertiesTable
  content={[
    {
      name: "maxSize",
      type: "number",
      description:
        "各チャンクの最大サイズ（sentence 戦略で必須）",
    },
    {
      name: "minSize",
      type: "number",
      isOptional: true,
      defaultValue: "50",
      description:
        "各チャンクの最小サイズ。これより小さいチャンクは、可能な場合は隣接するチャンクと結合されます。",
    },
    {
      name: "targetSize",
      type: "number",
      isOptional: true,
      description:
        "チャンクの推奨ターゲットサイズ。既定では maxSize の 80% です。この戦略はこのサイズに近いチャンクの作成を目指します。",
    },
    {
      name: "sentenceEnders",
      type: "string[]",
      isOptional: true,
      defaultValue: "['.', '!', '?']",
      description:
        "分割境界として扱う文末記号の配列。",
    },
    {
      name: "fallbackToWords",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description:
        "maxSize を超える文に対して語単位の分割にフォールバックするかどうか。",
    },
    {
      name: "fallbackToCharacters",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description:
        "maxSize を超える語に対して文字単位の分割にフォールバックするかどうか。fallbackToWords が有効な場合にのみ適用されます。",
    },
  ]}
/>

<div id="html">
  ### HTML
</div>

<PropertiesTable
  content={[
    {
      name: "headers",
      type: "Array<[string, string]>",
      description:
        "見出しベースの分割用に、［セレクタ、メタデータキー］の組を並べた配列",
    },
    {
      name: "sections",
      type: "Array<[string, string]>",
      description:
        "セクションベースの分割用に、［セレクタ、メタデータキー］の組を並べた配列",
    },
    {
      name: "returnEachLine",
      type: "boolean",
      isOptional: true,
      description: "各行を個別のチャンクとして返すかどうか",
    },
  ]}
/>

**重要:** HTML 戦略を使用する場合、一般的なオプションはすべて無視されます。見出しベースの分割には `headers` を、セクションベースの分割には `sections` を使用してください。両方を同時に指定した場合は `sections` が無視されます。

<div id="markdown">
  ### Markdown
</div>

<PropertiesTable
  content={[
    {
      name: "headers",
      type: "Array<[string, string]>",
      isOptional: true,
      description: "［見出しレベル, メタデータキー］のペアの配列",
    },
    {
      name: "stripHeaders",
      type: "boolean",
      isOptional: true,
      description: "出力から見出しを削除するかどうか",
    },
    {
      name: "returnEachLine",
      type: "boolean",
      isOptional: true,
      description: "各行を個別のチャンクとして返すかどうか",
    },
  ]}
/>

**重要:** `headers` オプションを使用すると、Markdown 戦略はすべての一般オプションを無視し、コンテンツは Markdown の見出し構造に基づいて分割されます。Markdown でサイズ基準のチャンク分割を使うには、`headers` パラメータを省略してください。

<div id="semantic-markdown">
  ### セマンティックMarkdown
</div>

<PropertiesTable
  content={[
    {
      name: "joinThreshold",
      type: "number",
      isOptional: true,
      defaultValue: "500",
      description:
        "関連セクションを結合する際の最大トークン数。単体でこの上限を超えるセクションはそのまま残し、より小さいセクションは、合計サイズがこのしきい値未満であれば同階層の兄弟セクションまたは親セクションと結合されます。",
    },
    {
      name: "modelName",
      type: "string",
      isOptional: true,
      description:
        "トークナイズに使用するモデル名。指定されていれば、そのモデルに基づくトークナイズの `encodingName` が使用されます。",
    },
    {
      name: "encodingName",
      type: "string",
      isOptional: true,
      defaultValue: "cl100k_base",
      description:
        "使用するトークンエンコーディング名。指定の `modelName` があればそこから導出されます。",
    },
    {
      name: "allowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description:
        "トークナイズ時に許可するスペシャルトークンの集合。すべてのスペシャルトークンを許可する場合は 'all' を指定します。",
    },
    {
      name: "disallowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      defaultValue: "all",
      description:
        "トークナイズ時に不許可とするスペシャルトークンの集合。すべてのスペシャルトークンを不許可にする場合は 'all' を指定します。",
    },
  ]}
/>

<div id="token">
  ### トークン
</div>

<PropertiesTable
  content={[
    {
      name: "encodingName",
      type: "string",
      isOptional: true,
      description: "使用するトークンエンコーディング名",
    },
    {
      name: "modelName",
      type: "string",
      isOptional: true,
      description: "トークナイズに用いるモデル名",
    },
    {
      name: "allowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description:
        "トークナイズ時に許可するスペシャルトークンの集合。すべてのスペシャルトークンを許可する場合は 'all'",
    },
    {
      name: "disallowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description:
        "トークナイズ時に許可しないスペシャルトークンの集合。すべてのスペシャルトークンを不許可にする場合は 'all'",
    },
  ]}
/>

<div id="json">
  ### JSON
</div>

<PropertiesTable
  content={[
    {
      name: "maxSize",
      type: "number",
      description: "各チャンクの最大サイズ",
    },
    {
      name: "minSize",
      type: "number",
      isOptional: true,
      description: "各チャンクの最小サイズ",
    },
    {
      name: "ensureAscii",
      type: "boolean",
      isOptional: true,
      description: "ASCII エンコードを保証するかどうか",
    },
    {
      name: "convertLists",
      type: "boolean",
      isOptional: true,
      description: "JSON 内のリストを変換するかどうか",
    },
  ]}
/>

<div id="latex">
  ### Latex
</div>

Latex戦略は、上記の一般的なチャンク化オプションのみを使用します。数学・学術文書向けに最適化された、LaTeXに対応した分割を提供します。

<div id="return-value">
  ## 戻り値
</div>

チャンク化されたドキュメントを含む `MDocument` インスタンスを返します。各チャンクには次の内容が含まれます：

```typescript
interface DocumentNode {
  text: string;
  metadata: Record<string, any>;
  embedding?: number[];
}
```
