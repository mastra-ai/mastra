---
title: "リファレンス: MastraModelOutput | ストリーミング | Mastra Docs"
description: "MastraModelOutput の完全なリファレンス。agent.stream() が返すストリームオブジェクトで、モデル出力に対するストリーミングアクセスと Promise ベースのアクセスを提供します。"
---

import PropertiesTable from "@site/src/components/PropertiesTable";


<div id="mastramodeloutput">
  # MastraModelOutput
</div>

`MastraModelOutput` クラスは [.stream()](./stream) によって返され、モデル出力へのストリーミングおよびプロミスベースのアクセスの両方を提供します。構造化出力の生成、ツール呼び出し、推論、ならびに包括的な使用状況のトラッキングをサポートします。

```typescript
// MastraModelOutput は agent.stream() から返されます
const stream = await agent.stream("Hello world");
```

セットアップと基本的な使用方法については、[.stream()](./stream) メソッドのドキュメントを参照してください。


<div id="streaming-properties">
  ## ストリーミングプロパティ
</div>

これらのプロパティは、生成中のモデル出力にリアルタイムでアクセスできます:

<PropertiesTable
  content={[
    {
      name: "fullStream",
      type: "ReadableStream<ChunkType<OUTPUT>>",
      description:
        "テキスト、ツール呼び出し、推論、メタデータ、制御チャンクなど、すべてのチャンクタイプを含む完全なストリーム。モデルの応答のあらゆる側面にきめ細かくアクセスできます。",
      properties: [
        {
          type: "ReadableStream",
          parameters: [
            {
              name: "ChunkType",
              type: "ChunkType<OUTPUT>",
              description:
                "ストリーミング中に出力されうるすべてのチャンクタイプ",
            },
          ],
        },
      ],
    },
    {
      name: "textStream",
      type: "ReadableStream<string>",
      description:
        "テキストのみを段階的に出力するストリーム。メタデータ、ツール呼び出し、制御チャンクをすべて除外し、生成中のテキストだけを提供します。",
    },
    {
      name: "objectStream",
      type: "ReadableStream<PartialSchemaOutput<OUTPUT>>",
      description:
        "出力スキーマ使用時の、構造化オブジェクトの進捗更新を流すストリーム。構築途中の部分的なオブジェクトを逐次出力し、構造化データ生成をリアルタイムで可視化できます。",
      properties: [
        {
          type: "ReadableStream",
          parameters: [
            {
              name: "PartialSchemaOutput",
              type: "PartialSchemaOutput<OUTPUT>",
              description:
                "定義済みスキーマに適合する、部分的に完成したオブジェクト",
            },
          ],
        },
      ],
    },
    {
      name: "elementStream",
      type: "ReadableStream<InferSchemaOutput<OUTPUT> extends (infer T)[] ? T : never>",
      description:
        "出力スキーマが配列型を定義している場合の、個々の配列要素を流すストリーム。配列全体の完了を待たず、各要素が完成し次第出力されます。",
    },
  ]}
/>

<div id="promise-based-properties">
  ## Promise ベースのプロパティ
</div>

これらのプロパティは、ストリームの完了後に最終的な値へと解決されます:

<PropertiesTable
  content={[
  {
    name: "text",
    type: "Promise<string>",
    description:
      "モデルから返される完全に連結されたテキストレスポンス。テキスト生成が完了すると解決されます。"
  },
  {
    name: "object",
    type: "Promise<InferSchemaOutput<OUTPUT>>",
    description:
      "出力スキーマを使用する際の完全な構造化オブジェクトレスポンス。解決前にスキーマに対して検証されます。検証が失敗すると拒否されます。",
    properties: [
      {
        type: "Promise",
        parameters: [
          {
            name: "InferSchemaOutput",
            type: "InferSchemaOutput<OUTPUT>",
            description:
              "スキーマ定義と完全に一致する型付きオブジェクト"
          }
        ]
      }
    ]
  },
  {
    name: "reasoning",
    type: "Promise<string>",
    description:
      "推論をサポートするモデル(OpenAIのo1シリーズなど)の完全な推論テキスト。推論機能を持たないモデルの場合は空文字列を返します。"
  },
  {
    name: "reasoningText",
    type: "Promise<string | undefined>",
    description:
      "推論コンテンツへの代替アクセス。推論をサポートしないモデルの場合はundefinedになる可能性がありますが、'reasoning'は空文字列を返します。"
  },
  {
    name: "toolCalls",
    type: "Promise<ToolCallChunk[]>",
    description:
      "実行中に行われたすべてのツール呼び出しチャンクの配列。各チャンクにはツールのメタデータと実行詳細が含まれます。",
    properties: [
      {
        type: "ToolCallChunk",
        parameters: [
          {
            name: "type",
            type: "'tool-call'",
            description: "チャンクタイプ識別子"
          },
          {
            name: "runId",
            type: "string",
            description: "実行ラン識別子"
          },
          {
            name: "from",
            type: "ChunkFrom",
            description: "チャンクのソース(AGENT、WORKFLOWなど)"
          },
          {
            name: "payload",
            type: "ToolCallPayload",
            description:
              "toolCallId、toolName、args、実行詳細を含むツール呼び出しデータ"
          }
        ]
      }
    ]
  },
  {
    name: "toolResults",
    type: "Promise<ToolResultChunk[]>",
    description:
      "ツール呼び出しに対応するすべてのツール結果チャンクの配列。実行結果とエラー情報が含まれます。",
    properties: [
      {
        type: "ToolResultChunk",
        parameters: [
          {
            name: "type",
            type: "'tool-result'",
            description: "チャンクタイプ識別子"
          },
          {
            name: "runId",
            type: "string",
            description: "実行ラン識別子"
          },
          {
            name: "from",
            type: "ChunkFrom",
            description: "チャンクのソース(AGENT、WORKFLOWなど)"
          },
          {
            name: "payload",
            type: "ToolResultPayload",
            description:
              "toolCallId、toolName、result、エラーステータスを含むツール結果データ"
          }
        ]
      }
    ]
  },
  {
    name: "usage",
    type: "Promise<LanguageModelUsage>",
    description:
      "入力トークン、出力トークン、合計トークン、推論トークン(推論モデルの場合)を含むトークン使用統計。",
    properties: [
      {
        type: "Record",
        parameters: [
          {
            name: "inputTokens",
            type: "number",
            description: "入力プロンプトで消費されたトークン"
          },
          {
            name: "outputTokens",
            type: "number",
            description: "レスポンスで生成されたトークン"
          },
          {
            name: "totalTokens",
            type: "number",
            description: "入力トークンと出力トークンの合計"
          },
          {
            name: "reasoningTokens",
            type: "number",
            isOptional: true,
            description: "隠れた推論トークン(推論モデルの場合)"
          },
          {
            name: "cachedInputTokens",
            type: "number",
            isOptional: true,
            description: "キャッシュヒットした入力トークンの数"
          }
        ]
      }
    ]
  },
  {
    name: "finishReason",
    type: "Promise<string | undefined>",
    description:
      "生成が停止した理由(例:'stop'、'length'、'tool_calls'、'content_filter')。ストリームが終了していない場合はundefinedです。",
    properties: [
      {
        type: "enum",
        parameters: [
          {
            name: "stop",
            type: "'stop'",
            description: "モデルが自然に終了"
          },
          {
            name: "length",
            type: "'length'",
            description: "最大トークン制限に達した"
          },
          {
            name: "tool_calls",
            type: "'tool_calls'",
            description: "モデルがツールを呼び出した"
          },
          {
            name: "content_filter",
            type: "'content_filter'",
            description: "コンテンツがフィルタリングされた"
          }
        ]
      }
    ]
  }
]}
/>

<div id="error-properties">
  ## エラーのプロパティ
</div>

<PropertiesTable
  content={[
    {
      name: "error",
      type: "string | Error | { message: string; stack: string; } | undefined",
      description:
        "ストリームでエラーが発生した場合のエラー情報。エラーがなければ undefined。文字列メッセージ、Error オブジェクト、またはスタックトレースを含むシリアライズ済みエラーのいずれかです。",
    },
  ]}
/>

<div id="methods">
  ## メソッド
</div>

<PropertiesTable
  content={[
    {
      name: "getFullOutput",
      type: "() => Promise<FullOutput>",
      description:
        "テキスト、構造化オブジェクト、ツール呼び出し、使用状況統計、推論テキスト、メタデータなど、すべての結果を含む包括的な出力オブジェクトを返します。ストリームの全結果に単一のメソッドでアクセスできます。",
      properties: [
        {
          type: "FullOutput",
          parameters: [
            {
              name: "text",
              type: "string",
              description: "完全なテキスト応答",
            },
            {
              name: "object",
              type: "InferSchemaOutput<OUTPUT>",
              isOptional: true,
              description: "スキーマが指定されている場合の構造化出力",
            },
            {
              name: "toolCalls",
              type: "ToolCallChunk[]",
              description: "行われたすべてのツール呼び出しチャンク",
            },
            {
              name: "toolResults",
              type: "ToolResultChunk[]",
              description: "すべてのツール結果チャンク",
            },
            {
              name: "usage",
              type: "Record<string, number>",
              description: "トークン使用量の統計",
            },
            {
              name: "reasoning",
              type: "string",
              isOptional: true,
              description: "利用可能な場合の推論テキスト",
            },
            {
              name: "finishReason",
              type: "string",
              isOptional: true,
              description: "生成が終了した理由",
            },
          ],
        },
      ],
    },
    {
      name: "consumeStream",
      type: "(options?: ConsumeStreamOptions) => Promise<void>",
      description:
        "チャンクを個別に処理せず、ストリーム全体を手動で消費します。最終的な Promise ベースの結果だけが必要で、ストリームの消費を明示的に開始したい場合に便利です。",
      properties: [
        {
          type: "ConsumeStreamOptions",
          parameters: [
            {
              name: "onError",
              type: "(error: Error) => void",
              isOptional: true,
              description: "ストリームエラーを処理するコールバック",
            },
          ],
        },
      ],
    },
  ]}
/>

<div id="usage-examples">
  ## 使い方の例
</div>

<div id="basic-text-streaming">
  ### テキストストリーミングの基本
</div>

```typescript
const stream = await agent.stream("俳句を書いて");

// 生成されるテキストをストリーミング
for await (const text of stream.textStream) {
  process.stdout.write(text);
}

// または完全なテキストを取得
const fullText = await stream.text;
console.log(fullText);
```


<div id="structured-output-streaming">
  ### 構造化出力のストリーミング
</div>

```typescript
const stream = await agent.stream("ユーザーデータを生成", {
  structuredOutput: {
    schema: z.object({
      name: z.string(),
      age: z.number(),
      email: z.string(),
    }),
  },
});

// 部分的なオブジェクトをストリーミング
for await (const partial of stream.objectStream) {
  console.log("進行状況:", partial); // { name: "John" }, { name: "John", age: 30 }, ...
}

// 最終的な検証済みオブジェクトを取得
const user = await stream.object;
console.log("最終結果:", user); // { name: "John", age: 30, email: "john@example.com" }
```

````

### ツール呼び出しと結果

```typescript
const stream = await agent.stream("ニューヨークの天気は?", {
  tools: { weather: weatherTool }
});

// ツール呼び出しを監視
const toolCalls = await stream.toolCalls;
const toolResults = await stream.toolResults;

console.log("呼び出されたツール:", toolCalls);
console.log("結果:", toolResults);
````


<div id="complete-output-access">
  ### 生成結果への完全アクセス
</div>

```typescript
const stream = await agent.stream("このデータを分析");

const output = await stream.getFullOutput();
console.log({
  text: output.text,
  usage: output.usage,
  reasoning: output.reasoning,
  finishReason: output.finishReason,
});
```


<div id="full-stream-processing">
  ### フルストリーム・プロセッシング
</div>

```typescript
const stream = await agent.stream("複雑なタスク");

for await (const chunk of stream.fullStream) {
  switch (chunk.type) {
    case "text-delta":
      process.stdout.write(chunk.payload.text);
      break;
    case "tool-call":
      console.log(`${chunk.payload.toolName}を呼び出し中...`);
      break;
    case "reasoning-delta":
      console.log(`推論: ${chunk.payload.text}`);
      break;
    case "finish":
      console.log(`完了! 理由: ${chunk.payload.stepResult.reason}`);
      break;
  }
}
```


<div id="error-handling">
  ### 例外処理
</div>

```typescript
const stream = await agent.stream("このデータを分析");

try {
  // オプション1: consumeStreamでエラーを処理
  await stream.consumeStream({
    onError: (error) => {
      console.error("ストリームエラー:", error);
    },
  });

  const result = await stream.text;
} catch (error) {
  console.error("結果の取得に失敗しました:", error);
}

// オプション2: errorプロパティを確認
const result = await stream.getFullOutput();
if (stream.error) {
  console.error("ストリームにエラーがありました:", stream.error);
}
```


<div id="related-types">
  ## 関連型
</div>

- [.stream()](./stream) - MastraModelOutput を返すメソッド
- [ChunkType](../ChunkType) - ストリーム全体で取り得るチャンクの種類