---
title: "レガシーワークフローにおける制御フロー：分岐、マージ、条件 | Workflows (Legacy) | Mastra Docs"
sidebar_position: 7
sidebar_label: "制御フロー"
description: "Mastra のレガシー ワークフローにおける制御フローでは、分岐・マージ・条件を管理し、ロジック要件を満たすレガシー ワークフローを構築できます。"
---

<div id="control-flow-in-legacy-workflows-branching-merging-and-conditions">
  # レガシー ワークフローにおける制御フロー：分岐、マージ、条件
</div>

複数ステップのプロセスを作成する際には、ステップを並列に実行したり、順次に連結したり、結果に応じて異なる経路をたどったりする必要が生じる場合があります。このページでは、分岐・マージ・条件を管理し、ロジック要件を満たすワークフローを構築する方法を説明します。コードスニペットでは、複雑な制御フローを組み立てるための主要なパターンを示します。

<div id="parallel-execution">
  ## 並列実行
</div>

互いに依存していない場合、複数のステップを同時に実行できます。ステップが独立したタスクを実行する場合、この方法でワークフローを高速化できます。以下のコードは、2つのステップを並列に追加する方法を示しています。

```typescript
myWorkflow.step(fetchUserData).step(fetchOrderData);
```

詳細は、[Parallel Steps](/examples/workflows_legacy/parallel-steps) の例をご覧ください。


<div id="sequential-execution">
  ## 逐次実行
</div>

あるステップの出力を次のステップの入力として確実に利用するため、処理を厳密な順序で実行する必要がある場合があります。依存関係のある処理をつなぐには .then() を使用します。以下のコードは、ステップを順番にチェーンする方法を示しています。

```typescript
myWorkflow.step(fetchOrderData).then(validateData).then(processOrder);
```

詳細は、[Sequential Steps](/examples/workflows_legacy/sequential-steps) のサンプルをご参照ください。


<div id="branching-and-merging-paths">
  ## 分岐と統合のパス
</div>

異なる結果ごとに異なるパスが必要な場合には、分岐が有効です。完了後にパスを統合することもできます。以下のコードは、stepA の後に分岐し、後で stepF に収束（統合）する方法を示しています：

```typescript
myWorkflow
  .step(stepA)
  .then(stepB)
  .then(stepD)
  .after(stepA)
  .step(stepC)
  .then(stepE)
  .after([stepD, stepE])
  .step(stepF);
```

この例では：

* stepA は stepB に進み、続いて stepD に進みます。
* なお、stepA は別途 stepC もトリガーし、その結果 stepE に進みます。
* また、stepD と stepE の両方が完了すると、stepF がトリガーされます。

詳細は [Branching Paths](/examples/workflows_legacy/branching-paths) の例をご覧ください。


<div id="merging-multiple-branches">
  ## 複数ブランチのマージ
</div>

複数の他のステップが完了してからのみ実行されるステップが必要になることがあります。Mastra では、複数の依存関係を1つのステップに指定できる複合的な `.after([])` 構文を提供しています。

```typescript
myWorkflow
  .step(fetchUserData)
  .then(validateUserData)
  .step(fetchProductData)
  .then(validateProductData)
  // このステップは、validateUserData と validateProductData の両方が完了した場合にのみ実行されます
  .after([validateUserData, validateProductData])
  .step(processOrder);
```

この例では:

* `fetchUserData` と `fetchProductData` は並列ブランチで実行されます
* 各ブランチにそれぞれ検証ステップがあります
* 両方の検証ステップが正常に完了した場合にのみ、`processOrder` ステップが実行されます

このパターンは次の用途に特に有用です:

* 並列実行パスの合流
* ワークフローにおける同期ポイントの実装
* 先に進む前に必要なデータがすべて揃っていることの担保

複数の `.after([])` 呼び出しを組み合わせることで、より複雑な依存関係パターンを作成することもできます:

```typescript
myWorkflow
  // 第1ブランチ
  .step(stepA)
  .then(stepB)
  .then(stepC)

  // 第2ブランチ
  .step(stepD)
  .then(stepE)

  // 第3ブランチ
  .step(stepF)
  .then(stepG)

  // このステップは複数ブランチの完了に依存します
  .after([stepC, stepE, stepG])
  .step(finalStep);
```


<div id="cyclical-dependencies-and-loops">
  ## 循環的な依存関係とループ
</div>

ワークフローでは、特定の条件が満たされるまで手順を繰り返す必要が生じることがよくあります。Mastra には、ループを作成するための強力な手段として `until` と `while` の 2 つが用意されています。これらのメソッドにより、反復処理を直感的に実装できます。

<div id="using-manual-cyclical-dependencies-legacy-approach">
  ### 手動による循環依存の利用（レガシー手法）
</div>

以前のバージョンでは、条件を用いて循環依存関係を手動で定義し、ループを作成できました。

```typescript
myWorkflow
  .step(fetchData)
  .then(processData)
  .after(processData)
  .step(finalizeData, {
    when: { "processData.status": "success" },
  })
  .step(fetchData, {
    when: { "processData.status": "retry" },
  });
```

この方法でも機能しますが、より新しい `until` と `while` メソッドを使うと、ループをより簡潔で保守しやすい形で作成できます。


<div id="using-until-for-condition-based-loops">
  ### 条件に基づくループでの `until` の使用
</div>

`until` メソッドは、指定した条件が true になるまでステップを繰り返します。引数は次のとおりです。

1. ループを停止する条件
2. 繰り返すステップ
3. 繰り返しステップに渡す任意の変数

```typescript
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// 目標に達するまでカウンターをインクリメントするステップ
const incrementStep = new LegacyStep({
  id: "increment",
  inputSchema: z.object({
    // 現在のカウンター値
    counter: z.number().optional(),
  }),
  outputSchema: z.object({
    // 更新後のカウンター値
    updatedCounter: z.number(),
  }),
  execute: async ({ context }) => {
    const { counter = 0 } = context.inputData;
    return { updatedCounter: counter + 1 };
  },
});

workflow
  .step(incrementStep)
  .until(
    async ({ context }) => {
      // カウンターが10に達したら停止する
      const result = context.getStepResult(incrementStep);
      return (result?.updatedCounter ?? 0) >= 10;
    },
    incrementStep,
    {
      // 現在のカウンターを次の反復処理に渡す
      counter: {
        step: incrementStep,
        path: "updatedCounter",
      },
    },
  )
  .then(finalStep);
```

参照に基づく条件も使用できます：

```typescript
workflow
  .step(incrementStep)
  .until(
    {
      ref: { step: incrementStep, path: "updatedCounter" },
      query: { $gte: 10 },
    },
    incrementStep,
    {
      counter: {
        step: incrementStep,
        path: "updatedCounter",
      },
    },
  )
  .then(finalStep);
```


<div id="using-while-for-condition-based-loops">
  ### 条件ベースのループでの `while` の使用
</div>

`while` メソッドは、指定した条件が真である間、処理を繰り返します。引数は `until` と同じです:

1. ループを続行するかどうかを判定する条件
2. 繰り返す処理
3. 繰り返す処理に渡す任意の変数

```typescript
// 目標値に達するまでカウンターを増やすステップ
const incrementStep = new LegacyStep({
  id: "increment",
  inputSchema: z.object({
    // 現在のカウンターの値
    counter: z.number().optional(),
  }),
  outputSchema: z.object({
    // 更新後のカウンターの値
    updatedCounter: z.number(),
  }),
  execute: async ({ context }) => {
    const { counter = 0 } = context.inputData;
    return { updatedCounter: counter + 1 };
  },
});

workflow
  .step(incrementStep)
  .while(
    async ({ context }) => {
      // カウンターが10未満の間は継続
      const result = context.getStepResult(incrementStep);
      return (result?.updatedCounter ?? 0) < 10;
    },
    incrementStep,
    {
      // 現在のカウンターを次の反復処理へ渡す
      counter: {
        step: incrementStep,
        path: "updatedCounter",
      },
    },
  )
  .then(finalStep);
```

参照に基づく条件も使用できます：

```typescript
workflow
  .step(incrementStep)
  .while(
    {
      ref: { step: incrementStep, path: "updatedCounter" },
      query: { $lt: 10 },
    },
    incrementStep,
    {
      counter: {
        step: incrementStep,
        path: "updatedCounter",
      },
    },
  )
  .then(finalStep);
```


<div id="comparison-operators-for-reference-conditions">
  ### 参照条件の比較演算子
</div>

参照ベースの条件を使用する場合、次の比較演算子を使用できます：

| Operator | Description        |
| -------- | ------------------ |
| `$eq`    | 等しい             |
| `$ne`    | 等しくない         |
| `$gt`    | より大きい         |
| `$gte`   | 以上               |
| `$lt`    | より小さい         |
| `$lte`   | 以下               |

<div id="conditions">
  ## 条件
</div>

前のステップのデータに基づいてステップを実行するかどうかを制御するには、when プロパティを使用します。条件の指定方法は次の3通りです。

<div id="option-1-function">
  ### オプション1：関数
</div>

```typescript
myWorkflow.step(
  new Step({
    id: "processData",
    execute: async ({ context }) => {
      // アクション処理のロジック
    },
  }),
  {
    when: async ({ context }) => {
      const fetchData = context?.getStepResult<{ status: string }>("fetchData");
      return fetchData?.status === "success";
    },
  },
);
```


<div id="option-2-query-object">
  ### オプション 2: Query オブジェクト
</div>

```typescript
myWorkflow.step(
  new Step({
    id: "processData",
    execute: async ({ context }) => {
      // アクション処理のロジック
    },
  }),
  {
    when: {
      ref: {
        step: {
          id: "fetchData",
        },
        path: "status",
      },
      query: { $eq: "success" },
    },
  },
);
```


<div id="option-3-simple-path-comparison">
  ### オプション3: シンプルなパス比較
</div>

```typescript
myWorkflow.step(
  new Step({
    id: "processData",
    execute: async ({ context }) => {
      // アクションの処理ロジック
    },
  }),
  {
    when: {
      "fetchData.status": "success",
    },
  },
);
```


<div id="data-access-patterns">
  ## データアクセスパターン
</div>

Mastra では、ステップ間でデータを受け渡す方法が複数用意されています：

1. **Context オブジェクト** - コンテキスト経由でステップの結果に直接アクセス
2. **変数マッピング** - あるステップの出力を別のステップの入力に明示的にマップ
3. **getStepResult メソッド** - ステップの出力を型安全に取得

それぞれの方法には、ユースケースや型安全性の要件に応じた利点があります。

<div id="using-getstepresult-method">
  ### getStepResult メソッドの使用
</div>

`getStepResult` メソッドは、ステップ結果へ型安全にアクセスする方法を提供します。TypeScript で作業する際は、型情報を保持できるため、この方法を推奨します。

<div id="basic-usage">
  #### 基本的な使い方
</div>

型安全性を高めるために、`getStepResult` に型パラメータを指定できます:

```typescript showLineNumbers title="src/mastra/workflows/get-step-result.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

const fetchUserStep = new LegacyStep({
  id: "fetchUser",
  outputSchema: z.object({
    name: z.string(),
    userId: z.string(),
  }),
  execute: async ({ context }) => {
    return { name: "John Doe", userId: "123" };
  },
});

const analyzeDataStep = new LegacyStep({
  id: "analyzeData",
  execute: async ({ context }) => {
    // 前のステップの結果に型安全にアクセス
    const userData = context.getStepResult<{ name: string; userId: string }>(
      "fetchUser",
    );

    if (!userData) {
      return { status: "error", message: "ユーザーデータが見つかりません" };
    }

    return {
      analysis: `ユーザー ${userData.name} のデータを分析しました`,
      userId: userData.userId,
    };
  },
});
```


<div id="using-step-references">
  #### ステップ参照の使用
</div>

最も型安全な方法は、`getStepResult` の呼び出しでステップを直接参照することです。

```typescript showLineNumbers title="src/mastra/workflows/step-reference.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// 出力スキーマを定義したステップ
const fetchUserStep = new LegacyStep({
  id: "fetchUser",
  outputSchema: z.object({
    userId: z.string(),
    name: z.string(),
    email: z.string(),
  }),
  execute: async () => {
    return {
      userId: "user123",
      name: "John Doe",
      email: "john@example.com",
    };
  },
});

const processUserStep = new LegacyStep({
  id: "processUser",
  execute: async ({ context }) => {
    // TypeScriptはfetchUserStepのoutputSchemaから正しい型を推論する
    const userData = context.getStepResult(fetchUserStep);

    return {
      processed: true,
      userName: userData?.name,
    };
  },
});

const workflow = new LegacyWorkflow({
  name: "user-workflow",
});

workflow.step(fetchUserStep).then(processUserStep).commit();
```


<div id="using-variable-mapping">
  ### 変数マッピングの使用
</div>

変数マッピングは、ステップ間のデータフローを明示的に定義する方法です。
この手法により依存関係が明確になり、型安全性も高まります。
ステップに注入されるデータは `context.inputData` オブジェクトから参照でき、ステップの `inputSchema` に基づいて型付けされます。

```typescript showLineNumbers title="src/mastra/workflows/variable-mapping.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

const fetchUserStep = new LegacyStep({
  id: "fetchUser",
  outputSchema: z.object({
    userId: z.string(),
    name: z.string(),
    email: z.string(),
  }),
  execute: async () => {
    return {
      userId: "user123",
      name: "John Doe",
      email: "john@example.com",
    };
  },
});

const sendEmailStep = new LegacyStep({
  id: "sendEmail",
  inputSchema: z.object({
    recipientEmail: z.string(),
    recipientName: z.string(),
  }),
  execute: async ({ context }) => {
    const { recipientEmail, recipientName } = context.inputData;

    // メール送信処理をここに記述
    return {
      status: "sent",
      to: recipientEmail,
    };
  },
});

const workflow = new LegacyWorkflow({
  name: "email-workflow",
});

workflow
  .step(fetchUserStep)
  .then(sendEmailStep, {
    variables: {
      // fetchUserの特定フィールドをsendEmailの入力にマッピング
      recipientEmail: { step: fetchUserStep, path: "email" },
      recipientName: { step: fetchUserStep, path: "name" },
    },
  })
  .commit();
```

変数マッピングの詳細は、[ワークフロー変数によるデータマッピング](./variables)のドキュメントをご覧ください。


<div id="using-the-context-object">
  ### Context オブジェクトの使用
</div>

Context オブジェクトは、すべてのステップ結果とその出力に直接アクセスできます。この方法はより柔軟ですが、型安全性を保つためには慎重な取り扱いが必要です。
ステップ結果には、`context.steps` オブジェクトを通して直接アクセスできます。

```typescript showLineNumbers title="src/mastra/workflows/context-access.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

const processOrderStep = new LegacyStep({
  id: "processOrder",
  execute: async ({ context }) => {
    // 前のステップからデータを取得
    let userData: { name: string; userId: string };
    if (context.steps["fetchUser"]?.status === "success") {
      userData = context.steps.fetchUser.output;
    } else {
      throw new Error("ユーザーデータが見つかりません");
    }

    return {
      orderId: "order123",
      userId: userData.userId,
      status: "processing",
    };
  },
});

const workflow = new LegacyWorkflow({
  name: "order-workflow",
});

workflow.step(fetchUserStep).then(processOrderStep).commit();
```


<div id="workflow-level-type-safety">
  ### ワークフロー単位の型安全性
</div>

ワークフロー全体で型安全性を徹底するには、すべてのステップに型を定義し、それらを Workflow に渡します。
これにより、条件内でのコンテキストオブジェクトや、最終的なワークフロー出力に含まれるステップ結果に対しても型安全性を確保できます。

```typescript showLineNumbers title="src/mastra/workflows/workflow-typing.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// 型付き出力を持つステップを作成
const fetchUserStep = new LegacyStep({
  id: "fetchUser",
  outputSchema: z.object({
    userId: z.string(),
    name: z.string(),
    email: z.string(),
  }),
  execute: async () => {
    return {
      userId: "user123",
      name: "John Doe",
      email: "john@example.com",
    };
  },
});

const processOrderStep = new LegacyStep({
  id: "processOrder",
  execute: async ({ context }) => {
    // TypeScriptはuserDataの型を認識します
    const userData = context.getStepResult(fetchUserStep);

    return {
      orderId: "order123",
      status: "processing",
    };
  },
});

const workflow = new LegacyWorkflow<
  [typeof fetchUserStep, typeof processOrderStep]
>({
  name: "typed-workflow",
});

workflow
  .step(fetchUserStep)
  .then(processOrderStep)
  .until(async ({ context }) => {
    // TypeScriptはここでuserDataの型を認識します
    const res = context.getStepResult("fetchUser");
    return res?.userId === "123";
  }, processOrderStep)
  .commit();
```


<div id="accessing-trigger-data">
  ### トリガーデータへのアクセス
</div>

ステップの結果に加えて、ワークフローを開始した元のトリガーデータにもアクセスできます。

```typescript showLineNumbers title="src/mastra/workflows/trigger-data.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// トリガースキーマを定義
const triggerSchema = z.object({
  customerId: z.string(),
  orderItems: z.array(z.string()),
});

type TriggerType = z.infer<typeof triggerSchema>;

const processOrderStep = new LegacyStep({
  id: "processOrder",
  execute: async ({ context }) => {
    // 型安全にトリガーデータにアクセス
    const triggerData = context.getStepResult<TriggerType>("trigger");

    return {
      customerId: triggerData?.customerId,
      itemCount: triggerData?.orderItems.length || 0,
      status: "processing",
    };
  },
});

const workflow = new LegacyWorkflow({
  name: "order-workflow",
  triggerSchema,
});

workflow.step(processOrderStep).commit();
```


<div id="accessing-resume-data">
  ### レジュメデータへのアクセス
</div>

ステップに注入されたデータは `context.inputData` オブジェクトから参照でき、ステップの `inputSchema` に基づいて型付けされています。

```typescript showLineNumbers title="src/mastra/workflows/resume-data.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

const processOrderStep = new LegacyStep({
  id: "processOrder",
  inputSchema: z.object({
    orderId: z.string(),
  }),
  execute: async ({ context, suspend }) => {
    const { orderId } = context.inputData;

    if (!orderId) {
      await suspend();
      return;
    }

    return {
      orderId,
      status: "processed",
    };
  },
});

const workflow = new LegacyWorkflow({
  name: "order-workflow",
});

workflow.step(processOrderStep).commit();

const run = workflow.createRun();
const result = await run.start();

const resumedResult = await workflow.resume({
  runId: result.runId,
  stepId: "processOrder",
  inputData: {
    orderId: "123",
  },
});

console.log({ resumedResult });
```


<div id="accessing-workflow-results">
  ### ワークフロー結果へのアクセス
</div>

`Workflow` の型パラメータにステップの型を渡すことで、ワークフローの結果に型安全にアクセスできます。

```typescript showLineNumbers title="src/mastra/workflows/get-results.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

const fetchUserStep = new LegacyStep({
  id: "fetchUser",
  outputSchema: z.object({
    userId: z.string(),
    name: z.string(),
    email: z.string(),
  }),
  execute: async () => {
    return {
      userId: "user123",
      name: "John Doe",
      email: "john@example.com",
    };
  },
});

const processOrderStep = new LegacyStep({
  id: "processOrder",
  outputSchema: z.object({
    orderId: z.string(),
    status: z.string(),
  }),
  execute: async ({ context }) => {
    const userData = context.getStepResult(fetchUserStep);
    return {
      orderId: "order123",
      status: "processing",
    };
  },
});

const workflow = new LegacyWorkflow<
  [typeof fetchUserStep, typeof processOrderStep]
>({
  name: "typed-workflow",
});

workflow.step(fetchUserStep).then(processOrderStep).commit();

const run = workflow.createRun();
const result = await run.start();

// 結果はステップ結果の判別共用体です
// そのため、ステータスチェックで絞り込む必要があります
if (result.results.processOrder.status === "success") {
  // TypeScriptは結果の型を認識します
  const orderId = result.results.processOrder.output.orderId;
  console.log({ orderId });
}

if (result.results.fetchUser.status === "success") {
  const userId = result.results.fetchUser.output.userId;
  console.log({ userId });
}
```


<div id="best-practices-for-data-flow">
  ### データフローのベストプラクティス
</div>

1. **型安全性のために Step 参照と併せて getStepResult を使う**
   - TypeScript が正しい型を推論できるようにする
   - コンパイル時に型エラーを検出できる

2. \*_明示的な依存関係には Variable Mapping を使う_
   - データフローを明確にし、保守しやすくする
   - ステップ間の依存関係の有用なドキュメントになる

3. **ステップの出力スキーマを定義する**
   - 実行時にデータを検証する
   - `execute` 関数の戻り値の型を検証する
   - TypeScript の型推論を改善する

4. **欠損データを適切に扱う**
   - プロパティにアクセスする前にステップ結果の有無を常に確認する
   - 任意データにはフォールバック値を用意する

5. **データ変換はシンプルに保つ**
   - 変数マッピングではなく、専用のステップでデータを変換する
   - ワークフローのテストやデバッグを容易にする

<div id="comparison-of-data-flow-methods">
  ### データフロー手法の比較
</div>

| 手法              | 型安全性 | 明示性 | ユースケース                                         |
| ----------------- | -------- | ------ | ---------------------------------------------------- |
| getStepResult     | 最高     | 高い   | 厳密な型付けが必要な複雑なワークフロー               |
| Variable Mapping  | 高い     | 高い   | 依存関係を明確かつ明示的に示す必要がある場合         |
| context.steps     | 中程度   | 低い   | シンプルなワークフローでステップデータに素早くアクセス |

ユースケースに適したデータフロー手法を選択することで、型安全性と保守性を両立したワークフローを構築できます。