---
title: "メモリプロセッサー | メモリ | Mastra ドキュメント"
description: "Mastra のメモリプロセッサーを使って、言語モデルに送信する前にメッセージをフィルタ、要約・削減、変換し、コンテキストウィンドウの制約を管理する方法を学びます。"
---

<div id="memory-processors">
  # メモリプロセッサ
</div>

メモリプロセッサは、メモリから取得したメッセージの一覧を、エージェントのコンテキストウィンドウに追加して LLM に送信する前に加工・変更できる仕組みです。コンテキストの規模管理、内容のフィルタリング、パフォーマンス最適化に役立ちます。

プロセッサは、メモリ設定（例：`lastMessages`、`semanticRecall`）に基づいて取得されたメッセージに対して動作します。新たに届くユーザーメッセージには影響しません。

<div id="built-in-processors">
  ## 組み込みプロセッサ
</div>

Mastra には組み込みのプロセッサがあります：

<div id="tokenlimiter">
  ### `TokenLimiter`
</div>

このプロセッサは、LLM のコンテキストウィンドウ制限を超えて発生するエラーを防ぐために使用されます。取得したメモリメッセージのトークン数を数え、合計が指定された `limit` を下回るまで最も古いメッセージを削除します。

```typescript copy showLineNumbers {9-12}
import { Memory } from "@mastra/memory";
import { TokenLimiter } from "@mastra/memory/processors";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent({
  model: openai("gpt-4o"),
  memory: new Memory({
    processors: [
      // メモリ由来のトークン総数が約127kを超えないようにする
      new TokenLimiter(127000),
    ],
  }),
});
```

`TokenLimiter` はデフォルトで `o200k_base` エンコーディングを使用します（GPT-4o に適合）。必要に応じて、別のモデル向けに他のエンコーディングを指定できます。

```typescript copy showLineNumbers {6-9}
// 必要なエンコーディングをインポートします（例：古い OpenAI モデル用）
import cl100k_base from "js-tiktoken/ranks/cl100k_base";

const memoryForOlderModel = new Memory({
  processors: [
    new TokenLimiter({
      limit: 16000, // 16k コンテキストモデル向けの上限例
      encoding: cl100k_base,
    }),
  ],
});
```

エンコーディングの詳細については、[OpenAI Cookbook](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken#encodings) または [`js-tiktoken` リポジトリ](https://github.com/dqbd/tiktoken) をご覧ください。


<div id="toolcallfilter">
  ### `ToolCallFilter`
</div>

このプロセッサは、LLM に送信されるメモリメッセージからツール呼び出しを取り除きます。コンテキストから冗長になりがちなツールのやり取りを除外することでトークンを節約でき、将来のやり取りで詳細が不要な場合に有用です。また、常にエージェントに特定のツールを再度呼び出させ、メモリ内の過去のツール結果に依存させないようにしたい場合にも役立ちます。

```typescript copy showLineNumbers {5-14}
import { Memory } from "@mastra/memory";
import { ToolCallFilter, TokenLimiter } from "@mastra/memory/processors";

const memoryFilteringTools = new Memory({
  processors: [
    // 例 1: すべてのツール呼び出し・結果を削除
    new ToolCallFilter(),

    // 例 2: ノイズの多い画像生成ツールの呼び出し・結果のみ削除
    new ToolCallFilter({ exclude: ["generateImageTool"] }),

    // TokenLimiter は必ず最後に配置
    new TokenLimiter(127000),
  ],
});
```


<div id="applying-multiple-processors">
  ## 複数のプロセッサの適用
</div>

複数のプロセッサをチェーンできます。`processors` 配列に記載された順に実行され、あるプロセッサの出力が次のプロセッサの入力になります。

**順序が重要です！** 一般的には、チェーンの **最後** に `TokenLimiter` を配置するのがベストプラクティスです。これにより、他のフィルタリング後の最終的なメッセージ群に対して動作し、最も正確にトークン制限を適用できます。

```typescript copy showLineNumbers {7-14}
import { Memory } from "@mastra/memory";
import { ToolCallFilter, TokenLimiter } from "@mastra/memory/processors";
// 仮のカスタムプロセッサ『PIIFilter』が存在すると仮定します
// import { PIIFilter } from './custom-processors';

const memoryWithMultipleProcessors = new Memory({
  processors: [
    // 1. まず特定のツール呼び出しを除外します
    new ToolCallFilter({ exclude: ["verboseDebugTool"] }),
    // 2. カスタムフィルタを適用（例：仮の個人情報を除去 — 取扱注意）
    // new PIIFilter(),
    // 3. 最後にトークン制限を適用します
    new TokenLimiter(127000),
  ],
});
```


<div id="creating-custom-processors">
  ## カスタムプロセッサの作成
</div>

`MemoryProcessor` の基底クラスを拡張して、独自のロジックを実装できます。

```typescript copy showLineNumbers {5-20,24-27}
import { Memory } from "@mastra/memory";
import { CoreMessage, MemoryProcessorOpts } from "@mastra/core";
import { MemoryProcessor } from "@mastra/core/memory";

class ConversationOnlyFilter extends MemoryProcessor {
  constructor() {
    // 必要に応じてデバッグをしやすくするための名前を付けます
    super({ name: "ConversationOnlyFilter" });
  }

  process(
    messages: CoreMessage[],
    _opts: MemoryProcessorOpts = {}, // メモリ取得時に渡されるオプション。ここで使うことはほとんどありません
  ): CoreMessage[] {
    // ロールに基づいてメッセージをフィルタします
    return messages.filter(
      (msg) => msg.role === "user" || msg.role === "assistant",
    );
  }
}

// カスタムプロセッサを使用する
const memoryWithCustomFilter = new Memory({
  processors: [
    new ConversationOnlyFilter(),
    new TokenLimiter(127000), // トークン制限は引き続き適用します
  ],
});
```

カスタムプロセッサを作成する際は、入力の `messages` 配列やその要素のオブジェクトを直接変更しないでください。
