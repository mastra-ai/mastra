# PR 1.1: Observability Core Types Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add foundational type definitions for unified observability (logging, metrics, scores, feedback) to @mastra/core, following existing tracing patterns.

**Architecture:** Extend the three-tier type pattern (Input → Exported → Record) used by tracing to all observability signals. Create new type files for each signal, add ObservabilityContextMixin interface, update context types to extend it, and wire no-op implementations for immediate use.

**Tech Stack:** TypeScript interfaces, Zod schemas (for storage types in Phase 6), existing @mastra/core patterns.

---

## Pre-Implementation Checklist

- [ ] Ensure you're on the `esp/obs_core_additions` branch
- [ ] Run `pnpm build:core` to verify current state compiles
- [ ] Run `pnpm test:core` to verify existing tests pass

---

## Task 1: Create Logging Types

**Files:**

- Create: `packages/core/src/observability/types/logging.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create logging.ts with LogLevel, LoggerContext, ExportedLog, LogEvent**

```typescript
// packages/core/src/observability/types/logging.ts

// ============================================================================
// Log Level
// ============================================================================

/** Log severity levels */
export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal'

// ============================================================================
// LoggerContext (API Interface)
// ============================================================================

/**
 * LoggerContext - API for emitting structured logs.
 * Logs are automatically correlated with the current span's trace/span IDs.
 */
export interface LoggerContext {
  debug(message: string, data?: Record<string, unknown>): void
  info(message: string, data?: Record<string, unknown>): void
  warn(message: string, data?: Record<string, unknown>): void
  error(message: string, data?: Record<string, unknown>): void
}

// ============================================================================
// ExportedLog (Event Bus Transport)
// ============================================================================

/**
 * Log data transported via the event bus.
 * Must be JSON-serializable (Date serializes via toJSON()).
 *
 * Context fields (runId, sessionId, userId, environment, etc.) are stored
 * in metadata, following the same pattern as tracing spans.
 */
export interface ExportedLog {
  /** When the log was emitted */
  timestamp: Date

  /** Log severity level */
  level: LogLevel

  /** Human-readable log message */
  message: string

  /** Structured data associated with this log */
  data?: Record<string, unknown>

  /** Trace ID for correlation (from current span) */
  traceId?: string

  /** Span ID for correlation (from current span) */
  spanId?: string

  /** Optional tags for filtering/categorization */
  tags?: string[]

  /**
   * User-defined metadata.
   * Context fields are stored here: runId, sessionId, userId, environment,
   * serviceName, organizationId, entityType, entityName, etc.
   * This follows the same pattern as BaseSpan.metadata in tracing.ts.
   */
  metadata?: Record<string, unknown>
}

// ============================================================================
// LogEvent (Event Bus Event)
// ============================================================================

/** Log event emitted to the ObservabilityBus */
export interface LogEvent {
  type: 'log'
  log: ExportedLog
}
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './logging'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS (no type errors)

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/logging.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add logging types for observability

Add LogLevel, LoggerContext interface, ExportedLog interface, and LogEvent
type following the Input/Exported/Record pattern from tracing.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Create Metrics Types

**Files:**

- Create: `packages/core/src/observability/types/metrics.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create metrics.ts with MetricType, MetricsContext, ExportedMetric, MetricEvent, cardinality config**

```typescript
// packages/core/src/observability/types/metrics.ts

// ============================================================================
// Metric Type
// ============================================================================

/** Types of metrics */
export type MetricType = 'counter' | 'gauge' | 'histogram'

// ============================================================================
// MetricsContext (API Interface)
// ============================================================================

/**
 * MetricsContext - API for emitting metrics.
 * Provides counter, gauge, and histogram metric types.
 */
export interface MetricsContext {
  counter(name: string): Counter
  gauge(name: string): Gauge
  histogram(name: string): Histogram
}

export interface Counter {
  add(value: number, additionalLabels?: Record<string, string>): void
}

export interface Gauge {
  set(value: number, additionalLabels?: Record<string, string>): void
}

export interface Histogram {
  record(value: number, additionalLabels?: Record<string, string>): void
}

// ============================================================================
// ExportedMetric (Event Bus Transport)
// ============================================================================

/**
 * Metric data transported via the event bus.
 * Represents a single metric observation.
 * Must be JSON-serializable (Date serializes via toJSON()).
 *
 * Environment fields (organizationId, environment, serviceName) are stored
 * in metadata, following the same pattern as tracing spans.
 *
 * Note: Histogram aggregation (bucket counts, sum, count) is computed at
 * the storage layer, not in the individual metric event.
 */
export interface ExportedMetric {
  /** When the metric was recorded */
  timestamp: Date

  /** Metric name (e.g., mastra_agent_duration_ms) */
  name: string

  /** Type of metric */
  metricType: MetricType

  /** Metric value (single observation) */
  value: number

  /** Metric labels for dimensional filtering */
  labels: Record<string, string>

  /**
   * User-defined metadata.
   * Environment fields are stored here: organizationId, environment,
   * serviceName, etc. These are kept separate from labels to avoid
   * cardinality issues.
   */
  metadata?: Record<string, unknown>
}

// ============================================================================
// MetricEvent (Event Bus Event)
// ============================================================================

/** Metric event emitted to the ObservabilityBus */
export interface MetricEvent {
  type: 'metric'
  metric: ExportedMetric
}

// ============================================================================
// Cardinality Protection
// ============================================================================

/**
 * Default labels to block from metrics to prevent cardinality explosion.
 * These are high-cardinality fields that should not be used as metric labels.
 */
export const DEFAULT_BLOCKED_LABELS = [
  'trace_id',
  'span_id',
  'run_id',
  'request_id',
  'user_id',
  'resource_id',
  'session_id',
  'thread_id',
] as const

/** Cardinality protection configuration */
export interface CardinalityConfig {
  /**
   * Labels to block from metrics.
   * Set to undefined to use DEFAULT_BLOCKED_LABELS.
   * Set to empty array to allow all labels.
   */
  blockedLabels?: string[]

  /**
   * Whether to block UUID-like values in labels.
   * @default true
   */
  blockUUIDs?: boolean
}

/** Metrics-specific configuration */
export interface MetricsConfig {
  /** Whether metrics are enabled */
  enabled?: boolean
  /** Cardinality protection settings */
  cardinality?: CardinalityConfig
}
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './metrics'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/metrics.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add metrics types for observability

Add MetricType, MetricsContext/Counter/Gauge/Histogram interfaces,
ExportedMetric interface, MetricEvent type, and cardinality protection
config following the Input/Exported/Record pattern.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Create Scores Types

**Files:**

- Create: `packages/core/src/observability/types/scores.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create scores.ts with ScoreInput, ExportedScore, ScoreEvent**

```typescript
// packages/core/src/observability/types/scores.ts

// ============================================================================
// ScoreInput (User Input)
// ============================================================================

/**
 * User-provided score data for evaluating span/trace quality.
 * Used with span.addScore() and trace.addScore().
 */
export interface ScoreInput {
  /** Name of the scorer (e.g., "relevance", "accuracy", "toxicity") */
  scorerName: string

  /** Numeric score value (typically 0-1 or 0-100) */
  score: number

  /** Human-readable explanation of the score */
  reason?: string

  /** Experiment identifier for A/B testing or evaluation runs */
  experiment?: string

  /** Additional metadata specific to this score */
  metadata?: Record<string, unknown>
}

// ============================================================================
// ExportedScore (Event Bus Transport)
// ============================================================================

/**
 * Score data transported via the event bus.
 * Must be JSON-serializable (Date serializes via toJSON()).
 *
 * Context fields (organizationId, userId, environment, etc.) are stored
 * in metadata, following the same pattern as tracing spans. The metadata
 * is inherited from the span/trace being scored.
 */
export interface ExportedScore {
  /** When the score was recorded */
  timestamp: Date

  /** Trace being scored */
  traceId: string

  /** Specific span being scored (undefined = trace-level score) */
  spanId?: string

  /** Name of the scorer */
  scorerName: string

  /** Numeric score value */
  score: number

  /** Human-readable explanation */
  reason?: string

  /** Experiment identifier for A/B testing */
  experiment?: string

  /**
   * User-defined metadata.
   * Inherited from the span/trace being scored, merged with score-specific metadata.
   * Contains context fields: organizationId, userId, environment, serviceName,
   * entityType, entityName, etc.
   */
  metadata?: Record<string, unknown>
}

// ============================================================================
// ScoreEvent (Event Bus Event)
// ============================================================================

/** Score event emitted to the ObservabilityBus */
export interface ScoreEvent {
  type: 'score'
  score: ExportedScore
}
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './scores'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/scores.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add scores types for observability

Add ScoreInput (user API), ExportedScore (event bus transport), and
ScoreEvent type for attaching evaluation scores to spans/traces.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 4: Create Feedback Types

**Files:**

- Create: `packages/core/src/observability/types/feedback.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create feedback.ts with FeedbackInput, ExportedFeedback, FeedbackEvent**

```typescript
// packages/core/src/observability/types/feedback.ts

// ============================================================================
// FeedbackInput (User Input)
// ============================================================================

/**
 * User-provided feedback data for human evaluation of span/trace quality.
 * Used with span.addFeedback() and trace.addFeedback().
 */
export interface FeedbackInput {
  /** Source of the feedback (e.g., "user", "admin", "qa") */
  source: string

  /** Type of feedback (e.g., "thumbs", "rating", "correction") */
  feedbackType: string

  /** Feedback value (e.g., "up"/"down", 1-5, correction text) */
  value: number | string

  /** Optional comment explaining the feedback */
  comment?: string

  /** User who provided the feedback */
  userId?: string

  /** Experiment identifier for A/B testing or evaluation runs */
  experiment?: string

  /** Additional metadata specific to this feedback */
  metadata?: Record<string, unknown>
}

// ============================================================================
// ExportedFeedback (Event Bus Transport)
// ============================================================================

/**
 * Feedback data transported via the event bus.
 * Must be JSON-serializable (Date serializes via toJSON()).
 *
 * Context fields (organizationId, environment, etc.) are stored
 * in metadata, following the same pattern as tracing spans. The metadata
 * is inherited from the span/trace receiving feedback.
 */
export interface ExportedFeedback {
  /** When the feedback was recorded */
  timestamp: Date

  /** Trace receiving feedback */
  traceId: string

  /** Specific span receiving feedback (undefined = trace-level feedback) */
  spanId?: string

  /** Source of the feedback */
  source: string

  /** Type of feedback */
  feedbackType: string

  /** Feedback value */
  value: number | string

  /** Optional comment */
  comment?: string

  /** Experiment identifier for A/B testing */
  experiment?: string

  /**
   * User-defined metadata.
   * Inherited from the span/trace receiving feedback, merged with feedback-specific metadata.
   * Contains context fields: organizationId, environment, serviceName,
   * entityType, entityName, etc. The userId from FeedbackInput is also stored here.
   */
  metadata?: Record<string, unknown>
}

// ============================================================================
// FeedbackEvent (Event Bus Event)
// ============================================================================

/** Feedback event emitted to the ObservabilityBus */
export interface FeedbackEvent {
  type: 'feedback'
  feedback: ExportedFeedback
}
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './feedback'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/feedback.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add feedback types for observability

Add FeedbackInput (user API), ExportedFeedback (event bus transport),
and FeedbackEvent type for attaching user feedback to spans/traces.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 5: Create Event Bus Interface

**Files:**

- Create: `packages/core/src/observability/types/bus.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create bus.ts with ObservabilityEventBus interface and ObservabilityEvent union**

```typescript
// packages/core/src/observability/types/bus.ts

import type { TracingEvent } from './tracing'
import type { LogEvent } from './logging'
import type { MetricEvent } from './metrics'
import type { ScoreEvent } from './scores'
import type { FeedbackEvent } from './feedback'

// ============================================================================
// ObservabilityEventBus Interface
// ============================================================================

/**
 * Generic event bus interface for observability events.
 * Implementations handle buffering, batching, and delivery to exporters.
 */
export interface ObservabilityEventBus<TEvent> {
  /** Emit an event to the bus */
  emit(event: TEvent): void

  /** Subscribe to events. Returns unsubscribe function. */
  subscribe(handler: (event: TEvent) => void): () => void

  /** Flush any buffered events */
  flush(): Promise<void>

  /** Shutdown the bus and release resources */
  shutdown(): Promise<void>
}

// ============================================================================
// ObservabilityEvent Union
// ============================================================================

/**
 * Union of all observability event types.
 * Used by the unified ObservabilityBus that handles all signals.
 */
export type ObservabilityEvent = TracingEvent | LogEvent | MetricEvent | ScoreEvent | FeedbackEvent
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './bus'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/bus.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add event bus interface for observability

Add ObservabilityEventBus generic interface and ObservabilityEvent union
type that combines all signal event types (tracing, logs, metrics,
scores, feedback).

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 6: Create ObservabilityContextMixin Interface

**Files:**

- Create: `packages/core/src/observability/types/context.ts`
- Modify: `packages/core/src/observability/types/index.ts`

**Step 1: Create context.ts with ObservabilityContextMixin**

```typescript
// packages/core/src/observability/types/context.ts

import type { TracingContext } from './tracing'
import type { LoggerContext } from './logging'
import type { MetricsContext } from './metrics'

// ============================================================================
// ObservabilityContextMixin
// ============================================================================

/**
 * Mixin interface that provides unified observability access.
 * All execution contexts (tools, workflow steps, processors) extend this
 * to gain access to tracing, logging, and metrics.
 */
export interface ObservabilityContextMixin {
  /** Tracing context for span operations */
  tracing: TracingContext

  /** Logger for structured logging with trace correlation */
  logger: LoggerContext

  /** Metrics for counters, gauges, histograms */
  metrics: MetricsContext

  /**
   * @deprecated Use `tracing` instead. Will be removed in v2.0.
   */
  tracingContext: TracingContext
}
```

**Step 2: Add exports to types/index.ts**

Add to `packages/core/src/observability/types/index.ts`:

```typescript
export * from './context'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/context.ts packages/core/src/observability/types/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add ObservabilityContextMixin interface

Add mixin interface combining tracing, logger, and metrics contexts.
Includes deprecated tracingContext alias for backward compatibility.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 7: Create No-Op Context Implementations

**Files:**

- Create: `packages/core/src/observability/no-op/context.ts`
- Modify: `packages/core/src/observability/no-op.ts` (add re-exports)

**Step 1: Create no-op/context.ts with no-op logger and metrics**

```typescript
// packages/core/src/observability/no-op/context.ts

import type { LoggerContext } from '../types/logging'
import type { MetricsContext, Counter, Gauge, Histogram } from '../types/metrics'

// ============================================================================
// No-Op Metric Instruments
// ============================================================================

const noOpCounter: Counter = {
  add() {},
}

const noOpGauge: Gauge = {
  set() {},
}

const noOpHistogram: Histogram = {
  record() {},
}

// ============================================================================
// No-Op LoggerContext
// ============================================================================

/**
 * No-op logger context that silently discards all log calls.
 * Used when observability is not configured.
 */
export const noOpLoggerContext: LoggerContext = {
  debug() {},
  info() {},
  warn() {},
  error() {},
}

// ============================================================================
// No-Op MetricsContext
// ============================================================================

/**
 * No-op metrics context that silently discards all metric operations.
 * Used when observability is not configured.
 */
export const noOpMetricsContext: MetricsContext = {
  counter() {
    return noOpCounter
  },
  gauge() {
    return noOpGauge
  },
  histogram() {
    return noOpHistogram
  },
}
```

**Step 2: Create no-op directory and index**

First, create the directory structure. The existing `no-op.ts` file should be checked - if it exists as a file, we need to convert it to a directory with an index.ts.

Check current structure:

```bash
ls -la packages/core/src/observability/no-op*
```

If `no-op.ts` is a file, rename it and create directory:

```bash
mv packages/core/src/observability/no-op.ts packages/core/src/observability/no-op/observability.ts
```

Then create `packages/core/src/observability/no-op/index.ts`:

```typescript
// packages/core/src/observability/no-op/index.ts

export * from './observability'
export * from './context'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/no-op/
git commit -m "$(cat <<'EOF'
feat(core): add no-op logger and metrics contexts

Add noOpLoggerContext and noOpMetricsContext singletons that silently
discard operations when observability is not configured. Reorganize
no-op module as directory for better organization.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 8: Create Context Factory

**Files:**

- Create: `packages/core/src/observability/context-factory.ts`
- Modify: `packages/core/src/observability/index.ts`

**Step 1: Create context-factory.ts**

```typescript
// packages/core/src/observability/context-factory.ts

import type { TracingContext } from './types/tracing'
import type { LoggerContext } from './types/logging'
import type { MetricsContext } from './types/metrics'
import type { ObservabilityContextMixin } from './types/context'
import { noOpLoggerContext, noOpMetricsContext } from './no-op/context'

// ============================================================================
// No-Op TracingContext
// ============================================================================

/**
 * No-op tracing context used when observability is not configured.
 */
const noOpTracingContext: TracingContext = {
  currentSpan: undefined,
}

// ============================================================================
// Context Factory
// ============================================================================

/**
 * Creates an observability context mixin with real or no-op implementations.
 * Use this when constructing execution contexts for tools, workflow steps, etc.
 *
 * @param tracingContext - TracingContext with current span, or undefined for no-op
 * @param loggerContext - LoggerContext for logging, or undefined for no-op
 * @param metricsContext - MetricsContext for metrics, or undefined for no-op
 * @returns ObservabilityContextMixin with all three contexts
 */
export function createObservabilityContext(
  tracingContext?: TracingContext,
  loggerContext?: LoggerContext,
  metricsContext?: MetricsContext,
): ObservabilityContextMixin {
  const tracing = tracingContext ?? noOpTracingContext

  return {
    tracing,
    logger: loggerContext ?? noOpLoggerContext,
    metrics: metricsContext ?? noOpMetricsContext,
    tracingContext: tracing, // deprecated alias
  }
}
```

**Step 2: Export from observability/index.ts**

Add to `packages/core/src/observability/index.ts`:

```typescript
export { createObservabilityContext } from './context-factory'
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/context-factory.ts packages/core/src/observability/index.ts
git commit -m "$(cat <<'EOF'
feat(core): add createObservabilityContext factory

Add factory function that creates ObservabilityContextMixin with real
or no-op implementations. Includes deprecated tracingContext alias
for backward compatibility.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 9: Update Span Interface with addScore/addFeedback

**Files:**

- Modify: `packages/core/src/observability/types/tracing.ts`

**Step 1: Add imports for ScoreInput and FeedbackInput**

At the top of `packages/core/src/observability/types/tracing.ts`, add:

```typescript
import type { ScoreInput } from './scores'
import type { FeedbackInput } from './feedback'
```

**Step 2: Add addScore and addFeedback to Span interface**

Find the `Span` interface in tracing.ts and add these methods:

```typescript
export interface Span<TType extends SpanType> extends BaseSpan<TType> {
  // ... existing properties and methods ...

  /**
   * Add a quality score to this span.
   * Scores are emitted via the ObservabilityBus and can be persisted/exported.
   */
  addScore(score: ScoreInput): void

  /**
   * Add user feedback to this span.
   * Feedback is emitted via the ObservabilityBus and can be persisted/exported.
   */
  addFeedback(feedback: FeedbackInput): void
}
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: May have errors in implementations that need the new methods - note these for later

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/tracing.ts
git commit -m "$(cat <<'EOF'
feat(core): add addScore/addFeedback to Span interface

Extend Span interface with methods for attaching evaluation scores
and user feedback. Implementation will be added in PR 1.2.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 10: Add Trace Interface

**Files:**

- Modify: `packages/core/src/observability/types/tracing.ts`

**Step 1: Add Trace interface after Span interface**

```typescript
// ============================================================================
// Trace Interface
// ============================================================================

/**
 * Trace represents a complete execution trace with all its spans.
 * Used for post-hoc score/feedback attachment via mastra.getTrace().
 */
export interface Trace {
  /** The trace identifier */
  readonly traceId: string

  /** All spans in this trace */
  readonly spans: ReadonlyArray<AnySpan>

  /**
   * Get a specific span by ID.
   * @param spanId - The span identifier
   * @returns The span if found, null otherwise
   */
  getSpan(spanId: string): AnySpan | null

  /**
   * Add a score at the trace level.
   * Uses root span's metadata for context inheritance.
   */
  addScore(score: ScoreInput): void

  /**
   * Add feedback at the trace level.
   * Uses root span's metadata for context inheritance.
   */
  addFeedback(feedback: FeedbackInput): void
}
```

**Step 2: Export Trace from types/index.ts**

Verify Trace is exported (it should be via `export * from './tracing'`).

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/tracing.ts
git commit -m "$(cat <<'EOF'
feat(core): add Trace interface for post-hoc operations

Add Trace interface with spans collection, getSpan lookup, and
trace-level addScore/addFeedback methods. Enables mastra.getTrace()
API for attaching scores/feedback after execution.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 11: Add Exporter Interface Extensions

**Files:**

- Modify: `packages/core/src/observability/types/tracing.ts` (or create exporter.ts if separate)

**Step 1: Find or create exporter interface location**

Check if there's an existing `ObservabilityExporter` interface in tracing.ts or elsewhere. If it exists, modify it. Otherwise, add to tracing.ts or create a new exporter.ts.

**Step 2: Add signal handler methods to ObservabilityExporter**

```typescript
import type { LogEvent } from './logging'
import type { MetricEvent } from './metrics'
import type { ScoreEvent } from './scores'
import type { FeedbackEvent } from './feedback'

/**
 * Interface for observability exporters that handle signal events.
 * Handler presence indicates signal support (no separate capability flags needed).
 */
export interface ObservabilityExporter {
  /** Unique name for this exporter */
  readonly name: string

  // ============================================================================
  // Signal Handlers (implement the ones you support)
  // ============================================================================

  /** Handle tracing events (span started/updated/ended) */
  onTracingEvent?(event: TracingEvent): void | Promise<void>

  /** Handle log events */
  onLogEvent?(event: LogEvent): void | Promise<void>

  /** Handle metric events */
  onMetricEvent?(event: MetricEvent): void | Promise<void>

  /** Handle score events */
  onScoreEvent?(event: ScoreEvent): void | Promise<void>

  /** Handle feedback events */
  onFeedbackEvent?(event: FeedbackEvent): void | Promise<void>

  // ============================================================================
  // Lifecycle
  // ============================================================================

  /** Flush any buffered events */
  flush?(): Promise<void>

  /** Shutdown the exporter and release resources */
  shutdown?(): Promise<void>

  // ============================================================================
  // Backward Compatibility (existing methods)
  // ============================================================================

  /**
   * @deprecated Use onTracingEvent instead. Will delegate to onTracingEvent in BaseExporter.
   */
  exportTracingEvent?(event: TracingEvent): Promise<void>

  /** Initialize exporter with options */
  init?(options: InitExporterOptions): void

  /** Internal: set logger instance */
  __setLogger?(logger: IMastraLogger): void

  /**
   * @deprecated Use span.addScore() or trace.addScore() instead.
   */
  addScoreToTrace?(args: { traceId: string; spanId?: string; score: ScoreInput }): Promise<void>
}
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS or known implementation errors

**Step 4: Commit**

```bash
git add packages/core/src/observability/types/tracing.ts
git commit -m "$(cat <<'EOF'
feat(core): add signal handlers to ObservabilityExporter interface

Extend ObservabilityExporter with onLogEvent, onMetricEvent, onScoreEvent,
onFeedbackEvent handlers. Handler presence indicates signal support.
Keep backward-compatible exportTracingEvent method.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 12: Add Storage Strategy Types

**Files:**

- Modify: `packages/core/src/storage/domains/observability/types.ts`

**Step 1: Add new storage strategy types**

Add after the existing `TracingStorageStrategy` type:

```typescript
// ============================================================================
// Storage Strategy Types
// ============================================================================

/** Existing tracing storage strategies */
export type TracingStorageStrategy = 'realtime' | 'batch-with-updates' | 'insert-only'

/** Logs storage strategies */
export type LogsStorageStrategy = 'realtime' | 'batch'

/** Metrics storage strategies */
export type MetricsStorageStrategy = 'realtime' | 'batch'

/** Scores storage strategies */
export type ScoresStorageStrategy = 'realtime' | 'batch'

/** Feedback storage strategies */
export type FeedbackStorageStrategy = 'realtime' | 'batch'

/** Helper type for strategy getter return values */
export type StrategyHint<T> = { preferred: T; supported: T[] } | null
```

**Step 2: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 3: Commit**

```bash
git add packages/core/src/storage/domains/observability/types.ts
git commit -m "$(cat <<'EOF'
feat(core): add storage strategy types for all signals

Add LogsStorageStrategy, MetricsStorageStrategy, ScoresStorageStrategy,
FeedbackStorageStrategy types and StrategyHint helper type. Follows
existing TracingStorageStrategy pattern.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 13: Add Storage Strategy Getters

**Files:**

- Modify: `packages/core/src/storage/domains/observability/base.ts`

**Step 1: Import new strategy types**

Add imports:

```typescript
import type {
  TracingStorageStrategy,
  LogsStorageStrategy,
  MetricsStorageStrategy,
  ScoresStorageStrategy,
  FeedbackStorageStrategy,
  StrategyHint,
} from './types'
```

**Step 2: Add strategy getter methods to ObservabilityStorage**

Add these methods to the `ObservabilityStorage` class:

```typescript
export abstract class ObservabilityStorage extends StorageDomain {
  // Existing tracingStrategy getter...

  /**
   * Logs storage strategy hint.
   * Returns null by default (logs not supported).
   * Override in adapters that support log storage.
   */
  public get logsStrategy(): StrategyHint<LogsStorageStrategy> {
    return null
  }

  /**
   * Metrics storage strategy hint.
   * Returns null by default (metrics not supported).
   * Override in adapters that support metric storage.
   */
  public get metricsStrategy(): StrategyHint<MetricsStorageStrategy> {
    return null
  }

  /**
   * Scores storage strategy hint.
   * Returns null by default (scores not supported).
   * Override in adapters that support score storage.
   */
  public get scoresStrategy(): StrategyHint<ScoresStorageStrategy> {
    return null
  }

  /**
   * Feedback storage strategy hint.
   * Returns null by default (feedback not supported).
   * Override in adapters that support feedback storage.
   */
  public get feedbackStrategy(): StrategyHint<FeedbackStorageStrategy> {
    return null
  }
}
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/core/src/storage/domains/observability/base.ts
git commit -m "$(cat <<'EOF'
feat(core): add storage strategy getters for all signals

Add logsStrategy, metricsStrategy, scoresStrategy, feedbackStrategy
getters to ObservabilityStorage base class. All return null by default
(opt-in pattern). Adapters override to indicate support.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 14: Update ToolExecutionContext

**Files:**

- Modify: `packages/core/src/tools/types.ts`

**Step 1: Import ObservabilityContextMixin**

Add import:

```typescript
import type { ObservabilityContextMixin } from '../observability/types/context'
```

**Step 2: Update ToolExecutionContext to extend ObservabilityContextMixin**

Change from:

```typescript
export interface ToolExecutionContext<...> {
  mastra?: MastraUnion;
  requestContext?: RequestContext<TRequestContext>;
  tracingContext?: TracingContext;
  // ...
}
```

To:

```typescript
export interface ToolExecutionContext<
  TSuspend = unknown,
  TResume = unknown,
  TRequestContext extends Record<string, any> | unknown = unknown,
> extends Partial<ObservabilityContextMixin> {
  mastra?: MastraUnion
  requestContext?: RequestContext<TRequestContext>
  abortSignal?: AbortSignal
  writer?: ToolStream
  agent?: AgentToolExecutionContext<TSuspend, TResume>
  workflow?: WorkflowToolExecutionContext<TSuspend, TResume>
  mcp?: MCPToolExecutionContext
}
```

Note: Use `Partial<ObservabilityContextMixin>` since these fields are optional in tools.

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: May have errors - note for resolution

**Step 4: Commit**

```bash
git add packages/core/src/tools/types.ts
git commit -m "$(cat <<'EOF'
feat(core): extend ToolExecutionContext with ObservabilityContextMixin

ToolExecutionContext now extends Partial<ObservabilityContextMixin>,
providing tracing, logger, and metrics access. Keeps tracingContext
for backward compatibility via the mixin's deprecated alias.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 15: Update ExecuteFunctionParams (Workflow Steps)

**Files:**

- Modify: `packages/core/src/workflows/step.ts`

**Step 1: Import ObservabilityContextMixin**

Add import:

```typescript
import type { ObservabilityContextMixin } from '../observability/types/context'
```

**Step 2: Update ExecuteFunctionParams**

The type should include the observability fields. Since ExecuteFunctionParams is complex, add the mixin fields:

```typescript
export type ExecuteFunctionParams<...> = {
  // ... existing fields ...
  tracingContext: TracingContext;
} & Partial<Pick<ObservabilityContextMixin, 'tracing' | 'logger' | 'metrics'>>;
```

Or extend with intersection:

```typescript
export type ExecuteFunctionParams<...> = {
  // existing fields
} & { tracing?: TracingContext; logger?: LoggerContext; metrics?: MetricsContext };
```

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS or note errors

**Step 4: Commit**

```bash
git add packages/core/src/workflows/step.ts
git commit -m "$(cat <<'EOF'
feat(core): add observability context to ExecuteFunctionParams

Workflow step execute functions now receive tracing, logger, and metrics
contexts for unified observability access.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 16: Update ProcessorContext

**Files:**

- Modify: `packages/core/src/processors/index.ts`

**Step 1: Import ObservabilityContextMixin**

Add import:

```typescript
import type { ObservabilityContextMixin } from '../observability/types/context'
```

**Step 2: Update ProcessorContext**

```typescript
export interface ProcessorContext<TTripwireMetadata = unknown> extends Partial<ObservabilityContextMixin> {
  abort: (reason?: string, options?: TripWireOptions<TTripwireMetadata>) => never
  retryCount: number
  writer?: ProcessorStreamWriter
  abortSignal?: AbortSignal
}
```

Remove the standalone `tracingContext?: TracingContext;` since it's now in the mixin.

**Step 3: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: PASS or note errors

**Step 4: Commit**

```bash
git add packages/core/src/processors/index.ts
git commit -m "$(cat <<'EOF'
feat(core): extend ProcessorContext with ObservabilityContextMixin

ProcessorContext now extends Partial<ObservabilityContextMixin>,
providing tracing, logger, and metrics access to processors.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 17: Add Mastra Interface Extensions

**Files:**

- Modify: `packages/core/src/mastra/types.ts` (or wherever Mastra interface is defined)

**Step 1: Add getTrace, logger, and metrics to Mastra interface**

Find the Mastra class or interface and add:

```typescript
import type { Trace } from '../observability/types/tracing'
import type { LoggerContext } from '../observability/types/logging'
import type { MetricsContext } from '../observability/types/metrics'

export interface Mastra {
  // ... existing members ...

  /**
   * Retrieve a trace for post-hoc score/feedback attachment.
   * Returns null if trace not found or storage not configured.
   */
  getTrace(traceId: string): Promise<Trace | null>

  /**
   * Direct logger for use outside trace context.
   * Logs emitted via this API will not have trace correlation.
   * Use for startup logs, background jobs, or other non-traced scenarios.
   */
  readonly logger: LoggerContext

  /**
   * Direct metrics API for use outside trace context.
   * Metrics emitted via this API will not have auto-labels from spans.
   * Use for background jobs, startup metrics, or other non-traced scenarios.
   */
  readonly metrics: MetricsContext
}
```

**Step 2: Run typecheck to verify**

Run: `cd packages/core && pnpm typecheck`
Expected: Errors in Mastra class implementation (expected - implementation in PR 1.2)

**Step 3: Commit**

```bash
git add packages/core/src/mastra/
git commit -m "$(cat <<'EOF'
feat(core): add getTrace, logger, metrics to Mastra interface

Extend Mastra interface with:
- getTrace(traceId) for post-hoc score/feedback attachment
- logger property for direct logging outside trace context
- metrics property for direct metrics outside trace context

Implementation will be added in PR 1.2.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 18: Final Verification and Type Index Cleanup

**Files:**

- Verify: `packages/core/src/observability/types/index.ts`
- Verify: `packages/core/src/observability/index.ts`

**Step 1: Ensure all types are exported from types/index.ts**

```typescript
// packages/core/src/observability/types/index.ts

export * from './tracing'
export * from './logging'
export * from './metrics'
export * from './scores'
export * from './feedback'
export * from './bus'
export * from './context'
```

**Step 2: Ensure public API is exported from observability/index.ts**

```typescript
// packages/core/src/observability/index.ts

export * from './types'
export { createObservabilityContext } from './context-factory'
export { noOpLoggerContext, noOpMetricsContext } from './no-op/context'
// ... existing exports ...
```

**Step 3: Run full typecheck**

Run: `cd packages/core && pnpm typecheck`
Document any remaining errors for PR 1.2 implementation work.

**Step 4: Run tests**

Run: `cd packages/core && pnpm test`
Ensure existing tests pass.

**Step 5: Final commit**

```bash
git add packages/core/src/observability/
git commit -m "$(cat <<'EOF'
chore(core): finalize observability type exports

Ensure all new observability types are properly exported from
package public API.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Post-Implementation Checklist

- [ ] All new type files created
- [ ] All types exported from index files
- [ ] `pnpm typecheck` passes (or documents expected implementation errors)
- [ ] `pnpm test:core` passes
- [ ] All commits made with proper messages
- [ ] Ready for PR 1.2 implementation work

---

## Files Created/Modified Summary

| Action | File                                                          |
| ------ | ------------------------------------------------------------- |
| Create | `packages/core/src/observability/types/logging.ts`            |
| Create | `packages/core/src/observability/types/metrics.ts`            |
| Create | `packages/core/src/observability/types/scores.ts`             |
| Create | `packages/core/src/observability/types/feedback.ts`           |
| Create | `packages/core/src/observability/types/bus.ts`                |
| Create | `packages/core/src/observability/types/context.ts`            |
| Create | `packages/core/src/observability/no-op/context.ts`            |
| Create | `packages/core/src/observability/context-factory.ts`          |
| Modify | `packages/core/src/observability/types/index.ts`              |
| Modify | `packages/core/src/observability/types/tracing.ts`            |
| Modify | `packages/core/src/observability/index.ts`                    |
| Modify | `packages/core/src/observability/no-op.ts` → `no-op/index.ts` |
| Modify | `packages/core/src/storage/domains/observability/types.ts`    |
| Modify | `packages/core/src/storage/domains/observability/base.ts`     |
| Modify | `packages/core/src/tools/types.ts`                            |
| Modify | `packages/core/src/workflows/step.ts`                         |
| Modify | `packages/core/src/processors/index.ts`                       |
| Modify | `packages/core/src/mastra/types.ts` (or index.ts)             |
