---
title: "Agent Dependencies | Agent Documentation | Mastra"
description: Learn how to use Mastra's dependency injection system to provide runtime configuration to agents and tools in a type-safe manner.
---

# Agent Dependencies

Mastra's Agent class supports a powerful dependency injection system that allows you to securely pass runtime configuration to tools in a type-safe manner. With strong type safety through Zod schemas, you can ensure your agents have everything they need at runtime.

## Overview

The dependency system allows you to:

1. Define a schema for dependencies using Zod
2. Pass dependencies to the agent at runtime
3. Access those dependencies in tools

The type and runtime systems work together to ensure:

- The type system helps you define the correct shape of dependencies, but doesn't strictly enforce their presence
- Dependencies you provide must match the schema you defined
- Dependencies are properly passed to tools and are validated against each tool's own schema at runtime

This approach gives you flexibility while still providing validation where it matters most - when the agent is actually executing.

## Basic Usage

### 1. Define a dependencies schema

```typescript
import { z } from "zod";

export const weatherDepsSchema = z.object({
  apiKey: z.string(),
  userId: z.number(),
  temperatureUnit: z.enum(['celsius', 'fahrenheit']),
});
```

### 2. Create an agent with the schema

```typescript
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";
import { weatherDepsSchema } from "../schemas/dependencies";

export const weatherAgent = new Agent({
  name: "WeatherAgent",
  instructions: "You are a helpful agent that provides weather information",
  model: openai("gpt-4o"),
  dependenciesSchema: weatherDepsSchema,
});
```

### 3. Provide dependencies when generating responses

```typescript
const agent = mastra.getAgent("weatherAgent");

// TypeScript enforces that the provided dependencies match the schema
const response = await agent.generate("What's the weather like today?", {
  dependencies: {
    apiKey: process.env.WEATHER_API_KEY,
    userId: 123,
    temperatureUnit: 'celsius',
  },
});

console.log(response.text);
```

> ⚠️ Validation Errors: If dependencies are missing or incorrect, Mastra throws clear validation errors at runtime.

## Creating Tools with Dependencies

Tools can access the dependencies:

```typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { weatherDepsSchema } from "../schemas/dependencies";

export const weatherTool = createTool({
  id: "getWeather",
  description: "Get the current weather for a location",
  inputSchema: z.object({
    location: z.string().describe("The location to get weather for"),
  }),
  dependenciesSchema: weatherDepsSchema, // Same schema as the agent
  execute: async ({ context, dependencies }) => {
    const { apiKey, userId, temperatureUnit } = dependencies;

    console.log(`User ${userId} requested weather for ${context.location}`);

    const weather = await fetchWeather(context.location, {
      apiKey, 
      temperatureUnit
    });
    
    return { result: weather, };
  },
});

async function fetchWeather(
  location: string,
  { apiKey, temperatureUnit }: { apiKey: string; temperatureUnit: string }
) {
  // Implementation would use the apiKey to call a weather API
  return {
    location,
    temperature: "72°F",
    conditions: "Sunny",
    unit: temperatureUnit
  };
}
```

## Type Safety Examples

### With Dependencies Schema

```typescript
// Agent with dependencies schema
const agentWithDeps = new Agent({
  name: "WeatherAgent",
  instructions: "You are an agent that can fetch weather information",
  model: openai("gpt-4o"),
  dependenciesSchema: weatherDepsSchema,
});

// CORRECT: Providing required dependencies
await agentWithDeps.generate("What is the weather?", {
  dependencies: {
    apiKey: process.env.WEATHER_API_KEY,
    userId: 123,
    temperatureUnit: 'celsius',
  },
});

// ERROR: Missing required dependencies
await agentWithDeps.generate("What is the weather?");
// ⚠️ Will throw: "Dependencies validation failed"

// ERROR: Wrong dependency structure
await agentWithDeps.generate("What is the weather?", {
  dependencies: {
    key: process.env.WEATHER_API_KEY, // Wrong property name
    id: 123, // Wrong property name
    unit: 'celsius', // Wrong property name
  },
});
// ⚠️ Will throw: "Dependencies validation failed"
```

## Full Example

```typescript
import { openai } from '@ai-sdk/openai';
import { Agent } from '@mastra/core/agent';
import { createTool } from '@mastra/core/tools';
import { config } from 'dotenv';
import { z } from 'zod';

config();

// Step 1: Define your dependencies schema
const depsSchema = z.object({
  weatherApiKey: z.string(),
  temperatureUnit: z.enum(['celsius', 'fahrenheit']),
  userName: z.string().optional(),
});

type DependenciesType = z.infer<typeof depsSchema>;

// Step 2: Define a function to fetch real weather data using OpenWeatherMap API
async function fetchWeather(
  location: string,
  { weatherApiKey, temperatureUnit }: { weatherApiKey: string; temperatureUnit: 'celsius' | 'fahrenheit' },
) {
  const units = temperatureUnit === 'celsius' ? 'metric' : 'imperial';
  const loc = encodeURIComponent(location);
  const url = `https://api.openweathermap.org/data/2.5/weather?q=${loc}&appid=${weatherApiKey}&units=${units}`;

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Error fetching weather: ${response.statusText}`);
  }

  const dataSchema = z.object({
    name: z.string(),
    main: z.object({
      temp: z.number(),
      humidity: z.number(),
    }),
    weather: z.array(
      z.object({
        description: z.string(),
      }),
    ),
  });

  const data = dataSchema.parse(await response.json());

  return {
    location: data.name,
    temperature: data.main.temp,
    conditions: data.weather[0]?.description ?? 'unknown',
    humidity: `${data.main.humidity}%`,
    unit: temperatureUnit,
  };
}

// Step 3: Create a tool to get the weather forecast
const weatherTool = createTool({
  id: 'getWeatherForecast',
  description: 'Get the current weather forecast for a location',
  inputSchema: z.object({
    location: z.string().describe('The city or location to get weather for'),
  }),
  dependenciesSchema: depsSchema,
  execute: async ({ context, dependencies }) => {
    return await fetchWeather(context.location, {
      weatherApiKey: dependencies.weatherApiKey,
      temperatureUnit: dependencies.temperatureUnit,
    });
  },
});

// Step 4: Create an agent with empty instructions
const agent = new Agent({
  name: 'WeatherAgent',
  instructions: '', // Start with empty instructions
  model: openai('gpt-4o'),
  dependenciesSchema: depsSchema,
  tools: { weatherTool },
});

// Step 5: Function to build instructions with dependencies
function buildInstructions(deps: DependenciesType): string {
  return `You are an agent that can fetch weather information.
  If the user's name is provided (${deps.userName}), greet them by name.
  Always display temperatures in ${deps.temperatureUnit}.`;
}

// Step 6: Run the agent with provided dependencies and runtime instructions
async function main() {
  const apiKey = process.env.WEATHER_API_KEY;
  if (!apiKey) {
    throw new Error('Missing WEATHER_API_KEY environment variable');
  }

  console.log('Getting weather in Fahrenheit:');

  try {
    const result = await agent.generate('What is the weather in San Francisco?', {
      instructions: buildInstructions(dependencies),
      dependencies: {
        weatherApiKey: apiKey,
        temperatureUnit: 'fahrenheit' as const,
        userName: 'John',
      },
    });
    console.log(result.text);
  } catch (error) {
    console.error('Error:', error);
  }
}

void main().catch(console.error);
```

Output Example:

```
Getting weather in Fahrenheit:
Hello John! The current weather in San Francisco is 45.9°F with a few clouds and a humidity of 72%.
```

## Override Instructions at Runtime

While dependencies are primarily used for tools, you can also provide custom instructions at runtime:

```typescript
const agent = mastra.getAgent("weatherAgent");

// Override instructions when generating a response
const response = await agent.generate("What's the weather like today?", {
  instructions: "You are a pirate weather forecaster. Always speak like a pirate when giving weather information.",
  dependencies: {
    apiKey: process.env.WEATHER_API_KEY,
    userId: 123,
    temperatureUnit: 'celsius',
  },
});

console.log(response.text); // Outputs a pirate-themed weather forecast
```

## Advanced Topics

### Behavior Without a Schema

If you create an agent without a dependencies schema:

```typescript
const agent = new Agent({
  name: "SimpleAgent",
  instructions: "You are a simple agent",
  model: openai("gpt-4o"),
  // No dependenciesSchema defined
});
```

At runtime:

1. If you pass dependencies, they will be passed through to tools
2. No validation is performed when no schema is defined
3. If you don't pass dependencies or pass undefined/null, an empty object `{}` will be provided instead

However, at the compile-time level:

```typescript
// This is allowed when no schema is defined
await agent.generate("Tell me a joke", {
  dependencies: {
    someValue: "some-data", // Works in runtime but may not be type-safe
  },
});

// TypeScript WILL produce errors when you try to use tools that expect a specific schema
const toolWithSchema = createTool({
  id: "toolWithSchema",
  dependenciesSchema: z.object({
    apiKey: z.string(),
  }),
  // ... other properties
});

// This causes TypeScript errors even though runtime works
const agentWithoutSchema = new Agent({
  name: "NoSchemaAgent",
  tools: {
    toolWithSchema, // Error: Tool expects schema that agent doesn't provide
  },
  model: openai("gpt-4o"),
});
```

### Tools with Different Dependency Schemas

At the compile-time level, Mastra enforces that agent and tools have matching dependency schemas. However, there are two runtime nuances:

1. **Subset Schemas**: If a tool's schema is a subset of the agent's schema, it will work properly at runtime.

2. **Incompatible Schemas**: If a tool's schema is completely different from the agent's schema, it will fail at runtime.

For tools with different schemas, you may need to use type casting, but **this approach is not recommended** and should be used with caution:

```typescript
// This type casting lets TypeScript compile but may fail at runtime
const agent = new Agent({
  tools: {
    differentTool: differentTool as any, // Not recommended
  },
  dependenciesSchema: agentDepsSchema,
});
```

## Runtime Validation

Mastra performs runtime validation of dependencies using the Zod schema:

1. Agent-level validation when the agent has a dependencies schema
2. Tool-level validation when a tool has its own dependencies schema
3. Custom validation inside tools (e.g., checking value ranges)

## Best Practices

1. **Define clear schemas**: Make your dependency schemas clear and specific.

2. **Match agent and tool schemas**: Tools should generally use the exact same dependency schema as the agent they'll be registered with. This ensures full type safety and prevents runtime errors.

3. **Use caution with subset schemas**: While it's technically possible to use subset schemas for tools, this approach is error-prone and requires explicit type casting. Only use this approach when absolutely necessary, and carefully test for runtime errors.

4. **Avoid type casting when possible**: Type casting (especially using `as any`) bypasses TypeScript's safety checks and can lead to runtime errors. When a tool truly needs different dependencies, consider creating a wrapper that properly maps agent dependencies to tool dependencies.

5. **Test error cases**: Ensure your code handles validation failures gracefully.

6. **Document dependencies**: Clearly document what each dependency is for and which tools require which dependencies.

7. **Use consistent naming**: Use consistent naming conventions across your application to avoid confusion when dependencies are passed between components.
