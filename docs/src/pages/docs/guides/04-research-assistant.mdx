---
title: "Building a Research Paper Assistant | Mastra RAG Guides"
description: Guide on creating an AI research assistant that can analyze and answer questions about academic papers using RAG.
---

import { Steps } from "nextra/components";

# Building a Research Paper Assistant with RAG

In this guide, we'll create an AI research assistant that can analyze academic papers and answer specific questions about their content using Retrieval Augmented Generation (RAG).

We'll use the GPT-3 paper [Language Models are Few-Shot Learners](https://arxiv.org/pdf/2005.14165.pdf) as our example.

## Understanding RAG Components

Let's understand how RAG works and how we'll implement each component:

1. Knowledge Store/Index
   - Converting text into vector representations
   - Creating numerical representations of content
   - Implementation: We'll use OpenAI's text-embedding-3-small to create embeddings and store them in PgVector

2. Retriever
   - Finding relevant content via similarity search
   - Matching query embeddings with stored vectors
   - Implementation: We'll use PgVector to perform similarity searches on our stored embeddings

3. Generator
   - Processing retrieved content with an LLM
   - Creating contextually informed responses
   - Implementation: We'll use GPT-4o-mini to generate answers based on retrieved content

Our implementation will:
1. Process the GPT-3 paper into embeddings
2. Store them in PgVector for quick retrieval
3. Use similarity search to find relevant sections
4. Generate accurate responses using retrieved context

## Project Structure

```
research-assistant/
├── src/
│   ├── agents/
│   │   └── researchAgent.ts
│   └── index.ts
├── package.json
└── .env
```

<Steps>
### Initialize Project and Install Dependencies

First, create a new directory for your project and navigate into it:

```bash
mkdir research-assistant
cd research-assistant
```

Initialize a new Node.js project and install the required dependencies:

```bash
npm init -y
npm install @mastra/core @mastra/rag @mastra/pg @ai-sdk/openai zod
```

Set up environment variables for API access and database connection:

```bash filename=".env" copy
OPENAI_API_KEY=your_openai_api_key
POSTGRES_CONNECTION_STRING=your_connection_string
```

Create the necessary files for our project:

```bash
mkdir -p src/agents
touch src/agents/researchAgent.ts src/index.ts
```

### Create the Research Assistant Agent

Now we'll create our RAG-enabled research assistant. The agent uses:
- A [Vector Query Tool](/docs/reference/tools/vector-query-tool) for performing semantic search over our vector store to find relevant content in our papers.
- GPT-4o-mini for understanding queries and generating responses
- Custom instructions that guide the agent on how to analyze papers, use retrieved content effectively, and acknowledge limitations

```typescript copy showLineNumbers filename="src/agents/researchAgent.ts"
import { Agent } from '@mastra/core/agent';
import { openai } from '@ai-sdk/openai';
import { createVectorQueryTool } from '@mastra/rag';

// Create a tool for semantic search over our paper embeddings
const vectorQueryTool = createVectorQueryTool({
  vectorStoreName: 'pgVector',
  indexName: 'papers',
  model: openai.embedding('text-embedding-3-small'),
});

export const researchAgent = new Agent({
  name: 'Research Assistant',
  instructions: 
    `You are a helpful research assistant that analyzes academic papers. 
    Use the tool provided to find relevant information from papers, 
    and provide accurate, well-supported answers based on the retrieved content. 
    If the available content does not fully address a question, acknowledge this limitation.`,
  model: openai('gpt-4o-mini'),
  tools: {
    vectorQueryTool,
  },
});
```

### Set Up the Mastra Instance and Vector Store

```typescript copy showLineNumbers filename="src/index.ts"
import { MDocument } from '@mastra/rag';
import { Mastra } from '@mastra/core';
import { PgVector } from '@mastra/pg';
import { embedMany } from 'ai';

import { researchAgent } from './agents/researchAgent';

const pgVector = new PgVector(process.env.POSTGRES_CONNECTION_STRING!);
export const mastra = new Mastra({
  agents: { researchAgent },
  vectors: { pgVector },
});
```

### Load and Process the Paper

This step handles the initial document processing. We:
1. Fetch the research paper from its URL
2. Convert it into a document object
3. Split it into smaller, manageable chunks for better processing

```typescript copy showLineNumbers{14} filename="src/index.ts"
// Load the paper
const paperUrl = "https://arxiv.org/pdf/2005.14165.pdf";
const response = await fetch(paperUrl);
const paperText = await response.text();

// Create document and chunk it
const doc = MDocument.fromText(paperText);
const chunks = await doc.chunk({
  strategy: 'recursive',
  size: 512,
  overlap: 50,
  separator: '\n',
});
```

### Create and Store Embeddings

Finally, we'll prepare our content for RAG by:
1. Generating embeddings for each chunk of text
2. Creating a vector store index to hold our embeddings
3. Storing both the embeddings and metadata (original text and source information) in our vector database

> **Note**: This metadata is crucial as it allows us to return the actual content when the vector store finds relevant matches.

This allows our agent to efficiently search and retrieve relevant information.

```typescript copy showLineNumbers{28} filename="src/index.ts"
// Generate embeddings
const { embeddings } = await embedMany({
  model: openai.embedding('text-embedding-3-small'),
  values: chunks.map(chunk => chunk.text),
});

// Get the vector store instance from Mastra
const vectorStore = mastra.getVector('pgVector');

// Create an index for our paper chunks
await vectorStore.createIndex({
  indexName: 'papers',
  dimension: 1536,
});

// Store embeddings
await vectorStore.upsert({
  indexName: 'papers',
  vectors: embeddings,
  metadata: chunks.map(chunk => ({
    text: chunk.text,
    source: 'gpt3-paper'
  })),
});
```

This will:
1. Load the paper from the URL
2. Split it into manageable chunks
3. Generate embeddings for each chunk
4. Store both the embeddings and text in our vector database

### Test the Assistant

Let's test our research assistant with different types of queries:

```typescript filename="src/index.ts" showLineNumbers{52} copy
const agent = mastra.getAgent('researchAgent');

// Query about experimental findings
const query1 = "What were the main findings about few-shot performance?";
const response1 = await agent.generate(query1);
console.log("\nQuery:", query1);
console.log("Response:", response1.text);
```

You should see output like:
```
Query: What were the main findings about few-shot performance?
Response: The GPT-3 paper demonstrated that larger language models exhibit strong few-shot learning capabilities. 
Specifically, they found that models could perform tasks with just a few examples, or even zero examples, 
showing performance that scaled predictably with model size. The 175B parameter model achieved particularly 
strong results, approaching or matching SOTA performance on many NLP tasks without any gradient updates or 
fine-tuning.
```

Let's try a question about technical details:
```typescript filename="src/index.ts" showLineNumbers{60} copy
// Query about technical details
const query2 = "Explain the scaling laws they discovered";
const response2 = await agent.generate(query2);
console.log("\nQuery:", query2);
console.log("Response:", response2.text);
```

Output:
```
Query: Explain the scaling laws they discovered
Response: The researchers found that model performance improved smoothly and predictably with scale. 
They observed that performance improved roughly log-linearly with model size, compute, and dataset size. 
Specifically, they found that doubling the model size consistently resulted in a linear improvement in 
performance across their measured tasks, suggesting that even larger models could continue this trend.
```

Finally, let's ask about broader implications:
```typescript filename="src/index.ts" showLineNumbers{66} copy
// Query about broader implications
const query3 = "What limitations and risks were identified?";
const response3 = await agent.generate(query3);
console.log("\nQuery:", query3);
console.log("Response:", response3.text);
```

Output:
```
Query: What limitations and risks were identified?
Response: The paper identified several key limitations and risks. Computationally, the models require 
significant resources to train and deploy. They also noted potential misuse risks, including generating 
misleading information or spam. The authors specifically highlighted concerns about bias in training data 
and the model's potential to amplify these biases. They also acknowledged limitations in their evaluation 
methodology and the need for more robust testing frameworks.
```

### Serve the Application

Start the Mastra server to expose your research assistant via API:

```bash
mastra dev --dir src
```

Your research assistant will be available at:
```
http://localhost:4111/api/agents/researchAgent/generate
```

Test with curl:

```bash
curl -X POST http://localhost:4111/api/agents/researchAgent/generate \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      { "role": "user", "content": "What were the main findings about few-shot performance?" }
    ]
  }'
```
</Steps>

## Advanced RAG Examples

Explore these examples for more advanced RAG techniques:
- [Filter RAG](/examples/rag/filter-rag) for filtering results using metadata
- [Cleanup RAG](/examples/rag/cleanup-rag) for optimizing information density
- [Chain of Thought RAG](/examples/rag/cot-rag) for complex reasoning queries
- [Rerank RAG](/examples/rag/rerank/rerank-rag) for improved result relevance
