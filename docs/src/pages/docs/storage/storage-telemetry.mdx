---
title: Using Storage with Telemetry | Mastra Docs
description: Guide on integrating OpenTelemetry with Mastra's storage system for monitoring and tracing.
---

# Using Storage with Telemetry

Mastra integrates with OpenTelemetry to provide comprehensive monitoring and tracing capabilities for storage operations. This helps you understand performance, diagnose issues, and optimize your application.

## Storage Telemetry Setup

### Basic Configuration

```ts showLineNumbers copy
import { DefaultStorage } from '@mastra/core/storage';
import { TelemetryConfig } from '@mastra/core/telemetry';

// Initialize storage with telemetry
const storage = new DefaultStorage({
  name: 'my-storage',  // Used in telemetry spans
  config: {
    // Database configuration
    url: 'file:app.db',  // SQLite database path
    
    // Connection settings
    pool: {
      min: 2,    // Minimum connections
      max: 10,   // Maximum connections
    },
  },
  
  // Telemetry configuration
  telemetry: new TelemetryConfig({
    // Service identification
    serviceName: 'my-service',  // For trace grouping
    serviceVersion: '1.0.0',    // For version tracking
    
    // Feature flags
    enabled: true,        // Enable telemetry
    debug: false,         // Debug logging
    
    // Trace configuration
    samplingRatio: 1.0,   // Sample all traces
    propagation: true,    // Trace context propagation
  }),
});

// This setup enables:
// 1. SQL operation tracing
// 2. Performance monitoring
// 3. Error tracking
// 4. Resource usage metrics
```

### Custom Exporter

Configure a custom trace exporter:

```ts showLineNumbers copy
import { DefaultStorage } from '@mastra/core/storage';
import { OTLPTraceExporter } from '@mastra/core/telemetry';

const storage = new DefaultStorage({
  name: 'my-storage',
  config: {
    url: 'file:app.db',
  },
  telemetry: {
    exporter: new OTLPTraceExporter({
      url: 'http://localhost:4318/v1/traces',
    }),
  },
});
```

## Trace Operations

### Storage Operations

Mastra automatically traces key storage operations:

```ts showLineNumbers copy
// Storage operations are automatically traced

// 1. Save messages with prepared statements
await storage.saveMessages({
  messages: [{
    threadId: 'thread-123',
    content: 'Hello',
  }],
}); // Trace: storage.saveMessages
// - SQL preparation
// - Parameter binding
// - Execution time
// - Row count

// 2. Retrieve messages with filters
await storage.getMessages({
  threadId: 'thread-123',
  selectBy: {
    limit: 10,
    order: 'desc',
  },
}); // Trace: storage.getMessages
// - Query planning
// - Index usage
// - Result size
// - Cache hits

// 3. Thread management operations
await storage.saveThread({
  thread: {
    resourceId: 'user-123',
    metadata: {
      category: 'support',
    },
  },
}); // Trace: storage.saveThread
// - JSON serialization
// - Transaction timing
// - Constraint checks
// - Index updates

// Each operation generates spans with:
// 1. SQL operation details
// 2. Parameter values (sanitized)
// 3. Execution metrics
// 4. Error context if failed
```

### Vector Operations

Vector operations are also traced:

```ts showLineNumbers copy
// Vector operations generate traces
await store.createIndex({
  indexName: 'my-collection',
  dimension: 1536,
}); // Generates trace: vector.createIndex

await store.upsert({
  indexName: 'my-collection',
  vectors: embeddings,
}); // Generates trace: vector.upsert

await store.search({
  indexName: 'my-collection',
  vector: queryVector,
}); // Generates trace: vector.search
```

## Trace Analysis

### Span Structure

Each trace includes detailed information:

```ts showLineNumbers copy
// Example trace span for a storage operation
{
  // Span identification
  id: 'span-123',           // Unique span ID
  parentSpanId: 'parent-span-123',  // Parent operation
  traceId: 'trace-123',     // Trace grouping
  
  // Operation details
  name: 'storage.saveMessages',  // Operation name
  scope: 'mastra-storage',      // Component scope
  kind: 'internal',             // Operation type
  
  // Database attributes
  attributes: {
    // Database information
    'db.system': 'libsql',     // Database type
    'db.name': 'app.db',       // Database name
    'db.operation': 'insert',   // SQL operation
    'db.statement': '/* Prepared */',  // Sanitized SQL
    
    // Operation context
    'thread.id': 'thread-123',  // Thread context
    'message.count': 1,         // Operation size
    
    // Performance metrics
    'db.connection_id': 'conn-1',  // Connection used
    'db.rows_affected': 1,      // Operation impact
    'db.execution_time_ms': 50, // SQL execution time
    
    // Error handling
    'error.type': null,         // Error if failed
    'error.message': null,      // Error details
  },
  
  // Timing information
  startTime: 1647523600000,  // Operation start
  endTime: 1647523601000,    // Operation end
  
  // Additional context
  events: [
    {
      name: 'db.prepare',
      timestamp: 1647523600010,
    },
    {
      name: 'db.execute',
      timestamp: 1647523600500,
    },
  ],
  
  // Resource information
  resource: {
    'service.name': 'my-service',
    'service.version': '1.0.0',
    'host.name': 'server-1',
  },
}
```

### Performance Metrics

Key metrics tracked:

- Operation latency
- Success/failure rates
- Batch sizes
- Resource usage

## Telemetry Integration

### Memory Integration

Tracing memory operations:

```ts showLineNumbers copy
import { Memory } from '@mastra/core/memory';

const memory = new Memory({
  storage,
  telemetry: {
    enabled: true,
    serviceName: 'memory-service',
  },
});

// Memory operations are traced
await memory.remember({
  threadId: 'thread-123',
  messages: messages,
}); // Generates trace: memory.remember
```

### Agent Integration

Tracing agent operations:

```ts showLineNumbers copy
import { Agent } from '@mastra/core/agent';

const agent = new Agent({
  memory,
  telemetry: {
    enabled: true,
    serviceName: 'agent-service',
  },
});

// Agent operations create traces
await agent.stream('Hello', {
  threadId: 'thread-123',
}); // Generates traces: agent.stream -> memory.remember -> storage.saveMessages
```

## Best Practices

### Configuration

```ts showLineNumbers copy
// Configure telemetry with best practices
const telemetry = new TelemetryConfig({
  // Environment-based configuration
  enabled: process.env.NODE_ENV === 'production',  // Production only
  debug: process.env.NODE_ENV === 'development',   // Debug in dev
  
  // Sampling configuration
  samplingRatio: 0.1,  // Sample 10% of traces
  samplingRules: [
    // Always trace errors
    { target: 'error', sample: 1.0 },
    // Sample slow operations more
    { target: 'duration > 1s', sample: 0.5 },
  ],
  
  // Batch processing for efficiency
  batchSize: 100,         // Traces per batch
  batchTimeout: 5000,     // Flush after 5s
  maxQueueSize: 1000,     // Maximum queued traces
  
  // Default context attributes
  defaultAttributes: {
    // Service identification
    'service.name': 'my-service',
    'service.version': '1.0.0',
    
    // Deployment context
    'deployment.environment': 'production',
    'deployment.region': 'us-west-2',
    
    // Application context
    'app.name': 'mastra-api',
    'app.version': '2.1.0',
  },
  
  // Resource limits
  limits: {
    eventSize: 256 * 1024,    // Max event size
    attributeCount: 128,       // Max attributes
    attributeLength: 4096,     // Max attribute length
    spanAttributeCount: 32,    // Max span attributes
  },
  
  // Error handling
  onError: (error) => {
    console.error('Telemetry error:', error);
    // Alert monitoring system
    alertMonitoring(error);
  },
});

// This configuration:
// 1. Optimizes trace collection
// 2. Manages resource usage
// 3. Provides error context
// 4. Scales with application
```

### Error Handling

```ts showLineNumbers copy
// Configure storage with robust error handling
const storage = new DefaultStorage({
  telemetry: {
    enabled: true,
    
    // Comprehensive error handling
    onError: (error) => {
      // 1. Log error details
      console.error('Telemetry error:', {
        error: error.message,
        type: error.name,
        stack: error.stack,
        context: error.context,
      });
      
      // 2. Handle specific error types
      switch (error.name) {
        case 'ConnectionError':
          // Retry with exponential backoff
          retryWithBackoff(() => {
            return storage.reconnect();
          });
          break;
          
        case 'QuotaExceededError':
          // Reduce sampling rate
          storage.updateTelemetry({
            samplingRatio: 0.01,  // 1% sampling
          });
          break;
          
        case 'ConfigurationError':
          // Fallback to default config
          storage.resetTelemetry();
          break;
          
        default:
          // Disable problematic features
          storage.disableTelemetry();
      }
      
      // 3. Alert monitoring systems
      alertMonitoring({
        service: 'storage-telemetry',
        error: error,
        severity: 'high',
      });
      
      // 4. Record error metrics
      recordMetric('telemetry.errors', 1, {
        type: error.name,
        handled: true,
      });
    },
    
    // Recovery configuration
    recovery: {
      maxRetries: 3,
      backoffMs: 1000,
      timeout: 30000,
    },
  },
});

// This setup provides:
// 1. Detailed error tracking
// 2. Automatic recovery
// 3. Graceful degradation
// 4. Monitoring integration
```

## Next Steps

- Learn about [Storage as Memory](./memory-storage.mdx)
- Explore [Vector Storage](./vector-storage.mdx)
- See [Telemetry Examples](../../examples/telemetry/)