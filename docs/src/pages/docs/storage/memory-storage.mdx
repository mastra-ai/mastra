---
title: Storage as Memory | Mastra Docs
description: Technical guide on using storage systems for memory management in Mastra, including configuration and optimization.
---

# Storage as Memory

Mastra's storage system integrates deeply with its memory management capabilities, providing persistent storage for conversation history and contextual information.

## Memory Storage Integration

### Default Configuration

By default, Memory uses LibSQL for both message storage and vector operations:

```ts showLineNumbers copy
import { Memory } from '@mastra/core/memory';

// Initialize memory with default LibSQL storage
const memory = new Memory({
  name: 'my-memory',  // Used for logging and identification
  options: {
    // Configure message retention
    lastMessages: 40,  // Keep last 40 messages for context window
    
    // Enable semantic search with default FastEmbed
    semanticRecall: true,  // Uses bge-small-en-v1.5 embeddings
  },
});

// This setup will:
// 1. Create an in-memory SQLite database
// 2. Initialize FastEmbed for vector operations
// 3. Set up default tables for messages and threads
// 4. Configure automatic cleanup of old messages
```

### Custom Storage Configuration

You can configure Memory to use any storage implementation:

```ts showLineNumbers copy
import { Memory } from '@mastra/core/memory';
import { DefaultStorage } from '@mastra/core/storage';

const storage = new DefaultStorage({
  name: 'custom-storage',
  config: {
    url: 'file:memory.db',
  },
});

const memory = new Memory({
  name: 'my-memory',
  storage,
  options: {
    lastMessages: 40,
    semanticRecall: true,
  },
});
```

## Storage Operations

### Message Storage

The storage system handles message persistence:

```ts showLineNumbers copy
// Store new messages in a thread
await storage.saveMessages({
  messages: [{
    threadId: 'thread-123',  // Links message to a conversation
    role: 'user',           // Message source (user/assistant/system)
    content: 'Message content',
    createdAt: new Date(),  // Timestamp for ordering
    metadata: {
      source: 'chat',      // Origin of the message
      language: 'en',      // Content language
      // Add custom metadata for filtering
      priority: 'high',
      category: 'support',
    },
  }],
});

// Retrieve messages with memory configuration
const messages = await storage.getMessages({
  threadId: 'thread-123',  // Get messages from this thread
  selectBy: {
    limit: 40,            // Maximum messages to return
    before: new Date(),    // Get messages before this time
    // Optional filters
    filter: {
      role: ['user', 'assistant'],  // Only these roles
      metadata: {
        priority: 'high',   // Filter by metadata
      },
    },
  },
  threadConfig: {
    lastMessages: 40,       // Recent message window
    semanticRecall: true,   // Include similar messages
  },
});

// Messages are returned with:
// 1. Chronological ordering
// 2. Metadata preserved
// 3. Vector similarity scores (if semanticRecall)
// 4. Thread context
```

### Thread Management

Threads organize conversations and maintain context:

```ts showLineNumbers copy
// Create thread
const thread = await storage.saveThread({
  thread: {
    resourceId: 'user-123',
    title: 'Support Chat',
    metadata: {
      category: 'support',
      priority: 'high',
    },
  },
});

// Update thread metadata
await storage.updateThread({
  id: thread.id,
  title: 'Resolved: Support Chat',
  metadata: {
    status: 'resolved',
    resolvedAt: new Date(),
  },
});
```

## Memory Optimization

### Process Isolation

When using `:memory:` storage:

```ts showLineNumbers copy
// Test environment with isolated memory
const testStorage = new DefaultStorage({
  name: 'test-storage',
  config: { 
    url: ':memory:',  // Creates new SQLite database in memory
    // Perfect for testing because:
    // 1. Each test gets clean state
    // 2. No file system interaction needed
    // 3. Fast setup and teardown
    // 4. No cleanup required
  },
});

// Development server with separate memory
const devStorage = new DefaultStorage({
  name: 'dev-storage',
  config: { 
    url: ':memory:',  // Different process = different database
    // Benefits for development:
    // 1. No test data pollution
    // 2. Quick restarts (no file locks)
    // 3. Easy state reset
    // 4. Parallel development instances
  },
});

// Each process gets its own isolated database:
// - Test runner process → clean test database
// - Dev server process → separate dev database
// - CI/CD process → isolated CI database
```

Benefits:
- Clean test environment
- No data pollution
- Automatic cleanup

### Persistent Storage

For production use:

```ts showLineNumbers copy
const prodStorage = new DefaultStorage({
  name: 'prod-storage',
  config: { url: 'file:prod.db' },
});
```

Benefits:
- Data persistence
- Cross-process sharing
- Backup support

## Memory Configuration Options

### Basic Settings

```ts showLineNumbers copy
const memory = new Memory({
  storage,
  options: {
    // Recent message handling
    lastMessages: 40,
    
    // Semantic search configuration
    semanticRecall: {
      topK: 5,
      messageRange: 2,
    },
    
    // Thread options
    threads: {
      generateTitle: true,
    },
  },
});
```

### Use Case Configurations

```ts showLineNumbers copy
// Chat support - minimal context
const supportMemory = new Memory({
  storage,
  options: {
    lastMessages: 10,
    semanticRecall: false,
  },
});

// Project management - extensive context
const projectMemory = new Memory({
  storage,
  options: {
    lastMessages: 50,
    semanticRecall: {
      topK: 10,
      messageRange: 3,
    },
  },
});
```

## Next Steps

- Learn about [Vector Storage](./vector-storage.mdx)
- Configure [Storage Telemetry](./storage-telemetry.mdx)
- See [Memory Examples](../../examples/memory/)