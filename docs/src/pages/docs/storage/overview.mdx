---
title: Storage in Mastra | Mastra Docs
description: Technical overview of Mastra's storage system, detailing its integration with memory and data persistence capabilities.
---

# Storage in Mastra

Mastra's storage system provides a robust SQL-based foundation for managing conversation history, workflow state, and agent evaluations. Built on modern SQL databases like LibSQL and PostgreSQL, it offers a consistent interface with prepared statements, proper JSON handling, and efficient sorted queries, making it both powerful for production use and simple for development.

## Overview

At its core, Mastra's storage system is built around four key tables:

1. **Messages**: Store conversation content with proper ordering
2. **Threads**: Organize messages into coherent conversations
3. **Workflow Snapshots**: Persist state for long-running operations
4. **Evaluations**: Track and analyze agent performance

All operations use prepared statements for security and efficiency, with proper JSON serialization for complex data types. The system maintains consistency through SQL transactions and provides robust error handling for all database operations.

## Key Features

### 1. SQL-First Design
- **Prepared Statements**: All operations use SQL prepared statements for security
- **JSON Handling**: Proper serialization and deserialization of complex data
- **Sorted Queries**: Efficient implementation of ordered operations
- **Multiple Backends**: Support for SQLite, PostgreSQL, and cloud databases

### 2. Memory Integration
- **Seamless Memory Management**: Direct integration with Mastra's memory system
- **Semantic Search**: Built-in vector storage for similarity search
- **Efficient Caching**: Smart caching for frequently accessed data

### 3. Development Experience
- **Process Isolation**: Clean separation between test and development data
- **Zero Configuration**: Works out of the box with sensible defaults
- **Easy Migration**: Simple path from development to production

### 4. Production Ready
- **Transaction Support**: ACID compliance for data integrity
- **Performance Monitoring**: Built-in telemetry and tracing
- **Error Recovery**: Robust error handling and recovery mechanisms

## When to Use What

### In-Memory Storage (`:memory:`)
- ✅ Unit testing with isolated test data
- ✅ Clean development environment
- ✅ Automatic cleanup after tests
- ✅ Process-specific storage (dev server, tests, CI)
- ❌ Cross-process data sharing
- ❌ Production deployments

### File-Based Storage (`file:*.db`)
- ✅ Cross-process data persistence
- ✅ Development environments
- ✅ Small to medium deployments
- ✅ Data backup and migration
- ❌ High-concurrency workloads
- ❌ Distributed systems

### Production Storage (PostgreSQL, etc)
- ✅ Production deployments
- ✅ High-concurrency workloads
- ✅ Distributed systems
- ✅ Enterprise applications
- ✅ Cloud deployments

## Implementation Details

### SQL Implementation
Mastra's storage system is built on a robust SQL foundation with several key design principles:

1. **Prepared Statements**
   - All SQL operations use prepared statements
   - Prevents SQL injection vulnerabilities
   - Improves query performance through statement caching

2. **JSON Handling**
   - Native JSON column types for complex data
   - Automatic serialization/deserialization
   - Efficient JSON querying capabilities

3. **Sorted Operations**
   - SQL-based implementation of sorted sets
   - Efficient ordering and pagination
   - Index-optimized query patterns

### Process Isolation
When using `:memory:` storage, each process gets its own isolated database instance:

1. **Test Environment**
   - Dedicated in-memory database per test run
   - Automatic cleanup after test completion
   - No cross-contamination between tests

2. **Development Server**
   - Separate memory storage for dev server
   - Clean development environment
   - No test data pollution

3. **Data Persistence**
   - Use file storage for cross-process data sharing
   - Perfect for development and small deployments
   - Enables data backup and migration

## Getting Started

### Quick Start

Here's a simple example to get started with Mastra's storage system:

```ts showLineNumbers copy
import { DefaultStorage } from '@mastra/core/storage';

// Create a storage instance
const storage = new DefaultStorage({
  name: 'quickstart',
  config: {
    // Use in-memory storage for development
    url: ':memory:',
    // Or file-based storage for persistence
    // url: 'file:app.db',
  },
});

// Create a thread for conversation
const thread = await storage.saveThread({
  thread: {
    resourceId: 'user-123',
    title: 'First Chat',
  },
});

// Save messages to the thread
await storage.saveMessages({
  messages: [{
    threadId: thread.id,
    role: 'user',
    content: 'Hello Mastra!',
  }],
});

// Retrieve messages
const messages = await storage.getMessages({
  threadId: thread.id,
});
```

This example demonstrates:
- Creating a storage instance
- Starting a conversation thread
- Saving and retrieving messages
- Basic storage configuration

### Installation

```bash
# Install core package
npm install @mastra/core

# Optional: Install additional storage providers
npm install @mastra/pg     # PostgreSQL support
npm install @mastra/vector # Vector storage
```

### Basic Concepts

1. **Storage Instance**: Central point for data operations
2. **Threads**: Group related messages and maintain context
3. **Messages**: Store conversation content and metadata
4. **Workflows**: Persist state for long-running operations

## Architecture Overview

Storage in Mastra operates at three levels:

1. **Core Storage Layer**: Handles raw data persistence through the `MastraStorage` interface
2. **Memory Integration**: Provides data access and caching for the memory system
3. **Mastra Class Integration**: Coordinates storage access across the application

This layered approach enables:
- Persistent storage of conversations, workflows, and evaluations
- Efficient data retrieval for memory operations
- Consistent data access patterns across the application
- Flexible storage configurations for different environments

## Core Storage Layer

### Storage Interface

The `MastraStorage` abstract class forms the foundation of Mastra's storage system. It defines a consistent interface for data operations, ensuring that all storage implementations provide the same capabilities:

```ts showLineNumbers copy
import { DefaultStorage } from '@mastra/core/storage';

// Initialize storage with a name and configuration
const storage = new DefaultStorage({
  name: 'my-storage',  // Used for logging and telemetry
  config: {
    // Choose storage type:
    // - 'file:my-database.db' for persistent storage
    // - ':memory:' for temporary, in-memory storage
    url: 'file:my-database.db',
    
    // Optional: Configure connection pool
    pool: {
      min: 2,   // Minimum connections
      max: 10,  // Maximum connections
    },
  },
});

// Storage is now ready for:
// - Thread management
// - Message persistence
// - Workflow state handling
// - Evaluation storage
```

Key responsibilities:

1. **Data Operations**
   - Thread creation and management
   - Message storage and retrieval
   - Workflow state persistence
   - Evaluation data handling

2. **Table Management**
   - Automatic table creation
   - Schema initialization
   - Data migration support

3. **Transaction Handling**
   - Atomic operations when supported
   - Data consistency maintenance
   - Error recovery
```

### Data Structure

The storage system organizes data into four interconnected tables, each serving a specific purpose:

1. **Workflow Snapshots** (`workflow_snapshot`)
   - Captures the state of running workflows
   - Enables workflow resumption after interruptions
   - Schema:
     ```sql
     workflow_name TEXT,
     run_id TEXT,
     snapshot TEXT,        -- JSON serialized state
     createdAt TIMESTAMP,
     updatedAt TIMESTAMP
     ```

2. **Messages** (`messages`)
   - Records all conversation interactions
   - Maintains conversational context
   - Schema:
     ```sql
     id TEXT PRIMARY KEY,
     thread_id TEXT,
     role TEXT,           -- user/assistant/system
     content TEXT,        -- message content
     createdAt TIMESTAMP
     ```

3. **Threads** (`threads`)
   - Groups related messages into conversations
   - Enables conversation management
   - Schema:
     ```sql
     id TEXT PRIMARY KEY,
     resource_id TEXT,    -- external reference
     title TEXT,
     metadata TEXT,       -- JSON metadata
     createdAt TIMESTAMP,
     updatedAt TIMESTAMP
     ```

4. **Evaluations** (`evals`)
   - Stores agent evaluation results
   - Enables performance analysis
   - Schema:
     ```sql
     input TEXT,
     output TEXT,
     result JSONB,        -- evaluation metrics
     agent_name TEXT,
     metric_name TEXT,
     test_info TEXT       -- test metadata
     ```

## Memory System Integration

The storage layer plays a crucial role in Mastra's memory system by providing persistent storage for conversation history and context.

### Memory Storage Patterns

1. **Default Memory Storage**
   - Automatically initializes storage if none provided
   - Uses in-memory SQLite for development
   - Provides immediate data access

```ts showLineNumbers copy
import { Memory } from '@mastra/core/memory';

// Initialize memory with automatic storage setup
const memory = new Memory({
  name: 'my-memory',
  options: {
    // Configure message retention
    lastMessages: 40,     // Keep last 40 messages in context
    
    // Enable semantic search for relevant context
    semanticRecall: true, // Uses vector similarity search
    
    // Thread management options
    threads: {
      generateTitle: true, // AI generates thread titles
      titleModel: 'gpt-3.5-turbo', // Model for title generation
      maxTitleLength: 100, // Maximum title length
    },
  },
});

// Memory will:
// 1. Create SQLite storage if none provided
// 2. Initialize vector storage for semantic search
// 3. Set up thread management
// 4. Configure message retention
```

2. **Custom Storage Configuration**
   - Allows specific storage implementation
   - Enables persistent data storage
   - Supports custom database configuration

```ts showLineNumbers copy
import { Memory } from '@mastra/core/memory';
import { DefaultStorage } from '@mastra/core/storage';

// Custom storage setup
const storage = new DefaultStorage({
  name: 'my-storage',
  config: { url: 'file:custom.db' },
});

// Memory with custom storage
const memory = new Memory({
  name: 'my-memory',
  storage,  // Use custom storage
  options: {
    lastMessages: 40,
    semanticRecall: true,
  }
});
```

### Memory-Storage Interaction

1. **Message Retrieval**
   - Storage provides raw message data
   - Memory system processes and filters messages
   - Combines with semantic search when enabled

2. **Thread Management**
   - Storage maintains thread structure
   - Memory uses threads for context organization
   - Enables efficient conversation retrieval

3. **Data Persistence**
   - Storage ensures message durability
   - Memory caches frequent access patterns
   - Balances performance and reliability
```

## Storage Configuration

Mastra's storage system supports two primary modes of operation, each suited for different use cases:

### In-Memory Storage

Using `:memory:` creates an isolated SQLite database in memory:

```ts showLineNumbers copy
// Development configuration with in-memory storage
const storage = new DefaultStorage({
  name: 'dev-storage',
  config: { 
    url: ':memory:',  // Creates isolated SQLite database
    // Each process gets its own instance:
    // - Test process: Clean test environment
    // - Dev server: Separate development data
    // - CI/CD: Isolated testing environment
  },
});

// Benefits:
// 1. Fast setup and teardown
// 2. No file system interaction
// 3. Perfect for testing and development
// 4. Automatic cleanup on process exit
```

Characteristics:
- **Process Isolation**: Each process gets its own storage instance
- **Test Environment**: Test processes use isolated storage
- **Development Server**: Dev server maintains separate storage
- **Data Lifecycle**: Data exists only during process lifetime
- **Performance**: Fast access but no persistence

Best for:
- Development environments
- Testing scenarios
- CI/CD pipelines
- Rapid prototyping

### Persistent Storage

Using file-based storage creates a durable SQLite database:

```ts showLineNumbers copy
const storage = new DefaultStorage({
  name: 'prod-storage',
  config: { url: 'file:database.db' }
});
```

Characteristics:
- **Data Durability**: Information survives process restarts
- **State Sharing**: Multiple processes can access same data
- **Production Ready**: Suitable for deployed applications
- **Backup Support**: File can be backed up and restored
- **Migration**: Supports schema and data migrations

Best for:
- Production deployments
- Multi-process applications
- Systems requiring data persistence
- Applications with backup requirements

## Mastra Class Integration

The Mastra class serves as the central coordinator for storage operations:

### Storage Configuration

```ts showLineNumbers copy
import { Mastra } from '@mastra/core';
import { DefaultStorage } from '@mastra/core/storage';

// Initialize storage
const storage = new DefaultStorage({
  name: 'app-storage',
  config: { url: 'file:app.db' },
});

// Configure Mastra instance
const mastra = new Mastra({
  storage,      // Storage instance
  agents: {},   // Agent configurations
  vectors: {},  // Vector store configs
  logger: true, // Enable logging
});
```

### Storage Responsibilities

1. **Central Configuration**
   - Manages storage instance lifecycle
   - Coordinates access across components
   - Handles initialization and shutdown

2. **Component Integration**
   - Provides storage to agents when needed
   - Coordinates with vector stores
   - Manages workflow persistence

3. **Operational Control**
   - Monitors storage operations
   - Handles error conditions
   - Provides telemetry data

### Important Notes

1. **Memory Configuration**
   - Memory should be configured on Agent instances
   - Deprecated: Setting memory on Mastra class
   - Each agent can have its own memory config

2. **Storage Lifecycle**
   - Storage initialized with Mastra
   - Shared across all components
   - Cleanup handled by Mastra instance
```

## Common Operations

The storage system provides a comprehensive API for data operations:

### Thread Management

Threads organize conversations and maintain context:

```ts showLineNumbers copy
// Create new thread
const thread = await storage.saveThread({
  thread: {
    resourceId: 'resource-123',  // External reference
    title: 'Thread Title',       // Display name
    metadata: {                  // Custom metadata
      category: 'support',
      priority: 'high'
    },
  },
});

// Update existing thread
await storage.updateThread({
  id: thread.id,
  title: 'Updated Title',
  metadata: {
    status: 'resolved',
    closedAt: new Date()
  },
});

// Retrieve thread
const existingThread = await storage.getThreadById({
  threadId: thread.id
});

// Find threads by resource
const threads = await storage.getThreadsByResourceId({
  resourceId: 'resource-123'
});
```

### Message Operations

Messages represent individual interactions within threads:

```ts showLineNumbers copy
// Save new messages
await storage.saveMessages({
  messages: [{
    threadId: thread.id,
    role: 'user',           // user/assistant/system
    content: 'Query text',  // Message content
    createdAt: new Date(),  // Timestamp
    metadata: {             // Optional metadata
      source: 'web',
      language: 'en'
    }
  }],
});

// Retrieve messages
const messages = await storage.getMessages({
  threadId: thread.id,
  selectBy: {
    limit: 10,            // Message count
    before: new Date(),    // Time filter
    roles: ['user']        // Role filter
  },
  threadConfig: {          // Memory config
    lastMessages: 40,
    semanticRecall: true
  }
});
```

### Workflow Operations

Manage workflow state and execution data:

```ts showLineNumbers copy
// Save workflow snapshot
await storage.persistWorkflowSnapshot({
  workflowName: 'data-processing',
  runId: 'run-123',
  snapshot: {
    state: 'processing',
    progress: 75,
    lastStep: 'validate'
  }
});

// Load workflow state
const snapshot = await storage.loadWorkflowSnapshot({
  workflowName: 'data-processing',
  runId: 'run-123'
});
```

## Next Steps

- Learn about [Memory Management](../agents/01-agent-memory.mdx)
- See [Storage Configuration](../reference/storage/config.mdx)
- View [Storage Examples](../../examples/storage/)
