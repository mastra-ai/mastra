# Memory Threads and Resources

Mastra's memory system is organized around **threads** and **resources**. This architecture provides an efficient way to manage conversations for multiple users while maintaining separate contexts.

Memory threads allow you to build chat UIs where users can view and resume previous conversations, create distinct conversation histories for different topics, manage the lifecycle of conversations (creation, archiving, deletion), and build administrative interfaces for support or moderation. Many of these scenarios involve integrating with a frontend, as detailed in the [UI Integration page](./frontend-integration.mdx).

## Understanding Resources and Threads

In Mastra, memory organization is built around two key concepts:

1. **resourceId**: Identifies the user or entity (e.g., `user_123` or `org_456`)
2. **threadId**: Identifies a specific conversation thread (e.g., `support_789`)

Each resource has a list of threads that are attached to it:

```text
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│  Resource A   │     │  Resource B   │     │  Resource C   │
│ (User 123)    │     │ (User 456)    │     │ (User 789)    │
└───────┬───────┘     └───────┬───────┘     └───────┬───────┘
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Threads    │     │   Threads    │     │   Threads    │
├──────────────┤     ├──────────────┤     ├──────────────┤
│ Thread A-1   │     │ Thread B-1   │     │ Thread C-1   │
│ Thread A-2   │     │ Thread B-2   │     │ Thread C-2   │
│ Thread A-3   │     │              │     │ Thread C-3   │
└──────────────┘     └──────────────┘     └──────────────┘
```

Each thread maintains its own set of messages:

```text
┌─────────────────┐
│    Thread A-1   │
└────────┬────────┘
         │
         ▼
┌──────────────────────────────────┐
│           Messages               │
├──────────────────────────────────┤
│ User: "Hello"                    │
│ Assistant: "Hi there!"           │
│ User: "Can you help me?"         │
│ Assistant: "Sure, how can I help?│
└──────────────────────────────────┘
```

## Using Threads

The following example demonstrates how to use a single agent instance with different `resourceId` and `threadId` combinations to manage separate conversations for multiple users ("alice" and "bob"). Mastra automatically isolates the memory based on these IDs.

```typescript
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent({
  name: "SupportAgent",
  instructions: "You provide customer support.",
  model: openai("gpt-4o"),
  memory: new Memory(),
});

// Use with different users
await agent.stream("I need help with my account", {
  resourceId: "user_alice", // First user
  threadId: "support_thread_1",
});
await agent.stream("How do I upgrade my plan?", {
  resourceId: "user_bob", // Second user (isolated)
  threadId: "support_thread_2",
});

// Continue conversation with first user
await agent.stream("Did you find a solution to my problem?", {
  resourceId: "user_alice",
  threadId: "support_thread_1",
});
```

## Multiple Threads Per User

Users can have multiple conversation threads for different topics:

```typescript
const userId = "user_charlie";

// Support conversation
await agent.stream("I need help with billing", {
  resourceId: userId,
  threadId: "support_thread_123",
});

// Product feedback conversation (separate context)
await agent.stream("I have some suggestions for your product", {
  resourceId: userId,
  threadId: "feedback_thread_456",
});

// Continue support conversation with context intact
await agent.stream("Did you find my billing issue?", {
  resourceId: userId,
  threadId: "support_thread_123",
});
```

## Thread Management and Retrieval

You can programmatically access and manage user threads, which is essential for building interactive chat applications. See the [getThreadsByResourceId reference](../reference/memory/getThreadsByResourceId.mdx) for more details on retrieving threads.

```typescript
// Get all threads for a specific user
const threads = await memory.getThreadsByResourceId({
  resourceId: "user_alice",
});

// Display thread information
console.log(`User Alice has ${threads.length} conversation threads`);
threads.forEach((thread) => {
  console.log(`- ${thread.id}: ${thread.title}`);
});
```

For example, in a chat application, you might list all of a user's conversations in a sidebar, allowing them to click on any thread to continue that specific conversation.

## Memory Sharing Between Agents

You can control whether agents share memory or have isolated contexts:

```typescript
// Agents with isolated memory (different threadIds)
await agentA.stream("Message for Agent A", {
  resourceId: "user_123",
  threadId: "conversation_with_agent_A",
});

await agentB.stream("Message for Agent B", {
  resourceId: "user_123",
  threadId: "conversation_with_agent_B",
});

// Agents with shared memory (same resourceId and threadId)
await specialistAgent.stream("The user has a premium account", {
  resourceId: "user_123",
  threadId: "support_thread_456",
});

await generalAgent.stream("What type of account does the user have?", {
  resourceId: "user_123",
  threadId: "support_thread_456",
});
// Second agent will know about the premium account information
```

## Related Content

- [Memory Overview](./overview.mdx) - Understand the fundamentals of memory in Mastra
- [Getting Started with Memory](./getting-started.mdx) - Learn how to set up memory for your agents
- [Conversation History](./last-messages.mdx) - Learn about basic turn-based memory
- [Working Memory](./working-memory.mdx) - Store and retrieve continuously relevant information
