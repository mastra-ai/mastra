# Storing Continuously Relevant Information (Working Memory)

While [conversation history](./last-messages.mdx) and [similarity search](./semantic-recall.mdx) help agents remember conversations, working memory enables them to maintain persistent information about users across all interactions. This feature is particularly valuable for maintaining preferences, user details, and ongoing state that should always be available to the agent.

## Quick Start

Here's a minimal example of setting up an agent with working memory:

```typescript
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { openai } from "@ai-sdk/openai";

// Create agent with working memory enabled
const agent = new Agent({
  name: "PersonalAssistant",
  instructions: "You are a helpful personal assistant.",
  model: openai("gpt-4o"),
  memory: new Memory({
    options: {
      workingMemory: {
        enabled: true,
        use: "tool-call", // Recommended setting
      },
    },
  }),
});
```

## When to Use Working Memory

Unlike message history which focuses on conversation flow, working memory acts like an agent's active thoughts - the key information they keep readily available about the user, like how a person would naturally remember someone's name, preferences, or important details during a conversation.

Working memory is ideal for:

- Storing user preferences that should persist across conversations
- Maintaining state for ongoing tasks or processes
- Keeping important user details readily available
- Maintaining non-linear information that should always be "top of mind"

## How Working Memory Works

Working memory uses an unstructured text string that the agent is able to update over time, similar to a state store:

1. The agent receives a template defining what information to track
2. During conversations, the agent updates this information automatically
3. The working memory is injected into every conversation's context
4. Updates are handled invisibly to users through markdown blocks or tool calls

```text
        ┌────────────────────┐
        │  User Interaction  │
        └─────────┬──────────┘
                  ▼
  ┌────────────────────────────┐
  │      Context Window        │
  │    ───────────────         │
  │    System Instructions     │
  │    Working Memory          │
  │    Last Messages           │
  │    Current User Message    │
  └─────────────┬──────────────┘
                │ sent to
                ▼
        ┌────────────────┐
        │  LLM Provider  │
        └───────┬────────┘
                ▼
      ┌───────────────────────┐
      │    Agent Response     │
      │  with Memory Updates  │
      └─────────┬─────────────┘
                ▼
   ┌──────────────────────────┐
   │  Extract & Store Memory  │
   │         Updates          │
   └──────────┬───────────────┘
              ▼
  ┌────────────────────────────┐
  │   Persistent Storage Layer │
  │  (Stored in Memory Thread) │
  └─────────────┬──────────────┘
                ▼
      ┌───────────────────────┐
      │   Next Interaction    │
      │  (Includes Updated    │
      │   Working Memory)     │
      └───────────────────────┘
```

## Configuring Working Memory

### Memory Templates

Templates encourage agents to maintain specific types of information. The template serves as a guide for what information the agent should track and update:

```typescript
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      template: `# User Profile

## Preferences
- Theme: 
- Language: 

## Personal Info
- Name: 
- Timezone: 
`,
    },
  },
});
```

If no template is provided, a default template is used. You may also need to include specific instructions in your agent's system prompt to ensure it properly maintains the information defined in your template.

### Update Modes

Working memory supports two update modes:

1. **Text Stream Mode** (Current Default): Updates via markdown blocks in responses

```typescript
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      use: "text-stream", // Current default, but will be deprecated
    },
  },
});
```

2. **Tool Call Mode** (Recommended): Updates via explicit tool calls

```typescript
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      use: "tool-call", // Recommended as it will become the default in future
    },
  },
});
```

We recommend using tool-call mode as it will become the default in future versions, and text-stream mode will eventually be deprecated.

### Handling Updates in Streams

When using text-stream mode, you'll need to prevent markdown blocks from being visible to users:

```typescript
import { maskStreamTags } from "@mastra/core/utils";

// Only needed for text-stream mode
for await (const chunk of maskStreamTags(
  response.textStream,
  "working_memory",
)) {
  process.stdout.write(chunk);
}
```

Note: This is only necessary when using text-stream mode. With tool-call mode, memory updates are handled automatically without needing to mask the stream.

## Related Features

Working memory integrates with other memory features to enhance agent capabilities:

- **[Conversation History](./last-messages.mdx)**: For recent conversation context
- **[Similarity Search](./semantic-recall.mdx)**: For finding relevant past information
- **[Memory Threads](./memory-threads.mdx)**: For managing conversation organization
- **[Token Management](./token-management.mdx)**: For optimizing memory token usage

