---
title: "AI トレーシング | 可観測性 | Mastra ドキュメント"
description: "Mastra アプリ向けに AI トレーシングを設定する"
---

import { Callout } from "nextra/components";


# AIトレーシング

AIトレーシングは、アプリケーション内のAI関連処理に特化したモニタリングとデバッグ機能を提供します。有効化すると、Mastraはエージェントの実行、LLMの生成、ツール呼び出し、ワークフローの各ステップについて、AI特有のコンテキストとメタデータを含むトレースを自動的に作成します。

従来のアプリケーショントレーシングとは異なり、AIトレーシングはAIパイプラインの把握に特化しています。具体的には、トークン使用量、モデルのパラメータ、ツール実行の詳細、会話の流れを記録します。これにより、問題のデバッグ、パフォーマンスの最適化、本番環境におけるAIシステムの挙動の把握が容易になります。

## 仕組み

AI Traces は次の手順で作成されます:

- **エクスポーターを設定** → トレースデータをオブザーバビリティプラットフォームに送信
- **サンプリング戦略を設定** → 収集するトレースを制御
- **エージェントとワークフローを実行** → Mastra が AI Tracing で自動的に計装します

## 設定

### 基本構成

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  // ... その他の設定
  observability: {
    default: { enabled: true }, // DefaultExporterとCloudExporterを有効化
  },
  storage: new LibSQLStore({
    url: "file:./mastra.db", // トレーシングにはストレージが必要
  }),
});
```

有効化すると、デフォルト設定には自動的に以下が含まれます:

* **サービス名**: `"mastra"`
* **サンプリング**: `"always"` - 100% のトレースをサンプリング
* **エクスポーター**:
  * `DefaultExporter` - 設定したストレージにトレースを永続化
  * `CloudExporter` - Mastra Cloud にトレースを送信（`MASTRA_CLOUD_ACCESS_TOKEN` が必要）
* **プロセッサ**: `SensitiveDataFilter` - 機密フィールドを自動的にマスキング


### 拡張版の基本設定

このデフォルト設定は、以下のようなより詳しい設定に相当する、最小限のヘルパーです。

```ts filename="src/mastra/index.ts" showLineNumbers copy
import { CloudExporter, DefaultExporter, SensitiveDataFilter } from '@mastra/core/ai-tracing';

export const mastra = new Mastra({
  // ... その他の設定
  observability: {
    configs: {
      default: {
        serviceName: "mastra",
        sampling: { type: 'always' },
        processors: [
          new SensitiveDataFilter(),
        ],
        exporters: [
          new CloudExporter(),
          new DefaultExporter(),
        ],
      }
    }
  },
  storage: new LibSQLStore({
    url: "file:./mastra.db", // トレーシングにはストレージが必要
  }),
});
```


## エクスポーター

エクスポーターは、AIのトレースデータの送信先と保存方法を決定します。適切なエクスポーターを選ぶことで、既存のオブザーバビリティスタックとの統合、データ所在要件の順守、コストとパフォーマンスの最適化が可能になります。複数のエクスポーターを同時に使用し、同じトレースデータを異なる送信先に配信できます。たとえば、詳細なトレースはデバッグ用にローカルへ保存しつつ、本番監視のためにサンプリングしたデータはクラウドプロバイダーへ送信することができます。

### 内蔵エクスポーター

Mastra には、すぐに使えるエクスポーターが 2 つ用意されています:

- **[Default](/docs/observability/ai-tracing/exporters/default)** - プレイグラウンドでの閲覧のため、トレースをローカルストレージに保存します
- **[Cloud](/docs/observability/ai-tracing/exporters/cloud)** - 本番環境の監視やコラボレーションのために、トレースを Mastra Cloud に送信します

### 外部エクスポーター

内部エクスポーターに加え、Mastra は主要なオブザーバビリティプラットフォームとの連携に対応しています。これらのエクスポーターにより、既存の監視基盤を活用しつつ、アラート、ダッシュボード、他のアプリケーションメトリクスとの相関など、プラットフォーム固有の機能を活用できます。

- **[Arize](/docs/observability/ai-tracing/exporters/arize)** - OpenInference のセマンティック規約に沿って Arize Phoenix または Arize AX へトレースをエクスポート
- **[Braintrust](/docs/observability/ai-tracing/exporters/braintrust)** - Braintrust の評価・オブザーバビリティプラットフォームへトレースをエクスポート
- **[Langfuse](/docs/observability/ai-tracing/exporters/langfuse)** - Langfuse のオープンソース LLM エンジニアリングプラットフォームへトレースを送信
- **[LangSmith](/docs/observability/ai-tracing/exporters/langsmith)** - LangSmith のオブザーバビリティ／評価ツールキットへトレースを送信
- **[OpenTelemetry](/docs/observability/ai-tracing/exporters/otel)** - OpenTelemetry 互換のあらゆるオブザーバビリティシステムへトレースを送信
  - サポート: Dash0、Laminar、New Relic、SigNoz、Traceloop、Zipkin など！

## サンプリング戦略

サンプリングは、どのトレースを収集するかを制御し、オブザーバビリティの要件とリソースコストのバランスを取るのに役立ちます。トラフィックの多い本番環境では、すべてのトレースを収集するのは高コストで、必ずしも必要ではありません。サンプリング戦略を用いることで、エラーや重要な処理に関する重要な情報を取りこぼさずに、代表性のあるトレースのサブセットを取得できます。

Mastra は次の 4 つのサンプリング戦略をサポートしています:

### 常時サンプリング

トレースを100%収集します。完全な可観測性が必要な開発やデバッグ、または低トラフィックのシナリオに最適です。

```ts
sampling: { type: 'always' }
```


### Never Sample

トレースを完全に無効にします。トレースに価値がない特定の環境や、設定を削除せずに一時的にトレースを無効化したい場合に便利です。

```ts
sampling: { type: 'never' }
```


### 比率ベースのサンプリング

トレースの一定割合をランダムに取得します。全トレースを収集するコストをかけずに統計的な示唆を得たい本番環境に最適です。確率値は 0（トレースなし）から 1（全トレース）までの範囲です。

```ts
sampling: {
  type: 'ratio',
  probability: 0.1  // トレースの10%をサンプリング
}
```


### カスタムサンプリング

実行時のコンテキスト、メタデータ、ビジネスルールなどに基づいて独自のサンプリングロジックを実装します。ユーザー層やリクエスト種別、エラー条件に応じたサンプリングなど、複雑なシナリオに最適です。

```ts
sampling: {
  type: 'custom',
  sampler: (options) => {
    // プレミアムユーザーを高い割合でサンプリング
    if (options?.metadata?.userTier === 'premium') {
      return Math.random() < 0.5; // 50%サンプリング
    }

    // その他は1%サンプリング（デフォルト）
    return Math.random() < 0.01;
  }
}
```


### 完全な例

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    configs: {
      "10_percent": {
        serviceName: 'my-service',
        // トレースの10%をサンプリング
        sampling: {
          type: 'ratio',
          probability: 0.1
        },
        exporters: [new DefaultExporter()],
      }
    },
  },
});
```


## 複数コンフィグのセットアップ

複雑なアプリケーションでは、シナリオに応じて異なるトレーシング設定が必要になることがよくあります。開発中はフルサンプリングで詳細なトレースが欲しく、プロダクションではサンプリングしたトレースを外部プロバイダーへ送信し、特定の機能や顧客セグメント向けに専用の設定を用いたい、といったケースです。`configSelector` 関数は実行時に設定を動的に選択でき、リクエストコンテキスト、環境変数、フィーチャーフラグ、あるいは任意のカスタムロジックに基づいてトレースのルーティングを行えます。

このアプローチは次のような場合に特に有用です:

- 観測要件の異なる A/B テストを実施する場合
- 特定の顧客やサポート案件に対して強化されたデバッグを提供する場合
- 既存のモニタリングに影響を与えずに新しいトレーシングプロバイダーを段階的に導入する場合
- リクエスト種別ごとにサンプリング率を変えてコストを最適化する場合
- コンプライアンスやデータ所在地要件に合わせてトレースストリームを分離して維持する場合

<Callout type="info">
特定の実行では単一のコンフィグしか使用できません。ただし、1 つのコンフィグから同時に複数のエクスポーターへデータを送信することは可能です。
</Callout>

### 動的な設定の選択

実行時のコンテキストに応じて適切なトレース設定を選択するには、`configSelector` を使用します:

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    default: { enabled: true }, // 'default' インスタンスを提供
    configs: {
      langfuse: {
        serviceName: 'langfuse-service',
        exporters: [langfuseExporter],
      },
      braintrust: {
        serviceName: 'braintrust-service',
        exporters: [braintrustExporter],
      },
      debug: {
        serviceName: 'debug-service',
        sampling: { type: 'always' },
        exporters: [new DefaultExporter()],
      },
    },
    configSelector: (context, availableTracers) => {
      // サポートリクエスト用にdebug設定を使用
      if (context.runtimeContext?.get('supportMode')) {
        return 'debug';
      }

      // 特定の顧客を異なるプロバイダーに振り分け
      const customerId = context.runtimeContext?.get('customerId');
      if (customerId && premiumCustomers.includes(customerId)) {
        return 'braintrust';
      }

      // 特定のリクエストをlangfuseに振り分け
      if (context.runtimeContext?.get('useExternalTracing')) {
        return 'langfuse';
      }

      return 'default';
    },
  },
});
```


### 環境別の設定

よくあるパターンとして、デプロイ環境に応じて設定を選択します。

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    configs: {
      development: {
        serviceName: 'my-service-dev',
        sampling: { type: 'always' },
        exporters: [new DefaultExporter()],
      },
      staging: {
        serviceName: 'my-service-staging',
        sampling: { type: 'ratio', probability: 0.5 },
        exporters: [langfuseExporter],
      },
      production: {
        serviceName: 'my-service-prod',
        sampling: { type: 'ratio', probability: 0.01 },
        exporters: [cloudExporter, langfuseExporter],
      },
    },
    configSelector: (context, availableTracers) => {
      const env = process.env.NODE_ENV || 'development';
      return env;
    },
  },
});
```


### よくある設定パターンとトラブルシューティング

#### デフォルト設定が優先されます

デフォルト設定が有効で、カスタム設定も定義されている場合は、明示的に別の設定を選択しない限り、**常にデフォルト設定が使用されます**。

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    default: { enabled: true }, // これは常に使用されます！
    configs: {
      langfuse: {
        serviceName: 'my-service',
        exporters: [langfuseExporter], // ここには到達しません
      },
    },
  },
});
```

**解決策:**

1. **デフォルトを無効にする**して、カスタム設定のみを使用する:

```ts
observability: {
  // デフォルト設定を無効にするには、この行をコメントアウトまたは削除してください
  // default: { enabled: true },
  configs: {
    langfuse: { /* ... */ }
  }
}
```

2. **configSelector を使う** ことで、設定を切り替えます:

```ts
observability: {
  default: { enabled: true },
  configs: {
    langfuse: { /* ... */ }
  },
  configSelector: (context, availableConfigs) => {
    // 'default'と'langfuse'を選択するロジック
    return useExternalTracing ? 'langfuse' : 'default';
  }
}
```


#### Playground と Cloud へのアクセスを維持する

外部エクスポーターを使ってカスタム構成を作成する場合、Mastra Playground および Cloud へのアクセスを失う可能性があります。外部エクスポーターを追加しつつアクセスを維持するには、デフォルトのエクスポーターをカスタム構成に含めてください。

```ts filename="src/mastra/index.ts" showLineNumbers copy
import { DefaultExporter, CloudExporter } from '@mastra/core/ai-tracing';
import { ArizeExporter } from '@mastra/arize';

export const mastra = new Mastra({
  observability: {
    default: { enabled: false }, // カスタム設定を使用するためデフォルトを無効化
    configs: {
      production: {
        serviceName: 'my-service',
        exporters: [
          new ArizeExporter({    // 外部エクスポーター
            endpoint: process.env.PHOENIX_ENDPOINT,
            apiKey: process.env.PHOENIX_API_KEY,
          }),
          new DefaultExporter(),  // Playgroundへのアクセスを維持
          new CloudExporter(),    // Cloudへのアクセスを維持
        ],
      },
    },
  },
});
```

この構成では、トレースが3つの宛先すべてに同時に送信されます。

* 外部の可観測性向けの **Arize Phoenix/AX**
* ローカルのPlaygroundでのアクセス向けの **DefaultExporter**
* Mastra Cloudのダッシュボード向けの **CloudExporter**

<Callout type="info">
  メモ: 1つのトレースは複数のエクスポーターに送信できます。異なるサンプリング率やプロセッサーを使いたい場合を除き、エクスポーターごとに個別の設定は不要です。
</Callout>


## カスタムメタデータの追加

カスタムメタデータを使うと、トレースに追加情報を付与でき、問題のデバッグや本番環境でのシステム挙動の把握が容易になります。メタデータには、ビジネスロジックの詳細、パフォーマンスメトリクス、ユーザーコンテキスト、または実行時に何が起きたかを理解するのに役立つあらゆる情報を含められます。

トレーシングコンテキストを使って、任意のスパンにメタデータを追加できます:

```ts showLineNumbers copy
execute: async ({ inputData, tracingContext }) => {
  const startTime = Date.now();
  const response = await fetch(inputData.endpoint);

  // 現在のスパンにカスタムメタデータを追加
  tracingContext.currentSpan?.update({
    metadata: {
      apiStatusCode: response.status,
      endpoint: inputData.endpoint,
      responseTimeMs: Date.now() - startTime,
      userTier: inputData.userTier,
      region: process.env.AWS_REGION,
    }
  });

  return await response.json();
}
```

ここで設定したメタデータは、構成済みのすべてのエクスポーターに表示されます。


### RuntimeContext からのメタデータ自動付与

各スパンに手動でメタデータを追加する代わりに、Mastra を設定して RuntimeContext から値を自動抽出し、トレース内のすべてのスパンにメタデータとして付与できます。これは、ユーザー識別子、環境情報、機能フラグ、あるいはリクエストスコープのデータなどを、トレース全体で一貫して追跡するのに役立ちます。

#### 設定レベルの抽出

トレース設定で抽出する RuntimeContext のキーを定義します。これらのキーは、この設定で作成されるすべてのスパンのメタデータとして自動的に含まれます。

```ts filename="src/mastra/index.ts" showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    configs: {
      default: {
        serviceName: 'my-service',
        runtimeContextKeys: ['userId', 'environment', 'tenantId'],
        exporters: [new DefaultExporter()],
      },
    },
  },
});
```

これからは、RuntimeContext を使ってエージェントやワークフローを実行すると、これらの値が自動的に抽出されます。

```ts showLineNumbers copy
const runtimeContext = new RuntimeContext();
runtimeContext.set('userId', 'user-123');
runtimeContext.set('environment', 'production');
runtimeContext.set('tenantId', 'tenant-456');

// このトレース内のすべてのスパンに、userId、environment、tenantId のメタデータが自動的に付与されます
const result = await agent.generate({
  messages: [{ role: 'user', content: 'Hello' }],
  runtimeContext,
});
```


#### リクエストごとの追加

`tracingOptions.runtimeContextKeys` を使用して、トレース固有のキーを追加できます。これらは設定レベルのキーとマージされます。

```ts showLineNumbers copy
const runtimeContext = new RuntimeContext();
runtimeContext.set('userId', 'user-123');
runtimeContext.set('environment', 'production');
runtimeContext.set('experimentId', 'exp-789');

const result = await agent.generate({
  messages: [{ role: 'user', content: 'こんにちは' }],
  runtimeContext,
  tracingOptions: {
    runtimeContextKeys: ['experimentId'], // 設定済みのキーに追加
  },
});

// すべてのスパンに userId、environment、experimentId が含まれます
```


#### ネストされた値の抽出

RuntimeContext のネストされた値を取得するには、ドット記法を使用します:

```ts showLineNumbers copy
export const mastra = new Mastra({
  observability: {
    configs: {
      default: {
        runtimeContextKeys: ['user.id', 'session.data.experimentId'],
        exporters: [new DefaultExporter()],
      },
    },
  },
});

const runtimeContext = new RuntimeContext();
runtimeContext.set('user', { id: 'user-456', name: 'John Doe' });
runtimeContext.set('session', { data: { experimentId: 'exp-999' } });

// メタデータには以下が含まれます: { user: { id: 'user-456' }, session: { data: { experimentId: 'exp-999' } } }
```


#### 仕組み

1. **TraceState の計算**: トレース開始時（ルートスパン作成時）に、Mastra は設定レベルのキーとリクエスト単位のキーを統合し、抽出対象のキーを決定します
2. **自動抽出**: ルートスパン（エージェントの実行、ワークフローの実行）は RuntimeContext からメタデータを自動的に抽出します
3. **子スパンでの抽出**: 子スパンも、作成時に `runtimeContext` を渡せばメタデータを抽出できます
4. **メタデータの優先順位**: スパンのオプションに明示的に渡されたメタデータは、抽出されたメタデータより常に優先されます

#### 子スパンとメタデータの抽出

ツールやワークフローのステップ内で子スパンを作成する際に、`runtimeContext` パラメータを渡すと、メタデータの抽出を有効にできます。

```ts showLineNumbers copy
execute: async ({ tracingContext, runtimeContext }) => {
  // runtimeContextを使用して子スパンを作成 - メタデータ抽出が行われます
  const dbSpan = tracingContext.currentSpan?.createChildSpan({
    type: 'generic',
    name: 'database-query',
    runtimeContext,  // メタデータ抽出を有効にするために渡す
  });

  const results = await db.query('SELECT * FROM users');
  dbSpan?.end({ output: results });

  // runtimeContextなしで子スパンを作成 - メタデータ抽出は行われません
  const cacheSpan = tracingContext.currentSpan?.createChildSpan({
    type: 'generic',
    name: 'cache-check',
    // runtimeContextなし - メタデータは抽出されません
  });

  return results;
}
```

これにより、どの子スパンに RuntimeContext メタデータを含めるかをきめ細かく制御できます。ルートスパン（エージェント／ワークフロー実行）は常に自動的にメタデータを抽出しますが、子スパンは `runtimeContext` を明示的に渡した場合にのみ抽出します。


## 子スパンの作成

子スパンを使うと、ワークフローのステップやツール内のきめ細かな処理を追跡できます。データベースクエリ、API 呼び出し、ファイル操作、複雑な計算といったサブ処理の可視化に役立ちます。この階層構造により、パフォーマンスのボトルネックを特定し、処理の正確な実行順序を把握できます。

特定の処理を追跡するために、ツール呼び出しやワークフローステップ内で子スパンを作成します：

```ts showLineNumbers copy
execute: async ({ input, tracingContext }) => {
  // メインのデータベース操作用に別の子スパンを作成
  const querySpan = tracingContext.currentSpan?.createChildSpan({
    type: 'generic',
    name: 'database-query',
    input: { query: input.query },
    metadata: { database: 'production' },
  });

  try {
    const results = await db.query(input.query);
    querySpan?.end({
      output: results.data,
      metadata: {
        rowsReturned: results.length,
        queryTimeMs: results.executionTime,
        cacheHit: results.fromCache
      }
    });
    return results;
  } catch (error) {
    querySpan?.error({
      error,
      metadata: { retryable: isRetryableError(error) }
    });
    throw error;
  }
}
```

子スパンは親のトレースコンテキストを自動的に継承し、オブザーバビリティプラットフォーム上で関係の階層を維持します。


## スパンプロセッサ

スパンプロセッサは、エクスポート前にトレースデータを変換、フィルタ、または付加情報で強化できる機能です。スパンの作成からエクスポートまでの間にあるパイプラインとして機能し、セキュリティ、コンプライアンス、デバッグなどの目的に合わせてスパンを修正できます。Mastra には組み込みのプロセッサが用意されており、カスタム実装にも対応しています。

### 組み込みプロセッサ

* [Sensitive Data Filter](/docs/observability/ai-tracing/processors/sensitive-data-filter) は機密情報を伏せ字化（マスキング）します。既定のオブザーバビリティ設定で有効です。

### カスタムプロセッサの作成

`AISpanProcessor` インターフェースを実装することで、カスタムのスパンプロセッサを作成できます。次は、スパン内のすべての入力テキストを小文字に変換する簡単な例です。

```ts filename="src/processors/lowercase-input-processor.ts" showLineNumbers copy
import type { AISpanProcessor, AnyAISpan } from '@mastra/core/ai-tracing';

export class LowercaseInputProcessor implements AISpanProcessor {
  name = 'lowercase-processor';

  process(span: AnyAISpan): AnyAISpan {
    span.input = `${span.input}`.toLowerCase()
    return span;
  }

  async shutdown(): Promise<void> {
    // 必要に応じてクリーンアップ
  }
}

// カスタムプロセッサを使用
export const mastra = new Mastra({
  observability: {
    configs: {
      development: {
        processors: [
          new LowercaseInputProcessor(),
          new SensitiveDataFilter(),
        ],
        exporters: [new DefaultExporter()],
      },
    },
  },
});
```

定義された順にプロセッサが実行され、複数の変換を連結できます。カスタムプロセッサの一般的なユースケースは次のとおりです。

* 環境固有のメタデータの追加
* 条件に基づく span のフィルタリング
* データ形式の正規化
* 高ボリュームなトレースのサンプリング
* span へのビジネスコンテキストの付与


## トレースIDの取得

トレースを有効にした状態でエージェントやワークフローを実行すると、レスポンスに `traceId` が含まれます。これを使って、オブザーバビリティ・プラットフォームで完全なトレースを参照できます。これは、デバッグやカスタマーサポート、システム内の他のイベントとのトレースの相関付けに役立ちます。

### エージェントのトレースID

`generate` と `stream` の両メソッドは、レスポンスでトレースIDを返します。

```ts showLineNumbers copy
// generateを使用
const result = await agent.generate({
  messages: [{ role: 'user', content: 'こんにちは' }]
});

console.log('トレースID:', result.traceId);

// streamを使用
const streamResult = await agent.stream({
  messages: [{ role: 'user', content: '物語を聞かせて' }]
});

console.log('トレースID:', streamResult.traceId);
```


### ワークフローのトレース ID

ワークフローの実行でもトレース ID が返されます。

```ts showLineNumbers copy
// ワークフロー実行を作成
const run = await mastra.getWorkflow('myWorkflow').createRunAsync();

// ワークフローを開始
const result = await run.start({
  inputData: { data: 'これを処理' }
});

console.log('トレースID:', result.traceId);

// またはワークフローをストリーミング
const { stream, getWorkflowState } = run.stream({
  inputData: { data: 'これを処理' }
});

// トレースIDを含む最終状態を取得
const finalState = await getWorkflowState();
console.log('トレースID:', finalState.traceId);
```


### Trace ID の使用

Trace ID を取得したら、次のことができます:

1. **Mastra Playground でトレースを検索**: トレースビューに移動し、ID で検索します
2. **外部プラットフォームでトレースを照会**: Langfuse、Braintrust、または利用中のオブザーバビリティプラットフォームでその ID を使用します
3. **ログとの相関付け**: アプリケーションログに Trace ID を含め、相互参照できるようにします
4. **デバッグのために共有**: 調査のためにサポートチームや開発者に Trace ID を提供します

Trace ID はトレースが有効な場合にのみ取得できます。トレースが無効化されているか、サンプリングによってリクエストが除外されている場合、`traceId` は `undefined` になります。

## 外部トレーシングシステムとの統合

既存の分散トレーシング（OpenTelemetry、Datadog など）を利用しているアプリケーション内で Mastra のエージェントやワークフローを実行する場合、Mastra のトレースを親トレースのコンテキストに接続できます。これにより、リクエストフロー全体を一元的に可視化でき、Mastra の処理がより大きなシステムの中でどのように組み込まれているかを把握しやすくなります。

### 外部トレースIDの引き渡し

親システムのトレースコンテキストを指定するには、`tracingOptions` パラメータを使用します。

```ts showLineNumbers copy
// 既存のトレーシングシステムからトレースコンテキストを取得
const parentTraceId = getCurrentTraceId(); // 既存のトレーシングシステム
const parentSpanId = getCurrentSpanId();   // 既存のトレーシングシステム

// 親トレースの一部としてMastraの操作を実行
const result = await agent.generate('このデータを分析', {
  tracingOptions: {
    traceId: parentTraceId,
    parentSpanId: parentSpanId,
  }
});

// Mastraトレースは分散トレース内で子として表示されます
```


### OpenTelemetry の統合

OpenTelemetry と連携することで、Mastra のトレースを既存のオブザーバビリティ プラットフォームにシームレスに表示できます。

```ts showLineNumbers copy
import { trace } from '@opentelemetry/api';

// 現在の OpenTelemetry スパンを取得
const currentSpan = trace.getActiveSpan();
const spanContext = currentSpan?.spanContext();

if (spanContext) {
  const result = await agent.generate(userMessage, {
    tracingOptions: {
      traceId: spanContext.traceId,
      parentSpanId: spanContext.spanId,
    }
  });
}
```


### ワークフローの統合

ワークフローでも、トレース伝播に同じパターンが利用できます。

```ts showLineNumbers copy
const workflow = mastra.getWorkflow('data-pipeline');
const run = await workflow.createRunAsync();

const result = await run.start({
  inputData: { data: '...' },
  tracingOptions: {
    traceId: externalTraceId,
    parentSpanId: externalSpanId,
  }
});
```


### ID 形式の要件

Mastra はトレース ID とスパン ID を検証して、互換性を確保します：

- **トレース ID**：1〜32 桁の 16 進数（OpenTelemetry では 32 桁）
- **スパン ID**：1〜16 桁の 16 進数（OpenTelemetry では 16 桁）

無効な ID は適切に処理され、Mastra はエラーを記録して処理を継続します：

- 無効なトレース ID → 新しいトレース ID を生成
- 無効な親スパン ID → 親子関係を無視

これにより、入力が不正でもトレーシングがアプリケーションをクラッシュさせることはありません。

### 例: Express ミドルウェア

以下は、Express アプリケーションでのトレース伝播を示す完全な例です。

```ts showLineNumbers copy
import { trace } from '@opentelemetry/api';
import express from 'express';

const app = express();

app.post('/api/analyze', async (req, res) => {
  // 現在のOpenTelemetryコンテキストを取得
  const currentSpan = trace.getActiveSpan();
  const spanContext = currentSpan?.spanContext();

  const result = await agent.generate(req.body.message, {
    tracingOptions: spanContext ? {
      traceId: spanContext.traceId,
      parentSpanId: spanContext.spanId,
    } : undefined,
  });

  res.json(result);
});
```

これにより、HTTP リクエストの処理と Mastra エージェントの実行の両方を含む単一の分散トレースが作成され、任意のオブザーバビリティプラットフォームで表示できます。


## 何がトレースされるか

Mastra は自動的に次のスパンを作成します：

### エージェントのオペレーション

- **エージェントラン** - 指示とツールを用いた一連の実行
- **LLM 呼び出し** - トークンやパラメータを伴うモデルとのやり取り
- **ツール実行** - 入力と出力を伴う関数呼び出し
- **メモリ操作** - スレッドおよびセマンティックリコール

### ワークフローの操作

- **ワークフローの実行** - 開始から終了までの一連の実行
- **個々のステップ** - 入出力を伴うステップの処理
- **制御フロー** - 条件分岐、ループ、並列実行
- **待機処理** - 遅延やイベント待ち

## トレースの確認

トレースは以下の場所で確認できます：

- **Mastra Playground** - ローカル開発環境
- **Mastra Cloud** - 本番環境の監視ダッシュボード
- **Arize Phoenix / Arize AX** - Arize エクスポーター使用時
- **Braintrust Console** - Braintrust エクスポーター使用時
- **Langfuse Dashboard** - Langfuse エクスポーター使用時

## 参考

### 例

- [Basic AI トレーシングの基本例](/examples/observability/basic-ai-tracing) - 動作する実装

### 参考ドキュメント

- [Configuration API](/reference/observability/ai-tracing/configuration) - ObservabilityConfig の詳細
- [AITracing Classes](/reference/observability/ai-tracing/ai-tracing) - 主要なクラスとメソッド
- [Span Interfaces](/reference/observability/ai-tracing/span) - スパンの種類とライフサイクル
- [Type Definitions](/reference/observability/ai-tracing/interfaces) - インターフェースの完全なリファレンス

### エクスポーター

- [DefaultExporter](/reference/observability/ai-tracing/exporters/default-exporter) - ストレージへの永続化
- [CloudExporter](/reference/observability/ai-tracing/exporters/cloud-exporter) - Mastra Cloud と連携
- [ConsoleExporter](/reference/observability/ai-tracing/exporters/console-exporter) - デバッグ出力
- [Arize](/reference/observability/ai-tracing/exporters/arize) - Arize Phoenix と Arize AX に対応
- [Braintrust](/reference/observability/ai-tracing/exporters/braintrust) - Braintrust と連携
- [Langfuse](/reference/observability/ai-tracing/exporters/langfuse) - Langfuse と連携
- [OpenTelemetry](/reference/observability/ai-tracing/exporters/otel) - OTEL 互換プラットフォームに対応

### プロセッサ

- [Sensitive Data Filter](/docs/observability/ai-tracing/processors/sensitive-data-filter) - データのマスキング