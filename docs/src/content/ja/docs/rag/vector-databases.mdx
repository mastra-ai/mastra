---
title: "ベクターデータベースにエンベディングを保存する | Mastra ドキュメント"
description: Mastra におけるベクターの保存オプションに関するガイド。類似検索のための組み込みおよび専用のベクターデータベースを取り上げます。
---

import { Tabs } from "nextra/components";


## ベクトルデータベースに埋め込みを保存する

埋め込みを生成したら、ベクトル類似検索に対応したデータベースに保存する必要があります。Mastra は、さまざまなベクトルデータベースで埋め込みの保存と検索を行うための一貫したインターフェースを提供します。

## 対応データベース

{/*
LLM CONTEXT: この Tabs コンポーネントは、Mastra がサポートする各種ベクターデータベース実装を紹介します。
各タブでは、特定のベクターデータベースプロバイダーのセットアップと構成方法を示します。
タブごとに、データベース間で一貫した API パターンを提示し、プロバイダーの切り替え方を理解しやすくします。
各タブには、そのデータベース固有の import 文、初期化コード、基本操作（createIndex、upsert）が含まれます。
プロバイダーには PgVector、Pinecone、Qdrant、Chroma、Astra、LibSQL、Upstash、Cloudflare、MongoDB、OpenSearch、Couchbase、S3 Vectors が含まれます。
*/}

<Tabs items={['MongoDB', 'Pg Vector', 'Pinecone', 'Qdrant', 'Chroma', 'Astra', 'LibSQL', 'Upstash', 'Cloudflare', 'OpenSearch', 'Couchbase', 'LanceDB', 'S3 Vectors']}>
  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { MongoDBVector } from '@mastra/mongodb'

    const store = new MongoDBVector({
      uri: process.env.MONGODB_URI,
      dbName: process.env.MONGODB_DATABASE
    })
    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });
    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });

    ```

    ### MongoDB Atlas Vector Search の利用

    詳細なセットアップ手順やベストプラクティスについては、[MongoDB Atlas Vector Search の公式ドキュメント](https://www.mongodb.com/docs/atlas/atlas-vector-search/vector-search-overview/?utm_campaign=devrel\&utm_source=third-party-content\&utm_medium=cta\&utm_content=mastra-docs)をご覧ください。
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { PgVector } from '@mastra/pg';

    const store = new PgVector({ connectionString: process.env.POSTGRES_CONNECTION_STRING })

    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```

    ### pgvector を使った PostgreSQL の利用

    pgvector 拡張機能を備えた PostgreSQL は、すでに PostgreSQL を利用しており、インフラの複雑さを最小限に抑えたいチームにとって適したソリューションです。
    詳細なセットアップ手順やベストプラクティスについては、[公式の pgvector リポジトリ](https://github.com/pgvector/pgvector)をご参照ください。
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { PineconeVector } from '@mastra/pinecone'

    const store = new PineconeVector({
      apiKey: process.env.PINECONE_API_KEY,
    })
    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });
    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { QdrantVector } from '@mastra/qdrant'

    const store = new QdrantVector({
      url: process.env.QDRANT_URL,
      apiKey: process.env.QDRANT_API_KEY
    })

    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });

    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { ChromaVector } from '@mastra/chroma'

    // Chroma をローカルで動かす
    // const store = new ChromaVector()

    // Chroma Cloud で動かす
    const store = new ChromaVector({
      apiKey: process.env.CHROMA_API_KEY,
      tenant: process.env.CHROMA_TENANT,
      database: process.env.CHROMA_DATABASE
    })

    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { AstraVector } from '@mastra/astra'

    const store = new AstraVector({
      token: process.env.ASTRA_DB_TOKEN,
      endpoint: process.env.ASTRA_DB_ENDPOINT,
      keyspace: process.env.ASTRA_DB_KEYSPACE
    })

    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });

    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { LibSQLVector } from "@mastra/core/vector/libsql";

    const store = new LibSQLVector({
      connectionUrl: process.env.DATABASE_URL,
      authToken: process.env.DATABASE_AUTH_TOKEN // 省略可: Turso のクラウドデータベース用
    })

    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { UpstashVector } from '@mastra/upstash'

    // Upstash では、ストアをインデックスと呼びます
    const store = new UpstashVector({
      url: process.env.UPSTASH_URL,
      token: process.env.UPSTASH_TOKEN
    })

    // ここで store.createIndex の呼び出しはありません。Upstash では（Upstash で namespace と呼ばれる）インデックスが自動的に作成されます
    // 該当する namespace がまだ存在しない場合は、upsert 時に自動作成されます。
    await store.upsert({
      indexName: "myCollection", // Upstash における namespace 名
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { CloudflareVector } from '@mastra/vectorize'

    const store = new CloudflareVector({
      accountId: process.env.CF_ACCOUNT_ID,
      apiToken: process.env.CF_API_TOKEN
    })
    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });
    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { OpenSearchVector } from '@mastra/opensearch'

    const store = new OpenSearchVector({ url: process.env.OPENSEARCH_URL })

    await store.createIndex({
      indexName: "my-collection",
      dimension: 1536,
    });

    await store.upsert({
      indexName: "my-collection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { CouchbaseVector } from '@mastra/couchbase'

    const store = new CouchbaseVector({
      connectionString: process.env.COUCHBASE_CONNECTION_STRING,
      username: process.env.COUCHBASE_USERNAME,
      password: process.env.COUCHBASE_PASSWORD,
      bucketName: process.env.COUCHBASE_BUCKET,
      scopeName: process.env.COUCHBASE_SCOPE,
      collectionName: process.env.COUCHBASE_COLLECTION,
    })
    await store.createIndex({
      indexName: "myCollection",
      dimension: 1536,
    });
    await store.upsert({
      indexName: "myCollection",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { LanceVectorStore } from '@mastra/lance'

    const store = await LanceVectorStore.create('/path/to/db')

    await store.createIndex({
      tableName: "myVectors",
      indexName: "myCollection",
      dimension: 1536,
    });

    await store.upsert({
      tableName: "myVectors",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    });
    ```

    ### LanceDB の使用

    LanceDB は、Lance のカラムナ形式の上に構築された組み込み型ベクターデータベースで、ローカル開発やクラウド環境へのデプロイに適しています。
    セットアップ手順やベストプラクティスの詳細は、[LanceDB の公式ドキュメント](https://lancedb.github.io/lancedb/)をご覧ください。
  </Tabs.Tab>

  <Tabs.Tab>
    ```ts filename="vector-store.ts" showLineNumbers copy
    import { S3Vectors } from "@mastra/s3vectors";

    const store = new S3Vectors({
      vectorBucketName: "my-vector-bucket",
      clientConfig: {
        region: "us-east-1",
      },
      nonFilterableMetadataKeys: ["content"],
    });

    await store.createIndex({
      indexName: "my-index",
      dimension: 1536,
    });
    await store.upsert({
      indexName: "my-index",
      vectors: embeddings,
      metadata: chunks.map(chunk => ({ text: chunk.text })),
      metadata: chunks.map(chunk => ({ text: chunk.text })),
    ```
  </Tabs.Tab>
</Tabs>

## ベクターストレージの使用

初期化が完了すると、すべてのベクターストアでインデックスの作成、埋め込みのアップサート、クエリの実行に同一のインターフェースを利用できます。

### インデックスの作成

埋め込みを保存する前に、使用する埋め込みモデルの次元数に合わせたインデックスを作成する必要があります。

```ts filename="store-embeddings.ts" showLineNumbers copy
// 次元 1536（text-embedding-3-small 用）のインデックスを作成する
await store.createIndex({
  indexName: "myCollection",
  dimension: 1536,
});
```

選択した埋め込みモデルの出力次元数に、次元サイズを合わせる必要があります。一般的な次元数は次のとおりです:

* OpenAI text-embedding-3-small: 1536 次元（またはカスタム例: 256）
* Cohere embed-multilingual-v3: 1024 次元
* Google `text-embedding-004`: 768 次元（またはカスタム）

> **重要**: インデックスの次元数は作成後に変更できません。別のモデルを使う場合は、新しい次元数でインデックスを削除して作り直してください。


### データベースの命名ルール

各ベクターデータベースは、互換性の確保と競合の防止のため、インデックスやコレクションに固有の命名規則を設けています。

{/*
LLM CONTEXT: この Tabs コンポーネントは、各種ベクターデータベースの命名規則を表示します。
各タブでは、各データベースプロバイダーに固有の命名要件や制約を説明します。
これにより、ユーザーは制約を理解し、インデックスやコレクション作成時の命名競合を回避できます。
規則を明確にするため、有効な名前と無効な名前の例を示します。
*/}

<Tabs items={['MongoDB', 'Pg Vector', 'Pinecone', 'Qdrant', 'Chroma', 'Astra', 'LibSQL', 'Upstash', 'Cloudflare', 'OpenSearch', 'S3 Vectors']}>
  <Tabs.Tab>
    コレクション（インデックス）名は次の条件を満たす必要があります:

    * 文字またはアンダースコアで始まること
    * 120バイト以内であること
    * 文字、数字、アンダースコア、またはドットのみを含むこと
    * `$` またはヌル文字を含まないこと
    * 例: `my_collection.123` は有効
    * 例: `my-index` は無効（ハイフンを含む）
    * 例: `My$Collection` は無効（`$` を含む）
  </Tabs.Tab>

  <Tabs.Tab>
    Index 名は次の条件を満たす必要があります:

    * 先頭は英字またはアンダースコアであること
    * 英字、数字、アンダースコアのみを含むこと
    * 例: `my_index_123` は有効
    * 例: `my-index` は無効（ハイフンを含む）
  </Tabs.Tab>

  <Tabs.Tab>
    Index 名は次の条件を満たす必要があります:

    * 小文字、数字、ハイフンのみを使用する
    * ドットを含めない（DNS ルーティングに使用されるため）
    * ラテン文字以外や絵文字を使用しない
    * プロジェクト ID を含めた合計の長さが 52 文字未満である
      * 例: `my-index-123` は有効
      * 例: `my.index` は無効（ドットを含む）
  </Tabs.Tab>

  <Tabs.Tab>
    コレクション名は次を満たす必要があります:

    * 長さが1〜255文字であること
    * 次の特殊文字を含まないこと:
      * `< > : " / \ | ? *`
      * Null文字（`\0`）
      * ユニットセパレータ（`\u{1F}`）
    * 例: `my_collection_123` は有効
    * 例: `my/collection` は無効（スラッシュを含むため）
  </Tabs.Tab>

  <Tabs.Tab>
    コレクション名は次の条件を満たす必要があります:

    * 3〜63文字であること
    * 文字または数字で始まり、文字または数字で終わること
    * 文字、数字、アンダースコア、ハイフンのみを含むこと
    * 連続するピリオド（..）を含まないこと
    * 有効なIPv4アドレスでないこと
    * 例: `my-collection-123` は有効
    * 例: `my..collection` は無効（ピリオドが連続しているため）
  </Tabs.Tab>

  <Tabs.Tab>
    コレクション名は次の条件を満たす必要があります:

    * 空でないこと
    * 48文字以内であること
    * 英字・数字・アンダースコアのみを含むこと
    * 例: `my_collection_123` は有効
    * 例: `my-collection` は無効（ハイフンが含まれるため）
  </Tabs.Tab>

  <Tabs.Tab>
    Index 名は次の条件を満たす必要があります:

    * 文字またはアンダースコアで始まること
    * 文字、数字、アンダースコアのみを含むこと
    * 例: `my_index_123` は有効
    * 例: `my-index` は無効（ハイフンを含むため）
  </Tabs.Tab>

  <Tabs.Tab>
    Namespace 名は次の条件を満たす必要があります:

    * 2〜100文字であること
    * 含める文字は次のみ:
      * 英数字 (a-z, A-Z, 0-9)
      * アンダースコア、ハイフン、ドット
    * 特殊文字 (&#95;, -, .) で始めたり終わったりしないこと
    * 大文字と小文字を区別する場合があること
    * 例: `MyNamespace123` は有効
    * 例: `_namespace` は無効 (先頭がアンダースコアのため)
  </Tabs.Tab>

  <Tabs.Tab>
    Index 名は次の条件を満たす必要があります:

    * 文字で始まること
    * 32文字未満であること
    * 小文字の ASCII 英字、数字、ハイフンのみを含むこと
    * スペースの代わりにハイフンを使用すること
    * 例: `my-index-123` は有効
    * 例: `My_Index` は無効（大文字とアンダースコア）
  </Tabs.Tab>

  <Tabs.Tab>
    インデックス名は次を満たす必要があります:

    * 小文字のみを使用すること
    * 先頭をアンダースコアまたはハイフンで始めないこと
    * スペースやカンマを含めないこと
    * 特殊文字を含めないこと（例: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`）
    * 例: `my-index-123` は有効
    * 例: `My_Index` は無効（大文字を含むため）
    * 例: `_myindex` は無効（先頭がアンダースコアのため）
  </Tabs.Tab>

  <Tabs.Tab>
    インデックス名は次を満たす必要があります:

    * 同一のベクターバケット内で一意であること
    * 3〜63文字であること
    * 小文字の英字（`a–z`）、数字（`0–9`）、ハイフン（`-`）、ドット（`.`）のみを使用すること
    * 英字または数字で始まり、英字または数字で終わること
    * 例: `my-index.123` は有効
    * 例: `my_index` は無効（アンダースコアを含む）
    * 例: `-myindex` は無効（ハイフンで始まる）
    * 例: `myindex-` は無効（ハイフンで終わる）
    * 例: `MyIndex` は無効（大文字を含む）
  </Tabs.Tab>
</Tabs>

### 埋め込みのアップサート

インデックスを作成したら、埋め込みを基本的なメタデータと一緒に保存できます。

```ts filename="store-embeddings.ts" showLineNumbers copy
// 対応するメタデータとともに埋め込みを保存する
await store.upsert({
  indexName: "myCollection", // インデックス名
  vectors: embeddings, // 埋め込みベクトルの配列
  metadata: chunks.map((chunk) => ({
    text: chunk.text, // 元のテキスト内容
    id: chunk.id, // 任意の一意の識別子
  })),
});
```

upsert 操作では次のことを行います:

* 埋め込みベクトルの配列と対応するメタデータを受け取る
* 同じ ID の既存ベクトルを更新する
* 存在しない場合は新しいベクトルを作成する
* 大規模データセットに対して自動でバッチ処理を行う

さまざまなベクトルストアでの埋め込みの upsert の完全な例は、[Upsert Embeddings](../../examples/rag/upsert/upsert-embeddings.mdx) ガイドを参照してください。


## メタデータの追加

ベクターストアは、フィルタリングや整理のために、リッチなメタデータ（JSONでシリアライズ可能な任意のフィールド）をサポートします。メタデータは固定スキーマなしで保存されるため、想定外のクエリ結果を避けるには、フィールド名を一貫して使用してください。

**重要**: メタデータはベクトルストアにとって不可欠です。これがないと、元のテキストを返したり結果を絞り込んだりする手段のない数値ベクトルの埋め込みしか持てません。最低でも、ソーステキストはメタデータとして必ず保存してください。

```ts showLineNumbers copy
// 整理やフィルタリングをしやすくするため、充実したメタデータとともに埋め込みを保存する
await store.upsert({
  indexName: "myCollection",
  vectors: embeddings,
  metadata: chunks.map((chunk) => ({
    // 基本情報
    text: chunk.text,
    id: chunk.id,

    // ドキュメントの整理
    source: chunk.source,
    category: chunk.category,

    // 時間関連のメタデータ
    createdAt: new Date().toISOString(),
    version: "1.0",

    // カスタムフィールド
    language: chunk.language,
    author: chunk.author,
    confidenceScore: chunk.score,
  })),
});
```

メタデータに関する主な留意点:

* フィールド名は厳密に統一すること — &#39;category&#39; と &#39;Category&#39; のような不一致はクエリに影響します
* フィルタやソートに使う予定のフィールドのみを含めること — 余分なフィールドはオーバーヘッドになります
* コンテンツの新鮮さを追跡できるよう、タイムスタンプ（例: &#39;createdAt&#39;, &#39;lastUpdated&#39;）を追加すること


## ベストプラクティス

- 一括挿入の前にインデックスを作成する
- 大量挿入にはバッチ処理を使用する（`upsert` メソッドは自動でバッチ処理を行います）
- クエリ対象となるメタデータのみを保存する
- 埋め込みの次元数をモデルに合わせる（例：`text-embedding-3-small` の場合は 1536）