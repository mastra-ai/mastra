---
title: "ワーキングメモリ | メモリ | Mastra ドキュメント"
description: "Mastraでワーキングメモリを構成し、永続的なユーザーデータや設定を保存する方法を学びましょう。"
---

import YouTube from "@/components/youtube";


# ワーキングメモリ

[会話履歴](/docs/memory/overview#conversation-history) と [セマンティックリコール](./semantic-recall.mdx) はエージェントが会話を思い出すのに役立ちますが、ワーキングメモリは、エージェントがユーザーに関する情報をやり取りの間にわたって持続的に保持できるようにします。

これは、エージェントのアクティブな思考や下書き帳のようなもので、ユーザーやタスクに関する重要な情報を手元に置いておくことを指します。人が会話中に自然と相手の名前や好み、重要な詳細を覚えておくのと同じようなものです。

これは、常に関連し、エージェントが常時利用できるべき継続的な状態を維持するのに有用です。

ワーキングメモリは次の2つのスコープで保持できます:

- **リソーススコープ**（デフォルト）：同じユーザーに対するすべての会話スレッド間でメモリが保持されます
- **スレッドスコープ**：メモリは会話スレッドごとに分離されます

**重要:** スコープを切り替えると、エージェントは他方のスコープのメモリを参照できません。スレッドスコープのメモリはリソーススコープのメモリと完全に分離されています。

## クイックスタート

作業メモリを備えたエージェントをセットアップする最小構成の例は次のとおりです：

```typescript {12-15}
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { openai } from "@ai-sdk/openai";

// ワーキングメモリを有効にしてエージェントを作成
const agent = new Agent({
  name: "PersonalAssistant",
  instructions: "あなたは頼れるパーソナルアシスタントです。",
  model: openai("gpt-4o"),
  memory: new Memory({
    options: {
      workingMemory: {
        enabled: true,
      },
    },
  }),
});
```


## 仕組み

Working memory は、エージェントが時間の経過に応じて更新し、常に必要となる情報を蓄積しておける Markdown テキストのブロックです。

<YouTube id="UMy_JHLf1n8" />

## メモリの永続スコープ

ワーキングメモリは2種類のスコープで動作し、会話をまたいだメモリの保持方法を選択できます。

### リソース単位のメモリ（デフォルト）

デフォルトでは、同じユーザー（resourceId）の会話スレッド全体で作業メモリが保存され、ユーザーの記憶が永続的に維持されます。

```typescript
const memory = new Memory({
  storage,
  options: {
    workingMemory: {
      enabled: true,
      scope: 'resource', // メモリはすべてのユーザースレッド間で保持されます
      template: `# ユーザープロフィール
- **名前**:
- **場所**:
- **興味・関心**:
- **設定**:
- **長期目標**:
`,
    },
  },
});
```

**ユースケース:**

* ユーザーの嗜好を記憶するパーソナルアシスタント
* 顧客情報や状況を把握し続けるカスタマーサービスボット
* 学習者の進捗を追跡する教育アプリ


### エージェントでの使用

resource-scoped memory を使用する場合は、`resourceId` パラメータを必ず渡してください:

```typescript
// リソーススコープのメモリには resourceId が必要です
const response = await agent.generate("こんにちは！", {
  threadId: "conversation-123",
  resourceId: "user-alice-456" // 異なるスレッドでも同じユーザー
});
```


### スレッド単位のメモリ

スレッド単位のメモリは、作業メモリを各会話スレッドごとに分離します。各スレッドは、それぞれ独立したメモリを保持します。

```typescript
const memory = new Memory({
  storage,
  options: {
    workingMemory: {
      enabled: true,
      scope: 'thread', // メモリはスレッドごとに分離されます
      template: `# ユーザープロフィール
- **名前**:
- **興味・関心**:
- **現在の目標**:
`,
    },
  },
});
```

**ユースケース:**

* 別々のトピックについての別個の会話
* 一時的またはセッション固有の情報
* 各スレッドにワーキングメモリは必要だが、スレッド自体は短命で互いに関連しないワークフロー


## ストレージアダプターのサポート

リソーススコープのワーキングメモリには、`mastra_resources` テーブルに対応した専用のストレージアダプターが必要です。

### ✅ 対応ストレージアダプター

- **LibSQL** (`@mastra/libsql`)
- **PostgreSQL** (`@mastra/pg`)
- **Upstash** (`@mastra/upstash`)

## カスタムテンプレート

テンプレートは、エージェントが作業メモリでどの情報を追跡・更新するかを指示します。テンプレートが指定されていない場合はデフォルトのテンプレートが使用されますが、通常はエージェントの特定のユースケースに合わせてカスタムテンプレートを定義し、最も関連性の高い情報を確実に記憶できるようにすることをお勧めします。

以下はカスタムテンプレートの例です。この例では、ユーザーがそれらの情報を含むメッセージを送信した時点で、エージェントはユーザーの名前、位置情報、タイムゾーンなどを保存します。

```typescript {5-28}
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      template: `
# ユーザープロフィール

## 個人情報

- 氏名:
- 居住地:
- タイムゾーン:

## 望ましい設定

- コミュニケーションのスタイル: [例: フォーマル、カジュアル]
- プロジェクトの目標:
- 重要な締め切り:
  - [締め切り 1]: [日付]
  - [締め切り 2]: [日付]

## セッション状況

- 直近に議論したタスク:
- 未解決の質問:
  - [質問 1]
  - [質問 2]
`,
    },
  },
});
```


## 効果的なテンプレート設計

よく構造化されたテンプレートは、エージェントが情報を解釈・更新しやすい状態を保ちます。テンプレートは、アシスタントに常に最新化してほしい簡潔なフォームとして扱いましょう。

- **短く要点を押さえたラベル。** 段落や長すぎる見出しは避けましょう。ラベルは簡潔に（例:
  `## Personal Info` や `- Name:`）しておくと、更新が読みやすく、途中で切り捨てられにくくなります。
- **大文字・小文字の表記を統一する。** 大文字小文字が不一致（`Timezone:` と `timezone:`）だと、更新が雑になりがちです。見出しや箇条書きのラベルは Title Case か lower case のどちらかに統一しましょう。
- **プレースホルダー文言はシンプルに。** `[e.g., Formal]` や `[Date]` といったヒントを使い、LLM が正しい箇所を埋めやすくします。
- **非常に長い値は省略する。** 短い形式だけが必要な場合は、全文の法的表記ではなく、
  `- Name: [First name or nickname]` や `- Address (short):` のようなガイダンスを含めましょう。
- **`instructions` に更新ルールを明記する。** テンプレートのどの部分をいつ埋めるか、またはクリアするかを、エージェントの `instructions` フィールドで直接指示できます。

### 代替テンプレートスタイル

必要な項目が少ない場合は、より短い単一ブロックを使用します:

```typescript
const basicMemory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      template: `ユーザー情報:\n- 名前:\n- 好きな色:\n- 現在のトピック:`,
    },
  },
});
```

より物語的なスタイルを好む場合は、重要な要点を短い段落形式でまとめることもできます。

```typescript
const paragraphMemory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      template: `重要事項:\n\nユーザーの重要情報（名前、主な目標、現在のタスク）を簡潔な段落でまとめてください。`,
    },
  },
});
```


## 構造化ワーキングメモリ

ワーキングメモリは、Markdown テンプレートの代わりに構造化スキーマで定義することもできます。これにより、追跡すべきフィールドや型を [Zod](https://zod.dev/) のスキーマで正確に指定できます。スキーマを使用すると、エージェントはスキーマに準拠した JSON オブジェクトとしてワーキングメモリを表示・更新します。

**重要:** `template` と `schema` のどちらか一方を指定し、両方を同時には指定しないでください。

### 例：スキーマベースの作業記憶

```typescript
import { z } from 'zod';
import { Memory } from '@mastra/memory';

const userProfileSchema = z.object({
  name: z.string().optional(),
  location: z.string().optional(),
  timezone: z.string().optional(),
  preferences: z.object({
    communicationStyle: z.string().optional(),
    projectGoal: z.string().optional(),
    deadlines: z.array(z.string()).optional(),
  }).optional(),
});

const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
      schema: userProfileSchema,
      // テンプレート: ...（設定しない）
    },
  },
});
```

スキーマが提供されている場合、エージェントはワーキングメモリをJSONオブジェクトとして受け取ります。例：

```json
{
  "name": "Sam",
  "location": "Berlin",
  "timezone": "CET",
  "preferences": {
    "communicationStyle": "丁寧",
    "projectGoal": "MVP をリリースする",
    "deadlines": ["2025-07-01"]
  }
}
```


## Template と Schema の選択

- エージェントに、ユーザープロファイルやスクラッチパッドなどの自由形式テキストとしてメモリを保持させたい場合は、**template**（Markdown）を使用します。
- 検証可能で、JSON としてプログラムからアクセスできる構造化された型安全なデータが必要な場合は、**schema** を使用します。
- 同時に有効にできるのは一方のみです。`template` と `schema` を同時に設定することはサポートされていません。

## 例: マルチステップのリテンション

以下は、短いユーザーとの会話の中で `User Profile` テンプレートがどのように更新されるかを簡略化して示したものです。

```nohighlight
# ユーザープロフィール

## 個人情報

- 名前:
- 居住地:
- タイムゾーン:

--- ユーザーが「私の名前は**Sam**で、**Berlin**から来ました」と言った後 ---

# ユーザープロフィール
- 名前: Sam
- 居住地: Berlin
- タイムゾーン:

--- ユーザーが「ちなみに普段は**CET**です」と付け加えた後 ---

# ユーザープロフィール
- 名前: Sam
- 居住地: Berlin
- タイムゾーン: CET
```

エージェントは、作業メモリに保存されているため、以降の応答で `Sam` や `Berlin` を情報を再度求めることなく参照できます。

期待どおりに作業メモリが更新されない場合は、エージェントの `instructions` 設定に、このテンプレートを「どのように」「いつ」使用するかに関するシステム指示を追加できます。


## 初期ワーキングメモリの設定

エージェントは通常 `updateWorkingMemory` ツールでワーキングメモリを更新しますが、スレッドの作成や更新時に、プログラムで初期ワーキングメモリを設定することもできます。これは、ユーザーデータ（名前、好み、その他の情報など）を毎回のリクエストで渡さなくてもエージェントが利用できるようにあらかじめ組み込むのに役立ちます。

### スレッドのメタデータでワーキングメモリを設定する

スレッドを作成する際は、メタデータの `workingMemory` キーで初期ワーキングメモリを指定できます:

```typescript filename="src/app/medical-consultation.ts" showLineNumbers copy
// 初期の作業メモリを持つスレッドを作成する
const thread = await memory.createThread({
  threadId: "thread-123",
  resourceId: "user-456",
  title: "医療相談",
  metadata: {
    workingMemory: `# 患者プロフィール
- 氏名: John Doe
- 血液型: O+
- アレルギー: ペニシリン
- 服用中の薬: なし
- 既往歴: 高血圧（良好にコントロール）
`
  }
});

// エージェントは以後のすべてのメッセージでこの情報にアクセスできる
await agent.generate("私の血液型は何ですか？", {
  threadId: thread.id,
  resourceId: "user-456"
});
// 応答: "あなたの血液型はO+です。"
```


### 作業メモリをプログラムから更新する

既存のスレッドの作業メモリを更新することもできます。

```typescript filename="src/app/medical-consultation.ts" showLineNumbers copy
// 作業メモリを追加・変更するためにスレッドのメタデータを更新
await memory.updateThread({
  id: "thread-123",
  title: thread.title,
  metadata: {
    ...thread.metadata,
    workingMemory: `# 患者プロフィール
- 氏名: John Doe
- 血液型: O+
- アレルギー: ペニシリン、イブプロフェン  // 更新
- 服用中の薬: リシノプリル 10mg/日  // 追加
- 既往歴: 高血圧（コントロール良好）
`
  }
});
```


### メモリを直接更新する

または、`updateWorkingMemory` メソッドを直接使用します。

```typescript filename="src/app/medical-consultation.ts" showLineNumbers copy
await memory.updateWorkingMemory({
  threadId: "thread-123",
  resourceId: "user-456", // リソーススコープのメモリに必須
  workingMemory: "更新後のメモリ内容..."
});
```


## 例

- [基本的なワーキングメモリ](/examples/memory/working-memory-basic)
- [テンプレートを用いたワーキングメモリ](/examples/memory/working-memory-template)
- [スキーマを用いたワーキングメモリ](/examples/memory/working-memory-schema)
- [リソースごとのワーキングメモリ](https://github.com/mastra-ai/mastra/tree/main/examples/memory-per-resource-example) - リソース単位のメモリ永続化を示す完結したサンプル