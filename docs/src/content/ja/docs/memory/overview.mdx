---
title: "メモリ概要 | メモリ | Mastra ドキュメント"
description: "Mastra のメモリシステムにおけるワーキングメモリ、会話履歴、セマンティックリコールの仕組みを学びましょう。"
---

import { Steps } from "nextra/components";


# メモリの概要

Mastra のメモリは、関連情報を言語モデルのコンテキストウィンドウに要約して取り込むことで、エージェントが会話全体を通じてコンテキストを管理できるようにします。

Mastra は 3 種類のメモリをサポートします：ワーキングメモリ、会話履歴、セマンティックリコール。メモリには 2 段階のスコープがあり、会話スレッドごとに分離する（スレッドスコープ）ことも、同一ユーザーのすべての会話で共有する（リソーススコープ）こともできます。

Mastra のメモリシステムは、[storage providers](#memory-storage-adapters) を使用して、アプリケーションの再起動をまたいで会話スレッド、メッセージ、ワーキングメモリを永続化します。

## はじめに

まずは必要な依存関係をインストールします。

```bash copy
npm install @mastra/core @mastra/memory @mastra/libsql
```

次に、メインの Mastra インスタンスにストレージアダプターを追加します。メモリを有効にしたエージェントは、この共有ストレージを使ってやり取りを保存し、参照（再利用）します。

```typescript {6-8} filename="src/mastra/index.ts" showLineNumbers copy
import { Mastra } from "@mastra/core/mastra";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  // ...
  storage: new LibSQLStore({
    url: ":memory:"
  })
});
```

次に、エージェントの`memory`パラメータに`Memory`インスタンスを渡してメモリを有効化します：

```typescript {3-5} filename="src/mastra/agents/test-agent.ts" showLineNumbers copy
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";

export const testAgent = new Agent({
  // ...
  memory: new Memory()
});
```

そのメモリインスタンスには、ワーキングメモリ、会話履歴、セマンティックリコール向けに設定できるオプションがあります。


## さまざまなタイプのメモリ

Mastra は 3 種類のメモリをサポートします：ワーキングメモリ、会話履歴、セマンティックリコール。

[**ワーキングメモリ**](./working-memory.mdx) は、名前、好み、目標、その他の構造化データなど、ユーザー固有の情報を永続的に保存します（ChatGPT に「私について教えて」と尋ねられる機能を思い浮かべてください）。これは、エージェントが時間経過とともに更新できる Markdown テキストのブロック（または代替として Zod スキーマ）として実装されています。

[**会話履歴**](./conversation-history.mdx) は、現在の会話における直近のメッセージを保持し、短期的な連続性を確保して対話の流れを維持します。

[**セマンティックリコール**](./semantic-recall.mdx) は、意味的な関連性に基づいて過去の会話から古いメッセージを検索・取得します。マッチはベクトル検索で見つけられ、理解を深めるために周辺のコンテキストを含めることができます。

Mastra はこれらすべてのメモリを単一のコンテキストウィンドウに統合します。合計がモデルのトークン上限を超える場合は、[memory processors](./memory-processors.mdx) を使用して、モデルに送信する前にメッセージを要約・フィルタリングしてください。

## スレッドとリソースによるメモリのスコープ

すべてのメモリタイプはデフォルトで[リソーススコープ](./working-memory.mdx#resource-scoped-memory-default)であり、同一のユーザーまたはエンティティに対するすべての会話にわたって保持されます。[スレッドスコープ](./working-memory.mdx#thread-scoped-memory)に設定すると、メモリは単一の会話スレッドに限定されます。

## メモリストレージアダプター

会話間で情報を保存・呼び出すには、メモリにストレージアダプターが必要です。

利用可能なオプションには、[LibSQL](/docs/memory/storage/memory-with-libsql)、[MongoDB](/docs/memory/storage/memory-with-mongodb)、[Postgres](/docs/memory/storage/memory-with-pg)、および [Upstash](/docs/memory/storage/memory-with-upstash) があります。

LibSQL はファイルベースまたはインメモリで動作し、インストールが容易でプレイグラウンドとの相性も良いため、標準で採用しています。

## 専用ストレージ

エージェントごとに専用のストレージを設定でき、タスクや会話、記憶した情報をエージェント間で分離して保持できます。

### エージェントへのストレージ追加

エージェントに専用ストレージを割り当てるには、必要な依存関係をインストールしてインポートし、`Memory` のコンストラクターに `storage` インスタンスを渡します。

```typescript {3, 9-11} filename="src/mastra/agents/test-agent.ts" showLineNumbers copy
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { LibSQLStore } from "@mastra/libsql";

export const testAgent = new Agent({
  // 省略
  memory: new Memory({
    // 省略
    storage: new LibSQLStore({
      url: "file:agent-memory.db"
    })
  // 省略
  })
});
```


## 取得メッセージの表示

Mastra のデプロイでトレーシングが有効化され、メモリが `lastMessages` や `semanticRecall` で構成されている場合、エージェントのトレース出力には、コンテキスト用に取得されたすべてのメッセージ（直近の会話履歴と、セマンティック・リコールによって想起されたメッセージの両方）が表示されます。

これは、デバッグ、エージェントの意思決定の理解、各リクエストに対してエージェントが適切な情報を取得できているかの検証に役立ちます。

トレーシングの有効化と設定の詳細は、[Tracing](../observability/tracing) を参照してください。

## LibSQL を使ったローカル開発

`LibSQLStore` を用いたローカル開発では、VS Code の [SQLite Viewer](https://marketplace.visualstudio.com/items?itemName=qwtel.sqlite-viewer) 拡張機能を使って、保存されているメモリを確認できます。

![SQLite Viewer](/image/memory/memory-sqlite-viewer.jpg)

## 次のステップ

コア概念を理解したら、[semantic recall](./semantic-recall.mdx) に進み、Mastra エージェントに RAG メモリを追加する方法を学びましょう。

または、利用可能な設定項目については [configuration reference](../../reference/memory/Memory.mdx) を参照してください。