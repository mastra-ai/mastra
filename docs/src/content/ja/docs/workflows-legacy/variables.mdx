---
title: "ワークフロー（旧式）変数によるデータマッピング | Mastra Docs"
description: "Mastra のワークフローで、ステップ間のデータをマッピングし、動的なデータフローを作成するためにワークフロー変数を使う方法を学びます。"
---

# ワークフロー変数によるデータマッピング

Mastra のワークフロー変数は、ステップ間でのデータマッピングを可能にする強力な仕組みで、動的なデータフローを構築し、あるステップから別のステップへ情報を受け渡せます。

## ワークフロー変数を理解する

Mastra のワークフローにおいて、変数は次のような用途に使われます:

- トリガーの入力からステップの入力へのデータのマッピング
- あるステップの出力を別のステップの入力に受け渡す
- ステップの出力内にあるネストしたプロパティへアクセスする
- より柔軟で再利用しやすいワークフローステップを作成する

## データのマッピングに変数を使う

### 基本的な変数マッピング

ワークフローにステップを追加する際に `variables` プロパティを使用して、ステップ間でデータをマッピングできます。

```typescript showLineNumbers filename="src/mastra/workflows/index.ts" copy
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";

const workflow = new LegacyWorkflow({
  name: "data-mapping-workflow",
  triggerSchema: z.object({
    inputData: z.string(),
  }),
});

workflow
  .step(step1, {
    variables: {
      // トリガーのデータをステップの入力にマッピングする
      inputData: { step: "trigger", path: "inputData" },
    },
  })
  .then(step2, {
    variables: {
      // step1 の出力を step2 の入力にマッピングする
      previousValue: { step: step1, path: "outputField" },
    },
  })
  .commit();

// Mastra にワークフローを登録する
export const mastra = new Mastra({
  legacy_workflows: { workflow },
});
```


### ネストされたプロパティへのアクセス

`path` フィールドでドット記法を使って、ネストされたプロパティにアクセスできます。

```typescript showLineNumbers filename="src/mastra/workflows/index.ts" copy
workflow
  .step(step1)
  .then(step2, {
    variables: {
      // step1 の出力からネストされたプロパティにアクセスする
      nestedValue: { step: step1, path: "nested.deeply.value" },
    },
  })
  .commit();
```


### オブジェクト全体のマッピング

パスとして `.` を使用すると、オブジェクト全体をマッピングできます。

```typescript showLineNumbers filename="src/mastra/workflows/index.ts" copy
workflow
  .step(step1, {
    variables: {
      // トリガーのデータオブジェクト全体をマップする
      triggerData: { step: "trigger", path: "." },
    },
  })
  .commit();
```


### ループ内の変数

変数は `while` や `until` ループにも渡せます。これは、各イテレーション間や外部のステップからデータを受け渡すのに便利です。

```typescript showLineNumbers filename="src/mastra/workflows/loop-variables.ts" copy
// カウンターを1つ増やすステップ
const incrementStep = new LegacyStep({
  id: "increment",
  inputSchema: z.object({
    // 前回の反復処理からの前回値
    prevValue: z.number().optional(),
  }),
  outputSchema: z.object({
    // 更新後のカウンター値
    updatedCounter: z.number(),
  }),
  execute: async ({ context }) => {
    const { prevValue = 0 } = context.inputData;
    return { updatedCounter: prevValue + 1 };
  },
});

const workflow = new LegacyWorkflow({
  name: "counter",
});

workflow.step(incrementStep).while(
  async ({ context }) => {
    // カウンターが10未満の間は継続
    const result = context.getStepResult(incrementStep);
    return (result?.updatedCounter ?? 0) < 10;
  },
  incrementStep,
  {
    // 次の反復処理に前回値を渡す
    prevValue: {
      step: incrementStep,
      path: "updatedCounter",
    },
  },
);
```


## 変数の解決

ワークフローの実行時、Mastra は変数を次の手順で解決します:

1. `step` プロパティで指定されたソースステップを特定する
2. そのステップの出力を取得する
3. `path` を使って指定されたプロパティに移動する
4. 解決した値をターゲットステップのコンテキスト内の `inputData` プロパティとして挿入する

## 例

### トリガーデータのマッピング

この例では、ワークフローのトリガーからステップへデータをマッピングする方法を示します。

```typescript showLineNumbers filename="src/mastra/workflows/trigger-mapping.ts" copy
import { Mastra } from "@mastra/core";
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// ユーザー入力が必要なステップを定義する
const processUserInput = new LegacyStep({
  id: "processUserInput",
  execute: async ({ context }) => {
    // 変数マッピングにより、inputData は context で参照可能になる
    const { inputData } = context.inputData;

    return {
      processedData: `Processed: ${inputData}`,
    };
  },
});

// ワークフローを作成する
const workflow = new LegacyWorkflow({
  name: "trigger-mapping",
  triggerSchema: z.object({
    inputData: z.string(),
  }),
});

// トリガーのデータをステップにマッピングする
workflow
  .step(processUserInput, {
    variables: {
      inputData: { step: "trigger", path: "inputData" },
    },
  })
  .commit();

// ワークフローを Mastra に登録する
export const mastra = new Mastra({
  legacy_workflows: { workflow },
});
```


### ステップ間のマッピング

この例では、あるステップから別のステップへデータをマッピングする方法を示します。

```typescript showLineNumbers filename="src/mastra/workflows/step-mapping.ts" copy
import { Mastra } from "@mastra/core";
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// ステップ1: データを生成
const generateData = new LegacyStep({
  id: "generateData",
  outputSchema: z.object({
    nested: z.object({
      value: z.string(),
    }),
  }),
  execute: async () => {
    return {
      nested: {
        value: "step1-data",
      },
    };
  },
});

// ステップ2: ステップ1のデータを処理
const processData = new LegacyStep({
  id: "processData",
  inputSchema: z.object({
    previousValue: z.string(),
  }),
  execute: async ({ context }) => {
    // 変数マッピングにより previousValue を参照できます
    const { previousValue } = context.inputData;

    return {
      result: `Processed: ${previousValue}`,
    };
  },
});

// ワークフローを作成
const workflow = new LegacyWorkflow({
  name: "step-mapping",
});

// ステップ1のデータをステップ2へマッピング
workflow
  .step(generateData)
  .then(processData, {
    variables: {
      // generateData の出力から nested.value プロパティをマッピング
      previousValue: { step: generateData, path: "nested.value" },
    },
  })
  .commit();

// Mastra にワークフローを登録
export const mastra = new Mastra({
  legacy_workflows: { workflow },
});
```


## 型安全性

Mastra は、TypeScript 使用時に変数マッピングの型安全性を提供します。

```typescript showLineNumbers filename="src/mastra/workflows/type-safe.ts" copy
import { Mastra } from "@mastra/core";
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";

// 型安全性を高めるためにスキーマを定義する
const triggerSchema = z.object({
  inputValue: z.string(),
});

type TriggerType = z.infer<typeof triggerSchema>;

// 型付きコンテキストを持つステップ
const step1 = new LegacyStep({
  id: "step1",
  outputSchema: z.object({
    nested: z.object({
      value: z.string(),
    }),
  }),
  execute: async ({ context }) => {
    // TypeScript は triggerData の型構造を認識している
    const triggerData = context.getStepResult<TriggerType>("trigger");

    return {
      nested: {
        value: `processed-${triggerData?.inputValue}`,
      },
    };
  },
});

// スキーマを用いてワークフローを作成する
const workflow = new LegacyWorkflow({
  name: "type-safe-workflow",
  triggerSchema,
});

workflow.step(step1).commit();

// Mastra にワークフローを登録する
export const mastra = new Mastra({
  legacy_workflows: { workflow },
});
```


## ベストプラクティス

1. **入力と出力を検証する**: データの整合性を確保するために `inputSchema` と `outputSchema` を使用する。

2. **マッピングはシンプルに保つ**: 可能な限り、過度に複雑な入れ子のパスは避ける。

3. **デフォルト値を検討する**: マッピングされたデータが未定義の場合に備えて適切に処理する。

## 直接コンテキストアクセスとの比較

`context.steps` を使って前のステップの結果に直接アクセスすることも可能ですが、変数マッピングを使用すると次の利点があります:

| 特徴       | 変数マッピング                               | 直接コンテキストアクセス         |
| ---------- | -------------------------------------------- | -------------------------------- |
| 明確性     | データ依存関係が明示的                       | 依存関係が暗黙的                 |
| 再利用性   | ステップを異なるマッピングで再利用できる     | ステップが密結合                 |
| 型安全性   | TypeScript との統合性が高い                  | 手動での型アサーションが必要     |