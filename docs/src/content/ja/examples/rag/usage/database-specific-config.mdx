---
title: "データベース別の設定 | RAG | Mastra Examples"
description: ベクトル検索のパフォーマンスを最適化し、各種ベクトルストアの独自機能を活用するためのデータベース別設定の使い方を学びます。
---

import { Tabs } from "nextra/components";


# データベース固有の設定

この例では、ベクタークエリツールでデータベース固有の設定を活用し、パフォーマンスを最適化するとともに、各ベクターストアの固有の機能を引き出す方法を示します。

## 複数環境のセットアップ

環境ごとに異なる設定を使い分けます:

<Tabs items={['TypeScript', 'JavaScript']}>
  <Tabs.Tab>
    ```typescript
    import { openai } from "@ai-sdk/openai";
    import { createVectorQueryTool } from "@mastra/rag";
    import { RuntimeContext } from "@mastra/core/runtime-context";

    // ベース設定
    const createSearchTool = (environment: 'dev' | 'staging' | 'prod') => {
      return createVectorQueryTool({
        vectorStoreName: "pinecone",
        indexName: "documents",
        model: openai.embedding("text-embedding-3-small"),
        databaseConfig: {
          pinecone: {
            namespace: environment
          }
        }
      });
    };

    // 環境ごとのツールを作成
    const devSearchTool = createSearchTool('dev');
    const prodSearchTool = createSearchTool('prod');

    // もしくは実行時に上書き
    const dynamicSearchTool = createVectorQueryTool({
      vectorStoreName: "pinecone", 
      indexName: "documents",
      model: openai.embedding("text-embedding-3-small")
    });

    // 実行時に環境を切り替える
    const switchEnvironment = async (environment: string, query: string) => {
      const runtimeContext = new RuntimeContext();
      runtimeContext.set('databaseConfig', {
        pinecone: {
          namespace: environment
        }
      });

      return await dynamicSearchTool.execute({
        context: { queryText: query },
        mastra,
        runtimeContext
      });
    };
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript
    import { openai } from "@ai-sdk/openai";
    import { createVectorQueryTool } from "@mastra/rag";
    import { RuntimeContext } from "@mastra/core/runtime-context";

    // ベース設定
    const createSearchTool = (environment) => {
      return createVectorQueryTool({
        vectorStoreName: "pinecone",
        indexName: "documents", 
        model: openai.embedding("text-embedding-3-small"),
        databaseConfig: {
          pinecone: {
            namespace: environment
          }
        }
      });
    };

    // 環境ごとのツールを作成
    const devSearchTool = createSearchTool('dev');
    const prodSearchTool = createSearchTool('prod');

    // もしくは実行時に上書き
    const dynamicSearchTool = createVectorQueryTool({
      vectorStoreName: "pinecone",
      indexName: "documents",
      model: openai.embedding("text-embedding-3-small")
    });

    // 実行時に環境を切り替える
    const switchEnvironment = async (environment, query) => {
      const runtimeContext = new RuntimeContext();
      runtimeContext.set('databaseConfig', {
        pinecone: {
          namespace: environment
        }
      });

      return await dynamicSearchTool.execute({
        context: { queryText: query },
        mastra,
        runtimeContext
      });
    };
    ```
  </Tabs.Tab>
</Tabs>

## pgVector によるパフォーマンス最適化

ユースケースに合わせて検索パフォーマンスを最適化します:

<Tabs items={['High Accuracy', 'High Speed', 'Balanced']}>
  <Tabs.Tab>
    ```typescript
    // 高精度構成 - 低速だがより正確
    const highAccuracyTool = createVectorQueryTool({
      vectorStoreName: "postgres",
      indexName: "embeddings",
      model: openai.embedding("text-embedding-3-small"),
      databaseConfig: {
        pgvector: {
          ef: 400,          // HNSW の高精度設定
          probes: 20,       // IVFFlat の高リコール設定
          minScore: 0.85    // 高い品質しきい値
        }
      }
    });

    // 精度最優先のクリティカルな検索に使用
    const criticalSearch = async (query: string) => {
      return await highAccuracyTool.execute({
        context: { 
          queryText: query,
          topK: 5  // 件数は少なく、質を重視
        },
        mastra
      });
    };
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    // 高速構成 - 高速だが精度は低め
    const highSpeedTool = createVectorQueryTool({
      vectorStoreName: "postgres", 
      indexName: "embeddings",
      model: openai.embedding("text-embedding-3-small"),
      databaseConfig: {
        pgvector: {
          ef: 50,           // 速度重視で精度は控えめ
          probes: 3,        // 速度重視でリコールは控えめ
          minScore: 0.6     // 低めの品質しきい値
        }
      }
    });

    // リアルタイム用途で使用
    const realtimeSearch = async (query: string) => {
      return await highSpeedTool.execute({
        context: { 
          queryText: query,
          topK: 10  // 精度低下を補うため結果数を増やす
        },
        mastra
      });
    };
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    // バランス構成 - ちょうどよい妥協点
    const balancedTool = createVectorQueryTool({
      vectorStoreName: "postgres",
      indexName: "embeddings", 
      model: openai.embedding("text-embedding-3-small"),
      databaseConfig: {
        pgvector: {
          ef: 150,          // 中程度の精度
          probes: 8,        // 中程度のリコール
          minScore: 0.7     // 中程度の品質しきい値
        }
      }
    });

    // 負荷に応じてパラメータを調整
    const adaptiveSearch = async (query: string, isHighLoad: boolean) => {
      const runtimeContext = new RuntimeContext();
      
      if (isHighLoad) {
        // 高負荷時は速度を優先して品質を下げる
        runtimeContext.set('databaseConfig', {
          pgvector: {
            ef: 75,
            probes: 5,
            minScore: 0.65
          }
        });
      }

      return await balancedTool.execute({
        context: { queryText: query },
        mastra,
        runtimeContext
      });
    };
    ```
  </Tabs.Tab>
</Tabs>

## Pinecone を使ったマルチテナントアプリケーション

Pinecone のネームスペースを利用してテナント分離を実装します：

```typescript
interface Tenant {
  id: string;
  name: string;
  namespace: string;
}

class MultiTenantSearchService {
  private searchTool: RagTool

  constructor() {
    this.searchTool = createVectorQueryTool({
      vectorStoreName: "pinecone",
      indexName: "shared-documents",
      model: openai.embedding("text-embedding-3-small")
    });
  }

  async searchForTenant(tenant: Tenant, query: string) {
    const runtimeContext = new RuntimeContext();
    
    // 検索対象をテナントのネームスペースに限定する
    runtimeContext.set('databaseConfig', {
      pinecone: {
        namespace: tenant.namespace
      }
    });

    const results = await this.searchTool.execute({
      context: { 
        queryText: query,
        topK: 10
      },
      mastra,
      runtimeContext
    });

    // 結果にテナントのコンテキスト情報を付与する
    return {
      tenant: tenant.name,
      query,
      results: results.relevantContext,
      sources: results.sources
    };
  }

  async bulkSearchForTenants(tenants: Tenant[], query: string) {
    const promises = tenants.map(tenant => 
      this.searchForTenant(tenant, query)
    );
    
    return await Promise.all(promises);
  }
}

// 使用例
const searchService = new MultiTenantSearchService();

const tenants = [
  { id: '1', name: 'Company A', namespace: 'company-a' },
  { id: '2', name: 'Company B', namespace: 'company-b' }
];

const results = await searchService.searchForTenant(
  tenants[0], 
  "製品ドキュメンテーション"
);
```


## Pinecone を使ったハイブリッド検索

セマンティック検索とキーワード検索を組み合わせる:

```typescript
const hybridSearchTool = createVectorQueryTool({
  vectorStoreName: "pinecone",
  indexName: "documents",
  model: openai.embedding("text-embedding-3-small"),
  databaseConfig: {
    pinecone: {
      namespace: "production",
      sparseVector: {
        // キーワード「API」に対する疎ベクトルの例
        indices: [1, 5, 10, 15],
        values: [0.8, 0.6, 0.4, 0.2]
      }
    }
  }
});

// キーワードの疎ベクトルを生成するヘルパー関数
const generateSparseVector = (keywords: string[]) => {
  // これは簡略化した例です。実運用では
  // BM25 などの適切な疎エンコード手法を使用します
  const indices: number[] = [];
  const values: number[] = [];
  
  keywords.forEach((keyword, i) => {
    const hash = keyword.split('').reduce((a, b) => {
      a = ((a << 5) - a) + b.charCodeAt(0);
      return a & a;
    }, 0);
    
    indices.push(Math.abs(hash) % 1000);
    values.push(1.0 / (i + 1)); // 後になるキーワードほど重みを下げる
  });
  
  return { indices, values };
};

const hybridSearch = async (query: string, keywords: string[]) => {
  const runtimeContext = new RuntimeContext();
  
  if (keywords.length > 0) {
    const sparseVector = generateSparseVector(keywords);
    runtimeContext.set('databaseConfig', {
      pinecone: {
        namespace: "production",
        sparseVector
      }
    });
  }

  return await hybridSearchTool.execute({
    context: { queryText: query },
    mastra,
    runtimeContext
  });
};

// 使用例
const results = await hybridSearch(
  "REST API の使い方",
  ["API", "REST", "ドキュメント"]
);
```


## 品質ゲート型検索

検索品質の段階的向上を実装する：

```typescript
const createQualityGatedSearch = () => {
  const baseConfig = {
    vectorStoreName: "postgres",
    indexName: "embeddings",
    model: openai.embedding("text-embedding-3-small")
  };

  return {
    // まずは高精度の検索を試す
    highQuality: createVectorQueryTool({
      ...baseConfig,
      databaseConfig: {
        pgvector: {
          minScore: 0.85,
          ef: 200,
          probes: 15
        }
      }
    }),
    
    // 中精度にフォールバック
    mediumQuality: createVectorQueryTool({
      ...baseConfig,
      databaseConfig: {
        pgvector: {
          minScore: 0.7,
          ef: 150,
          probes: 10
        }
      }
    }),
    
    // 最終手段：低精度
    lowQuality: createVectorQueryTool({
      ...baseConfig,
      databaseConfig: {
        pgvector: {
          minScore: 0.5,
          ef: 100,
          probes: 5
        }
      }
    })
  };
};

const progressiveSearch = async (query: string, minResults: number = 3) => {
  const tools = createQualityGatedSearch();
  
  // まずは高精度を試す
  let results = await tools.highQuality.execute({
    context: { queryText: query },
    mastra
  });
  
  if (results.sources.length >= minResults) {
    return { quality: 'high', ...results };
  }
  
  // 中精度にフォールバック
  results = await tools.mediumQuality.execute({
    context: { queryText: query },
    mastra
  });
  
  if (results.sources.length >= minResults) {
    return { quality: 'medium', ...results };
  }
  
  // 最終手段：低精度
  results = await tools.lowQuality.execute({
    context: { queryText: query },
    mastra
  });
  
  return { quality: 'low', ...results };
};

// 使用例
const results = await progressiveSearch("複雑な技術的検索クエリ", 5);
console.log(`見つかった結果は${results.sources.length}件（品質: ${results.quality}）`);
```


## 重要なポイント

1. **環境の分離**: 環境やテナントごとにデータを分けるためにnamespaceを使用する
2. **パフォーマンス調整**: 精度と速度の要件に応じてef/probesのパラメータを調整する
3. **品質管理**: 低品質なマッチを除外するためにminScoreを使用する
4. **実行時の柔軟性**: コンテキストに応じて設定を動的に上書きする
5. **段階的な品質向上**: 品質レベルに応じたフォールバック戦略を実装する

このアプローチにより、柔軟性とパフォーマンスを維持しつつ、特定のユースケースに合わせてベクター検索を最適化できます。 