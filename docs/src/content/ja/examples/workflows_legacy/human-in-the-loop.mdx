---
title: "例: Human-in-the-Loop | ワークフロー（レガシー） | Mastra Docs"
description: 人による介入ポイントを組み込んだレガシーなワークフローをMastraで作成する例。
---

import { GithubLink } from "@/components/github-link";


# Human in the Loop Workflow (Legacy)

Human-in-the-loop ワークフローは、特定のポイントで実行を一時停止し、ユーザー入力の収集や意思決定、人間の判断が必要なアクションの実行を行えるようにします。この例では、人による介入ポイントを含むレガシー版ワークフローの作成方法を示します。

## 仕組み

1. ワークフローのステップは、必要に応じて人間の意思決定者向けのコンテキストを含むペイロードを添えて、`suspend()` 関数で実行を**一時停止**できます。
2. ワークフローが**再開**されると、人間からの入力は `resume()` の `context` パラメータとして渡されます。
3. この入力はステップの実行コンテキストで `context.inputData` として参照でき、ステップの `inputSchema` に従って型付けされます。
4. その後、ステップは人間の入力に基づいて実行を続行できます。

このパターンにより、自動化されたワークフローにおいて、安全で型チェックされた人による介入が可能になります。

## Inquirer を使った対話型ターミナルの例

この例では、ワークフローの一時停止中にターミナルから直接ユーザー入力を収集するために [Inquirer](https://www.npmjs.com/package/@inquirer/prompts) ライブラリを使う方法を示し、真にインタラクティブなヒューマン・イン・ザ・ループ体験を実現します。

```ts showLineNumbers copy
import { Mastra } from "@mastra/core";
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";
import { confirm, input, select } from "@inquirer/prompts";

// ステップ 1: 商品レコメンデーションを生成
const generateRecommendations = new LegacyStep({
  id: "generateRecommendations",
  outputSchema: z.object({
    customerName: z.string(),
    recommendations: z.array(
      z.object({
        productId: z.string(),
        productName: z.string(),
        price: z.number(),
        description: z.string(),
      }),
    ),
  }),
  execute: async ({ context }) => {
    const customerName = context.triggerData.customerName;

    // 実際のアプリケーションでは、ここで API や ML モデルを呼び出すことがあります
    // この例ではモックデータを返します
    return {
      customerName,
      recommendations: [
        {
          productId: "prod-001",
          productName: "Premium Widget",
          price: 99.99,
          description: "高度な機能を備えた当社のベストセラー高級ウィジェット",
        },
        {
          productId: "prod-002",
          productName: "Basic Widget",
          price: 49.99,
          description: "初心者向けの手頃な入門用ウィジェット",
        },
        {
          productId: "prod-003",
          productName: "Widget Pro Plus",
          price: 149.99,
          description: "延長保証付きのプロフェッショナル向けウィジェット",
        },
      ],
    };
  },
});
```

```ts showLineNumbers copy
// ステップ 2: 推薦内容の人手による承認とカスタマイズ
const reviewRecommendations = new LegacyStep({
  id: "reviewRecommendations",
  inputSchema: z.object({
    approvedProducts: z.array(z.string()),
    customerNote: z.string().optional(),
    offerDiscount: z.boolean().optional(),
  }),
  outputSchema: z.object({
    finalRecommendations: z.array(
      z.object({
        productId: z.string(),
        productName: z.string(),
        price: z.number(),
      }),
    ),
    customerNote: z.string().optional(),
    offerDiscount: z.boolean(),
  }),
  execute: async ({ context, suspend }) => {
    const { customerName, recommendations } = context.getStepResult(
      generateRecommendations,
    ) || {
      customerName: "",
      recommendations: [],
    };

    // Check if we have input from a resumed workflow
    const reviewInput = {
      approvedProducts: context.inputData?.approvedProducts || [],
      customerNote: context.inputData?.customerNote,
      offerDiscount: context.inputData?.offerDiscount,
    };

    // If we don't have agent input yet, suspend for human review
    if (!reviewInput.approvedProducts.length) {
      console.log(`Generating recommendations for customer: ${customerName}`);
      await suspend({
        customerName,
        recommendations,
        message:
          "これらの商品の推薦内容を、顧客に送信する前に確認してください。"
      });

      // プレースホルダーの戻り値（suspend により到達しません）
      return {
        finalRecommendations: [],
        customerNote: "",
        offerDiscount: false,
      };
    }

    // エージェントが選択した商品を処理する
    const finalRecommendations = recommendations
      .filter((product) =>
        reviewInput.approvedProducts.includes(product.productId),
      )
      .map((product) => ({
        productId: product.productId,
        productName: product.productName,
        price: product.price,
      }));

    return {
      finalRecommendations,
      customerNote: reviewInput.customerNote || "",
      offerDiscount: reviewInput.offerDiscount || false,
    };
  },
});
```


```ts showLineNumbers copy
// ステップ 3: おすすめ内容を顧客に送信する
const sendRecommendations = new LegacyStep({
  id: "sendRecommendations",
  outputSchema: z.object({
    emailSent: z.boolean(),
    emailContent: z.string(),
  }),
  execute: async ({ context }) => {
    const { customerName } = context.getStepResult(generateRecommendations) || {
      customerName: "",
    };
    const { finalRecommendations, customerNote, offerDiscount } =
      context.getStepResult(reviewRecommendations) || {
        finalRecommendations: [],
        customerNote: "",
        offerDiscount: false,
      };

    // おすすめ内容に基づいてメール本文を生成する
    let emailContent = `拝啓 ${customerName} 様\n\nお客様のご希望に基づき、以下の商品をおすすめいたします。\n\n`;

    finalRecommendations.forEach((product) => {
      emailContent += `- ${product.productName}: $${product.price.toFixed(2)}\n`;
    });

    if (offerDiscount) {
      emailContent +=
        "\n日頃のご愛顧に感謝し、次回のお買い物で10%割引となるコード「SAVE10」をぜひご利用ください。\n";
    }

    if (customerNote) {
      emailContent += `\n追伸: ${customerNote}\n`;
    }

    emailContent += "\nいつもご愛顧いただきありがとうございます。\n営業チーム";

    // 実際のアプリケーションでは、このメールを送信します
    console.log("生成されたメール本文:", emailContent);

    return {
      emailSent: true,
      emailContent,
    };
  },
});

// ワークフローを構築する
const recommendationWorkflow = new LegacyWorkflow({
  name: "product-recommendation-workflow",
  triggerSchema: z.object({
    customerName: z.string(),
  }),
});

recommendationWorkflow
  .step(generateRecommendations)
  .then(reviewRecommendations)
  .then(sendRecommendations)
  .commit();

// ワークフローを登録する
const mastra = new Mastra({
  legacy_workflows: { recommendationWorkflow },
});
```

```ts showLineNumbers copy
// Inquirer のプロンプトを使ったワークフローの例
async function runRecommendationWorkflow() {
  const registeredWorkflow = mastra.legacy_getWorkflow(
    "recommendationWorkflow",
  );
  const run = registeredWorkflow.createRun();

  console.log("商品レコメンデーション・ワークフローを開始します...");
  const result = await run.start({
    triggerData: {
      customerName: "Jane Smith",
    },
  });

  const isReviewStepSuspended =
    result.activePaths.get("reviewRecommendations")?.status === "suspended";

  // 人による確認のためにワークフローが一時停止しているか確認
  if (isReviewStepSuspended) {
    const { customerName, recommendations, message } = result.activePaths.get(
      "reviewRecommendations",
    )?.suspendPayload;

    console.log("\n===================================");
    console.log(message);
    console.log(`顧客: ${customerName}`);
    console.log("===================================\n");

    // ターミナルで営業担当者の入力を Inquirer で収集
    console.log("利用可能な商品おすすめ一覧:");
    recommendations.forEach((product, index) => {
      console.log(
        `${index + 1}. ${product.productName} - $${product.price.toFixed(2)}`,
      );
      console.log(`   ${product.description}\n`);
    });

    // 担当者にどの商品をおすすめするか選択してもらう
    const approvedProducts = await checkbox({
      message: "顧客におすすめする商品を選択してください:",
      choices: recommendations.map((product) => ({
        name: `${product.productName} ($${product.price.toFixed(2)})`,
        value: product.productId,
      })),
    });

    // 担当者にパーソナルメッセージを追加してもらう
    const includeNote = await confirm({
      message: "パーソナルメッセージを追加しますか？",
      default: false,
    });

    let customerNote = "";
    if (includeNote) {
      customerNote = await input({
        message: "顧客向けのパーソナライズドメッセージを入力してください:",
      });
    }

    // 割引を提供するか確認
    const offerDiscount = await confirm({
      message: "この顧客に10%の割引を提供しますか？",
      default: false,
    });

    console.log("\nレビューを送信しています...");

    // 担当者の入力でワークフローを再開
    const resumeResult = await run.resume({
      stepId: "reviewRecommendations",
      context: {
        approvedProducts,
        customerNote,
        offerDiscount,
      },
    });

    console.log("\n===================================");
    console.log("ワークフローが完了しました！");
    console.log("メールの内容:");
    console.log("===================================\n");
    console.log(
      resumeResult?.results?.sendRecommendations ||
        "メール内容は生成されませんでした",
    );

    return resumeResult;
  }

  return result;
}

// 対話的なターミナル入力でワークフローを実行
runRecommendationWorkflow().catch(console.error);
```


## 複数のユーザー入力を伴う高度な例

この例は、コンテンツモデレーションシステムなどで、複数の人による介入が必要となる、より複雑なワークフローを示しています。

```ts showLineNumbers copy
import { Mastra } from "@mastra/core";
import { LegacyStep, LegacyWorkflow } from "@mastra/core/workflows/legacy";
import { z } from "zod";
import { select, input } from "@inquirer/prompts";

// ステップ1: コンテンツを受け取り分析する
const analyzeContent = new LegacyStep({
  id: "analyzeContent",
  outputSchema: z.object({
    content: z.string(),
    aiAnalysisScore: z.number(),
    flaggedCategories: z.array(z.string()).optional(),
  }),
  execute: async ({ context }) => {
    const content = context.triggerData.content;

    // Simulate AI analysis
    const aiAnalysisScore = simulateContentAnalysis(content);
    const flaggedCategories =
      aiAnalysisScore < 0.7
        ? ["不適切の可能性あり", "要確認"]
        : [];

    return {
      content,
      aiAnalysisScore,
      flaggedCategories,
    };
  },
});
```

```ts showLineNumbers copy
// ステップ 2: レビュー対象のコンテンツをモデレートする
const moderateContent = new LegacyStep({
  id: "moderateContent",
  // 再開時に提供される人間の入力スキーマを定義
  inputSchema: z.object({
    moderatorDecision: z.enum(["approve", "reject", "modify"]).optional(),
    moderatorNotes: z.string().optional(),
    modifiedContent: z.string().optional(),
  }),
  outputSchema: z.object({
    moderationResult: z.enum(["approved", "rejected", "modified"]),
    moderatedContent: z.string(),
    notes: z.string().optional(),
  }),
  // @ts-ignore
  execute: async ({ context, suspend }) => {
    const analysisResult = context.getStepResult(analyzeContent);
    // ワークフロー再開時に提供された入力にアクセス
    const moderatorInput = {
      decision: context.inputData?.moderatorDecision,
      notes: context.inputData?.moderatorNotes,
      modifiedContent: context.inputData?.modifiedContent,
    };

    // AIの分析スコアが十分に高い場合は自動承認
    if (
      analysisResult?.aiAnalysisScore > 0.9 &&
      !analysisResult?.flaggedCategories?.length
    ) {
      return {
        moderationResult: "approved",
        moderatedContent: analysisResult.content,
        notes: "システムによる自動承認",
      };
    }

    // まだモデレーターの入力がない場合は、人によるレビューのため一時停止
    if (!moderatorInput.decision) {
      await suspend({
        content: analysisResult?.content,
        aiScore: analysisResult?.aiAnalysisScore,
        flaggedCategories: analysisResult?.flaggedCategories,
        message: "このコンテンツを確認し、モデレーションの判断を行ってください",
      });

      // プレースホルダーの戻り値
      return {
        moderationResult: "approved",
        moderatedContent: "",
      };
    }

    // モデレーターの判断を処理
    switch (moderatorInput.decision) {
      case "approve":
        return {
          moderationResult: "approved",
          moderatedContent: analysisResult?.content || "",
          notes: moderatorInput.notes || "モデレーターにより承認",
        };

      case "reject":
        return {
          moderationResult: "rejected",
          moderatedContent: "",
          notes: moderatorInput.notes || "モデレーターにより却下",
        };

      case "modify":
        return {
          moderationResult: "modified",
          moderatedContent:
            moderatorInput.modifiedContent || analysisResult?.content || "",
          notes: moderatorInput.notes || "モデレーターにより修正",
        };

      default:
        return {
          moderationResult: "rejected",
          moderatedContent: "",
          notes: "無効なモデレーターの判断",
        };
    }
  },
});
```


```ts showLineNumbers copy
// ステップ3: モデレーションを適用する
const applyModeration = new LegacyStep({
  id: "applyModeration",
  outputSchema: z.object({
    finalStatus: z.string(),
    content: z.string().optional(),
    auditLog: z.object({
      originalContent: z.string(),
      moderationResult: z.string(),
      aiScore: z.number(),
      timestamp: z.string(),
    }),
  }),
  execute: async ({ context }) => {
    const analysisResult = context.getStepResult(analyzeContent);
    const moderationResult = context.getStepResult(moderateContent);

    // Create audit log
    const auditLog = {
      originalContent: analysisResult?.content || "",
      moderationResult: moderationResult?.moderationResult || "unknown",
      aiScore: analysisResult?.aiAnalysisScore || 0,
      timestamp: new Date().toISOString(),
    };

    // Apply moderation action
    switch (moderationResult?.moderationResult) {
      case "approved":
        return {
          finalStatus: "コンテンツを公開",
          content: moderationResult.moderatedContent,
          auditLog,
        };

      case "modified":
        return {
          finalStatus: "コンテンツを修正のうえ公開",
          content: moderationResult.moderatedContent,
          auditLog,
        };

      case "rejected":
        return {
          finalStatus: "コンテンツを却下",
          auditLog,
        };

      default:
        return {
          finalStatus: "モデレーション処理でエラーが発生",
          auditLog,
        };
    }
  },
});
```


```ts showLineNumbers copy
// ワークフローを構築する
const contentModerationWorkflow = new LegacyWorkflow({
  name: "content-moderation-workflow",
  triggerSchema: z.object({
    content: z.string(),
  }),
});

contentModerationWorkflow
  .step(analyzeContent)
  .then(moderateContent)
  .then(applyModeration)
  .commit();

// ワークフローを登録する
const mastra = new Mastra({
  legacy_workflows: { contentModerationWorkflow },
});

// Inquirer のプロンプトを使ったワークフローの使用例
async function runModerationDemo() {
  const registeredWorkflow = mastra.legacy_getWorkflow(
    "contentModerationWorkflow",
  );
  const run = registeredWorkflow.createRun();

  // 審査が必要なコンテンツでワークフローを開始
  console.log("コンテンツモデレーションのワークフローを開始します...");
  const result = await run.start({
    triggerData: {
      content: "モデレーションが必要なユーザー生成コンテンツの例です。",
    },
  });

  const isReviewStepSuspended =
    result.activePaths.get("moderateContent")?.status === "suspended";

  // ワークフローが一時停止しているか確認
  if (isReviewStepSuspended) {
    const { content, aiScore, flaggedCategories, message } =
      result.activePaths.get("moderateContent")?.suspendPayload;

    console.log("\n===================================");
    console.log(message);
    console.log("===================================\n");

    console.log("レビュー対象のコンテンツ:");
    console.log(content);
    console.log(`\nAI 解析スコア: ${aiScore}`);
    console.log(
      `フラグ対象のカテゴリ: ${flaggedCategories?.join(", ") || "なし"}\n`,
    );

    // Inquirer を使ってモデレーターの判断を取得
    const moderatorDecision = await select({
      message: "モデレーションの判断を選択してください:",
      choices: [
        { name: "コンテンツをそのまま承認する", value: "approve" },
        { name: "コンテンツを完全に却下する", value: "reject" },
        { name: "公開前にコンテンツを修正する", value: "modify" },
      ],
    });

    // 判断に基づいて追加情報を入力
    let moderatorNotes = "";
    let modifiedContent = "";

    moderatorNotes = await input({
      message: "判断に関するメモを入力してください:",
    });

    if (moderatorDecision === "modify") {
      modifiedContent = await input({
        message: "修正後のコンテンツを入力してください:",
        default: content,
      });
    }

    console.log("\nモデレーションの判断を送信しています...");

    // モデレーターの入力でワークフローを再開
    const resumeResult = await run.resume({
      stepId: "moderateContent",
      context: {
        moderatorDecision,
        moderatorNotes,
        modifiedContent,
      },
    });

    if (resumeResult?.results?.applyModeration?.status === "success") {
      console.log("\n===================================");
      console.log(
        `モデレーション完了: ${resumeResult?.results?.applyModeration?.output.finalStatus}`,
      );
      console.log("===================================\n");

      if (resumeResult?.results?.applyModeration?.output.content) {
        console.log("公開されたコンテンツ:");
        console.log(resumeResult.results.applyModeration.output.content);
      }
    }

    return resumeResult;
  }

  console.log(
    "人による介入なしでワークフローが完了しました:",
    result.results,
  );
  return result;
}

// AI コンテンツ解析をシミュレーションするヘルパー関数
function simulateContentAnalysis(content: string): number {
  // 実際のアプリケーションでは、ここで AI サービスを呼び出します
  // この例ではランダムなスコアを返します
  return Math.random();
}

// デモ関数を呼び出す
runModerationDemo().catch(console.error);
```


## 重要な概念

1. **サスペンドポイント** - ステップの execute 内で `suspend()` 関数を使用して、ワークフローの実行を一時停止します。

2. **サスペンドペイロード** - 一時停止時に関連するデータを渡して、人による意思決定のための文脈を提供します:

```ts
await suspend({
  messageForHuman: "このデータをご確認ください",
  data: someImportantData,
});
```

3. **ワークフローのステータス確認** - ワークフローを開始したら、返されたステータスを確認して、一時停止中かどうかを確認します：

```ts
const result = await workflow.start({ triggerData });
if (result.status === "suspended" && result.suspendedStepId === "stepId") {
  // 一時停止状態を処理する
  console.log("ワークフローは入力待ちです:", result.suspendPayload);
}
```

4. **インタラクティブなターミナル入力** - Inquirer などのライブラリを使って、対話型プロンプトを作成します:

```ts
import { select, input, confirm } from "@inquirer/prompts";

// ワークフローがサスペンドされた場合
if (result.status === "suspended") {
  // サスペンドペイロードの情報を表示
  console.log(result.suspendPayload.message);

  // 対話的にユーザー入力を取得
  const decision = await select({
    message: "どうしますか？",
    choices: [
      { name: "承認", value: "approve" },
      { name: "却下", value: "reject" },
    ],
  });

  // 取得した入力でワークフローを再開
  await run.resume({
    stepId: result.suspendedStepId,
    context: { decision },
  });
}
```

5. **ワークフローの再開** - 人間の入力でワークフローの実行を続行するには、`resume()` メソッドを使用します:

```ts
const resumeResult = await run.resume({
  stepId: "suspendedStepId",
  context: {
    // このデータは中断されたステップに context.inputData として渡されます
    // また、ステップの inputSchema に適合している必要があります
    userDecision: "approve",
  },
});
```

6. **人によるデータ入力のスキーマ** - 人の入力で再開されうるステップに対して入力スキーマを定義し、型安全性を確保します。

```ts
const myStep = new LegacyStep({
  id: "myStep",
  inputSchema: z.object({
    // このスキーマは、resume のコンテキストで渡されたデータを検証し、
    // context.inputData として利用できるようにします
    userDecision: z.enum(["approve", "reject"]),
    userComments: z.string().optional(),
  }),
  execute: async ({ context, suspend }) => {
    // 以前のサスペンド時のユーザー入力があるか確認します
    if (context.inputData?.userDecision) {
      // ユーザーの判断を処理します
      return { result: `ユーザーの判断: ${context.inputData.userDecision}` };
    }

    // 入力がない場合は、人による判断を待つためにサスペンドします
    await suspend();
  },
});
```

Human-in-the-loop ワークフローは、自動化と人間の判断を組み合わせたシステムの構築に有効です。例：

* コンテンツモデレーションシステム
* 承認ワークフロー
* 人間による監督下の AI システム
* エスカレーションを伴うカスタマーサービス自動化

<br />

<br />

<hr className={"dark:border-[#404040] border-gray-300"} />

<br />

<br />

<GithubLink
  link={
"https://github.com/mastra-ai/mastra/blob/main/examples/basics/workflows-legacy/human-in-the-loop"
}
/>


## ワークフロー（レガシー）

以下のリンクは、レガシー版ワークフローの例を示すドキュメントです：

- [シンプルなワークフローの作成（レガシー）](/examples/workflows_legacy/creating-a-workflow)
- [順次ステップのワークフロー（レガシー）](/examples/workflows_legacy/sequential-steps)
- [ステップによる並列実行（レガシー）](/examples/workflows_legacy/parallel-steps)
- [分岐パス（レガシー）](/examples/workflows_legacy/branching-paths)
- [条件分岐付きワークフロー（レガシー／実験的）](/examples/workflows_legacy/conditional-branching)
- [ワークフロー（レガシー）からのエージェント呼び出し](/examples/workflows_legacy/calling-agent)
- [ツールをワークフローのステップとして使用（レガシー）](/examples/workflows_legacy/using-a-tool-as-a-step)
- [循環依存を含むワークフロー（レガシー）](/examples/workflows_legacy/cyclical-dependencies)
- [ワークフロー変数によるデータマッピング（レガシー）](/examples/workflows_legacy/workflow-variables)
- [一時停止と再開が可能なワークフロー（レガシー）](/examples/workflows_legacy/suspend-and-resume)