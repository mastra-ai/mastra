---
title: "リファレンス: MCPServer | MCP での Mastra ツール公開 | Mastra Docs"
description: MCPServer の API リファレンス — Mastra のツールや機能を Model Context Protocol サーバーとして公開するためのクラス。
---

# MCPServer

`MCPServer` クラスは、既存の Mastra のツールやエージェントを Model Context Protocol（MCP）サーバーとして公開する機能を提供します。これにより、任意の MCP クライアント（Cursor、Windsurf、Claude Desktop など）がこれらの機能に接続し、エージェントで利用できるようになります。

ツールやエージェントを Mastra アプリケーション内で直接使うだけでよい場合は、必ずしも MCP サーバーを作成する必要はありません。この API は、Mastra のツールやエージェントを外部の MCP クライアントに公開するためのものです。

[stdio（サブプロセス）および SSE（HTTP）の MCP トランスポート](https://modelcontextprotocol.io/docs/concepts/transports) の両方をサポートしています。

## コンストラクタ

新しい `MCPServer` を作成するには、サーバーの基本情報、提供するツール、そして必要に応じてツールとして公開するエージェントを指定します。

```typescript
import { openai } from "@ai-sdk/openai";
import { Agent } from "@mastra/core/agent";
import { createTool } from "@mastra/core/tools";
import { MCPServer } from "@mastra/mcp";
import { z } from "zod";
import { dataProcessingWorkflow } from "../workflows/dataProcessingWorkflow";

const myAgent = new Agent({
  name: "MyExampleAgent",
  description: "基本的な質問に対応できる汎用アシスタントです。"
  instructions: "あなたは役に立つアシスタントです。",
  model: openai("gpt-4o-mini"),
});

const weatherTool = createTool({
  id: "getWeather",
  description: "指定した場所の現在の天気を取得します。",
  inputSchema: z.object({ location: z.string() }),
  execute: async ({ context }) => `${context.location}の天気は晴れです。`,
});

const server = new MCPServer({
  name: "カスタムサーバー",
  version: "1.0.0",
  tools: { weatherTool },
  agents: { myAgent }, // this agent will become tool "ask_myAgent"
  workflows: {
    dataProcessingWorkflow, // this workflow will become tool "run_dataProcessingWorkflow"
  }
});
```


### 構成プロパティ

コンストラクタは、以下のプロパティを持つ `MCPServerConfig` オブジェクトを受け取ります:

<PropertiesTable
  content={[
    {
      name: "name",
      type: "string",
      isOptional: false,
      description:
        "サーバーのわかりやすい名前（例: 'My Weather and Agent Server'）。",
    },
    {
      name: "version",
      type: "string",
      isOptional: false,
      description: "サーバーのセマンティックバージョン（例: '1.0.0'）。",
    },
    {
      name: "tools",
      type: "ToolsInput",
      isOptional: false,
      description:
        "キーがツール名、値が Mastra のツール定義（`createTool` または Vercel AI SDK で作成）のオブジェクト。これらのツールはそのまま公開されます。",
    },
    {
      name: "agents",
      type: "Record<string, Agent>",
      isOptional: true,
      description:
        "キーがエージェント識別子、値が Mastra Agent インスタンスのオブジェクト。各エージェントは自動的に `ask_<agentIdentifier>` という名前のツールに変換されます。エージェントはコンストラクタの設定で空でない `description` 文字列プロパティを定義している必要があります。この説明はツールの説明として使用されます。エージェントの説明が欠落している、または空の場合、MCPServer の初期化時にエラーがスローされます。",
    },
    {
      name: "workflows",
      type: "Record<string, Workflow>",
      isOptional: true,
      description:
        "キーがワークフロー識別子、値が Mastra Workflow インスタンスのオブジェクト。各ワークフローは `run_<workflowKey>` という名前のツールに変換されます。ワークフローの `inputSchema` はツールの入力スキーマになります。ワークフローは空でない `description` 文字列プロパティを持っている必要があり、これはツールの説明に使用されます。ワークフローの説明が欠落している、または空の場合、エラーがスローされます。ツールは `workflow.createRunAsync()` を呼び出し、その後 `run.start({ inputData: <tool_input> })` を実行してワークフローを起動します。エージェントやワークフローから派生したツール名（例: `ask_myAgent` や `run_myWorkflow`）が、明示的に定義されたツール名や他の派生名と衝突した場合は、明示的に定義されたツールが優先され、警告がログに記録されます。以降の衝突を引き起こすエージェント／ワークフローはスキップされます。",
    },
    {
      name: "id",
      type: "string",
      isOptional: true,
      description:
        "サーバーの任意の一意な識別子。指定しない場合は UUID が生成されます。この ID は確定値とみなされ、指定された場合は Mastra によって変更されません。",
    },
    {
      name: "description",
      type: "string",
      isOptional: true,
      description: "MCP サーバーの役割・機能に関する任意の説明。",
    },
    {
      name: "repository",
      type: "Repository", // { url: string; source: string; id: string; }
      isOptional: true,
      description:
        "サーバーのソースコードに関する任意のリポジトリ情報。",
    },
    {
      name: "releaseDate",
      type: "string", // ISO 8601
      isOptional: true,
      description:
        "このサーバーバージョンの任意のリリース日（ISO 8601 文字列）。指定しない場合はインスタンス化時刻が既定になります。",
    },
    {
      name: "isLatest",
      type: "boolean",
      isOptional: true,
      description:
        "これが最新バージョンであるかを示す任意のフラグ。指定しない場合は true が既定です。",
    },
    {
      name: "packageCanonical",
      type: "'npm' | 'docker' | 'pypi' | 'crates' | string",
      isOptional: true,
      description:
        "サーバーをパッケージとして配布する場合の正準パッケージ形式（例: 'npm', 'docker'）。",
    },
    {
      name: "packages",
      type: "PackageInfo[]",
      isOptional: true,
      description: "このサーバーのインストール可能なパッケージ一覧（任意）。",
    },
    {
      name: "remotes",
      type: "RemoteInfo[]",
      isOptional: true,
      description: "このサーバーのリモートアクセスポイント一覧（任意）。",
    },
    {
      name: "resources",
      type: "MCPServerResources",
      isOptional: true,
      description:
        "サーバーが MCP リソースをどのように扱うかを定義するオブジェクト。詳細は「Resource Handling」のセクションを参照してください。",
    },
    {
      name: "prompts",
      type: "MCPServerPrompts",
      isOptional: true,
      description:
        "サーバーが MCP プロンプトをどのように扱うかを定義するオブジェクト。詳細は「Prompt Handling」のセクションを参照してください。",
    },
  ]}
/>

## エージェントをツールとして公開する

`MCPServer` の強力な機能のひとつは、Mastra エージェントを呼び出し可能なツールとして自動的に公開できる点です。設定の `agents` プロパティにエージェントを指定すると、次のように動作します。

- **ツール命名**: 各エージェントは `ask_<agentKey>` という名前のツールに変換されます。ここで `<agentKey>` は `agents` オブジェクト内でそのエージェントに割り当てたキーです。たとえば `agents: { myAgentKey: myAgentInstance }` と設定すると、`ask_myAgentKey` という名前のツールが作成されます。

- **ツールの機能**:

  - **説明**: 生成されるツールの説明は次の形式になります: "エージェント `<AgentName>` に質問します。元のエージェントの指示: `<agent description>`"
  - **入力**: ツールは `message` プロパティ（文字列）を持つ単一のオブジェクト引数を受け取ります: `{ message: "エージェントへの質問内容" }`
  - **実行**: このツールが呼び出されると、対応するエージェントの `generate()` メソッドを、提供された `query` を渡して実行します。
  - **出力**: エージェントの `generate()` メソッドの結果が、そのままツールの出力として返されます。

- **名前の衝突**: `tools` 設定で明示的に定義されたツールが、エージェント由来のツールと同じ名前を持つ場合（例: `ask_myAgentKey` というツールがあり、同時にキー `myAgentKey` のエージェントもある場合）、_明示的に定義されたツールが優先されます_。この競合がある場合、エージェントはツールに変換されず、警告がログに記録されます。

これにより、MCP クライアントは他のツール同様に、自然言語のクエリでエージェントとやり取りできるようになります。

### エージェントからツールへの変換

`agents` 構成プロパティでエージェントを指定すると、`MCPServer` は各エージェントに対応するツールを自動的に作成します。ツール名は `ask_<agentIdentifier>` で、`<agentIdentifier>` は `agents` オブジェクトで使用したキーです。

生成されたツールの説明は次のとおりです: "エージェント `<agent.name>` に質問します。エージェントの説明: `<agent.description>`"

**重要**: エージェントをツールに変換するには、インスタンス化時の構成で空でない `description` 文字列プロパティが**必ず**設定されている必要があります（例: `new Agent({ name: 'myAgent', description: 'This agent does X.', ... })`）。`description` が欠落している、または空のエージェントが `MCPServer` に渡された場合、`MCPServer` のインスタンス化時にエラーがスローされ、サーバーのセットアップは失敗します。

これにより、MCP を通じてエージェントの生成機能を素早く公開でき、クライアントはエージェントへ直接「質問」できるようになります。

## メソッド

`MCPServer` インスタンスに対して呼び出し、動作を制御したり情報を取得したりできる関数です。

### startStdio()

標準入力・標準出力（stdio）で通信するサーバーを起動するには、このメソッドを使用します。コマンドラインのプログラムとしてサーバーを実行する場合によく使われます。

```typescript
async startStdio(): Promise<void>
```

stdio を使ってサーバーを起動する方法は次のとおりです：

```typescript
const server = new MCPServer({
  // 上記は設定例です
});
await server.startStdio();
```


### startSSE()

このメソッドは、既存のウェブサーバーと MCP サーバーを統合し、通信に Server-Sent Events（SSE）を使用できるようにするためのものです。SSE 用またはメッセージ用のパスへのリクエストを受け取った際に、ウェブサーバー側のコードから呼び出してください。

```typescript
async startSSE({
  url,
  ssePath,
  messagePath,
  req,
  res,
}: {
  url: URL;
  ssePath: string;
  messagePath: string;
  req: any;
  res: any;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startSSE` を使用する方法の一例です。この例では、MCP クライアントは `http://localhost:1234/sse` にあるあなたの MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startSSE({
    url: new URL(req.url || "", `http://localhost:1234`),
    ssePath: "/sse",
    messagePath: "/message",
    req,
    res,
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTP サーバーがポート ${PORT} で待ち受け中`);
});
```

`startSSE` メソッドに必要な値の詳細は次のとおりです:

<PropertiesTable
  content={[
{
  name: "url",
  type: "URL",
  description: "ユーザーが要求しているウェブアドレス。",
},
{
  name: "ssePath",
  type: "string",
  description:
    "クライアントが SSE に接続するための URL の特定のパス（例: '/sse'）。",
},
{
  name: "messagePath",
  type: "string",
  description:
    "クライアントがメッセージを送信するための URL の特定のパス（例: '/message'）。",
},
{
  name: "req",
  type: "any",
  description: "ウェブサーバーから受け取るリクエストオブジェクト。",
},
{
  name: "res",
  type: "any",
  description:
    "データを返送するために使用する、ウェブサーバーのレスポンスオブジェクト。",
},
]}
/>


### startHonoSSE()

このメソッドは、既存のWebサーバーにMCPサーバーを統合し、通信にServer-Sent Events（SSE）を使えるようにします。SSE用またはメッセージ用のパスへのリクエストを受け取ったときに、Webサーバー側のコードから呼び出します。

```typescript
async startHonoSSE({
  url,
  ssePath,
  messagePath,
  req,
  res,
}: {
  url: URL;
  ssePath: string;
  messagePath: string;
  req: any;
  res: any;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startHonoSSE` を使用する方法を示しています。この例では、MCP クライアントが `http://localhost:1234/hono-sse` にあるあなたの MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startHonoSSE({
    url: new URL(req.url || "", `http://localhost:1234`),
    ssePath: "/hono-sse",
    messagePath: "/message",
    req,
    res,
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTP サーバーがポート ${PORT} で待機中`);
});
```

`startHonoSSE` メソッドに必要な値の詳細は次のとおりです。

<PropertiesTable
  content={[
{
  name: "url",
  type: "URL",
  description: "ユーザーがリクエストしているウェブアドレス。",
},
{
  name: "ssePath",
  type: "string",
  description:
    "クライアントがSSEに接続するURLの特定のパス（例: '/hono-sse'）。",
},
{
  name: "messagePath",
  type: "string",
  description:
    "クライアントがメッセージを送信するURLの特定のパス（例: '/message'）。",
},
{
  name: "req",
  type: "any",
  description: "Webサーバーに届いたリクエストオブジェクト。",
},
{
  name: "res",
  type: "any",
  description:
    "データを返すために使用されるWebサーバーのレスポンスオブジェクト。",
},
]}
/>


### startHTTP()

このメソッドは、既存のWebサーバーにMCPサーバーを統合し、通信にストリーミング対応のHTTPを使用できるようにするためのものです。WebサーバーがHTTPリクエストを受信したときに、サーバー側のコードからこれを呼び出します。

```typescript
async startHTTP({
  url,
  httpPath,
  req,
  res,
  options = { sessionIdGenerator: () => randomUUID() },
}: {
  url: URL;
  httpPath: string;
  req: http.IncomingMessage;
  res: http.ServerResponse<http.IncomingMessage>;
  options?: StreamableHTTPServerTransportOptions;
}): Promise<void>
```

次の例は、HTTP サーバーのリクエストハンドラー内で `startHTTP` を使用する方法を示しています。この例では、MCP クライアントは `http://localhost:1234/http` の MCP サーバーに接続できます。

```typescript
import http from "http";

const httpServer = http.createServer(async (req, res) => {
  await server.startHTTP({
    url: new URL(req.url || '', 'http://localhost:1234'),
    httpPath: `/mcp`,
    req,
    res,
    options: {
      sessionIdGenerator: undefined,
    },
  });
});

httpServer.listen(PORT, () => {
  console.log(`HTTP サーバーがポート ${PORT} で待ち受けています`);
});
```

`startHTTP` メソッドに必要な値の詳細は次のとおりです。

<PropertiesTable
  content={[
{
  name: 'url',
  type: 'URL',
  description: 'ユーザーがリクエストしているウェブアドレス。',
},
{
  name: 'httpPath',
  type: 'string',
  description:
    "MCP サーバーが HTTP リクエストを処理する URL の特定のパス（例: '/mcp'）。",
},
{
  name: 'req',
  type: 'http.IncomingMessage',
  description: 'ウェブサーバーからの受信リクエストオブジェクト。',
},
{
  name: 'res',
  type: 'http.ServerResponse',
  description:
    'データの返送に使用する、ウェブサーバーのレスポンスオブジェクト。',
},
{
  name: 'options',
  type: 'StreamableHTTPServerTransportOptions',
  description:
    'HTTP トランスポートのオプション設定。詳しくは下記のオプション表を参照してください。',
  optional: true,
},
]}
/>

`StreamableHTTPServerTransportOptions` オブジェクトを使用すると、HTTP トランスポートの動作をカスタマイズできます。利用可能なオプションは次のとおりです。

<PropertiesTable
  content={[
{
  name: 'sessionIdGenerator',
  type: '(() => string) | undefined',
  description:
    '一意のセッション ID を生成する関数。暗号学的に安全で、グローバルに一意な文字列である必要があります。セッション管理を無効化するには `undefined` を返します。',
},
{
  name: 'onsessioninitialized',
  type: '(sessionId: string) => void',
  description:
    '新しいセッションが初期化されたときに呼び出されるコールバック。アクティブな MCP セッションの追跡に役立ちます。',
  optional: true,
},
{
  name: 'enableJsonResponse',
  type: 'boolean',
  description:
    '`true` の場合、サーバーはストリーミングに Server-Sent Events (SSE) を使用せず、プレーンな JSON レスポンスを返します。既定値は `false` です。',
  optional: true,
},
{
  name: 'eventStore',
  type: 'EventStore',
  description:
    'メッセージの再開を可能にするイベントストア。これを指定すると、クライアントは再接続してメッセージストリームを再開できます。',
  optional: true,
},
]}
/>


### close()

このメソッドはサーバーを停止し、すべてのリソースを解放します。

```typescript
async close(): Promise<void>
```


### getServerInfo()

このメソッドでサーバーの基本情報を確認できます。

```typescript
getServerInfo(): ServerInfo
```


### getServerDetail()

このメソッドは、サーバー情報の詳細を取得できます。

```typescript
getServerDetail(): ServerDetail
```


### getToolListInfo()

このメソッドでは、サーバー作成時に設定されたツールの一覧を参照できます。読み取り専用のリストで、デバッグに有用です。

```typescript
getToolListInfo(): ToolListInfo
```


### getToolInfo()

このメソッドは、特定のツールの詳細情報を返します。

```typescript
getToolInfo(toolName: string): ToolInfo
```


### executeTool()

このメソッドは指定したツールを実行し、その結果を返します。

```typescript
executeTool(toolName: string, input: any): Promise<any>
```


### getStdioTransport()

`startStdio()` でサーバーを起動した場合、stdio 通信を管理するオブジェクトを取得できます。これは主に内部的な確認やテストのために使用します。

```typescript
getStdioTransport(): StdioServerTransport | undefined
```


### getSseTransport()

サーバーを `startSSE()` で起動している場合、SSE 通信を管理するオブジェクトを取得できます。`getStdioTransport` と同様に、主に内部確認やテスト用途向けです。

```typescript
getSseTransport(): SSEサーバートランスポート | undefined
```


### getSseHonoTransport()

サーバーを `startHonoSSE()` で起動した場合、SSE 通信を管理するオブジェクトを取得するために使用できます。`getSseTransport` と同様に、主に内部的な確認やテストのために使います。

```typescript
getSseHonoTransport(): SSETransport | undefined
```


### getStreamableHTTPTransport()

`startHTTP()` でサーバーを起動した場合、HTTP 通信を管理するオブジェクトを取得するためにこれを使用できます。`getSseTransport` と同様、主に内部チェックやテストのために使用します。

```typescript
getStreamableHTTPTransport(): StreamableHTTPServerTransport | undefined
```


### tools()

この MCP サーバーが提供する特定のツールを実行します。

```typescript
async executeTool(
  toolId: string,
  args: any,
  executionContext?: { messages?: any[]; toolCallId?: string },
): Promise<any>
```

<PropertiesTable
  content={[
{
  name: "toolId",
  type: "string",
  description: "実行するツールのIDまたは名前。",
},
{
  name: "args",
  type: "any",
  description: "ツールのexecute関数に渡す引数。",
},
{
  name: "executionContext",
  type: "object",
  isOptional: true,
  description:
    "メッセージやtoolCallIdなど、ツール実行時の任意のコンテキスト。",
},
]}
/>


## リソースの扱い

### MCP リソースとは？

リソースは Model Context Protocol（MCP）における基本的な概念で、サーバーがクライアントに対して読み取り可能なデータやコンテンツを公開し、LLM とのやり取りにおけるコンテキストとして利用できるようにするものです。これは、MCP サーバーが提供したいあらゆる種類のデータを表し、例えば次のようなものがあります:

- ファイルの内容
- データベースのレコード
- API レスポンス
- ライブなシステムデータ
- スクリーンショットや画像
- ログファイル

リソースは固有の URI（例: `file:///home/user/documents/report.pdf`, `postgres://database/customers/schema`）で識別され、テキスト（UTF-8 エンコード）またはバイナリデータ（base64 エンコード）を含むことができます。

クライアントは次の方法でリソースを発見できます:

1.  **ダイレクトリソース**: サーバーは `resources/list` エンドポイントを通じて具体的なリソースの一覧を公開します。
2.  **リソーステンプレート**: 動的なリソースに対して、サーバーはクライアントがリソース URI を構築するために使用する URI テンプレート（RFC 6570）を公開できます。

リソースを読み取るには、クライアントはその URI を指定して `resources/read` リクエストを送信します。クライアントがそのリソースを購読している場合、サーバーはリソース一覧の変更（`notifications/resources/list_changed`）や特定リソースの内容更新（`notifications/resources/updated`）を通知することもできます。

より詳しい情報は、[Resources に関する公式 MCP ドキュメント](https://modelcontextprotocol.io/docs/concepts/resources)を参照してください。

### `MCPServerResources` 型

`resources` オプションには `MCPServerResources` 型のオブジェクトを指定します。この型は、サーバーがリソース要求を処理するために使用するコールバック群を定義します。

```typescript
export type MCPServerResources = {
  // 利用可能なリソースを一覧するコールバック
  listResources: () => Promise<Resource[]>;

  // 特定のリソースのコンテンツを取得するコールバック
  getResourceContent: ({
    uri,
  }: {
    uri: string;
  }) => Promise<MCPServerResourceContent | MCPServerResourceContent[]>;

  // 利用可能なリソーステンプレートを一覧する任意のコールバック
  resourceTemplates?: () => Promise<ResourceTemplate[]>;
};

export type MCPServerResourceContent = { text?: string } | { blob?: string };
```

例：

```typescript
import { MCPServer } from "@mastra/mcp";
import type {
  MCPServerResourceContent,
  Resource,
  ResourceTemplate,
} from "@mastra/mcp";

// リソース／リソーステンプレートは通常、動的にフェッチされます。
const myResources: Resource[] = [
  { uri: "file://data/123.txt", name: "データファイル", mimeType: "text/plain" },
];

const myResourceContents: Record<string, MCPServerResourceContent> = {
  "file://data.txt/123": { text: "これはデータファイルの内容です。" },
};

const myResourceTemplates: ResourceTemplate[] = [
  {
    uriTemplate: "file://data/{id}",
    name: "データファイル",
    description: "データを含むファイルです。",
    mimeType: "text/plain",
  },
];

const myResourceHandlers: MCPServerResources = {
  listResources: async () => myResources,
  getResourceContent: async ({ uri }) => {
    if (myResourceContents[uri]) {
      return myResourceContents[uri];
    }
    throw new Error(`Resource content not found for ${uri}`);
  },
  resourceTemplates: async () => myResourceTemplates,
};

const serverWithResources = new MCPServer({
  name: "Resourceful Server",
  version: "1.0.0",
  tools: {
    /* ... your tools ... */
  },
  resources: myResourceHandlers,
});
```


### リソース変更のクライアントへの通知

利用可能なリソースやその内容が変更された場合、サーバーは特定のリソースを購読している接続中のクライアントに通知できます。

#### `server.resources.notifyUpdated({ uri: string })`

特定のリソース（`uri` で識別される）の内容が更新されたときにこのメソッドを呼び出します。この URI を購読しているクライアントがいる場合、`notifications/resources/updated` メッセージが送信されます。

```typescript
async server.resources.notifyUpdated({ uri: string }): Promise<void>
```

例：

```typescript
// 'file://data.txt' の内容を更新した後
await serverWithResources.resources.notifyUpdated({ uri: "file://data.txt" });
```


#### `server.resources.notifyListChanged()`

利用可能なリソースの一覧に変更があったとき（例：リソースが追加・削除されたとき）に、このメソッドを呼び出します。これにより、クライアントに `notifications/resources/list_changed` メッセージが送信され、リソース一覧の再取得を促します。

```typescript
async server.resources.notifyListChanged(): Promise<void>
```

例：

```typescript
// 'myResourceHandlers.listResources' で管理されているリストに新しいリソースを追加したあと
await serverWithResources.resources.notifyListChanged();
```


## プロンプトの取り扱い

### MCPプロンプトとは？

プロンプトは、MCPサーバーがクライアントに公開する再利用可能なテンプレートまたはワークフローです。引数を受け取り、リソースのコンテキストを含め、バージョン管理をサポートし、LLMとのやり取りの標準化に利用できます。

プロンプトは固有の名前（および任意のバージョン）で識別され、動的にも静的にもなり得ます。

### `MCPServerPrompts` 型

`prompts` オプションには、`MCPServerPrompts` 型のオブジェクトを指定します。この型は、サーバーがプロンプトリクエストを処理するために使用するコールバックを定義します。

```typescript
export type MCPServerPrompts = {
  // 利用可能なプロンプトを一覧取得するコールバック
  listPrompts: () => Promise<Prompt[]>;

  // 特定のプロンプトのメッセージ／コンテンツを取得するコールバック
  getPromptMessages?: ({
    name,
    version,
    args,
  }: {
    name: string;
    version?: string;
    args?: any;
  }) => Promise<{ prompt: Prompt; messages: PromptMessage[] }>;
};
```

例：

```typescript
import { MCPServer } from "@mastra/mcp";
import type { Prompt, PromptMessage, MCPServerPrompts } from "@mastra/mcp";

const prompts: Prompt[] = [
  {
    name: "analyze-code",
    description: "コードを改善するために分析する",
    version: "v1"
  },
  {
    name: "analyze-code",
    description: "コードを改善するために分析する（新しいロジック）",
    version: "v2"
  }
];

const myPromptHandlers: MCPServerPrompts = {
  listPrompts: async () => prompts,
  getPromptMessages: async ({ name, version, args }) => {
    if (name === "analyze-code") {
      if (version === "v2") {
        const prompt = prompts.find(p => p.name === name && p.version === "v2");
        if (!prompt) throw new Error("プロンプトのバージョンが見つかりません"),
        return {
          prompt,
          messages: [
            {
              role: "user",
              content: { type: "text", text: `新しいロジックでこのコードを分析してください: ${args.code}` }
            }
          ]
        };
      }
      // 既定値または v1
      const prompt = prompts.find(p => p.name === name && p.version === "v1");
      if (!prompt) throw new Error("プロンプトのバージョンが見つかりません"),
      return {
        prompt,
        messages: [
          {
            role: "user",
            content: { type: "text", text: `このコードを分析してください: ${args.code}` }
          }
        ]
      };
    }
    throw new Error("プロンプトが見つかりません"),
  }
};

const serverWithPrompts = new MCPServer({
  name: "Promptful Server",
  version: "1.0.0",
  tools: { /* ... */ },
  prompts: myPromptHandlers,
});
```


### プロンプト変更のクライアントへの通知

利用可能なプロンプトに変更があった場合、サーバーは接続中のクライアントに通知できます。

#### `server.prompts.notifyListChanged()`

利用可能なプロンプトの一覧に変更があった場合（例：プロンプトが追加・削除された場合）に、このメソッドを呼び出します。これにより、クライアントに `notifications/prompts/list_changed` メッセージが送信され、プロンプト一覧の再取得が促されます。

```typescript
await serverWithPrompts.prompts.notifyListChanged();
```


### プロンプト処理のベストプラクティス

- 明確で具体的なプロンプト名と説明を使用する。
- `getPromptMessages` で必須引数をすべて検証する。
- 破壊的変更の可能性がある場合は `version` フィールドを含める。
- 適切なプロンプトのロジックを選択するために `version` パラメータを使用する。
- プロンプトのリストに変更があった場合はクライアントに通知する。
- 分かりやすいメッセージでエラーを処理する。
- 引数の要件と利用可能なバージョンをドキュメント化する。

---

## 例

MCPServer のセットアップとデプロイの実践的な例については、[Deploying an MCPServer Example](/examples/agents/deploying-mcp-server) を参照してください。

このページ冒頭の例では、ツールとエージェントの両方を用いて `MCPServer` をインスタンス化する方法も示しています。

## エリシテーション

### Elicitation とは？

Elicitation は Model Context Protocol（MCP）の機能で、サーバーがユーザーに対して構造化された情報の提供を求められるようにするものです。これにより、サーバーが動的に追加データを収集できるインタラクティブなワークフローが実現します。

`MCPServer` クラスには、Elicitation 機能が自動的に組み込まれています。ツールは `execute` 関数で、ユーザー入力を要求するための `elicitation.sendRequest()` メソッドを含む `options` パラメータを受け取ります。

### ツール実行シグネチャ

ツールが MCP サーバーのコンテキスト内で実行される場合、追加の `options` パラメータを受け取ります:

```typescript
execute: async ({ context }, options) => {
  // context にはツールの入力パラメータが含まれます
  // options には引き出し機能や認証情報などのサーバー機能が含まれます
  
  // 認証情報にアクセス（利用可能な場合）
  if (options.extra?.authInfo) {
    console.log('認証済みリクエストの発信元:', options.extra.authInfo.clientId);
  }
  
  // 引き出し機能を使用
  const result = await options.elicitation.sendRequest({
    message: "情報をご提供ください",
    requestedSchema: { /* スキーマ */ }
  });
  
  return result;
}
```


### Elicitation の仕組み

一般的なユースケースはツールの実行中です。ツールがユーザー入力を必要とする場合、ツールの実行オプションで提供される elicitation 機能を使用できます:

1. ツールはメッセージとスキーマを指定して `options.elicitation.sendRequest()` を呼び出します
2. リクエストは接続されている MCP クライアントに送信されます
3. クライアントはユーザーにリクエストを提示します（UI、コマンドラインなど）
4. ユーザーは入力する、拒否する、またはリクエストをキャンセルします
5. クライアントはレスポンスをサーバーに返送します
6. ツールはレスポンスを受け取り、実行を続行します

### ツールでの引き出しの活用

以下は、ユーザーの連絡先情報を引き出すためにエリシテーションを用いるツールの例です：

```typescript
import { MCPServer } from "@mastra/mcp";
import { createTool } from "@mastra/core/tools";
import { z } from "zod";

const server = new MCPServer({
  name: "インタラクティブサーバー",
  version: "1.0.0",
  tools: {
    collectContactInfo: createTool({
      id: "collectContactInfo",
      description: "対話を通じてユーザーの連絡先情報を収集します",
      inputSchema: z.object({
        reason: z.string().optional().describe("連絡先情報を収集する理由"),
      }),
      execute: async ({ context }, options) => {
        const { reason } = context;
        
        // Log session info if available
        console.log('セッションからのリクエスト:', options.extra?.sessionId);

        try {
          // Request user input via elicitation
          const result = await options.elicitation.sendRequest({
            message: reason 
              ? `連絡先情報をご提供ください。${reason}`
              : '連絡先情報をご提供ください',
            requestedSchema: {
              type: 'object',
              properties: {
                name: {
                  type: 'string',
                  title: '氏名',
                  description: 'フルネーム',
                },
                email: {
                  type: 'string',
                  title: 'メールアドレス', 
                  description: 'メールアドレス',
                  format: 'email',
                },
                phone: {
                  type: 'string',
                  title: '電話番号',
                  description: '電話番号（任意）',
                },
              },
              required: ['name', 'email'],
            },
          });

          // Handle the user's response
          if (result.action === 'accept') {
            return `連絡先情報を収集しました: ${JSON.stringify(result.content, null, 2)}`;
          } else if (result.action === 'decline') {
            return 'ユーザーが連絡先情報の提供を拒否しました。';
          } else {
            return 'ユーザーが連絡先情報の提供をキャンセルしました。';
          }
        } catch (error) {
          return `連絡先情報の収集中にエラーが発生しました: ${error}`;
        }
      },
    }),
  },
});
```


### 要求スキーマの定義

`requestedSchema` は、プリミティブなプロパティのみを持つフラットなオブジェクトである必要があります。サポートされる型は次のとおりです：

* **String**: `{ type: 'string', title: 'Display Name', description: 'Help text' }`
* **Number**: `{ type: 'number', minimum: 0, maximum: 100 }`
* **Boolean**: `{ type: 'boolean', default: false }`
* **Enum**: `{ type: 'string', enum: ['option1', 'option2'] }`

スキーマ例：

```typescript
{
  type: 'object',
  properties: {
    name: {
      type: 'string',
      title: '氏名',
      description: 'フルネーム',
    },
    age: {
      type: 'number',
      title: '年齢',
      minimum: 18,
      maximum: 120,
    },
    newsletter: {
      type: 'boolean',
      title: 'ニュースレターを購読する',
      default: false,
    },
  },
  required: ['name'],
}
```


### 応答アクション

ユーザーは、情報提示（エリシテーション）リクエストに対して次の3通りに応答できます:

1. **Accept** (`action: 'accept'`): ユーザーがデータを提供し、送信を確定
   - 提供されたデータを含む `content` フィールドがある
2. **Decline** (`action: 'decline'`): ユーザーが情報提供を明確に拒否
   - `content` フィールドはない
3. **Cancel** (`action: 'cancel'`): ユーザーが判断せずにリクエストをキャンセル
   - `content` フィールドはない

ツールは、この3種類すべての応答タイプを適切に処理する必要があります。

### セキュリティに関する注意事項

- **パスワード、社会保障番号（SSN）、クレジットカード番号**などの機密情報を決して求めない
- 提供されたスキーマに照らして、すべてのユーザー入力を検証する
- 辞退やキャンセルを丁寧に処理する
- データ収集の目的を明確に説明する
- ユーザーのプライバシーと設定・選好を尊重する

### ツール実行 API

エリシテーション機能は、ツール実行時の `options` パラメータで利用できます。

```typescript
// ツールの execute 関数内
execute: async ({ context }, options) => {
  // ユーザー入力には elicitation を使用
  const result = await options.elicitation.sendRequest({
    message: string,           // ユーザーに表示するメッセージ
    requestedSchema: object    // 期待するレスポンス構造を定義する JSON スキーマ
  }): Promise<ElicitResult>
  
  // 必要に応じて認証情報にアクセス
  if (options.extra?.authInfo) {
    // options.extra.authInfo.token などを使用
  }
}
```

HTTP ベースのトランスポート（SSE または HTTP）を使用する場合、elicit は**セッション対応**であることに注意してください。これは、複数のクライアントが同じサーバーに接続している場合、ツール実行を開始したクライアントの正しいセッションへ elicit リクエストがルーティングされることを意味します。

`ElicitResult` 型:

```typescript
type ElicitResult = {
  action: 'accept' | 'decline' | 'cancel';
  content?: any; // action が 'accept' のときにのみ存在します
}
```


## 認証コンテキスト

HTTP ベースのトランスポートを使用する場合、ツールは `options.extra` を通じてリクエストのメタデータにアクセスできます。

```typescript
execute: async ({ context }, options) => {
  if (!options.extra?.authInfo?.token) {
    return "認証が必要です";
  }
  
  // 認証トークンを利用する
  const response = await fetch('/api/data', {
    headers: { Authorization: `Bearer ${options.extra.authInfo.token}` },
    signal: options.extra.signal,
  });
  
  return response.json();
}
```

`extra` オブジェクトには次が含まれます:

* `authInfo`: 認証情報（サーバー側ミドルウェアが提供する場合）
* `sessionId`: セッション識別子
* `signal`: 取り消し用の AbortSignal
* `sendNotification`/`sendRequest`: MCP プロトコルの関数

> 注: 認証を有効にするには、`server.startHTTP()` を呼び出す前に `req.auth` を設定するミドルウェアを HTTP サーバーに用意する必要があります。例:
>
> ```typescript
> httpServer.createServer((req, res) => {
>   // 認証ミドルウェアを追加
>   req.auth = validateAuthToken(req.headers.authorization);
>   
>   // その後 MCP サーバーへ渡す
>   await server.startHTTP({ url, httpPath, req, res });
> });
> ```


## 関連情報

- Mastra で MCP サーバーに接続する方法については、[MCPClient のドキュメント](./mcp-client)をご覧ください。
- Model Context Protocol について詳しくは、[@modelcontextprotocol/sdk のドキュメント](https://github.com/modelcontextprotocol/typescript-sdk)をご覧ください。