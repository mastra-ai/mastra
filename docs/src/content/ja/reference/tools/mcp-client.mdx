---
title: "リファレンス: MCPClient | ツール管理 | Mastra ドキュメント"
description: MCPClient の API リファレンス — 複数の Model Context Protocol サーバーとそのツールを管理するクラス。
---

# MCPClient

`MCPClient` クラスは、Mastra アプリケーションで複数の MCP サーバー接続とそれらのツールを一元的に管理するためのクラスです。接続のライフサイクル管理やツールの名前空間化を行い、設定済みのすべてのサーバーにまたがるツールへのアクセスを提供します。

このクラスは、非推奨となった [`MastraMCPClient`](/reference/tools/client) の後継です。

## コンストラクター

MCPClient クラスの新しいインスタンスを生成します。

```typescript
constructor({
  id?: string;
  servers: Record<string, MastraMCPServerDefinition>;
  timeout?: number;
}: MCPClientOptions)
```


### MCPClientOptions

<br />

<PropertiesTable
  content={[
    {
      name: "id",
      type: "string",
      isOptional: true,
      description:
        "構成インスタンスの任意の一意の識別子。同一構成で複数のインスタンスを作成する際のメモリリークを防ぐために使用します。",
    },
    {
      name: "servers",
      type: "Record<string, MastraMCPServerDefinition>",
      description:
        "サーバー構成のマップ。各キーは一意のサーバー識別子で、値はそのサーバーの構成です。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      defaultValue: "60000",
      description:
        "個別のサーバー構成で上書きされない限り、すべてのサーバーに適用される（ミリ秒単位の）グローバルタイムアウト値。",
    },
  ]}
/>

### MastraMCPServerDefinition

`servers` マップ内の各サーバーは `MastraMCPServerDefinition` 型で構成します。トランスポート種別は、指定されたパラメータに基づいて自動判別されます。

- `command` が指定されている場合は Stdio トランスポートを使用します。
- `url` が指定されている場合は、まず Streamable HTTP トランスポートを試し、初回の接続に失敗した場合はレガシーな SSE トランスポートにフォールバックします。

<br />

<PropertiesTable
  content={[
    {
      name: "command",
      type: "string",
      isOptional: true,
      description: "Stdio サーバー向け: 実行するコマンド。",
    },
    {
      name: "args",
      type: "string[]",
      isOptional: true,
      description: "Stdio サーバー向け: コマンドに渡す引数。",
    },
    {
      name: "env",
      type: "Record<string, string>",
      isOptional: true,
      description:
        "Stdio サーバー向け: コマンドに設定する環境変数。",
    },
    {
      name: "url",
      type: "URL",
      isOptional: true,
      description:
        "HTTP サーバー（Streamable HTTP または SSE）向け: サーバーの URL。",
    },
    {
      name: "requestInit",
      type: "RequestInit",
      isOptional: true,
      description: "HTTP サーバー向け: fetch API のリクエスト設定。",
    },
    {
      name: "eventSourceInit",
      type: "EventSourceInit",
      isOptional: true,
      description:
        "SSE フォールバック向け: SSE 接続用のカスタム fetch 設定。SSE でカスタムヘッダーを使用する場合は必須。",
    },
    {
      name: "logger",
      type: "LogHandler",
      isOptional: true,
      description: "追加のロギング用ハンドラー（任意）。",
    },
    {
      name: "timeout",
      type: "number",
      isOptional: true,
      description: "サーバー固有のタイムアウト（ミリ秒）。",
    },
    {
      name: "capabilities",
      type: "ClientCapabilities",
      isOptional: true,
      description: "サーバー固有の機能設定。",
    },
    {
      name: "enableServerLogs",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "このサーバーのログを有効にするかどうか。",
    },
  ]}
/>

## 手法

### getTools()

構成済みのすべてのサーバーからツールを取得します。ツール名は競合を防ぐため、サーバー名で名前空間化されます（形式は `serverName_toolName`）。\
Agent の定義に渡すことを想定しています。

```ts
new Agent({ tools: await mcp.getTools() });
```


### getToolsets()

名前空間付きのツール名（`serverName.toolName` の形式）を、それぞれのツール実装に対応付けたオブジェクトを返します。
generate または stream メソッドに動的に渡すことを想定しています。

```typescript
const res = await agent.stream(prompt, {
  toolsets: await mcp.getToolsets(),
});
```


### disconnect()

すべての MCP サーバーから切断し、リソースを解放します。

```typescript
async disconnect(): Promise<void>
```


### `resources` プロパティ

`MCPClient` インスタンスには、リソース関連の操作にアクセスするための `resources` プロパティがあります。

```typescript
const mcpClient = new MCPClient({
  /* …サーバー構成… */
});

// mcpClient.resources 経由でリソース関連のメソッドにアクセスします
const allResourcesByServer = await mcpClient.resources.list();
const templatesByServer = await mcpClient.resources.templates();
// …他のリソース関連のメソッドも同様です
```


#### `resources.list()`

接続されているすべての MCP サーバーから、利用可能なリソースをサーバー名ごとにグループ化して取得します。

```typescript
async list(): Promise<Record<string, Resource[]>>
```

例：

```typescript
const resourcesByServer = await mcpClient.resources.list();
for (const serverName in resourcesByServer) {
  console.log(`${serverName} からのリソース:`, resourcesByServer[serverName]);
}
```


#### `resources.templates()`

接続中のすべての MCP サーバーから利用可能なリソーステンプレートを取得し、サーバー名ごとにグループ化します。

```typescript
async templates(): Promise<Record<string, ResourceTemplate[]>>
```

例：

```typescript
const templatesByServer = await mcpClient.resources.templates();
for (const serverName in templatesByServer) {
  console.log(`${serverName} のテンプレート:`, templatesByServer[serverName]);
}
```


#### `resources.read(serverName: string, uri: string)`

指定したサーバーから、特定のリソースの内容を読み込みます。

```typescript
async read(serverName: string, uri: string): Promise<ReadResourceResult>
```

* `serverName`: サーバーの識別子（`servers` のコンストラクターオプションで使用するキー）。
* `uri`: 読み取り対象のリソースの URI。

例:

```typescript
const content = await mcpClient.resources.read(
  "myWeatherServer",
  "weather://current",
);
console.log("現在の天気：", content.contents[0].text);
```


#### `resources.subscribe(serverName: string, uri: string)`

指定された名前のサーバー上にある特定のリソースの更新を購読します。

```typescript
async subscribe(serverName: string, uri: string): Promise<object>
```

例：

```typescript
await mcpClient.resources.subscribe("myWeatherServer", "weather://current");
```


#### `resources.unsubscribe(serverName: string, uri: string)`

指定したサーバー上の特定のリソースに対する更新の購読を解除します。

```typescript
async unsubscribe(serverName: string, uri: string): Promise<object>
```

例：

```typescript
await mcpClient.resources.unsubscribe("myWeatherServer", "weather://current");
```


#### `resources.onUpdated(serverName: string, handler: (params: { uri: string }) => void)`

特定のサーバーで購読中のリソースが更新された際に呼び出される通知ハンドラーを設定します。

```typescript
async onUpdated(serverName: string, handler: (params: { uri: string }) => void): Promise<void>
```

例：

```typescript
mcpClient.resources.onUpdated("myWeatherServer", (params) => {
  console.log(`myWeatherServer のリソースが更新されました: ${params.uri}`);
  // ここでリソースの内容を再取得することもできます
  // await mcpClient.resources.read("myWeatherServer", params.uri);
});
```


#### `resources.onListChanged(serverName: string, handler: () => void)`

特定のサーバー上で利用可能なリソースの一覧に変更があった際に呼び出される通知ハンドラを設定します。

```typescript
async onListChanged(serverName: string, handler: () => void): Promise<void>
```

例：

```typescript
mcpClient.resources.onListChanged("myWeatherServer", () => {
  console.log("myWeatherServer のリソース一覧が更新されました。");
  // リソース一覧を再取得してください
  // await mcpClient.resources.list();
});
```


### `prompts` プロパティ

`MCPClient` インスタンスには、プロンプト関連の操作にアクセスできる `prompts` プロパティがあります。

```typescript
const mcpClient = new MCPClient({
  /* ...servers configuration... */
});

// mcpClient.prompts からプロンプト関連のメソッドにアクセスする
const allPromptsByServer = await mcpClient.prompts.list();
const { prompt, messages } = await mcpClient.prompts.get({
  serverName: "myWeatherServer",
  name: "current",
});
```


### `elicitation` プロパティ

`MCPClient` インスタンスには、エリシテーション関連の操作にアクセスできる `elicitation` プロパティがあります。エリシテーションにより、MCP サーバーはユーザーに対して構造化された情報の提供を求めることができます。

```typescript
const mcpClient = new MCPClient({
  /* ...servers configuration... */
});

// エリシテーションハンドラーを設定
mcpClient.elicitation.onRequest('serverName', async (request) => {
  // サーバーからのエリシテーションリクエストを処理
  console.log('サーバーからのリクエスト:', request.message);
  console.log('スキーマ:', request.requestedSchema);
  
  // ユーザーからの応答を返す
  return {
    action: 'accept',
    content: { name: 'John Doe', email: 'john@example.com' }
  };
});
```


#### `elicitation.onRequest(serverName: string, handler: ElicitationHandler)`

接続中の任意の MCP サーバーからエリシテーションリクエストが送信された際に呼び出されるハンドラー関数を登録します。ハンドラーはリクエストを受け取り、レスポンスを返す必要があります。

**ElicitationHandler 関数:**

ハンドラー関数は次のプロパティを持つリクエストオブジェクトを受け取ります:

* `message`: 必要な情報の内容を説明する、人間が読めるメッセージ
* `requestedSchema`: 期待されるレスポンスの構造を定義する JSON スキーマ

ハンドラーは次の内容を持つ `ElicitResult` を返す必要があります:

* `action`: `'accept'`、`'decline'`、または `'cancel'` のいずれか
* `content`: ユーザーのデータ（`'accept'` の場合のみ）

**例:**

```typescript
mcpClient.elicitation.onRequest('serverName', async (request) => {
  console.log(`サーバーからの要求: ${request.message}`);
  
  // 例: ユーザー入力の簡易収集
  if (request.requestedSchema.properties.name) {
    // ユーザーが承諾してデータを提供することをシミュレート
    return {
      action: 'accept',
      content: {
        name: 'Alice Smith',
        email: 'alice@example.com'
      }
    };
  }
  
  // ユーザーが要求を拒否することをシミュレート
  return { action: 'decline' };
});
```

**完全なインタラクティブな例:**

```typescript
import { MCPClient } from '@mastra/mcp';
import { createInterface } from 'readline';

const readline = createInterface({
  input: process.stdin,
  output: process.stdout,
});

function askQuestion(question: string): Promise<string> {
  return new Promise(resolve => {
    readline.question(question, answer => resolve(answer.trim()));
  });
}

const mcpClient = new MCPClient({
  servers: {
    interactiveServer: {
      url: new URL('http://localhost:3000/mcp'),
    },
  },
});

// Set up interactive elicitation handler
await mcpClient.elicitation.onRequest('interactiveServer', async (request) => {
  console.log(`\n📋 サーバーからの要求: ${request.message}`);
  console.log('必要な情報:');
  
  const schema = request.requestedSchema;
  const properties = schema.properties || {};
  const required = schema.required || [];
  const content: Record<string, any> = {};
  
  // 各フィールドの入力を取得
  for (const [fieldName, fieldSchema] of Object.entries(properties)) {
    const field = fieldSchema as any;
    const isRequired = required.includes(fieldName);
    
    let prompt = `${field.title || fieldName}`;
    if (field.description) prompt += `（${field.description}）`;
    if (isRequired) prompt += '（必須）';
    prompt += ': ';
    
    const answer = await askQuestion(prompt);
    
    // キャンセル処理
    if (answer.toLowerCase() === 'cancel') {
      return { action: 'cancel' };
    }
    
    // 必須項目の検証
    if (answer === '' && isRequired) {
      console.log(`❌ 「${fieldName}」は必須です`);
      return { action: 'decline' };
    }
    
    if (answer !== '') {
      content[fieldName] = answer;
    }
  }
  
  // 送信の確認
  console.log('\n📝 入力内容:');
  console.log(JSON.stringify(content, null, 2));
  
  const confirm = await askQuestion('\nこの情報を送信しますか？（yes/no/cancel）： ');
  
  if (confirm.toLowerCase() === 'yes' || confirm.toLowerCase() === 'y') {
    return { action: 'accept', content };
  } else if (confirm.toLowerCase() === 'cancel') {
    return { action: 'cancel' };
  } else {
    return { action: 'decline' };
  }
});
```


#### `prompts.list()`

接続中のすべての MCP サーバーから利用可能なプロンプトを取得し、サーバー名ごとにグループ化します。

```typescript
async list(): Promise<Record<string, Prompt[]>>
```

例：

```typescript
const promptsByServer = await mcpClient.prompts.list();
for (const serverName in promptsByServer) {
  console.log(`${serverName} のプロンプト:`, promptsByServer[serverName]);
}
```


#### `prompts.get({ serverName, name, args?, version? })`

サーバーから特定のプロンプトとそのメッセージを取得します。

```typescript
async get({
  serverName,
  name,
  args?,
  version?,
}: {
  serverName: string;
  name: string;
  args?: Record<string, any>;
  version?: string;
}): Promise<{ prompt: Prompt; messages: PromptMessage[] }>
```

例：

```typescript
const { prompt, messages } = await mcpClient.prompts.get({
  serverName: "myWeatherServer",
  name: "current",
  args: { location: "ロンドン" },
});
console.log(prompt);
console.log(messages);
```


#### `prompts.onListChanged(serverName: string, handler: () => void)`

指定したサーバーで利用可能なプロンプトの一覧が変更された際に呼び出される通知ハンドラーを設定します。

```typescript
async onListChanged(serverName: string, handler: () => void): Promise<void>
```

例：

```typescript
mcpClient.prompts.onListChanged("myWeatherServer", () => {
  console.log("myWeatherServer でプロンプト一覧が変更されました。");
  // プロンプト一覧を再取得してください
  // await mcpClient.prompts.list();
});
```


## Elicitation（情報引き出し）

Elicitation は、MCP サーバーがユーザーに対して構造化された情報の提供を求められる機能です。サーバーが追加のデータを必要とする場合、クライアントがユーザーに質問（プロンプト）して処理する elicitation リクエストを送信できます。代表的な例として、ツールの呼び出し時があります。

### Elicitation の仕組み

1. **サーバーリクエスト**: MCP サーバーツールがメッセージとスキーマを指定して `server.elicitation.sendRequest()` を呼び出します
2. **クライアントハンドラー**: あなたの elicitation ハンドラー関数がそのリクエストで呼び出されます
3. **ユーザー操作**: ハンドラーがユーザー入力（UI や CLI など経由）を収集します
4. **レスポンス**: ハンドラーがユーザーの応答（accept/decline/cancel）を返します
5. **ツールの継続**: サーバーツールは応答を受け取り、処理を続行します

### エリシテーションの設定

エリシテーションを用いるツールを呼び出す前に、エリシテーションハンドラーを設定しておく必要があります。

```typescript
import { MCPClient } from '@mastra/mcp';

const mcpClient = new MCPClient({
  servers: {
    interactiveServer: {
      url: new URL('http://localhost:3000/mcp'),
    },
  },
});

// 引き出し（elicitation）ハンドラーを設定する
mcpClient.elicitation.onRequest('interactiveServer', async (request) => {
  // サーバーからのユーザー入力リクエストを処理する
  console.log(`サーバーが必要としている内容: ${request.message}`);
  
  // ユーザー入力を収集するためのロジック
  const userData = await collectUserInput(request.requestedSchema);
  
  return {
    action: 'accept',
    content: userData
  };
});
```


### レスポンスタイプ

elicitation ハンドラーは、次の3つのレスポンスタイプのいずれかを返す必要があります:

- **Accept**: ユーザーがデータを提供し、送信を確認した
  ```typescript
  return {
    action: 'accept',
    content: { name: 'John Doe', email: 'john@example.com' }
  };
  ```

- **Decline**: ユーザーが明確に情報の提供を拒否した
  ```typescript
  return { action: 'decline' };
  ```

- **Cancel**: ユーザーがリクエストを閉じる、またはキャンセルした
  ```typescript
  return { action: 'cancel' };
  ```

### スキーマベースの入力収集

`requestedSchema` は、サーバーに必要なデータの構造を定義します。

```typescript
await mcpClient.elicitation.onRequest('interactiveServer', async (request) => {
  const { properties, required = [] } = request.requestedSchema;
  const content: Record<string, any> = {};
  
  for (const [fieldName, fieldSchema] of Object.entries(properties || {})) {
    const field = fieldSchema as any;
    const isRequired = required.includes(fieldName);
    
    // フィールドの型と必須条件に基づいて入力を収集する
    const value = await promptUser({
      name: fieldName,
      title: field.title,
      description: field.description,
      type: field.type,
      required: isRequired,
      format: field.format,
      enum: field.enum,
    });
    
    if (value !== null) {
      content[fieldName] = value;
    }
  }
  
  return { action: 'accept', content };
});
```


### ベストプラクティス

- **常にエリシテーションに対応する**: エリシテーションを利用する可能性のあるツールを呼び出す前にハンドラーを用意する
- **入力を検証する**: 必須項目が入力されているか確認する
- **ユーザーの選択を尊重する**: 辞退やキャンセルの応答を丁寧に扱う
- **わかりやすいUI**: 何の情報を、なぜ求めているのかを明確に示す
- **セキュリティ**: 機密情報の要求を自動承認しない

## 例

### 静的ツール構成

アプリ全体で MCP サーバーへの接続が単一のツールでは、`getTools()` を使用し、取得したツールをエージェントに渡します。

```typescript
import { MCPClient } from "@mastra/mcp";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

const mcp = new MCPClient({
  servers: {
    stockPrice: {
      command: "npx",
      args: ["tsx", "stock-price.ts"],
      env: {
        API_KEY: "APIキー",
      },
      log: (logMessage) => {
        console.log(`[${logMessage.level}] ${logMessage.message}`);
      },
    },
    weather: {
      url: new URL("http://localhost:8080/sse"),
    },
  },
  timeout: 30000, // グローバルな30秒のタイムアウト
});

// すべてのツールにアクセスできるエージェントを作成
const agent = new Agent({
  name: "マルチツールエージェント",
  instructions: "複数のツールサーバーにアクセスできます。",
  model: openai("gpt-4"),
  tools: await mcp.getTools(),
});

// リソースメソッドの使用例
async function checkWeatherResource() {
  try {
    const weatherResources = await mcp.resources.list();
    if (weatherResources.weather && weatherResources.weather.length > 0) {
      const currentWeatherURI = weatherResources.weather[0].uri;
      const weatherData = await mcp.resources.read(
        "weather",
        currentWeatherURI,
      );
      console.log("天気データ:", weatherData.contents[0].text);
    }
  } catch (error) {
    console.error("天気リソースの取得中にエラーが発生しました:", error);
  }
}
checkWeatherResource();

// プロンプトメソッドの使用例
async function checkWeatherPrompt() {
  try {
    const weatherPrompts = await mcp.prompts.list();
    if (weatherPrompts.weather && weatherPrompts.weather.length > 0) {
      const currentWeatherPrompt = weatherPrompts.weather.find(
        (p) => p.name === "current"
      );
      if (currentWeatherPrompt) {
        console.log("天気プロンプト:", currentWeatherPrompt);
      } else {
        console.log("現在の天気プロンプトが見つかりませんでした");
      }
    }
  } catch (error) {
    console.error("天気プロンプトの取得中にエラーが発生しました:", error);
  }
}
checkWeatherPrompt();
```


### 動的ツールセット

ユーザーごとに新しい MCP 接続が必要な場合は、`getToolsets()` を使用し、stream または generate を呼び出すときにツールを追加します。

```typescript
import { Agent } from "@mastra/core/agent";
import { MCPClient } from "@mastra/mcp";
import { openai } from "@ai-sdk/openai";

// まずはツールなしでエージェントを作成します
const agent = new Agent({
  name: "マルチツールエージェント",
  instructions: "ユーザーの株価と天気の確認を手伝います。",
  model: openai("gpt-4"),
});

// 後で、ユーザー固有の設定で MCP を設定します
const mcp = new MCPClient({
  servers: {
    stockPrice: {
      command: "npx",
      args: ["tsx", "stock-price.ts"],
      env: {
        API_KEY: "user-123-api-key",
      },
      timeout: 20000, // サーバーごとのタイムアウト
    },
    weather: {
      url: new URL("http://localhost:8080/sse"),
      requestInit: {
        headers: {
          Authorization: `Bearer user-123-token`,
        },
      },
    },
  },
});

// すべてのツールセットを stream() または generate() に渡します
const response = await agent.stream(
  "AAPLの状況と天気を教えて",
  {
    toolsets: await mcp.getToolsets(),
  },
);
```


## インスタンス管理

`MCPClient` クラスには、複数インスタンスの管理におけるメモリリーク防止機能が組み込まれています:

1. `id` を指定せずに同じ構成で複数のインスタンスを作成しようとすると、メモリリーク防止のためにエラーがスローされます
2. 同一構成で複数のインスタンスが必要な場合は、各インスタンスに固有の `id` を指定してください
3. 同じ構成でインスタンスを再作成する前に、`await configuration.disconnect()` を呼び出してください
4. 単一のインスタンスで足りる場合は、再作成を避けるために構成をより上位のスコープに移動することを検討してください

たとえば、`id` を指定せずに同じ構成で複数のインスタンスを作成しようとすると:

```typescript
// 最初のインスタンス - OK
const mcp1 = new MCPClient({
  servers: {
    /* ... */
  },
});

// 同一設定で2つ目のインスタンスを作成するとエラーになります
const mcp2 = new MCPClient({
  servers: {
    /* ... */
  },
});

// 解決方法はいずれか:
// 1. 一意のIDを付与する
const mcp3 = new MCPClient({
  id: "instance-1",
  servers: {
    /* ... */
  },
});

// 2. もしくは再作成前に切断する
await mcp1.disconnect();
const mcp4 = new MCPClient({
  servers: {
    /* ... */
  },
});
```


## サーバーのライフサイクル

MCPClient はサーバー接続を適切に処理します:

1. 複数サーバーに対する自動的な接続管理
2. 開発中のエラーメッセージを防ぐための、落ち着いた（グレースフルな）サーバーシャットダウン
3. 切断時のリソースの適切なクリーンアップ

## SSE リクエストヘッダーの使用

レガシーな SSE MCP トランスポートを使用する場合、MCP SDK の不具合により、`requestInit` と `eventSourceInit` の両方を設定する必要があります。

```ts
const sseClient = new MCPClient({
  servers: {
    exampleServer: {
      url: new URL("https://your-mcp-server.com/sse"),
      // 注意: SSE では requestInit だけでは不十分です
      requestInit: {
        headers: {
          Authorization: "Bearer your-token",
        },
      },
      // カスタムヘッダーを伴う SSE 接続では、これも必須です
      eventSourceInit: {
        fetch(input: Request | URL | string, init?: RequestInit) {
          const headers = new Headers(init?.headers || {});
          headers.set("Authorization", "Bearer your-token");
          return fetch(input, {
            ...init,
            headers,
          });
        },
      },
    },
  },
});
```


## 関連情報

- MCP サーバーの作成については、[MCPServer ドキュメント](./mcp-server)を参照してください。
- Model Context Protocol の詳細については、[@modelcontextprotocol/sdk ドキュメント](https://github.com/modelcontextprotocol/typescript-sdk)を参照してください。