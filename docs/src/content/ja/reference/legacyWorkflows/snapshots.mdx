---
title: "リファレンス: スナップショット | ワークフロー状態の永続化（レガシー） | Mastra ドキュメント"
description: "Mastra におけるスナップショットの技術リファレンス — サスペンドと再開機能を可能にする、シリアライズされたワークフロー状態"
---

# スナップショット

Mastra において、スナップショットは特定の時点におけるワークフローの完全な実行状態をシリアライズ可能な形で表したものです。スナップショットは、以下を含む、ワークフローを中断したまさにその地点から再開するために必要なすべての情報を保持します：

- ワークフロー内の各ステップの現在の状態
- 完了したステップの出力
- ワークフロー内で辿った実行パス
- 一時停止中のステップとそのメタデータ
- 各ステップの残りのリトライ回数
- 実行再開に必要な追加のコンテキストデータ

スナップショットは、ワークフローが一時停止されるたびに Mastra によって自動的に作成・管理され、設定されたストレージシステムに永続化されます。

## Suspend と Resume における Snapshot の役割

Snapshot は、Mastra の suspend と resume 機能を支える中核的な仕組みです。ワークフローステップが `await suspend()` を呼び出すと:

1. ワークフローの実行はその時点で一時停止される
2. ワークフローの現在の状態がスナップショットとして記録される
3. スナップショットがストレージに永続化される
4. ワークフローステップはステータス `'suspended'` で「一時停止中」としてマークされる
5. 後に停止中のステップで `resume()` が呼び出されると、スナップショットが取得される
6. ワークフローの実行は中断したまさにその地点から再開される

この仕組みにより、ヒューマン・イン・ザ・ループのワークフロー、レート制限への対処、外部リソースの待機、長時間の一時停止を要する複雑な分岐ワークフローの実装が強力に可能になります。

## スナップショットの構成要素

Mastra のワークフローのスナップショットは、いくつかの主要なコンポーネントから成ります。

```typescript
export interface LegacyWorkflowRunState {
  // コアの状態情報
  value: Record<string, string>; // 現在のステートマシンの値
  context: {
    // ワークフローのコンテキスト
    steps: Record<
      string,
      {
        // ステップの実行結果
        status: "success" | "failed" | "suspended" | "waiting" | "skipped";
        payload?: any; // ステップ固有のデータ
        error?: string; // 失敗時のエラー情報
      }
    >;
    triggerData: Record<string, any>; // 初期トリガー データ
    attempts: Record<string, number>; // 残りの再試行回数
    inputData: Record<string, any>; // 初期入力データ
  };

  activePaths: Array<{
    // 現在アクティブな実行パス
    stepPath: string[];
    stepId: string;
    status: string;
  }>;

  // メタデータ
  runId: string; // 一意の実行ID
  timestamp: number; // スナップショット作成時刻

  // 入れ子のワークフローおよび一時停止中のステップ用
  childStates?: Record<string, WorkflowRunState>; // 子ワークフローの状態
  suspendedSteps?: Record<string, string>; // 一時停止中のステップのマッピング
}
```


## スナップショットの保存と取得方法

Mastra は、設定済みのストレージシステムにスナップショットを永続化します。デフォルトでは LibSQL データベースに保存されますが、Upstash などの他のストレージプロバイダーを利用するように設定できます。
スナップショットは `workflow_snapshots` テーブルに格納され、libsql を使用する場合は、関連する実行の `run_id` によって一意に識別されます。
永続化レイヤーを用いることで、スナップショットをワークフロー間で保持でき、先進的なヒューマン・イン・ザ・ループ機能を実現できます。

[libsql storage](../storage/libsql.mdx) および [upstash storage](../storage/upstash.mdx) の詳細はこちらをご覧ください。

### スナップショットの保存

ワークフローが一時停止されると、Mastra は次の手順でワークフローのスナップショットを自動的に永続化します。

1. ステップ実行内の `suspend()` 関数がスナップショット処理を開始する
2. `WorkflowInstance.suspend()` メソッドが一時停止中のマシンを記録する
3. 現在の状態を保存するために `persistWorkflowSnapshot()` が呼び出される
4. スナップショットはシリアライズされ、設定済みデータベースの `workflow_snapshots` テーブルに保存される
5. 保存レコードにはワークフロー名、実行 ID、シリアライズ済みスナップショットが含まれる

### スナップショットの取得

ワークフローが再開されると、Mastra は次の手順で永続化されたスナップショットを取得します：

1. 特定のステップ ID を指定して `resume()` メソッドが呼び出される
2. `loadWorkflowSnapshot()` を使用してストレージからスナップショットを読み込む
3. スナップショットを解析し、再開に向けて準備する
4. スナップショットの状態を用いてワークフロー実行を再構成する
5. 中断されていたステップを再開し、実行を継続する

## スナップショットのストレージオプション

Mastra では、スナップショットを永続化するための複数のストレージオプションを提供しています。

`storage` インスタンスは `Mastra` クラスで設定され、`Mastra` インスタンスに登録されたすべてのワークフロー向けにスナップショットの永続化レイヤーを構成するために使用されます。つまり、同じ `Mastra` インスタンスに登録されたワークフロー間でストレージは共有されます。

### LibSQL（デフォルト）

デフォルトのストレージオプションは LibSQL で、SQLite 互換のデータベースです。

```typescript
import { Mastra } from "@mastra/core/mastra";
import { DefaultStorage } from "@mastra/core/storage/libsql";

const mastra = new Mastra({
  storage: new DefaultStorage({
    config: {
      url: "file:storage.db", // ローカルのファイルベースデータベース
      // 本番環境では:
      // url: process.env.DATABASE_URL,
      // authToken: process.env.DATABASE_AUTH_TOKEN,
    },
  }),
  legacy_workflows: {
    weatherWorkflow,
    travelWorkflow,
  },
});
```


### Upstash（Redis 互換）

サーバーレス環境向け:

```typescript
import { Mastra } from "@mastra/core/mastra";
import { UpstashStore } from "@mastra/upstash";

const mastra = new Mastra({
  storage: new UpstashStore({
    url: process.env.UPSTASH_URL,
    token: process.env.UPSTASH_TOKEN,
  }),
  workflows: {
    weatherWorkflow,
    travelWorkflow,
  },
});
```


## スナップショットを扱う際のベストプラクティス

1. **シリアライズ可能であることを確保する**: スナップショットに含める必要があるデータはすべてシリアライズ（JSON に変換）可能でなければなりません。

2. **スナップショットのサイズを最小化する**: 大きなデータオブジェクトをワークフローのコンテキストに直接保存するのは避けましょう。代わりに、それらへの参照（ID など）を保持し、必要時にデータを取得します。

3. **再開時のコンテキストは慎重に扱う**: ワークフローを再開する際に提供するコンテキストは慎重に検討してください。提供した内容は既存のスナップショットデータにマージされます。

4. **適切な監視を整える**: とくに長時間稼働する一時停止中のワークフローに対して監視を実装し、確実に再開されるようにします。

5. **ストレージのスケールを検討する**: 一時停止中のワークフローが多数あるアプリケーションでは、ストレージソリューションが適切にスケールしていることを確認してください。

## さらに進んだスナップショットのパターン

### カスタムスナップショットのメタデータ

ワークフローを一時停止する際に、再開時に役立つカスタムメタデータを含めることができます。

```typescript
await suspend({
  reason: "顧客承認待ち",
  requiredApprovers: ["マネージャー", "財務"],
  requestedBy: currentUser,
  urgency: "高",
  expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
});
```

このメタデータはスナップショットと一緒に保存され、再開時に利用可能です。


### 条件付きの再開

再開時には、suspend のペイロードに基づいて条件分岐のロジックを実装できます:

```typescript
run.watch(async ({ activePaths }) => {
  const isApprovalStepSuspended =
    activePaths.get("approval")?.status === "suspended";
  if (isApprovalStepSuspended) {
    const payload = activePaths.get("approval")?.suspendPayload;
    if (payload.urgency === "high" && currentUser.role === "manager") {
      await resume({
        stepId: "approval",
        context: { approved: true, approver: currentUser.id },
      });
    }
  }
});
```


## 関連項目

- [Suspend 関数リファレンス](./suspend.mdx)
- [Resume 関数リファレンス](./resume.mdx)
- [Watch 関数リファレンス](./watch.mdx)
- [Suspend と Resume のガイド](../../docs/workflows-legacy/suspend-and-resume.mdx)