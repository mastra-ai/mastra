---
title: "リファレンス: MastraModelOutput | Agents | Mastra ドキュメント"
description: "MastraModelOutput の完全リファレンス。agent.stream() が返すストリームオブジェクトで、モデル出力にストリーミングおよび Promise ベースでアクセスできます。"
---

import { Callout } from "nextra/components";
import { PropertiesTable } from "@/components/properties-table";


# MastraModelOutput

`MastraModelOutput` クラスは [.stream()](./stream.mdx) によって返され、モデル出力にストリーミングおよび Promise ベースの両方でアクセスできます。構造化出力の生成、ツール呼び出し、推論、そして包括的な使用状況の追跡をサポートします。

```typescript
// MastraModelOutputはagent.stream()から返されます
const stream = await agent.stream("Hello world");
```

セットアップと基本的な使い方については、[.stream()](./stream.mdx) メソッドのドキュメントをご覧ください。


## ストリーミングのプロパティ

これらのプロパティにより、生成中のモデル出力へリアルタイムにアクセスできます:

<PropertiesTable
  content={[
    {
      name: "fullStream",
      type: "ReadableStream<ChunkType<OUTPUT>>",
      description: "テキスト、ツール呼び出し、推論、メタデータ、制御チャンクを含む、あらゆるチャンクタイプの完全なストリーム。モデルの応答のあらゆる側面に対してきめ細かなアクセスを提供します。",
      properties: [{
        type: "ReadableStream",
        parameters: [
          { name: "ChunkType", type: "ChunkType<OUTPUT>", description: "ストリーミング中に出力され得るすべてのチャンクタイプ" }
        ]
      }]
    },
    {
      name: "textStream",
      type: "ReadableStream<string>",
      description: "テキストのみを段階的に配信するストリーム。メタデータ、ツール呼び出し、制御チャンクをすべて除外し、生成中のテキストだけを提供します。"
    },
    {
      name: "objectStream",
      type: "ReadableStream<PartialSchemaOutput<OUTPUT>>",
      description: "出力スキーマ使用時の、構造化オブジェクトの進行的な更新ストリーム。構築途中の部分オブジェクトを逐次出力し、構造化データ生成をリアルタイムに可視化できます。",
      properties: [{
        type: "ReadableStream",
        parameters: [
          { name: "PartialSchemaOutput", type: "PartialSchemaOutput<OUTPUT>", description: "定義済みスキーマに適合する未完成の部分オブジェクト" }
        ]
      }]
    },
    {
      name: "elementStream",
      type: "ReadableStream<InferSchemaOutput<OUTPUT> extends (infer T)[] ? T : never>",
      description: "出力スキーマが配列型を定義している場合に、配列要素を個別に配信するストリーム。配列全体の完了を待たず、各要素が完成し次第出力します。"
    }
  ]}
/>

## Promiseベースのプロパティ

これらのプロパティは、ストリーム完了後に最終値へ解決されます：

<PropertiesTable
  content={[
    {
      name: "text",
      type: "Promise<string>",
      description: "モデルからの完全な連結テキスト応答。テキスト生成が完了すると解決されます。"
    },
    {
      name: "object",
      type: "Promise<InferSchemaOutput<OUTPUT>>",
      description: "出力スキーマ使用時の完全な構造化オブジェクト応答。解決前にスキーマで検証され、検証に失敗した場合は拒否されます。",
      properties: [{
        type: "Promise",
        parameters: [
          { name: "InferSchemaOutput", type: "InferSchemaOutput<OUTPUT>", description: "スキーマ定義に厳密に一致する完全に型付けされたオブジェクト" }
        ]
      }]
    },
    {
      name: "reasoning",
      type: "Promise<string>",
      description: "推論対応モデル（OpenAIのo1シリーズなど）用の完全な推論テキスト。推論非対応モデルでは空文字列を返します。"
    },
    {
      name: "reasoningText",
      type: "Promise<string | undefined>",
      description: "推論コンテンツへの別のアクセス方法。推論非対応モデルではundefinedの場合があり、'reasoning'は空文字列を返します。"
    },
    {
      name: "toolCalls",
      type: "Promise<ToolCallChunk[]>",
      description: "実行中に行われたすべてのツール呼び出しチャンクの配列。各チャンクにはツールのメタデータと実行の詳細が含まれます。",
      properties: [{
        type: "ToolCallChunk",
        parameters: [
          { name: "type", type: "'tool-call'", description: "チャンクタイプ識別子" },
          { name: "runId", type: "string", description: "実行ラン識別子" },
          { name: "from", type: "ChunkFrom", description: "チャンクの発生元（AGENT、WORKFLOWなど）" },
          { name: "payload", type: "ToolCallPayload", description: "toolCallId、toolName、args、実行の詳細を含むツール呼び出しデータ" }
        ]
      }]
    },
    {
      name: "toolResults",
      type: "Promise<ToolResultChunk[]>",
      description: "ツール呼び出しに対応するすべてのツール結果チャンクの配列。実行結果とエラー情報を含みます。",
      properties: [{
        type: "ToolResultChunk",
        parameters: [
          { name: "type", type: "'tool-result'", description: "チャンクタイプ識別子" },
          { name: "runId", type: "string", description: "実行ラン識別子" },
          { name: "from", type: "ChunkFrom", description: "チャンクの発生元（AGENT、WORKFLOWなど）" },
          { name: "payload", type: "ToolResultPayload", description: "toolCallId、toolName、result、エラー状態を含むツール結果データ" }
        ]
      }]
    },
    {
      name: "usage",
      type: "Promise<LanguageModelUsage>",
      description: "トークン使用状況（入力トークン、出力トークン、合計トークン、推論トークン［推論モデル向け］）",
      properties: [{
        type: "Record",
        parameters: [
          { name: "inputTokens", type: "number", description: "入力プロンプトで消費されたトークン数" },
          { name: "outputTokens", type: "number", description: "応答で生成されたトークン数" },
          { name: "totalTokens", type: "number", description: "入力トークンと出力トークンの合計" },
          { name: "reasoningTokens", type: "number", isOptional: true, description: "非公開の推論トークン（推論モデル向け）" },
          { name: "cachedInputTokens", type: "number", isOptional: true, description: "キャッシュヒットとなった入力トークン数" }
        ]
      }]
    },
    {
      name: "finishReason",
      type: "Promise<string | undefined>",
      description: "生成が停止した理由（例：'stop'、'length'、'tool_calls'、'content_filter'）。ストリームが完了していない場合はundefined。",
      properties: [{
        type: "enum",
        parameters: [
          { name: "stop", type: "'stop'", description: "モデルが自然に完了" },
          { name: "length", type: "'length'", description: "最大トークン数に到達" },
          { name: "tool_calls", type: "'tool_calls'", description: "モデルがツールを呼び出した" },
          { name: "content_filter", type: "'content_filter'", description: "コンテンツがフィルタリングされた" }
        ]
      }]
    }
  ]}
/>

## エラーのプロパティ

<PropertiesTable
  content={[
    {
      name: "error",
      type: "string | Error | { message: string; stack: string; } | undefined",
      description: "ストリームでエラーが発生した場合のエラー情報。エラーが発生していない場合は undefined。文字列メッセージ、Error オブジェクト、またはスタックトレースを含むシリアライズ済みのエラーのいずれか。"
    }
  ]}
/>

## メソッド

<PropertiesTable
  content={[
    {
      name: "getFullOutput",
      type: "() => Promise<FullOutput>",
      description: "テキスト、構造化オブジェクト、ツール呼び出し、使用状況統計、推論、メタデータなど、すべての結果を含む包括的な出力オブジェクトを返します。ストリームの全結果にアクセスできる便利な単一メソッドです。",
      properties: [{
        type: "FullOutput",
        parameters: [
          { name: "text", type: "string", description: "完全なテキスト応答" },
          { name: "object", type: "InferSchemaOutput<OUTPUT>", isOptional: true, description: "スキーマが指定されている場合の構造化出力" },
          { name: "toolCalls", type: "ToolCallChunk[]", description: "発行されたすべてのツール呼び出しチャンク" },
          { name: "toolResults", type: "ToolResultChunk[]", description: "すべてのツール結果チャンク" },
          { name: "usage", type: "Record<string, number>", description: "トークン使用量の統計" },
          { name: "reasoning", type: "string", isOptional: true, description: "利用可能な場合の推論テキスト" },
          { name: "finishReason", type: "string", isOptional: true, description: "生成が終了した理由" }
        ]
      }]
    },
    {
      name: "consumeStream",
      type: "(options?: ConsumeStreamOptions) => Promise<void>",
      description: "チャンクを個別に処理せず、ストリーム全体を手動で消費します。最終的な Promise ベースの結果だけが必要で、ストリームの消費を明示的に開始したい場合に便利です。",
      properties: [{
        type: "ConsumeStreamOptions",
        parameters: [
          { name: "onError", type: "(error: Error) => void", isOptional: true, description: "ストリームエラーを処理するコールバック" }
        ]
      }]
    }
  ]}
/>

## 使い方の例

### テキストストリーミングの基本

```typescript
const stream = await agent.stream("俳句を書いて");

// 生成されるテキストをストリーミング
for await (const text of stream.textStream) {
  process.stdout.write(text);
}

// または完全なテキストを取得
const fullText = await stream.text;
console.log(fullText);
```


### 構造化出力のストリーミング

```typescript
const stream = await agent.stream("ユーザーデータを生成", {
  structuredOutput: {
    schema: z.object({
      name: z.string(),
      age: z.number(),
      email: z.string()
    })
  },
});

// 部分的なオブジェクトをストリーミング
for await (const partial of stream.objectStream) {
  console.log("進行状況:", partial); // { name: "John" }, { name: "John", age: 30 }, ...
}

// 最終的な検証済みオブジェクトを取得
const user = await stream.object;
console.log("最終結果:", user); // { name: "John", age: 30, email: "john@example.com" }
```

````

### ツール呼び出しと結果

```typescript
const stream = await agent.stream("ニューヨークの天気は?", {
  tools: { weather: weatherTool }
});

// ツール呼び出しを監視
const toolCalls = await stream.toolCalls;
const toolResults = await stream.toolResults;

console.log("呼び出されたツール:", toolCalls);
console.log("結果:", toolResults);
````


### 出力へのフルアクセス

```typescript
const stream = await agent.stream("このデータを分析してください");

const output = await stream.getFullOutput();
console.log({
  text: output.text,
  usage: output.usage,
  reasoning: output.reasoning,
  finishReason: output.finishReason
});
```


### 完全なストリーム処理

```typescript
const stream = await agent.stream("複雑なタスク");

for await (const chunk of stream.fullStream) {
  switch (chunk.type) {
    case 'text-delta':
      process.stdout.write(chunk.payload.text);
      break;
    case 'tool-call':
      console.log(`${chunk.payload.toolName}を呼び出し中...`);
      break;
    case 'reasoning-delta':
      console.log(`推論: ${chunk.payload.text}`);
      break;
    case 'finish':
      console.log(`完了！理由: ${chunk.payload.stepResult.reason}`);
      break;
  }
}
```


### エラー処理

```typescript
const stream = await agent.stream("このデータを分析してください");

try {
  // オプション1: consumeStreamでエラーを処理
  await stream.consumeStream({
    onError: (error) => {
      console.error("ストリームエラー:", error);
    }
  });

  const result = await stream.text;
} catch (error) {
  console.error("結果の取得に失敗しました:", error);
}

// オプション2: errorプロパティをチェック
const result = await stream.getFullOutput();
if (stream.error) {
  console.error("ストリームにエラーがありました:", stream.error);
}
```


## 関連する型

- [.stream()](./stream.mdx) - MastraModelOutput を返すメソッド
- [ChunkType](../ChunkType.mdx) - ストリーム全体で使用されるすべてのチャンクタイプ