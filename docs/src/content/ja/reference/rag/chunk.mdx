---
title: "リファレンス: .chunk() | ドキュメント処理 | RAG | Mastra ドキュメント"
description: Mastra の chunk 関数に関するドキュメント。さまざまな手法でドキュメントを小さなチャンクに分割します。
---

# リファレンス: .chunk()

`.chunk()` 関数は、さまざまな戦略やオプションを用いてドキュメントを小さなセグメントに分割します。

## 例

```typescript
import { MDocument } from "@mastra/rag";

const doc = MDocument.fromMarkdown(`
# はじめに
これは、チャンクに分割したいサンプルドキュメントです。

## セクション 1
ここは、いくつかの内容を含む最初のセクションです。

## セクション 2 
ここは、異なる内容を含む別のセクションです。
`);

// デフォルト設定での基本的なチャンク分割
const chunks = await doc.chunk();

// 見出し抽出を伴う Markdown 向けのチャンク分割
const chunksWithMetadata = await doc.chunk({
  strategy: "markdown",
  headers: [
    ["#", "title"],
    ["##", "section"],
  ],
  extract: {
    summary: true, // デフォルト設定で要約を抽出
    keywords: true, // デフォルト設定でキーワードを抽出
  },
});
```


## パラメーター

以下のパラメーターは、すべてのチャンク化ストラテジーで利用できます。
**重要:** 各ストラテジーは、その用途に関連するパラメーターの一部のみを使用します。

<PropertiesTable
  content={[
    {
      name: "strategy",
      type: "'recursive' | 'character' | 'token' | 'markdown' | 'semantic-markdown' | 'html' | 'json' | 'latex' | 'sentence'",
      isOptional: true,
      description:
        "使用するチャンク化ストラテジー。未指定の場合はドキュメントの種類に応じてデフォルトが適用されます。ストラテジーによっては追加の任意設定があります。デフォルト: .md ファイル → 'markdown', .html/.htm → 'html', .json → 'json', .tex → 'latex', それ以外 → 'recursive'",
    },
    {
      name: "maxSize",
      type: "number",
      isOptional: true,
      defaultValue: "4000",
      description: "各チャンクの最大サイズ。**注意:** 一部のストラテジー設定（ヘッダーありの Markdown、ヘッダーありの HTML）ではこのパラメーターは無視されます。",
    },
    {
      name: "size",
      type: "number",
      isOptional: true,
      description: "**非推奨:** 代わりに `maxSize` を使用してください。このパラメーターは次回のメジャーバージョンで削除されます。",
    },
    {
      name: "overlap",
      type: "number",
      isOptional: true,
      defaultValue: "50",
      description: "チャンク間で重複させる文字数／トークン数。",
    },
    {
      name: "lengthFunction",
      type: "(text: string) => number",
      isOptional: true,
      description: "テキスト長を算出する関数。既定では文字数を使用します。",
    },
    {
      name: "keepSeparator",
      type: "boolean | 'start' | 'end'",
      isOptional: true,
      description:
        "セパレーターをチャンクの先頭または末尾に残すかどうか。",
    },
    {
      name: "addStartIndex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "チャンクに開始インデックスのメタデータを付与するかどうか。",
    },
    {
      name: "stripWhitespace",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "チャンクから空白を削除するかどうか。",
    },
    {
      name: "extract",
      type: "ExtractParams",
      isOptional: true,
      description:
        "メタデータ抽出の設定。",
    },
  ]}
/>

`extract` パラメーターの詳細は、[ExtractParams リファレンス](/reference/rag/extract-params.mdx)をご覧ください。

## 戦略固有のオプション

戦略固有のオプションは、strategy パラメータと同じ階層のトップレベルパラメータとして渡します。例:

```typescript showLineNumbers copy
// 文字ベース戦略の例
const chunks = await doc.chunk({
  strategy: "character",
  separator: ".", // 文字ベース固有のオプション
  isSeparatorRegex: false, // 文字ベース固有のオプション
  maxSize: 300, // 共通オプション
});

// 再帰的戦略の例
const chunks = await doc.chunk({
  strategy: "recursive",
  separators: ["\n\n", "\n", " "], // 再帰的戦略固有のオプション
  language: "markdown", // 再帰的戦略固有のオプション
  maxSize: 500, // 共通オプション
});

// 文単位戦略の例
const chunks = await doc.chunk({
  strategy: "sentence",
  maxSize: 450, // 文単位戦略では必須
  minSize: 50, // 文単位戦略固有のオプション
  sentenceEnders: ["."], // 文単位戦略固有のオプション
  fallbackToCharacters: false, // 文単位戦略固有のオプション
  keepSeparator: true, // 共通オプション
});

// HTML 戦略の例
const chunks = await doc.chunk({
  strategy: "html",
  headers: [
    ["h1", "title"],
    ["h2", "subtitle"],
  ], // HTML 戦略固有のオプション
});

// Markdown 戦略の例
const chunks = await doc.chunk({
  strategy: "markdown",
  headers: [
    ["#", "title"],
    ["##", "section"],
  ], // Markdown 戦略固有のオプション
  stripHeaders: true, // Markdown 戦略固有のオプション
});

// セマンティック Markdown 戦略の例
const chunks = await doc.chunk({
  strategy: "semantic-markdown",
  joinThreshold: 500, // セマンティック Markdown 固有のオプション
  modelName: "gpt-3.5-turbo", // セマンティック Markdown 固有のオプション
});

// トークン戦略の例
const chunks = await doc.chunk({
  strategy: "token",
  encodingName: "gpt2", // トークン戦略固有のオプション
  modelName: "gpt-3.5-turbo", // トークン戦略固有のオプション
  maxSize: 1000, // 共通オプション
});
```

以下に記載のオプションは、設定オブジェクトのトップレベルに直接渡され、別個の options オブジェクト内にネストされることはありません。


### 文字

<PropertiesTable
  content={[
    {
      name: "separators",
      type: "string[]",
      isOptional: true,
      description: "優先度の高いものから順に試す区切り文字の配列。まず最初の区切り文字で分割を試み、できなければ次の候補へ順次フォールバックします。",
    },
    {
      name: "isSeparatorRegex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "区切り文字が正規表現パターンかどうかを示します。",
    },
  ]}
/>

### 再帰

<PropertiesTable
  content={[
    {
      name: "separators",
      type: "string[]",
      isOptional: true,
      description: "優先順に試すセパレーターの配列。まず最初のセパレーターで分割を試み、不可なら次以降に順次フォールバックします。",
    },
    {
      name: "isSeparatorRegex",
      type: "boolean",
      isOptional: true,
      defaultValue: "false",
      description: "セパレーターが正規表現パターンかどうか",
    },
    {
      name: "language",
      type: "Language",
      isOptional: true,
      description: "言語固有の分割動作に用いるプログラミング言語またはマークアップ言語。対応する値は Language enum を参照してください。",
    },
  ]}
/>

### 文

<PropertiesTable
  content={[
    {
      name: "maxSize",
      type: "number",
      description: "各チャンクの最大サイズ（Sentence 戦略で必須）",
    },
    {
      name: "minSize",
      type: "number",
      isOptional: true,
      defaultValue: "50",
      description: "各チャンクの最小サイズ。これより小さいチャンクは、可能であれば隣接するチャンクと結合されます。",
    },
    {
      name: "targetSize",
      type: "number",
      isOptional: true,
      description: "チャンクの推奨ターゲットサイズ。既定値は maxSize の 80%。この戦略はこのサイズに近いチャンクの作成を試みます。",
    },
    {
      name: "sentenceEnders",
      type: "string[]",
      isOptional: true,
      defaultValue: "['.', '!', '?']",
      description: "分割境界として使用する、文末を示す文字の配列。",
    },
    {
      name: "fallbackToWords",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "maxSize を超える文に対して、単語レベルの分割へフォールバックするかどうか。",
    },
    {
      name: "fallbackToCharacters",
      type: "boolean",
      isOptional: true,
      defaultValue: "true",
      description: "maxSize を超える単語に対して、文字レベルの分割へフォールバックするかどうか。fallbackToWords が有効な場合にのみ適用されます。",
    },
  ]}
/>

### HTML

<PropertiesTable
  content={[
    {
      name: "headers",
      type: "Array<[string, string]>",
      description:
        "見出しベースの分割用に、［セレクタ、メタデータキー］の組を並べた配列",
    },
    {
      name: "sections",
      type: "Array<[string, string]>",
      description:
        "セクションベースの分割用に、［セレクタ、メタデータキー］の組を並べた配列",
    },
    {
      name: "returnEachLine",
      type: "boolean",
      isOptional: true,
      description: "各行を個別のチャンクとして返すかどうか",
    },
  ]}
/>

**重要:** HTML 戦略を使用する場合、一般的なオプションはすべて無視されます。見出しベースの分割には `headers` を、セクションベースの分割には `sections` を使用してください。両方を同時に指定した場合は `sections` が無視されます。

### Markdown

<PropertiesTable
  content={[
    {
      name: "headers",
      type: "Array<[string, string]>",
      isOptional: true,
      description: "［見出しレベル, メタデータキー］のペアの配列",
    },
    {
      name: "stripHeaders",
      type: "boolean",
      isOptional: true,
      description: "出力から見出しを削除するかどうか",
    },
    {
      name: "returnEachLine",
      type: "boolean",
      isOptional: true,
      description: "各行を個別のチャンクとして返すかどうか",
    },
  ]}
/>

**重要:** `headers` オプションを使用すると、Markdown 戦略はすべての一般オプションを無視し、コンテンツは Markdown の見出し構造に基づいて分割されます。Markdown でサイズ基準のチャンク分割を使うには、`headers` パラメータを省略してください。

### セマンティックMarkdown

<PropertiesTable
  content={[
    {
      name: "joinThreshold",
      type: "number",
      isOptional: true,
      defaultValue: "500",
      description: "関連セクションを結合する際の最大トークン数。単体でこの上限を超えるセクションはそのまま残りますが、合計サイズがこの閾値内に収まる場合は、小さいセクションが兄弟や親セクションと結合されます。",
    },
    {
      name: "modelName",
      type: "string",
      isOptional: true,
      description: "トークン化に使用するモデル名。指定がある場合、そのモデルに対応するトークン化の `encodingName` が使用されます。",
    },
    {
      name: "encodingName",
      type: "string",
      isOptional: true,
      defaultValue: "cl100k_base",
      description: "使用するトークンエンコーディング名。指定されていれば `modelName` から導出されます。",
    },
    {
      name: "allowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description: "トークン化時に許可する特殊トークンのセット。すべての特殊トークンを許可する場合は 'all' を指定します。",
    },
    {
      name: "disallowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      defaultValue: "all",
      description: "トークン化時に不許可とする特殊トークンのセット。すべての特殊トークンを不許可にする場合は 'all' を指定します。",
    },
  ]}
/>

### トークン

<PropertiesTable
  content={[
    {
      name: "encodingName",
      type: "string",
      isOptional: true,
      description: "使用するトークンエンコーディングの名称",
    },
    {
      name: "modelName",
      type: "string",
      isOptional: true,
      description: "トークン化に使用するモデル名",
    },
    {
      name: "allowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description: "トークン化時に許可する特殊トークンの集合、またはすべての特殊トークンを許可する場合は 'all'",
    },
    {
      name: "disallowedSpecial",
      type: "Set<string> | 'all'",
      isOptional: true,
      description: "トークン化時に許可しない特殊トークンの集合、またはすべての特殊トークンを不許可にする場合は 'all'",
    },
  ]}
/>

### JSON

<PropertiesTable
  content={[
    {
      name: "maxSize",
      type: "number",
      description: "各チャンクの最大サイズ",
    },
    {
      name: "minSize",
      type: "number",
      isOptional: true,
      description: "各チャンクの最小サイズ",
    },
    {
      name: "ensureAscii",
      type: "boolean",
      isOptional: true,
      description: "ASCII エンコードを保証するかどうか",
    },
    {
      name: "convertLists",
      type: "boolean",
      isOptional: true,
      description: "JSON 内のリストを変換するかどうか",
    },
  ]}
/>

### Latex

Latex戦略は、上記の一般的なチャンク化オプションのみを使用します。数学・学術文書向けに最適化された、LaTeXに対応した分割を提供します。

## 戻り値

チャンク化されたドキュメントを含む `MDocument` インスタンスを返します。各チャンクには次の内容が含まれます：

```typescript
interface DocumentNode {
  text: string;
  metadata: Record<string, any>;
  embedding?: number[];
}
```
