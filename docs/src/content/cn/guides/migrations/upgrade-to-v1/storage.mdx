---
title: "存储 | v1 迁移指南"
description: "了解在升级到 v1 时如何迁移存储相关的更改。"
---

# 存储

存储 API 已通过跨所有方法的一致分页和命名模式进行了标准化。

## 数据库迁移

通过您的正常迁移过程运行这些 SQL 迁移（例如 Prisma Migrate、Drizzle Kit 或您的 DBA 审查流程）。

### 评分器表列重命名

`mastra_scorers` 表中的 `runtimeContext` 列已重命名为 `requestContext`。

:::note[谁需要此迁移]
仅当您将 `@mastra/pg` 或 `@mastra/libsql` 与评估/评分一起使用且 `runtimeContext` 列中有现有数据时。
:::

:::important[没有它会怎样]
现有评分记录将无法访问其请求上下文数据。
:::

在部署 v1（初始化时添加新的 `requestContext` 列）后，复制数据并删除旧列：

```sql
UPDATE mastra_scorers SET "requestContext" = "runtimeContext" WHERE "runtimeContext" IS NOT NULL;
ALTER TABLE mastra_scorers DROP COLUMN "runtimeContext";
```

### 重复跨度迁移

如果您从旧版本的 Mastra 升级，您的 `mastra_spans` 表中可能存在重复的 `(traceId, spanId)` 条目。V1 在这些列上添加了唯一约束以确保数据完整性，但如果存在重复项，则无法添加此约束。

:::note[谁需要此迁移]
仅当您有来自 v1 之前 Mastra 版本的现有跨度数据，并且遇到重复键违规或约束创建失败错误时。
:::

:::important[没有它会怎样]
存储初始化在尝试添加唯一约束时可能会失败，或者您可能会看到类似"重复键值违反唯一约束"的错误。
:::

**选项 1：使用 CLI（推荐）**

运行自动去重跨度并添加约束的迁移命令：

```bash
npx mastra migrate
```

CLI 捆绑您的项目，连接到配置的存储，并运行迁移。它在删除重复项时保留最完整的记录（基于 `endTime` 和属性）。

**选项 2：手动 SQL（PostgreSQL）**

如果您喜欢手动运行迁移：

```sql
-- 删除重复项，保留最完整的记录
DELETE FROM mastra_spans a USING mastra_spans b
WHERE a.ctid < b.ctid
  AND a."traceId" = b."traceId"
  AND a."spanId" = b."spanId";

-- 添加唯一约束
ALTER TABLE mastra_spans ADD CONSTRAINT mastra_spans_trace_span_unique UNIQUE ("traceId", "spanId");
```

**选项 3：手动迁移（其他数据库）**

对于 ClickHouse、LibSQL、MongoDB 或 MSSQL，使用程序化 API：

```typescript
const storage = mastra.getStorage();
const observabilityStore = await storage.getStore('observability');

// 检查是否需要迁移
const status = await observabilityStore?.checkSpansMigrationStatus();
console.log(status);

// 运行迁移
const result = await observabilityStore?.migrateSpans();
console.log(result);
```

### JSON 列（TEXT → JSONB）

**仅限 PostgreSQL。** `mastra_threads` 中的 `metadata` 列和 `mastra_workflow_snapshot` 中的 `snapshot` 列从 TEXT 更改为 JSONB。

:::note[推荐]
迁移到 JSONB 可以为 JSON 字段启用原生 PostgreSQL JSON 操作符和 GIN 索引，以获得更好的查询性能。
:::

```sql
ALTER TABLE mastra_threads
ALTER COLUMN metadata TYPE jsonb
USING metadata::jsonb;

ALTER TABLE mastra_workflow_snapshot
ALTER COLUMN snapshot TYPE jsonb
USING snapshot::jsonb;
```

## 新增

### MastraCompositeStore 中的存储组合

`MastraCompositeStore` 现在可以从不同的适配器组合存储域。当您需要不同数据库用于不同目的时使用它 - 例如，PostgreSQL 用于内存和工作流，但专用数据库用于可观测性。

```typescript
import { MastraCompositeStore } from "@mastra/core/storage";
import { MemoryPG, WorkflowsPG, ScoresPG } from "@mastra/pg";
import { MemoryLibSQL } from "@mastra/libsql";
import { Mastra } from "@mastra/core";

// 从不同的存储组合域
const mastra = new Mastra({
  storage: new MastraCompositeStore({
    id: "composite",
    domains: {
      memory: new MemoryLibSQL({ url: "file:./local.db" }),
      workflows: new WorkflowsPG({ connectionString: process.env.DATABASE_URL }),
      scores: new ScoresPG({ connectionString: process.env.DATABASE_URL }),
    },
  }),
});
```

有关更多详细信息，请参阅[存储组合参考](/cn/reference/storage/composite)。

## 变更

### `MastraStorage` 重命名为 `MastraCompositeStore`

`MastraStorage` 类已重命名为 `MastraCompositeStore`，以更好地反映其作为组合存储实现的角色，该实现将不同域路由到不同的底层存储。这避免与一般"Mastra 存储"概念（Mastra 实例上的 `storage` 属性）混淆。

旧的 `MastraStorage` 名称作为已弃用的别名保留以保持向后兼容性，但将在未来版本中删除。

要迁移，请更新您的导入和实例化：

```diff
- import { MastraStorage } from "@mastra/core/storage";
+ import { MastraCompositeStore } from "@mastra/core/storage";
  import { MemoryLibSQL } from "@mastra/libsql";
  import { WorkflowsPG } from "@mastra/pg";

  export const mastra = new Mastra({
-   storage: new MastraStorage({
+   storage: new MastraCompositeStore({
      id: "composite",
      domains: {
        memory: new MemoryLibSQL({ url: "file:./memory.db" }),
        workflows: new WorkflowsPG({ connectionString: process.env.DATABASE_URL }),
      },
    }),
  });
```

:::note
如果您直接使用单个存储实现（如 `PostgresStore` 或 `LibSQLStore`），则无需更改。这仅影响明确使用 `MastraStorage` 进行组合存储的代码。
:::

### 存储实例需要 `id` 属性

存储实例现在需要 `id` 属性。此唯一标识符用于在 Mastra 内跟踪和管理存储实例。`id` 应该是应用程序中每个存储实例的描述性唯一字符串。

要迁移，请在存储构造函数中添加 `id` 字段。

```diff
  const storage = new PostgresStore({
+   id: 'main-postgres-store',
    connectionString: process.env.POSTGRES_CONNECTION_STRING,
    schemaName: 'public',
  });

  const upstashStore = new UpstashStore({
+   id: 'upstash-cache-store',
    url: process.env.UPSTASH_REDIS_REST_URL,
    token: process.env.UPSTASH_REDIS_REST_TOKEN,
  });
```

### 分页从 `offset/limit` 改为 `page/perPage`

所有分页 API 现在使用 `page` 和 `perPage` 而不是 `offset` 和 `limit`。此更改提供了更直观的分页模型，与常见的 Web 分页模式保持一致。

要迁移，将所有分页参数从 `offset/limit` 更新为 `page/perPage`。请注意，`page` 是从 0 开始的。

```diff
  memoryStore.listMessages({
    threadId: 'thread-123',
-   offset: 0,
-   limit: 20,
+   page: 0,
+   perPage: 20,
  });
```

### `getMessagesPaginated` 改为 `listMessages`

`getMessagesPaginated()` 方法已替换为 `listMessages()`。新方法支持 `perPage: false` 以获取所有记录而不进行分页。此更改符合 `list*` 命名约定，并增加了获取所有记录的灵活性。

要迁移，重命名方法并更新分页参数。您现在可以使用 `perPage: false` 获取所有记录。

```diff
+ const memoryStore = await storage.getStore('memory');
+
  // 分页
- const result = await storage.getMessagesPaginated({
+ const result = await memoryStore?.listMessages({
    threadId: 'thread-123',
-   offset: 0,
-   limit: 20,
+   page: 0,
+   perPage: 20,
  });

  // 获取所有记录（无分页限制）
+ const allMessages = await memoryStore?.listMessages({
+   threadId: 'thread-123',
+   page: 0,
+   perPage: false,
+ });
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/storage-get-messages-paginated .
```

:::

### 通过 `getStore()` 访问特定于域的存储

存储操作现在通过特定于域的存储访问，而不是直接在存储实例上访问。

域包括：
- **`memory`** - 线程、消息和资源
- **`workflows`** - 工作流快照
- **`scores`** - 评估分数
- **`observability`** - 跟踪和跨度
- **`agents`** - 存储的代理数据

要迁移，使用域名调用 `getStore()`，然后在返回的存储上调用方法。

```diff
  const storage = mastra.getStorage();

  // 内存操作（线程、消息、资源）
- const thread = await storage.getThread({ threadId: '123' });
- await storage.saveThread({ thread });
+ const memoryStore = await storage.getStore('memory');
+ const thread = await memoryStore?.getThreadById({ threadId: '123' });
+ await memoryStore?.saveThread({ thread });

  // 工作流操作（快照）
- const snapshot = await storage.loadWorkflowSnapshot({ runId, workflowName });
- await storage.persistWorkflowSnapshot({ runId, workflowName, snapshot });
+ const workflowStore = await storage.getStore('workflows');
+ const snapshot = await workflowStore?.loadWorkflowSnapshot({ runId, workflowName });
+ await workflowStore?.persistWorkflowSnapshot({ runId, workflowName, snapshot });

  // 可观测性操作（跟踪、跨度）
- const traces = await storage.listTraces({ page: 0, perPage: 20 });
+ const observabilityStore = await storage.getStore('observability');
+ const traces = await observabilityStore?.listTraces({ page: 0, perPage: 20 });

  // 分数操作（评估）
- const scores = await storage.listScoresByScorerId({ scorerId: 'helpfulness' });
+ const scoresStore = await storage.getStore('scores');
+ const scores = await scoresStore?.listScoresByScorerId({ scorerId: 'helpfulness' });
```

### `getThreadsByResourceId` 改为 `listThreads`

`getThreadsByResourceId()` 方法已替换为 `listThreads()`。新方法添加了分页支持和按 `resourceId`、`metadata` 或两者过滤。

:::important

旧的 `getThreadsByResourceId()` 返回所有匹配的线程而不进行分页。新的 `listThreads()` 需要分页参数。要保留获取所有线程的旧行为，请使用 `perPage: false`。

:::

要迁移，使用内存存储和新的 `listThreads()` 方法以及分页和可选的过滤对象。

```diff
- const threads = await storage.getThreadsByResourceId({
-   resourceId: 'res-123',
- });
+ const memoryStore = await storage.getStore('memory');
+
+ // 分页（推荐用于大型数据集）
+ const result = await memoryStore?.listThreads({
+   filter: { resourceId: 'res-123' },
+   page: 0,
+   perPage: 20,
+ });
+ const threads = result?.threads;
+
+ // 或像以前一样获取所有线程（使用 perPage: false）
+ const allResult = await memoryStore?.listThreads({
+   filter: { resourceId: 'res-123' },
+   perPage: false,
+ });
+ const allThreads = allResult?.threads;
```

新方法还支持：
- 列出所有线程（省略过滤器）
- 仅按元数据过滤
- 组合的 resourceId + 元数据过滤器

```typescript
// 列出所有线程
await memoryStore?.listThreads({ page: 0, perPage: 20 });

// 仅按元数据过滤
await memoryStore?.listThreads({
  filter: { metadata: { status: 'active' } },
  page: 0,
  perPage: 20,
});

// 组合过滤器
await memoryStore?.listThreads({
  filter: {
    resourceId: 'user-123',
    metadata: { category: 'support' },
  },
  page: 0,
  perPage: 20,
});
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/storage-list-threads-by-resource-to-list-threads .
```

:::

### `getWorkflowRuns` 改为 `listWorkflowRuns`

`getWorkflowRuns()` 方法已重命名为 `listWorkflowRuns()`。此更改符合 `list*` 方法返回集合的约定。

要迁移，使用工作流存储，重命名方法调用并更新分页参数。

```diff
- const runs = await storage.getWorkflowRuns({
+ const workflowStore = await storage.getStore('workflows');
+ const runs = await workflowStore?.listWorkflowRuns({
    fromDate,
    toDate,
+   page: 0,
+   perPage: 20,
  });
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/storage-list-workflow-runs .
```

:::

### `getMessagesById` 改为 `listMessagesById`

`getMessagesById()` 方法已重命名为 `listMessagesById()`。此更改符合 `list*` 方法返回集合的约定。

要迁移，使用内存存储并重命名方法调用。

```diff
+ const memoryStore = await storage.getStore('memory');
- const result = await storage.getMessagesById({
+ const result = await memoryStore?.listMessagesById({
    messageIds: ['msg-1', 'msg-2'],
  });
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/storage-list-messages-by-id .
```

:::

### 存储 `getMessages` 和 `saveMessages` 签名

`getMessages()` 和 `saveMessages()` 方法的签名和返回类型已更改。格式重载已移除，方法现在始终使用 `MastraDBMessage`。此更改通过移除格式变体来简化 API。

要迁移，使用内存存储，移除格式参数，并更新代码以使用一致的返回类型。

```diff
+ const memoryStore = await storage.getStore('memory');
+
  // 始终返回 { messages: MastraDBMessage[] }
- const v1Messages = await storage.getMessages({ threadId, format: 'v1' });
- const v2Messages = await storage.getMessages({ threadId, format: 'v2' });
+ const result = await memoryStore?.getMessages({ threadId });
+ const messages = result?.messages; // MastraDBMessage[]

  // SaveMessages 始终使用 MastraDBMessage
- await storage.saveMessages({ messages: v1Messages, format: 'v1' });
- await storage.saveMessages({ messages: v2Messages, format: 'v2' });
+ const saveResult = await memoryStore?.saveMessages({ messages: mastraDBMessages });
+ const saved = saveResult?.messages; // MastraDBMessage[]
```

### 向量存储 API 从位置参数改为命名参数

所有向量存储方法现在使用命名参数而不是位置参数。此更改提高了代码可读性并使方法签名更易于维护。

要迁移，更新所有向量存储方法调用以使用命名参数。

```diff
- await vectorDB.createIndex(indexName, 3, 'cosine');
+ await vectorDB.createIndex({
+   indexName: indexName,
+   dimension: 3,
+   metric: 'cosine',
+ });

- await vectorDB.upsert(indexName, [[1, 2, 3]], [{ test: 'data' }]);
+ await vectorDB.upsert({
+   indexName: indexName,
+   vectors: [[1, 2, 3]],
+   metadata: [{ test: 'data' }],
+ });

- await vectorDB.query(indexName, [1, 2, 3], 5);
+ await vectorDB.query({
+   indexName: indexName,
+   queryVector: [1, 2, 3],
+   topK: 5,
+ });
```

### 向量存储方法重命名

`updateIndexById` 和 `deleteIndexById` 方法已分别重命名为 `updateVector` 和 `deleteVector`。此更改提供了更清晰的命名，更好地描述了操作。

要迁移，重命名方法并使用命名参数。

```diff
- await vectorDB.updateIndexById(indexName, id, update);
- await vectorDB.deleteIndexById(indexName, id);
+ await vectorDB.updateVector({ indexName, id, update });
+ await vectorDB.deleteVector({ indexName, id });
```

### PGVector 构造函数从连接字符串改为对象

PGVector 构造函数现在需要对象参数而不是连接字符串。此更改为所有存储适配器提供了更一致的 API。

要迁移，将连接字符串作为对象属性传递。

```diff
- const pgVector = new PgVector(process.env.POSTGRES_CONNECTION_STRING!);
+ const pgVector = new PgVector({
+   connectionString: process.env.POSTGRES_CONNECTION_STRING,
+ });
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/vector-pg-constructor .
```

:::

### PGVector `defineIndex` 改为 `buildIndex`

`defineIndex()` 方法已被移除，取而代之的是 `buildIndex()`。此更改为索引构建操作提供了更清晰的命名。

要迁移，重命名方法并使用命名参数。

```diff
- await vectorDB.defineIndex(indexName, 'cosine', { type: 'flat' });
+ await vectorDB.buildIndex({
+   indexName: indexName,
+   metric: 'cosine',
+   indexConfig: { type: 'flat' },
+ });
```

### PostgresStore `schema` 改为 `schemaName`

`schema` 参数已在 PostgresStore 构造函数中重命名为 `schemaName`。此更改提供了更清晰的命名，以避免与数据库模式概念混淆。

要迁移，重命名参数。

```diff
  const pgStore = new PostgresStore({
    connectionString: process.env.POSTGRES_CONNECTION_STRING,
-   schema: customSchema,
+   schemaName: customSchema,
  });
```

:::tip[Codemod]

您可以使用 Mastra 的 codemod CLI 自动更新代码：

```bash
npx @mastra/codemod@latest v1/storage-postgres-schema-name .
```

:::

### 评分存储方法改为 `listScoresBy*` 模式

评分存储 API 已重命名以遵循 `listScoresBy*` 模式。此更改提供了与更广泛的 API 命名约定的一致性。

要迁移，将方法名称从 `getScores` 更新为 `listScoresByScorerId` 和相关变体。

```diff
- const scores = await storage.getScores({ scorerName: 'helpfulness-scorer' });
+ const scores = await storage.listScoresByScorerId({
+   scorerId: 'helpfulness-scorer',
+ });
+ // 同样可用：listScoresByRunId、listScoresByEntityId、listScoresBySpan
```

## 移除

### 非分页存储函数

非分页存储函数已被移除，取而代之的是分页版本。所有列表操作现在都使用分页，尽管您可以使用 `perPage: false` 获取所有记录。此更改提供了跨 API 的一致性并防止意外加载大型数据集。

要迁移，通过域存储使用分页方法。要获取所有记录，请使用 `perPage: false`。

```diff
- // 非分页直接访问
- const messages = await storage.getMessages({ threadId });

+ // 通过域存储使用分页方法
+ const memoryStore = await storage.getStore('memory');
+ const result = await memoryStore?.listMessages({ threadId, page: 0, perPage: 20 });
+ // 或获取所有
+ const allMessages = await memoryStore?.listMessages({
+   threadId,
+   page: 0,
+   perPage: false,
+ });
```

### `getTraces` 和 `getTracesPaginated`

`getTraces()` 和 `getTracesPaginated()` 方法已从存储中移除。跟踪现在通过可观测性包而不是核心存储处理。此更改在核心存储和可观测性功能之间提供了更好的关注点分离。

要迁移，改用可观测性存储方法。

```diff
- const traces = await storage.getTraces({ traceId: 'trace-123' });
- const paginated = await storage.getTracesPaginated({ page: 0, perPage: 20 });

+ // 使用可观测性 API 获取跟踪
+ import { initObservability } from '@mastra/observability';
+ const observability = initObservability({ config: { ... } });
+ // 通过可观测性 API 访问跟踪
```

### 评估测试实用程序

评估域测试实用程序已从 `@internal/test-utils` 中移除。此更改反映了旧版评估功能的移除。

要迁移，直接使用存储 API 进行测试，而不是专门的评估测试实用程序。

```diff
- import { createEvalsTests } from '@internal/test-utils/domains/evals';
- createEvalsTests({ storage });

+ // 直接使用存储 API 进行测试
```

### MSSQL 存储中的 TABLE_EVALS

`TABLE_EVALS` 表已从 MSSQL 存储实现中移除。此更改反映了旧版评估功能的移除。

如果您将 MSSQL 存储与评估一起使用，请迁移到不同的存储适配器或移除评估功能。
