---
title: "Reference: createInngestAgent() | Workflows"
description: Documentation for the `createInngestAgent()` factory function, which wraps a Mastra Agent with Inngest's durable execution engine.
packages:
  - "@mastra/inngest"
---

# createInngestAgent()

The `createInngestAgent()` factory function wraps a Mastra Agent with Inngest's durable execution engine. The entire agentic loop becomes durable - if your server crashes mid-conversation, Inngest automatically resumes from where it left off.

## Usage example

```typescript
import { Agent } from "@mastra/core/agent";
import { createInngestAgent } from "@mastra/inngest";
import { Inngest } from "inngest";
import { realtimeMiddleware } from "@inngest/realtime/middleware";
import { openai } from "@ai-sdk/openai";

// Create Inngest client with realtime middleware
const inngest = new Inngest({
  id: "my-app",
  middleware: [realtimeMiddleware()],
});

// Create a regular Mastra Agent
const agent = new Agent({
  id: "my-agent",
  name: "My Agent",
  instructions: "You are a helpful assistant",
  model: openai("gpt-4o"),
});

// Wrap with durable execution
const durableAgent = createInngestAgent({ agent, inngest });

// Use the agent
const { output, runId, cleanup } = await durableAgent.stream([
  { role: "user", content: "Hello!" }
]);
const text = await output.text;
cleanup();
```

## Parameters

<PropertiesTable
  content={[
    {
      name: "options",
      type: "CreateInngestAgentOptions",
      description: "Configuration options for creating the durable agent.",
    },
  ]}
/>

### CreateInngestAgentOptions

<PropertiesTable
  content={[
    {
      name: "agent",
      type: "Agent",
      description: "The Mastra Agent to wrap with durable execution.",
    },
    {
      name: "inngest",
      type: "Inngest",
      description: "Inngest client instance. Must have realtimeMiddleware() configured for streaming.",
    },
    {
      name: "pubsub",
      type: "PubSub",
      isOptional: true,
      description: "Optional PubSub override. Defaults to InngestPubSub for Inngest realtime streaming.",
    },
  ]}
/>

## Returns

Returns an `InngestAgent` object with the following properties and methods:

<PropertiesTable
  content={[
    {
      name: "id",
      type: "string",
      description: "The agent's unique identifier (from the underlying Agent).",
    },
    {
      name: "name",
      type: "string",
      description: "The agent's name (from the underlying Agent).",
    },
    {
      name: "agent",
      type: "Agent",
      description: "The underlying Mastra Agent instance.",
    },
    {
      name: "inngest",
      type: "Inngest",
      description: "The Inngest client instance.",
    },
    {
      name: "stream",
      type: "(messages, options?) => Promise<InngestAgentStreamResult>",
      description: "Stream a response using Inngest's durable execution.",
    },
    {
      name: "resume",
      type: "(runId, resumeData, options?) => Promise<InngestAgentStreamResult>",
      description: "Resume a suspended workflow execution.",
    },
    {
      name: "prepare",
      type: "(messages, options?) => Promise<PrepareResult>",
      description: "Prepare for durable execution without starting it.",
    },
    {
      name: "getDurableWorkflows",
      type: "() => Workflow[]",
      description: "Returns the durable workflows required by this agent. Called by Mastra during registration.",
    },
  ]}
/>

## stream()

Stream a response from the durable agent.

```typescript
const { output, runId, threadId, resourceId, cleanup } = await durableAgent.stream(
  [{ role: "user", content: "Hello!" }],
  {
    onChunk: (chunk) => console.log(chunk),
    onFinish: (result) => console.log("Done:", result),
  }
);
```

### Parameters

<PropertiesTable
  content={[
    {
      name: "messages",
      type: "MessageListInput",
      description: "Messages to send to the agent. Can be a string, array of strings, or structured message objects.",
    },
    {
      name: "options",
      type: "InngestAgentStreamOptions",
      isOptional: true,
      description: "Optional configuration for the stream.",
    },
  ]}
/>

### InngestAgentStreamOptions

<PropertiesTable
  content={[
    {
      name: "instructions",
      type: "string",
      isOptional: true,
      description: "Custom instructions that override the agent's default instructions.",
    },
    {
      name: "context",
      type: "ModelMessage[]",
      isOptional: true,
      description: "Additional context messages to provide to the agent.",
    },
    {
      name: "memory",
      type: "MemoryConfig",
      isOptional: true,
      description: "Memory configuration for conversation persistence.",
    },
    {
      name: "runId",
      type: "string",
      isOptional: true,
      description: "Unique identifier for this execution run. Auto-generated if not provided.",
    },
    {
      name: "maxSteps",
      type: "number",
      isOptional: true,
      description: "Maximum number of steps to run.",
    },
    {
      name: "toolsets",
      type: "ToolsetsInput",
      isOptional: true,
      description: "Additional tool sets for this execution.",
    },
    {
      name: "clientTools",
      type: "ToolsInput",
      isOptional: true,
      description: "Client-side tools available during execution.",
    },
    {
      name: "toolChoice",
      type: "'auto' | 'none' | 'required' | { type: 'tool'; toolName: string }",
      isOptional: true,
      description: "Tool selection strategy.",
    },
    {
      name: "modelSettings",
      type: "ModelSettings",
      isOptional: true,
      description: "Model-specific settings like temperature.",
    },
    {
      name: "requireToolApproval",
      type: "boolean",
      isOptional: true,
      description: "Require approval for all tool calls. Agent will suspend and call onSuspended.",
    },
    {
      name: "autoResumeSuspendedTools",
      type: "boolean",
      isOptional: true,
      description: "Automatically resume suspended tools when user sends a new message.",
    },
    {
      name: "toolCallConcurrency",
      type: "number",
      isOptional: true,
      description: "Maximum concurrent tool calls.",
    },
    {
      name: "onChunk",
      type: "(chunk: ChunkType) => void | Promise<void>",
      isOptional: true,
      description: "Callback when a chunk is received.",
    },
    {
      name: "onStepFinish",
      type: "(result: AgentStepFinishEventData) => void | Promise<void>",
      isOptional: true,
      description: "Callback after each step completes.",
    },
    {
      name: "onFinish",
      type: "(result: AgentFinishEventData) => void | Promise<void>",
      isOptional: true,
      description: "Callback when execution completes.",
    },
    {
      name: "onError",
      type: "(error: Error) => void | Promise<void>",
      isOptional: true,
      description: "Callback when an error occurs.",
    },
    {
      name: "onSuspended",
      type: "(data: AgentSuspendedEventData) => void | Promise<void>",
      isOptional: true,
      description: "Callback when the workflow suspends (e.g., for tool approval).",
    },
  ]}
/>

### InngestAgentStreamResult

<PropertiesTable
  content={[
    {
      name: "output",
      type: "MastraModelOutput",
      description: "The streaming output. Access text via `await output.text`.",
    },
    {
      name: "runId",
      type: "string",
      description: "Unique identifier for this execution run.",
    },
    {
      name: "threadId",
      type: "string",
      isOptional: true,
      description: "Thread ID if using memory.",
    },
    {
      name: "resourceId",
      type: "string",
      isOptional: true,
      description: "Resource ID if using memory.",
    },
    {
      name: "cleanup",
      type: "() => void",
      description: "Cleanup function to call when done. Unsubscribes from pubsub.",
    },
  ]}
/>

## resume()

Resume a suspended workflow execution.

```typescript
const { output, cleanup } = await durableAgent.resume(
  runId,
  { approved: true },
  {
    onFinish: (result) => console.log("Resumed execution completed"),
  }
);
```

### Parameters

<PropertiesTable
  content={[
    {
      name: "runId",
      type: "string",
      description: "The run ID from the original stream() call.",
    },
    {
      name: "resumeData",
      type: "unknown",
      description: "Data to resume the workflow with (e.g., tool approval).",
    },
    {
      name: "options",
      type: "object",
      isOptional: true,
      description: "Optional callbacks and configuration.",
      properties: [
        {
          parameters: [
            {
              name: "threadId",
              type: "string",
              isOptional: true,
              description: "Thread ID if using memory.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "resourceId",
              type: "string",
              isOptional: true,
              description: "Resource ID if using memory.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "onChunk",
              type: "(chunk: ChunkType) => void | Promise<void>",
              isOptional: true,
              description: "Callback when a chunk is received.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "onStepFinish",
              type: "(result: AgentStepFinishEventData) => void | Promise<void>",
              isOptional: true,
              description: "Callback after each step completes.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "onFinish",
              type: "(result: AgentFinishEventData) => void | Promise<void>",
              isOptional: true,
              description: "Callback when execution completes.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "onError",
              type: "(error: Error) => void | Promise<void>",
              isOptional: true,
              description: "Callback when an error occurs.",
            },
          ],
        },
        {
          parameters: [
            {
              name: "onSuspended",
              type: "(data: AgentSuspendedEventData) => void | Promise<void>",
              isOptional: true,
              description: "Callback when the workflow suspends again.",
            },
          ],
        },
      ],
    },
  ]}
/>

## prepare()

Prepare for durable execution without starting it. Useful for getting the runId before execution.

```typescript
const { runId, messageId, workflowInput } = await durableAgent.prepare([
  { role: "user", content: "Hello!" }
]);
```

### Returns

<PropertiesTable
  content={[
    {
      name: "runId",
      type: "string",
      description: "Unique identifier for the execution run.",
    },
    {
      name: "messageId",
      type: "string",
      description: "Unique identifier for the message.",
    },
    {
      name: "workflowInput",
      type: "object",
      description: "The prepared workflow input data.",
    },
    {
      name: "threadId",
      type: "string",
      isOptional: true,
      description: "Thread ID if using memory.",
    },
    {
      name: "resourceId",
      type: "string",
      isOptional: true,
      description: "Resource ID if using memory.",
    },
  ]}
/>

## Type guard

Use `isInngestAgent()` to check if an object is an InngestAgent:

```typescript
import { isInngestAgent } from "@mastra/inngest";

if (isInngestAgent(agent)) {
  // agent is InngestAgent
  const { output, cleanup } = await agent.stream("Hello!");
}
```

## Mastra registration

When you add an `InngestAgent` to Mastra, the required workflow is automatically registered:

```typescript
import { Mastra } from "@mastra/core";
import { serve } from "@mastra/inngest";

const mastra = new Mastra({
  agents: { 
    myAgent: durableAgent,  // Workflow auto-registered
  },
  server: {
    apiRoutes: [
      {
        path: "/api/inngest",
        method: "ALL",
        createHandler: async ({ mastra }) => serve({ mastra, inngest }),
      },
    ],
  },
});
```

Mastra detects that `durableAgent` implements `DurableAgentLike` and:

1. Registers the underlying `agent` so the workflow can access it
2. Calls `getDurableWorkflows()` and registers the returned workflows
3. The workflow becomes available when `serve()` exposes it to Inngest

## Related

- [Inngest Deployment Guide](/guides/deployment/inngest) - Complete setup guide
- [Agent Class](/reference/agents/agent) - Creating Mastra agents
- [Workflow Class](/reference/workflows/workflow) - Workflow documentation
