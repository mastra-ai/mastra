---
title: "Reference: Cloudflare Storage | Storage"
description: Documentation for the Cloudflare KV storage implementation in Mastra.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import StorageDomainsNoObservability from "./_storage-domains-no-observability.mdx";
import SchemaManagementNoObservability from "./_schema-management-no-observability.mdx";

# Cloudflare Storage

The Cloudflare KV storage implementation provides a globally distributed, serverless key-value store solution using Cloudflare Workers KV.

## Installation

<Tabs>
<TabItem value="npm" label="npm">

```bash copy
npm install @mastra/cloudflare@beta
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash copy
pnpm add @mastra/cloudflare@beta
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash copy
yarn add @mastra/cloudflare@beta
```

</TabItem>
<TabItem value="bun" label="bun">

```bash copy
bun add @mastra/cloudflare@beta
```

</TabItem>
</Tabs>

## Usage

CloudflareStore can be configured in two ways: using Workers bindings (recommended for Cloudflare Workers) or the REST API (for Node.js or other environments).

<Tabs>
<TabItem value="workers" label="Workers Binding (Recommended)">

Use this approach when running in Cloudflare Workers:

```typescript copy showLineNumbers
import { CloudflareStore } from "@mastra/cloudflare";
import { TABLE_THREADS, TABLE_MESSAGES, TABLE_WORKFLOW_SNAPSHOT, TABLE_SCORERS } from "@mastra/core/storage";

// In your Cloudflare Worker
export default {
  async fetch(request: Request, env: { 
    [TABLE_THREADS]: KVNamespace;
    [TABLE_MESSAGES]: KVNamespace;
    [TABLE_WORKFLOW_SNAPSHOT]: KVNamespace;
    [TABLE_SCORERS]: KVNamespace;
  }) {
    const storage = new CloudflareStore({
      id: 'cloudflare-storage',
      bindings: {
        [TABLE_THREADS]: env[TABLE_THREADS],
        [TABLE_MESSAGES]: env[TABLE_MESSAGES],
        [TABLE_WORKFLOW_SNAPSHOT]: env[TABLE_WORKFLOW_SNAPSHOT],
        [TABLE_SCORERS]: env[TABLE_SCORERS],
      },
      keyPrefix: "dev_", // Optional: isolate keys per environment
    });
    
    // Use storage...
  },
};
```

</TabItem>
<TabItem value="rest" label="REST API">

Use this approach for Node.js or other non-Workers environments:

```typescript copy showLineNumbers
import { CloudflareStore } from "@mastra/cloudflare";

const storage = new CloudflareStore({
  id: 'cloudflare-storage',
  accountId: process.env.CLOUDFLARE_ACCOUNT_ID!,
  apiToken: process.env.CLOUDFLARE_API_TOKEN!,
  namespacePrefix: "dev_", // Optional: isolate namespaces per environment
});
```

</TabItem>
</Tabs>

## Parameters

<PropertiesTable
  content={[
    {
      name: "id",
      type: "string",
      description: "Unique identifier for this storage instance",
      isOptional: false,
    },
    {
      name: "bindings",
      type: "Record<TABLE_NAMES, KVNamespace>",
      description: "Cloudflare Workers KV bindings (for Workers runtime). Required when using Workers Binding API. Must include bindings for TABLE_THREADS, TABLE_MESSAGES, TABLE_WORKFLOW_SNAPSHOT, and TABLE_SCORERS.",
      isOptional: true,
    },
    {
      name: "accountId",
      type: "string",
      description: "Cloudflare Account ID (for REST API). Required when using REST API.",
      isOptional: true,
    },
    {
      name: "apiToken",
      type: "string",
      description: "Cloudflare API Token (for REST API). Required when using REST API.",
      isOptional: true,
    },
    {
      name: "namespacePrefix",
      type: "string",
      description:
        "Optional prefix for all namespace names (useful for environment isolation). Used with REST API.",
      isOptional: true,
    },
    {
      name: "keyPrefix",
      type: "string",
      description:
        "Optional prefix for all keys (useful for environment isolation). Used with Workers Binding API.",
      isOptional: true,
    },
  ]}
/>

## Storage Domains

CloudflareStore supports the following domains:

<StorageDomainsNoObservability />

To access domain-specific operations, use `getStore()`:

```typescript copy
// Access memory domain for threads and messages
const memoryStore = await storage.getStore('memory');

const threads = await memoryStore.listThreads({
  resourceId: 'user-123',
  page: 0,
  perPage: 20,
});

// Access workflows domain for workflow snapshots
const workflowsStore = await storage.getStore('workflows');

const snapshot = await workflowsStore.getWorkflowSnapshot({
  workflowId: 'my-workflow',
  runId: 'run-123',
});

// Access evals domain for scores
const evalsStore = await storage.getStore('evals');

const scores = await evalsStore.listScoresByScorerId({
  scorerId: 'my-scorer',
  pagination: { page: 0, perPage: 50 },
});
```

See the [Storage overview](/docs/v1/server-db/storage) for more information about storage domains and composite storage.


## Key Structure

Cloudflare KV storage uses a two-level structure: **KV namespaces** (one per table) and **keys** within those namespaces.

**Key Format:**
Keys follow the pattern: `{prefix}{tableName}:{id}` or `{prefix}{tableName}:{threadId}:{messageId}` for messages, where the prefix includes a `:` separator.

**Examples:**
- Threads: `dev_:mastra_threads:thread_123` (with `keyPrefix: "dev_"`)
- Messages: `dev_:mastra_messages:thread_123:msg_456`
- Workflows: `dev_:mastra_workflow_snapshot:myWorkflow:run_123`
- Scores: `dev_:mastra_scorers:score_789`

**Workers Binding API:**
- Each table maps to a separate KV namespace (e.g., `mastra_threads`, `mastra_messages`)
- `keyPrefix` is prepended to all keys within namespaces with a `:` separator
  - Example: With `keyPrefix: "dev_"`, keys become `dev_:mastra_threads:thread_123`
  - Format: `{keyPrefix}:{tableName}:{id}`
- Namespaces are created at deploy time via `wrangler.toml` bindings
- The namespace name itself is the table name (e.g., `mastra_threads`)

**REST API:**
- `namespacePrefix` is used in two ways:
  1. **Namespace names**: Prefixed with `{namespacePrefix}_` (e.g., `dev_mastra_threads`)
  2. **Keys within namespaces**: Prefixed with `{namespacePrefix}:` (e.g., `dev:mastra_threads:thread_123`)
- Namespaces are created automatically if they don't exist
- Note the different separators: `_` for namespace names, `:` for keys