---
title: "Migration: Upgrade to Mastra v1 | Migration Guide"
description: "Learn how to upgrade through breaking changes in pre-v1 versions of Mastra."
---

# Upgrade to Mastra v1

In this guide you'll learn how to upgrade through breaking changes in pre-v1 versions of Mastra. It'll also help you upgrade to Mastra v1.

Use your package manager to update your project's versions. Be sure to update **all** Mastra packages at the same time.

:::info

Versions mentioned in the headings refer to the `@mastra/core` package. If necessary, versions of other Mastra packages are called out in the detailed description.

All Mastra packages have a peer dependency on `@mastra/core` so your package manager can inform you about compatibility.

:::

## Migrate to v1.0.0-beta

### Removed: Memory.rememberMessages() and Renamed: Memory.query() to Memory.recall()

**Breaking Changes:**

1. `Memory.rememberMessages()` method has been removed
2. `Memory.query()` has been renamed to `Memory.recall()`
3. Parameter `vectorMessageSearch` is now `vectorSearchString`

**Why these changes?**

- "Remember" could imply persisting data, not just retrieving, which was confusing
- `query` and `rememberMessages` performed the same function - consolidating to one method simplifies the API
- `recall` better describes the action of retrieving messages from memory
- `vectorSearchString` is more consistent with the rest of the codebase

**Migration:**

If you were using `rememberMessages()`, switch to `recall()`:

```typescript
// Before
const { messages } = await memory.rememberMessages({
  threadId,
  resourceId,
});

// After
const { messages } = await memory.recall({
  threadId,
  resourceId,
});
```

If you were using `query()`, rename it to `recall()`:

```typescript
// Before
const { messages } = await memory.query({
  threadId,
  vectorMessageSearch: "What did we discuss?",
  threadConfig: { semanticRecall: true },
});

// After
const { messages } = await memory.recall({
  threadId,
  vectorSearchString: "What did we discuss?",
  threadConfig: { semanticRecall: true },
});
```

### Changed: Thread Title Generation Location and Default

**Breaking Changes:**

1. `generateTitle` has been moved from `threads.generateTitle` to the top-level of memory options
2. The default value has changed from `true` to `false`
3. Using `threads.generateTitle` will now throw an error

**Why these changes?**

- Simplify the API by moving `generateTitle` to the top level where it logically belongs
- Avoid unexpected LLM API calls and associated costs
- Give developers explicit control over when title generation occurs
- Improve predictability of memory behavior

**Migration:**

If your application uses `threads.generateTitle`, you must update it to use the top-level `generateTitle` option:

```typescript
// Before (v0.22 and earlier)
const agent = new Agent({
  memory: new Memory({
    options: {
      threads: {
        generateTitle: true, // ❌ This will now throw an error
      },
    },
  }),
});

// After (v0.23+)
const agent = new Agent({
  memory: new Memory({
    options: {
      generateTitle: true, // ✅ Now at the top level
    },
  }),
});
```

If your application relied on the old default behavior (automatic title generation), explicitly enable it:

```typescript
// Before (implicit true in v0.22)
const agent = new Agent({
  memory: new Memory({
    // generateTitle was true by default
  }),
});

// After (explicit true in v0.23+)
const agent = new Agent({
  memory: new Memory({
    options: {
      generateTitle: true, // Explicitly enable title generation
    },
  }),
});
```

You can also customize the model and instructions used for title generation:

```typescript
const agent = new Agent({
  memory: new Memory({
    options: {
      generateTitle: {
        model: openai("gpt-4o-mini"),
        instructions:
          "Generate a concise title (max 5 words) that summarizes the conversation",
      },
    },
  }),
});
```

### Changed: Memory Default Settings

The default settings for semantic recall have been optimized based on RAG research:

- **`topK`** increased from `2` to `4` - Retrieves 4 most relevant messages instead of 2
- **`messageRange`** changed from `{before: 2, after: 2}` to `{before: 1, after: 1}` - Includes 1 message before and after each retrieved message instead of 2

**Impact:**

When semantic recall is enabled, you'll now retrieve up to 12 messages total (4 × 3) instead of 10 messages (2 × 5). This provides ~8% better accuracy while only increasing message count by 20%.

**Action Required:**

If you were relying on the previous defaults and want to maintain the old behavior, explicitly set these values:

```typescript
const agent = new Agent({
  memory: {
    semanticRecall: {
      topK: 2,
      messageRange: { before: 2, after: 2 },
    },
  },
});
```

If you're not using semantic recall (it's disabled by default), no changes are needed.

### Removed: Legacy Watch Events (Client SDK)

**Breaking Changes:**

- The `.watch()` method has been removed from the client-js SDK's `Workflow` and `AgentBuilder` classes
- The `/api/workflows/:workflowId/watch` and `/api/agent-builder/:actionId/watch` HTTP endpoints have been removed
- Server-side code using `watch-v2` event types should update to the simplified `watch` API

**Why this change?**

- Simplify the workflow streaming API by consolidating on one implementation
- Remove legacy v1 event system that was superseded by v2
- Improve performance by eliminating duplicate event handling code
- Reduce API surface area and maintenance burden

**Migration:**

If you were using `run.watch()` from `@mastra/client-js`, switch to using `run.stream()`:

```typescript
// Before (v0.22 and earlier)
const workflow = mastraClient.getWorkflow('my-workflow');
const run = await workflow.createRun();

await run.watch((event) => {
  console.log('Step completed:', event);
});

// After (v0.23+)
const workflow = mastraClient.getWorkflow('my-workflow');
const run = await workflow.createRun();

const stream = await run.stream({
  inputData: { /* your input */ }
});

for await (const chunk of stream) {
  console.log('Step completed:', chunk);
}
```

### Changed: Message Format

An internal intermediary format has been removed. Messages now convert directly between `MastraMessageV2` (storage format) and AI SDK v5 `UIMessage`, simplifying the architecture and improving accuracy.

**Action required only if** you have messages stored in the old `MastraMessageV1` format **and** you:

1. **Directly inspect message metadata** - `__originalContent` is no longer present
2. **Rely on exact V1 message shape preservation** - Shape may differ after conversion (content is still preserved)
3. **Have custom message processing logic** - Verify it works with the new direct conversion flow

The storage format (`MastraMessageV2`) and all public APIs remain unchanged.

### Agent class

- Removed `generateVNext()` method. Use `generate()` instead.
- Removed `streamVNext()` method. Use `stream()` instead.
- `agent.llm` → `agent.getLLM()`
- `agent.tools` → `agent.listTools()`
- `agent.instructions` → `agent.getInstructions()`
- `agent.speak()` → `agent.voice.speak()`
- `agent.getSpeakers()` → `agent.voice.getSpeakers()`
- `agent.listen` → `agent.voice.listen()`
- `agent.fetchMemory` → `(await agent.getMemory()).recall()`
- `agent.toStep` → Add agent directly to the step, workflows handle the transformation
- `getDefaultGenerateOptions()` → `getDefaultGenerateOptionsLegacy()`
- `getDefaultStreamOptions()` → `getDefaultStreamOptionsLegacy()`
- `getDefaultVNextStreamOptions()` → `getDefaultOptions()`

#### Output Options

- Removed deprecated `output` field from `generate()`/`stream()` options. Use `structuredOutput.schema` instead:

```typescript
// Before
const result = await agent.generate(messages, {
  output: z.object({
    answer: z.string(),
  }),
});

// After
const result = await agent.generate(messages, {
  structuredOutput: {
    schema: z.object({
      answer: z.string(),
    }),
  },
});
```

#### Abort Signal

- Removed `modelSettings.abortSignal`. Use the top-level `abortSignal` option instead:

```typescript
// Before
const result = await agent.stream(messages, {
  modelSettings: {
    abortSignal: controller.signal,
    temperature: 0.7,
  },
});

// After
const result = await agent.stream(messages, {
  abortSignal: controller.signal,
  modelSettings: {
    temperature: 0.7,
  },
});
```

#### Tool execute signature

**Breaking Change:**

The tool `execute` function signature has been updated to use separate `input` and `context` parameters instead of a single destructured object.

```typescript
// Before
export const weatherTool = createTool({
  id: "weather-tool",
  execute: async ({ context }) => {
    return getWeather(context.location);
  },
});

// After
export const weatherTool = createTool({
  id: "weather-tool",
  execute: async (inputData) => {
    return getWeather(inputData.location);
  },
});
```

**Accessing execution context:**

Context properties like `mastra`, `requestContext`, `agent`, `workflow`, and `mcp` are now passed as the second parameter:

```typescript
// Before
export const weatherTool = createTool({
  id: "weather-tool",
  execute: async ({ context, requestContext, mastra }) => {
    const userTier = requestContext.get("userTier");
    const location = context.location;
    return getWeather(location, userTier);
  },
});

// After
export const weatherTool = createTool({
  id: "weather-tool",
  execute: async (inputData, context) => {
    const userTier = context?.requestContext?.get("userTier");
    return getWeather(inputData.location, userTier);
  },
});
```

**Agent-specific context:**

Agent-specific properties like `toolCallId`, `messages`, `suspend`, and `resumeData` are nested under `context.agent`:

```typescript
// After
export const suspendableTool = createTool({
  id: "suspendable-tool",
  suspendSchema: z.object({
    message: z.string(),
  }),
  resumeSchema: z.object({
    approval: z.boolean(),
  }),
  execute: async (inputData, context) => {
    if (!context?.agent?.resumeData) {
      return await context?.agent?.suspend({
        message: "Waiting for approval",
      });
    }

    if (context.agent.resumeData.approval) {
      return { success: true };
    }
  },
});
```

**Workflow-specific context:**

Workflow-specific properties like `workflowId`, `runId`, `state`, and `setState` are nested under `context.workflow`:

```typescript
// After
export const workflowTool = createTool({
  id: "workflow-tool",
  execute: async (inputData, context) => {
    const currentState = context?.workflow?.state;
    context?.workflow?.setState({ step: "completed" });
    return { result: "done" };
  },
});
```

**MCP tools:**

MCP-specific properties `elicitation` and `extra` are nested under `context.mcp`:

```typescript
export const accountBalance = createTool({
  id: "account-balance",
  description: "Fetches the current account balance for a given account",
  inputSchema: z.object({
    accountId: z.string(),
  }),
  outputSchema: z.object({
    balance: z.number(),
  }),
  execute: async (inputData, context) => {
    if (context?.mcp) {
      await checkAuth(context.mcp.extra.authInfo);

      const result = await context.mcp.elicitation.sendRequest({
        message: `Is it ok to fetch the account balance for account ${inputData.accountId}?`,
        requestedSchema: {
          type: "object",
          properties: {
            confirm: { type: "boolean" },
          },
          required: ["confirm"],
        },
      });

      if (result.action === "accept") {
        return {
          balance: getAccountBalance(inputData.accountId),
        };
      }
    }
  },
});
```

#### Tool output validation

Tools with an `outputSchema` now validate their return values. Previously, `outputSchema` was only used for type inference - the output was never validated at runtime.

If your tool returns data that doesn't match its `outputSchema`, it will now return a `ValidationError` instead of the invalid data.

**Fix the output to match the schema:**

```typescript
// Before - missing 'email' field would silently pass through
const getUserTool = createTool({
  id: "get-user",
  outputSchema: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(),
  }),
  execute: async (inputData) => {
    return { id: "123", name: "John" }; // Missing email
  },
});

// After - return all required fields
const getUserTool = createTool({
  id: "get-user",
  outputSchema: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(),
  }),
  execute: async (inputData) => {
    return { id: "123", name: "John", email: "john@example.com" };
  },
});
```

When validation fails, the tool returns a `ValidationError`:

```typescript
// Before v1 - invalid output would silently pass through
await getUserTool.execute({});
// { id: "123", name: "John" } - missing email

// After v1 - validation error is returned
await getUserTool.execute({});
// {
//   error: true,
//   message: "Tool output validation failed for get-user. The tool returned invalid output:\n- email: Required\n\nReturned output: {...}",
//   validationErrors: { ... }
// }
```

**Check for validation errors using type guards:**

```typescript
const result = await getUserTool.execute({});

// Type-safe check for validation errors
if ('error' in result && result.error) {
  console.error('Validation failed:', result.message);
  console.error('Details:', result.validationErrors);
  return;
}

// TypeScript knows result is valid here
console.log(result.id, result.name, result.email);
```

Alternatively, update the `outputSchema` to match your actual output, or remove `outputSchema` entirely if you don't need validation.

#### Input processors

- Removed the `@mastra/core/agent/input-processors` exports. They can found at `@mastra/core/processors` now.
- `InputProcessor` type removed in favour of `Processor` which implements a `processInput` function.

### Removed: `format` Parameter from `agent.stream()`

**Breaking Changes:**

The `format` parameter has been removed from `agent.stream()`/`agent.generate()`. AI SDK stream transformations are now handled by the `@mastra/ai-sdk` package.

**Why this change?**

- **Better separation of concerns**: AI SDK-specific formatting logic is now in a dedicated package
- **Improved tree-shaking**: Applications that don't use AI SDK don't bundle conversion code
- **Clearer API**: Stream methods focus on generation, while formatting is handled explicitly
- **Framework flexibility**: Makes it easier to support different UI frameworks without bloating the core

**Migration:**

If you were using `format: "aisdk"` for streaming, update your code to use `toAISdkStream` from `@mastra/ai-sdk`:

```typescript
// Before
const stream = await agent.stream(messages, {
  format: "aisdk", // ❌ No longer supported
});

// After
import { toAISdkStream } from "@mastra/ai-sdk";

const stream = await agent.stream(messages);
const aiSdkStream = toAISdkStream(stream, { from: "agent" }); // ✅ Explicit conversion
```

**Working with AI SDK UI components:**

The `@mastra/ai-sdk` package provides the `chatRoute()` utility for seamless integration with Vercel AI SDK. Instead of manually handling stream conversion, register a chat route in your Mastra server configuration:

```typescript
// src/mastra/index.ts
import { Mastra } from "@mastra/core";
import { chatRoute } from "@mastra/ai-sdk";

export const mastra = new Mastra({
  server: {
    apiRoutes: [
      chatRoute({
        path: "/chat",
        agent: "weatherAgent", // Fixed agent
      }),
      // Or use dynamic agents:
      chatRoute({
        path: "/chat/:agentId", // Dynamic agent ID
      }),
    ],
  },
});
```

Then use the `useChat()` hook in your frontend:

```typescript
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";

const { messages, sendMessage } = useChat({
  transport: new DefaultChatTransport({
    api: "http://localhost:4111/chat/weatherAgent",
  }),
});
```

**Advanced: Manual transformation**

If you need more control over the stream conversion, you can manually transform streams using `toAISdkStream`. See the [Using Vercel AI SDK documentation](/docs/frameworks/agentic-uis/ai-sdk) for details.

**Note:** The `/api/agents/:agentId/stream/ui` HTTP endpoint has also been deprecated. Use the standard `/api/agents/:agentId/stream` endpoint with `@mastra/ai-sdk` transformations instead.


### Changed: `RuntimeContext` renamed to `RequestContext`

The `RuntimeContext` class has been renamed to `RequestContext`, and all parameter names have been updated from `runtimeContext` to `requestContext` across all APIs.

**Why this change?**

- **Clearer naming**: "requestContext" better describes its purpose as request-specific data
- **Consistency**: Aligns with web framework conventions where "request context" is a common pattern
- **Less confusion**: Avoids ambiguity with "runtime" which could refer to execution environment

**Migration:**

Update imports, class instantiation, and parameter names:

```typescript
// Before
import { RuntimeContext } from "@mastra/core/runtime-context"; // ❌

const runtimeContext = new RuntimeContext(); // ❌
runtimeContext.set("userTier", "enterprise");

// After
import { RequestContext } from "@mastra/core/request-context"; // ✅

const requestContext = new RequestContext(); // ✅
requestContext.set("userTier", "enterprise");
```

**Agents:**

```typescript
// Before
await agent.generate(messages, {
  runtimeContext, // ❌
});

// After
await agent.generate(messages, {
  requestContext, // ✅
});
```

**Note**: This also affects workflow steps, dynamic configuration functions (memory, model, etc.), and anywhere else you pass or receive `runtimeContext`/`requestContext` as a parameter. See the "Tool execute signature" section above for the updated tool signature pattern.

### Changed: `@mastra/core` subpath imports

The `@mastra/core` package no longer allows top-level imports except for `Mastra` and `type Config`. You must use subpath imports for all other imports.

Here are some examples of how to migrate your imports:

```typescript
// Before
import { Mastra, type Config } from "@mastra/core"; // ✅
import { Agent } from "@mastra/core"; // ❌
import { createTool } from "@mastra/core"; // ❌
import { createStep } from "@mastra/core"; // ❌

// After
import { Mastra, type Config } from "@mastra/core"; // ✅
import { Agent } from "@mastra/core/agent"; // ✅
import { createTool } from "@mastra/core/tools"; // ✅
import { createStep } from "@mastra/core/workflows"; // ✅
```

Read the [package README](https://github.com/mastra-ai/mastra/blob/main/packages/core/README.md) or the [package.json](https://github.com/mastra-ai/mastra/blob/main/packages/core/package.json) for a full list of available subpath imports.

## Migrate to v0.22

### Changed: Memory Scope Defaults

`@mastra/memory` - `0.16.0`
`@mastra/core` - `0.22.0`

The default memory scope for both **working memory** and **semantic recall** has changed from `'thread'` to `'resource'`.

**Before:**

- Working memory defaulted to `scope: 'thread'` (isolated per conversation)
- Semantic recall defaulted to `scope: 'thread'` (search within current conversation only)

**After:**

- Working memory defaults to `scope: 'resource'` (persists across all user conversations)
- Semantic recall defaults to `scope: 'resource'` (search across all user conversations)

**Why this change?**

1. **Better user experience**: Most applications want to remember user information across conversations, not just within a single thread
2. **More intuitive default**: Users expect AI agents to "remember" them, which requires resource-scoped memory
3. **Alignment with common use cases**: The majority of production applications use resource-scoped memory

**Migration:**

If you want to maintain the old behavior where memory is isolated per conversation thread, explicitly set `scope: 'thread'` in your memory configuration:

```typescript showLineNumbers copy
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";

const memory = new Memory({
  storage: new LibSQLStore({ url: "file:local.db" }),
  options: {
    workingMemory: {
      enabled: true,
      scope: "thread", // Explicitly set to thread-scoped
      template: `# User Profile
- **Name**:
- **Interests**:
`,
    },
    semanticRecall: {
      topK: 3,
      scope: "thread", // Explicitly set to thread-scoped
    },
  },
});
```

If you want to adopt the new default behavior, you can optionally remove explicit `scope: 'resource'` declarations as they're now redundant.

### Changed: Message Format Unification

**Breaking Changes:**

1. `MastraMessageV2` type renamed to `MastraDBMessage`
2. `format` parameter removed from all get methods, `MastraDBMessage` is always the returned format, which can then be converted as needed via helper utils in `@mastra/ai-sdk`
3. MessageList `.v2()` methods renamed to `.db()`
4. AI SDK format conversion moved to `@mastra/ai-sdk/ui`

**Why these changes?**

- Provide a consistent and predictable API across all memory methods
- Clarify the purpose of message types with better naming
- Simplify the API by removing unnecessary format parameters
- Enable better tree-shaking by separating UI conversion utilities

**Migration:**

#### 1. Update Type Imports

Replace all instances of `MastraMessageV2` with `MastraDBMessage`:

```typescript
// Before
import { MastraMessageV2 } from "@mastra/core";
function yourCustomFunction(input: MastraMessageV2) {}
// After
import { MastraDBMessage } from "@mastra/core";
function yourCustomFunction(input: MastraDBMessage) {}
```

#### 2. Update Memory Method Return Types

The `recall` method (previously `rememberMessages`) now returns an object wrapper for consistency between all methods:

```typescript
// Before
const messages = await memory.rememberMessages({ threadId, resourceId });

// After
const { messages } = await memory.recall({ threadId, resourceId });
```

#### 4. Update AI SDK Format Conversion

Message format conversion for AI SDK compatibility has moved to dedicated utility functions:

```typescript
// Before
import { convertMessages } from '@mastra/core';
const uiMessages = convertMessages(messages).to('AI.V5');

// After
import { toAISdkV5Messages, toAISdkV4Messages } from '@mastra/ai-sdk/ui';

// For AI SDK v5
const v5Messages = toAISdkV5Messages(messages);

// For AI SDK v4
const v4Messages = toAISdkV4Messages(messages);
```

#### 5. Remove Format Parameters

The `format` parameter has been removed from all get methods. `MastraDBMessage` is now the default return format everywhere:

```typescript
// Before
const messages = await memory.getMessages({ threadId, format: "v2" });
const uiMessages = await memory.getMessages({ threadId, format: "ui" });

// After
const result = await memory.recall({ threadId });
const messages = result.messages; // Always MastraDBMessage[]

// Use conversion functions for AI SDK formats
import { toAISdkV5Messages } from "@mastra/ai-sdk/ui";
const uiMessages = toAISdkV5Messages(messages);
```

### Removed: MCP Classes

`@mastra/mcp` - `0.14.0`

- Removed `MastraMCPClient` class. Use [`MCPClient`](/reference/tools/mcp-client) class instead.
- Removed `MCPConfigurationOptions` type. Use [`MCPClientOptions`](/reference/tools/mcp-client#mcpclientoptions) type instead. The API is identical.
- Removed `MCPConfiguration` class. Use [`MCPClient`](/reference/tools/mcp-client) class instead.

### Removed: CLI flags & commands

`mastra` - `0.17.0`

- Removed the `mastra deploy` CLI command. Use the deploy instructions of your individual platform.
- Removed `--env` flag from `mastra build` command. To start the build output with a custom env use `mastra start --env <env>` instead.
- Remove `--port` flag from `mastra dev`. Use `server.port` on the `new Mastra()` class instead.

## Migrate to v0.21

No changes needed.

## Migrate to v0.20

- [VNext to Standard APIs](./vnext-to-standard-apis)
- [AgentNetwork to .network()](./agentnetwork)
