---
title: "Storage | Memory"
description: Configure storage for Mastra's memory system to persist conversations, workflows, and traces.
packages:
  - "@mastra/core"
  - "@mastra/libsql"
  - "@mastra/memory"
  - "@mastra/pg"
  - "@mastra/pinecone"
---

# Storage

For agents to remember previous conversations, Mastra needs a database. Configure a storage adapter by choosing one of the [supported providers](#supported-providers) and passing it to your Mastra instance.

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  storage: new LibSQLStore({
    id: 'mastra-storage',
    url: "file:./mastra.db",
  }),
});
```

Mastra automatically creates the necessary tables on first interaction. See the [core schema](/reference/storage/overview#core-schema) for details on what gets created, including tables for messages, threads, resources, workflows, traces, and evaluation datasets.

## Supported providers

Each provider page includes installation instructions, configuration parameters, and usage examples:

- [libSQL](/reference/storage/libsql)
- [PostgreSQL](/reference/storage/postgresql)
- [MongoDB](/reference/storage/mongodb)
- [Upstash](/reference/storage/upstash)
- [Cloudflare D1](/reference/storage/cloudflare-d1)
- [Cloudflare Durable Objects](/reference/storage/cloudflare)
- [Convex](/reference/storage/convex)
- [DynamoDB](/reference/storage/dynamodb)
- [LanceDB](/reference/storage/lance)
- [Microsoft SQL Server](/reference/storage/mssql)

:::tip
libSQL is the easiest way to get started because it doesn’t require running a separate database server
:::

## Configuration scope

Storage can be configured at the instance level (shared by all agents) or at the agent level (isolated to a specific agent).

### Instance-level storage

Add storage to your Mastra instance so all agents, workflows, observability traces and scores share the same memory provider:

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { PostgresStore } from "@mastra/pg";

export const mastra = new Mastra({
  storage: new PostgresStore({
    id: 'mastra-storage',
    connectionString: process.env.DATABASE_URL,
  }),
});

// Both agents inherit storage from the Mastra instance above
const agent1 = new Agent({ id: "agent-1", memory: new Memory() });
const agent2 = new Agent({ id: "agent-2", memory: new Memory() });
```

This is useful when all primitives share the same storage backend and have similar performance, scaling, and operational requirements.

#### Composite storage

[Composite storage](/reference/storage/composite) is an alternative way to configure instance-level storage. Use `MastraCompositeStore` to set the `memory` domain (and any other [domains](/reference/storage/composite#storage-domains) you need) to different storage providers.

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { MastraCompositeStore } from "@mastra/core/storage";
import { MemoryLibSQL } from "@mastra/libsql";
import { WorkflowsPG } from "@mastra/pg";
import { ObservabilityStorageClickhouse } from "@mastra/clickhouse";

export const mastra = new Mastra({
  storage: new MastraCompositeStore({
    id: "composite",
    domains: {
      // highlight-next-line
      memory: new MemoryLibSQL({ url: "file:./memory.db" }),
      workflows: new WorkflowsPG({ connectionString: process.env.DATABASE_URL }),
      observability: new ObservabilityStorageClickhouse({
        url: process.env.CLICKHOUSE_URL,
        username: process.env.CLICKHOUSE_USERNAME,
        password: process.env.CLICKHOUSE_PASSWORD,
      }),
    },
  }),
});
```

This is useful when different types of data have different performance or operational requirements, such as low-latency storage for memory, durable storage for workflows, and high-throughput storage for observability.

### Agent-level storage

Agent-level storage overrides storage configured at the instance level. Add storage to a specific agent when you need data boundaries or compliance requirements:

```typescript title="src/mastra/agents/your-agent.ts"
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { PostgresStore } from "@mastra/pg";

export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    storage: new PostgresStore({
      id: 'agent-storage',
      connectionString: process.env.AGENT_DATABASE_URL,
    }),
  }),
});
```

:::warning
[Mastra Cloud Store](/docs/mastra-cloud/deployment#using-mastra-cloud-store) does not support agent-level storage. You must use instance-level storage or bring your own database.
:::

## Threads and resources

Mastra organizes conversations using two identifiers: 

- **Thread**: a conversation session containing a sequence of messages.
- **Resource**: the entity that owns the thread - a user, organization, project, or any domain entity in your application.

Both identifiers are required for agents to store information:

```typescript title="src/mastra/agents/my-agent.ts"
const stream = await agent.stream("hello", {
  memory: {
    thread: "conversation-abc-123",
    resource: "user_123",
  },
});
```

:::note
[Studio](/docs/getting-started/studio) automatically generates a thread and resource ID for you. Pass these explicitly when calling `stream()` or `generate()` yourself, as illustrated above.
:::

### Thread title generation

Mastra can automatically generate descriptive thread titles based on the user's first message when `generateTitle` is enabled.

Use this option when implementing a ChatGPT-style chat interface to render a title alongside each thread in the conversation list (for example, in a sidebar) derived from the thread’s initial user message.

```typescript title="src/mastra/agents/my-agent.ts"
export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    options: {
      generateTitle: true,
    },
  }),
});
```

Title generation runs asynchronously after the agent responds and does not affect response time.

To optimize cost or behavior, provide a smaller [`model`](/models) and custom `instructions`:

```typescript title="src/mastra/agents/my-agent.ts"
export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    options: {
      generateTitle: {
        model: "openai/gpt-4o-mini",
        instructions: "Generate a 1 word title",
      },
    },
  }),
});
```

## Semantic recall

[Semantic recall](/docs/memory/semantic-recall) uses vector embeddings to retrieve relevant past messages based on meaning rather than recency. Unlike standard storage providers, it relies on a vector database for similarity search, which you can configure at the instance or agent level.

The vector database doesn't have to be the same as your storage provider. For example, you might use PostgreSQL for storage and Pinecone for vectors:

```typescript title="src/mastra/index.ts"
import { Mastra } from "@mastra/core";
import { PostgresStore } from "@mastra/pg";

export const mastra = new Mastra({
  storage: new PostgresStore({
    id: 'mastra-storage',
    connectionString: process.env.DATABASE_URL,
  }),
});
```

```typescript title="src/mastra/agents/your-agent.ts"
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { PineconeVector } from "@mastra/pinecone";

export const agent = new Agent({
  id: "agent",
  memory: new Memory({
    vector: new PineconeVector({
      id: 'agent-vector',
      apiKey: process.env.PINECONE_API_KEY,
    }),
    options: {
      semanticRecall: {
        topK: 5,
        messageRange: 2,
      },
    },
  }),
});
```

For the full list of supported vector providers, see [Semantic Recall storage configuration](/docs/memory/semantic-recall#storage-configuration).

