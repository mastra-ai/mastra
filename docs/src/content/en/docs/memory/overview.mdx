---
title: "Memory overview | Memory"
description: "Learn how Mastra's memory system works with working memory, message history, and semantic recall."
---

# Memory Overview

Memory is the most essential type of context engineering for AI agents. It gives your agent coherence across interactions and allows it to improve over time by retaining relevant information from past conversations.

Mastra requires a [storage provider](./storage) to persist memory and supports three types:

- [**Message history**](./message-history) captures recent messages from the current conversation, providing short-term continuity and maintaining dialogue flow.

- [**Working memory**](./working-memory) stores persistent user-specific details such as names, preferences, goals, and other structured data. This is implemented as a block of Markdown text that the agent can update over time (or as a Zod schema).

- [**Semantic recall**](./semantic-recall) retrieves older messages from past conversations based on semantic relevance. Matches are retrieved using vector search and can include surrounding context for better comprehension.

Mastra combines all memory types into a single context window. If the total exceeds the model's token limit, use [memory processors](./memory-processors) to trim or filter messages before sending them to the model.

## Getting started

First install the required dependencies:

```bash copy
npm install @mastra/core@beta @mastra/memory@beta @mastra/libsql@beta
```

Add a storage adapter to the main Mastra instance:

```typescript title="src/mastra/index.ts" showLineNumbers copy
import { Mastra } from "@mastra/core";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  storage: new LibSQLStore({
    id: 'mastra-storage',
    url: ":memory:",
  }),
});
```

Enable memory by passing a `Memory` instance to the agent's `memory` parameter:

```typescript title="src/mastra/agents/test-agent.ts" showLineNumbers copy
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";

export const testAgent = new Agent({
  id: "test-agent",
  memory: new Memory(),
});
```

:::note
Message history is enabled by default with the last 10 messages. This is the simplest complete example—your agent will now remember conversations.
:::

The memory instance has options you can configure for working memory, message history, and semantic recall.


## Storage

For memory to persist across application restarts, you need to configure a storage adapter. Mastra supports multiple database providers including PostgreSQL, MongoDB, LibSQL, and more.

Storage can be configured at the instance level (shared across all agents) or at the agent level (dedicated per agent). You can also use different databases for storage and vector operations.

See the [Storage](./storage) documentation for configuration options, supported providers, and examples.

## Debugging memory

When tracing is enabled, you can inspect exactly which messages the agent uses for context in each request. The trace output shows all memory included in the agent's context window—both recent message history and messages recalled via semantic recall.

This visibility helps you understand why an agent made specific decisions and verify that memory retrieval is working as expected.

For more details on enabling and configuring tracing, see [Tracing](../observability/tracing/overview).

### Inspecting stored data

When using `LibSQLStore` for local development, you can inspect stored memory directly using the [SQLite Viewer](https://marketplace.visualstudio.com/items?itemName=qwtel.sqlite-viewer) extension in your editor (VS Code, Cursor, etc.).

![SQLite Viewer](/img/memory/memory-sqlite-viewer.jpg)

## Next Steps

Now that you understand the core concepts, continue to [semantic recall](./semantic-recall) to learn how to add RAG memory to your Mastra agents.

Alternatively you can visit the [configuration reference](/reference/v1/memory/memory-class) for available options.
