---
title: "MastraStorage | Server & DB"
description: Overview of Mastra's storage system and data persistence capabilities.
---

import PropertiesTable from "@site/src/components/PropertiesTable";
import { SchemaTable } from "@site/src/components/SchemaTable";
import { StorageOverviewImage } from "@site/src/components/StorageOverviewImage";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# MastraStorage

`MastraStorage` organizes data into four **domains**, each handling a specific type of data:

- **`workflows`**: Stores suspended workflow snapshots and execution state
- **`memory`**: Stores conversation threads, messages, and resource-scoped working memory
- **`observability`**: Stores traces and spans for monitoring and debugging
- **`evals`**: Stores evaluation scores and scoring metadata from eval runs

Each domain can be configured independently, allowing you to use different storage backends for different domains if needed.


<br />

<br />

<StorageOverviewImage />

Mastra provides different storage providers, but you can treat them as interchangeable. Eg, you could use libsql in development but postgres in production, and your code will work the same both ways.

## Configuration

Mastra can be configured with a default storage option:

```typescript copy
import { Mastra } from "@mastra/core";
import { LibSQLStore } from "@mastra/libsql";

const mastra = new Mastra({
  storage: new LibSQLStore({
    id: 'mastra-storage',
    url: "file:./mastra.db",
  }),
});
```

If you do not specify any `storage` configuration, Mastra will not persist data across application restarts or deployments. For any
deployment beyond local testing you should provide your own storage
configuration either on `Mastra` or directly within `new Memory()`.

### Composite Storage

You can use a default store for most domains and override specific domains. This is useful when you want to use different storage backends for different domains (e.g., LibSQL for most domains, PostgreSQL for observability). The `default` parameter provides a fallback store for any domains not explicitly specified in `stores`:

```typescript copy
import { Mastra } from "@mastra/core";
import { MastraStorage } from "@mastra/core/storage";
import { LibSQLStore } from "@mastra/libsql";
import { ObservabilityStorage } from "@mastra/pg";
import pgPromise from "pg-promise";

// Default store for all domains
const defaultStore = new LibSQLStore({
  id: "default-storage",
  url: "file:./default.db",
});

// Override observability to use PostgreSQL
const pgp = pgPromise();
const sharedDbClient = pgp({
  connectionString: "postgresql://user:password@localhost:5432/mastra",
});

const observabilityStorage = new ObservabilityStorage({
  client: sharedDbClient,
  schema: "public",
});

const storage = new MastraStorage({
  id: "mastra-storage",
  name: "Mastra Storage",
  default: defaultStore, // Default for workflows, memory, evals
  stores: {
    observability: observabilityStorage, // Override observability
  },
});

const mastra = new Mastra({
  storage,
});
```

Only domains that are explicitly provided or exist in the default store will be initialized. This allows you to mix and match storage backends based on your needs.

## Data Schema

<Tabs>
  <TabItem value="messages" label="Messages">
Stores conversation messages and their metadata. Each message belongs to a thread and contains the actual content along with metadata about the sender role and message type.

<SchemaTable
  columns={[
    {
      name: "id",
      type: "uuidv4",
      description:
        "Unique identifier for the message (format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)",
      constraints: [{ type: "primaryKey" }, { type: "nullable", value: false }],
    },
    {
      name: "thread_id",
      type: "uuidv4",
      description: "Parent thread reference",
      constraints: [
        { type: "foreignKey", value: "threads.id" },
        { type: "nullable", value: false },
      ],
    },
    {
      name: "resourceId",
      type: "uuidv4",
      description: "ID of the resource that owns this message",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "content",
      type: "text",
      description:
        "JSON of the message content in V2 format. Example: `{ format: 2, parts: [...] }`",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "role",
      type: "text",
      description: "Enum of `user | assistant`",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "createdAt",
      type: "timestamp",
      description: "Used for thread message ordering",
      constraints: [{ type: "nullable", value: false }],
    },
  ]}
/>
<br />
The message `content` column contains a JSON object conforming to the `MastraMessageContentV2` type, which is designed to align closely with the AI SDK `UIMessage` message shape.

<SchemaTable
  columns={[
    {
      name: "format",
      type: "integer",
      description: "Message format version (currently 2)",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "parts",
      type: "array (JSON)",
      description:
        "Array of message parts (text, tool-invocation, file, reasoning, etc.). The structure of items in this array varies by `type`.",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "experimental_attachments",
      type: "array (JSON)",
      description: "Optional array of file attachments",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "content",
      type: "text",
      description: "Optional main text content of the message",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "toolInvocations",
      type: "array (JSON)",
      description: "Optional array summarizing tool calls and results",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "reasoning",
      type: "object (JSON)",
      description:
        "Optional information about the reasoning process behind the assistant's response",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "annotations",
      type: "object (JSON)",
      description: "Optional additional metadata or annotations",
      constraints: [{ type: "nullable", value: true }],
    },
  ]}
/>
<br />

<h3>Working with Messages</h3>

Messages are stored in the `MastraDBMessage` format, which provides a consistent structure across the entire Mastra system:

```typescript copy
// Get messages for a thread with pagination
const memoryStore = await mastra.getStore('memory');
if (!memoryStore) {
  throw new Error('Memory store not configured');
}

const result = await memoryStore.listMessages({
  threadId: "your-thread-id",
  page: 0,
  perPage: 50
});

console.log(result.messages); // MastraDBMessage[]
console.log(result.total); // Total count
console.log(result.hasMore); // Whether more pages exist

const messageIdArr = result.messages.map(message => message.id);

// Get messages by their IDs
const messages = await memoryStore.listMessagesById({ 
  messageIds: messageIdArr 
});

// Convert to AI SDK v5 UIMessage format for UI rendering
import { toAISdkV5Messages } from '@mastra/ai-sdk/ui';
const uiMessages = toAISdkV5Messages(result.messages);
```

</TabItem>

  <TabItem value="threads" label="Threads">
Groups related messages together and associates them with a resource. Contains metadata about the conversation.

<SchemaTable
  columns={[
    {
      name: "id",
      type: "uuidv4",
      description:
        "Unique identifier for the thread (format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)",
      constraints: [{ type: "primaryKey" }, { type: "nullable", value: false }],
    },
    {
      name: "resourceId",
      type: "text",
      description:
        "Primary identifier of the external resource this thread is associated with. Used to group and retrieve related threads.",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "title",
      type: "text",
      description: "Title of the conversation thread",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "metadata",
      type: "text",
      description: "Custom thread metadata as stringified JSON. Example:",
      example: {
        category: "support",
        priority: 1,
      },
    },
    {
      name: "createdAt",
      type: "timestamp",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "updatedAt",
      type: "timestamp",
      description: "Used for thread ordering history",
      constraints: [{ type: "nullable", value: false }],
    },
  ]}
/>
<br />
<h3>Working with Threads</h3>

```typescript copy
const memoryStore = await mastra.getStore('memory');

// Create a new thread
const thread = await memoryStore.createThread({
  resourceId: 'user-123',
  title: 'Support Conversation',
  metadata: { category: 'support', priority: 1 },
});

// Get thread by ID
const retrievedThread = await memoryStore.getThreadById({
  threadId: thread.id,
});

// List threads for a resource
const threads = await memoryStore.listThreadsByResourceId({
  resourceId: 'user-123',
  page: 0,
  perPage: 20,
});

// Update thread
await memoryStore.updateThread({
  id: thread.id,
  title: 'Updated Title',
  metadata: { category: 'support', priority: 2 },
});
```

</TabItem>
  <TabItem value="resources" label="Resources">
Stores user-specific data for resource-scoped working memory. Each resource represents a user or entity, allowing working memory to persist across all conversation threads for that user.

<SchemaTable
  columns={[
    {
      name: "id",
      type: "text",
      description:
        "Resource identifier (user or entity ID) - same as resourceId used in threads and agent calls",
      constraints: [{ type: "primaryKey" }, { type: "nullable", value: false }],
    },
    {
      name: "workingMemory",
      type: "text",
      description:
        "Persistent working memory data as Markdown text. Contains user profile, preferences, and contextual information that persists across conversation threads.",
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "metadata",
      type: "jsonb",
      description: "Additional resource metadata as JSON. Example:",
      example: {
        preferences: { language: "en", timezone: "UTC" },
        tags: ["premium", "beta-user"],
      },
      constraints: [{ type: "nullable", value: true }],
    },
    {
      name: "createdAt",
      type: "timestamp",
      description: "When the resource record was first created",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "updatedAt",
      type: "timestamp",
      description: "When the working memory was last updated",
      constraints: [{ type: "nullable", value: false }],
    },
  ]}
/>
<br />
<h3>Working with Resources</h3>

```typescript copy
const memoryStore = await mastra.getStore('memory');

// Get a resource by ID
const resource = await memoryStore.getResourceById({
  resourceId: 'user-123',
});

// Update resource working memory and metadata
await memoryStore.updateResource({
  resourceId: 'user-123',
  workingMemory: '# User Profile\n\nName: John Doe\nPreferences: English, UTC',
  metadata: {
    preferences: { language: 'en', timezone: 'UTC' },
    tags: ['premium', 'beta-user'],
  },
});

// Update only working memory
await memoryStore.updateResource({
  resourceId: 'user-123',
  workingMemory: '# Updated Profile\n\nName: John Doe\nEmail: john@example.com',
});

// Update only metadata
await memoryStore.updateResource({
  resourceId: 'user-123',
  metadata: {
    preferences: { language: 'en', timezone: 'PST' },
    tags: ['premium', 'beta-user', 'vip'],
  },
});
```

</TabItem>
  <TabItem value="workflows" label="Workflows">
When `suspend` is called on a workflow, its state is saved in the following format. When `resume` is called, that state is rehydrated.

<SchemaTable
  columns={[
    {
      name: "workflow_name",
      type: "text",
      description: "Name of the workflow",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "run_id",
      type: "uuidv4",
      description: "Unique identifier for the workflow execution. Used to track state across suspend/resume cycles (format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "snapshot",
      type: "text",
      description: "Serialized workflow state as JSON. Example:",
      example: {
        value: { currentState: 'running' },
        context: {
          stepResults: {},
          attempts: {},
          triggerData: {}
        },
        activePaths: [],
        runId: '550e8400-e29b-41d4-a716-446655440000',
        timestamp: 1648176000000
      },
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "createdAt",
      type: "timestamp",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "updatedAt",
      type: "timestamp",
      description: "Last modification time, used to track state changes during workflow execution",
      constraints: [{ type: "nullable", value: false }]
    }
  ]}
/>
<br />

<h3>Working with Workflow Snapshots</h3>

```typescript copy
const workflowsStore = await mastra.getStore('workflows');

// Save workflow snapshot (automatically called on suspend)
await workflowsStore.createWorkflowSnapshot({
  workflowId: 'my-workflow',
  runId: 'run-123',
  snapshot: {
    value: { currentState: 'running' },
    context: {
      stepResults: {},
      attempts: {},
      triggerData: {},
    },
    activePaths: [],
    runId: 'run-123',
    timestamp: Date.now(),
  },
});

// Load workflow snapshot (used when resuming)
const snapshot = await workflowsStore.getWorkflowSnapshot({
  workflowId: 'my-workflow',
  runId: 'run-123',
});

// List workflow runs
const runs = await workflowsStore.listWorkflowRuns({
  workflowId: 'my-workflow',
  page: 0,
  perPage: 50,
});
```

  </TabItem>
  <TabItem value="evals" label="Evals">
Stores eval results from running scorers against agent outputs.

<SchemaTable
  columns={[
    {
      name: "input",
      type: "text",
      description: "Input provided to the agent",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "output",
      type: "text",
      description: "Output generated by the agent",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "result",
      type: "jsonb",
      description: "Eval result data that includes score and details. Example:",
      example: {
        score: 0.95,
        details: {
          reason: "Response accurately reflects source material",
          citations: ["page 1", "page 3"]
        }
      },
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "agent_name",
      type: "text",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "metric_name",
      type: "text",
      description: "e.g Faithfulness, Hallucination, etc.",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "instructions",
      type: "text",
      description: "System prompt or instructions for the agent",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "test_info",
      type: "jsonb",
      description: "Additional test metadata and configuration",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "global_run_id",
      type: "uuidv4",
      description: "Groups related evaluation runs (e.g. all unit tests in a CI run)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "run_id",
      type: "uuidv4",
      description: "Unique identifier for the run being evaluated (format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "created_at",
      type: "timestamp",
      constraints: [{ type: "nullable", value: false }]
    }
  ]}
/>
<br />
<h3>Working with Evals</h3>

```typescript copy
const evalsStore = await mastra.getStore('evals');

// Save a score (automatically called by scorer hooks)
await evalsStore.saveScore({
  runId: 'run-123',
  scorerId: 'faithfulness-scorer',
  entityId: 'agent-1',
  entityType: 'AGENT',
  score: 0.95,
  reason: 'Response accurately reflects source material',
  source: 'LIVE',
  input: { question: 'What is...' },
  output: { answer: '...' },
});

// Get score by ID
const score = await evalsStore.getScoreById({ id: 'score-id' });

// List scores by scorer
const scores = await evalsStore.listScoresByScorerId({
  scorerId: 'faithfulness-scorer',
  pagination: { page: 0, perPage: 50 },
});

// List scores by run ID
const runScores = await evalsStore.listScoresByRunId({
  runId: 'run-123',
  pagination: { page: 0, perPage: 50 },
});
```

  </TabItem>
  <TabItem value="traces" label="Spans">
Captures spans for monitoring and debugging. Spans represent individual operations within a trace. The table uses a composite primary key of `traceId` and `spanId`.

<SchemaTable
  columns={[
    {
      name: "traceId",
      type: "text",
      description: "Root trace identifier that groups related spans (part of composite primary key)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "spanId",
      type: "text",
      description: "Unique identifier for this span within the trace (part of composite primary key)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "parentSpanId",
      type: "text",
      description: "ID of the parent span. Null if span is top level",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "name",
      type: "text",
      description: "Hierarchical operation name (e.g. `workflow.myWorkflow.execute`, `http.request`, `database.query`)",
      constraints: [{ type: "nullable", value: false }],
    },
    {
      name: "scope",
      type: "jsonb",
      description: "Mastra package info (e.g. `{\"core-version\": \"0.1.0\"}`)",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "spanType",
      type: "text",
      description: "Type of span (e.g. `WORKFLOW_RUN`, `WORKFLOW_STEP`, `AGENT_RUN`, `AGENT_STEP`, `TOOL_RUN`, `TOOL_STEP`)",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "attributes",
      type: "jsonb",
      description: "User defined key-value pairs that contain span metadata",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "metadata",
      type: "jsonb",
      description: "Additional span metadata",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "links",
      type: "jsonb",
      description: "Links to other related spans",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "input",
      type: "jsonb",
      description: "Input data for the span operation",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "output",
      type: "jsonb",
      description: "Output data from the span operation",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "error",
      type: "jsonb",
      description: "Error information if the span operation failed",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "startedAt",
      type: "timestamp",
      description: "When the span started",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "endedAt",
      type: "timestamp",
      description: "When the span ended",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "createdAt",
      type: "timestamp",
      description: "When the database record was created",
      constraints: [{ type: "nullable", value: false }]
    },
    {
      name: "updatedAt",
      type: "timestamp",
      description: "When the database record was last updated",
      constraints: [{ type: "nullable", value: true }]
    },
    {
      name: "isEvent",
      type: "boolean",
      description: "Whether this span represents an event",
      constraints: [{ type: "nullable", value: false }]
    }
  ]}
/>

<br />

<h3>Working with Observability</h3>

```typescript copy
const observabilityStore = await mastra.getStore('observability');

// Get a trace by ID (returns trace with all spans)
const trace = await observabilityStore.getTrace('trace-123');

// Get spans for a trace
const spans = trace?.spans || [];

// List traces with pagination and filters (returns root spans)
const result = await observabilityStore.listTraces({
  pagination: {
    page: 0,
    perPage: 50,
    dateRange: {
      start: new Date('2024-01-01'),
      end: new Date('2024-01-31'),
    },
  },
  filters: {
    spanType: 'WORKFLOW_RUN',
    entityType: 'workflow',
    entityId: 'my-workflow-id',
  },
});

// Access paginated spans (root spans representing traces)
const rootSpans = result.spans;
const paginationInfo = result.pagination;

// Create a span (typically done automatically by observability system)
await observabilityStore.createSpan({
  traceId: 'trace-123',
  spanId: 'span-123',
  parentSpanId: null, // null if top-level span
  name: 'workflow.execute',
  spanType: 'WORKFLOW_RUN',
  scope: { 'core-version': '0.1.0' },
  attributes: { workflowId: 'my-workflow' },
  metadata: null,
  links: null,
  startedAt: new Date(),
  endedAt: null, // null if span is still active
  input: { workflowId: 'my-workflow' },
  output: null,
  error: null,
  isEvent: false,
});
```

  </TabItem>
</Tabs>

## Storage Providers

Mastra supports the following storage providers:

### SQL Databases

- **[LibSQL Storage](/reference/v1/storage/libsql)** - SQLite storage
- **[PostgreSQL Storage](/reference/v1/storage/postgresql)** - Production-ready relational database
- **[MSSQL Storage](/reference/v1/storage/mssql)** - Microsoft SQL Server for enterprise deployments
- **[Cloudflare D1 Storage](/reference/v1/storage/cloudflare-d1)** - Serverless SQL database for Cloudflare Workers

### NoSQL Databases
- **[MongoDB Storage](/reference/v1/storage/mongodb)** - Document-based storage
- **[DynamoDB Storage](/reference/v1/storage/dynamodb)** - AWS DynamoDB with single-table design

### KV Stores
- **[Upstash Storage](/reference/v1/storage/upstash)** - Redis-based storage for serverless deployments
- **[Cloudflare Storage](/reference/v1/storage/cloudflare)** - Cloudflare KV for globally distributed key-value storage

### Specialized Storage
- **[LanceDB Storage](/reference/v1/storage/lance)** - High-performance storage with built-in vector operations

