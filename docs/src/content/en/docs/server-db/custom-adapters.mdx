---
title: "Custom Adapters | Server & DB"
description: "Create a custom server adapter for frameworks other than Hono or Express."
---

import PropertiesTable from "@site/src/components/PropertiesTable";

# Custom Adapters

If you need to run Mastra with a framework other than Hono or Express, you can create a custom adapter by extending the abstract `MastraServer` class.

## When to create a custom adapter

Create a custom adapter when:

- Your framework isn't Hono or Express (e.g., Fastify, Koa, native Node.js)
- You need custom request/response handling
- You're integrating with a serverless platform that requires specific patterns

For Hono or Express, use the built-in adapters instead:
- [@mastra/hono](/docs/server-db/hono-adapter)
- [@mastra/express](/docs/server-db/express-adapter)

## Abstract class

Extend `MastraServer` from `@mastra/server`:

```typescript copy
import { MastraServer } from '@mastra/server';

export class MyFrameworkServer extends MastraServer<
  MyApp,      // Your framework's app type
  MyRequest,  // Your framework's request type
  MyResponse  // Your framework's response type
> {
  // Implement abstract methods
}
```

## Required methods

You must implement these six abstract methods:

### registerContextMiddleware()

Attach Mastra context to every request. This makes the Mastra instance, request context, tools, and abort signal available to route handlers.

```typescript copy
registerContextMiddleware(): void {
  this.app.use('*', (req, res, next) => {
    // Attach context to your framework's request/response
    res.locals.mastra = this.mastra;
    res.locals.requestContext = new RequestContext();
    res.locals.tools = this.tools;
    res.locals.abortSignal = createAbortSignal(req);
    next();
  });
}
```

**Context to attach:**

| Key | Type | Description |
|-----|------|-------------|
| `mastra` | `Mastra` | The Mastra instance |
| `requestContext` | `RequestContext` | Request-scoped context map |
| `tools` | `Record<string, Tool>` | Available tools |
| `abortSignal` | `AbortSignal` | Request cancellation signal |
| `taskStore` | `InMemoryTaskStore` | A2A task storage (if configured) |

### registerAuthMiddleware()

Register authentication and authorization middleware. Only register if auth is configured.

```typescript copy
registerAuthMiddleware(): void {
  const authConfig = this.mastra.getServer()?.auth;
  if (!authConfig) return;

  // Register authentication (validate token, set user)
  this.app.use('*', async (req, res, next) => {
    const token = extractToken(req);
    const user = await authConfig.authenticateToken?.(token, req);
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    res.locals.user = user;
    next();
  });

  // Register authorization (check permissions)
  this.app.use('*', async (req, res, next) => {
    const allowed = await authConfig.authorize?.(
      req.path,
      req.method,
      res.locals.user,
      res
    );
    if (!allowed) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  });
}
```

### registerRoute()

Register a single route with your framework.

```typescript copy
async registerRoute(
  app: MyApp,
  route: ServerRoute,
  { prefix }: { prefix?: string }
): Promise<void> {
  const path = `${prefix || ''}${route.path}`;
  const method = route.method.toLowerCase();

  app[method](path, async (req, res) => {
    try {
      // 1. Extract parameters
      const params = await this.getParams(route, req);

      // 2. Validate with Zod schemas
      const queryParams = await this.parseQueryParams(route, params.queryParams);
      const body = await this.parseBody(route, params.body);

      // 3. Build handler params
      const handlerParams = {
        ...params.urlParams,
        ...queryParams,
        ...(typeof body === 'object' ? body : {}),
        mastra: this.mastra,
        requestContext: res.locals.requestContext,
        tools: res.locals.tools,
        abortSignal: res.locals.abortSignal,
        taskStore: this.taskStore,
      };

      // 4. Call handler
      const result = await route.handler(handlerParams);

      // 5. Send response
      return this.sendResponse(route, res, result);
    } catch (error) {
      const status = error.status ?? error.details?.status ?? 500;
      return res.status(status).json({ error: error.message });
    }
  });
}
```

### getParams()

Extract URL parameters, query parameters, and request body.

```typescript copy
async getParams(
  route: ServerRoute,
  request: MyRequest
): Promise<{
  urlParams: Record<string, string>;
  queryParams: Record<string, string>;
  body: unknown;
}> {
  return {
    urlParams: request.params,        // From route path (e.g., :agentId)
    queryParams: request.query,       // From URL query string
    body: request.body,               // From request body
  };
}
```

### sendResponse()

Send the response based on the route's response type.

```typescript copy
async sendResponse(
  route: ServerRoute,
  response: MyResponse,
  result: unknown
): Promise<unknown> {
  switch (route.responseType) {
    case 'json':
      return response.json(result);

    case 'stream':
      return this.stream(route, response, result);

    case 'datastream-response':
      // Return AI SDK Response directly
      return result;

    case 'mcp-http':
      // Handle MCP HTTP transport
      return this.handleMcpHttp(response, result);

    case 'mcp-sse':
      // Handle MCP SSE transport
      return this.handleMcpSse(response, result);

    default:
      return response.json(result);
  }
}
```

### stream()

Handle streaming responses for agent generation.

```typescript copy
async stream(
  route: ServerRoute,
  response: MyResponse,
  result: unknown
): Promise<unknown> {
  // Set streaming headers
  response.setHeader('Content-Type', 'text/plain');
  response.setHeader('Transfer-Encoding', 'chunked');

  const reader = result.fullStream.getReader();

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      // Apply redaction if enabled
      const chunk = this.streamOptions.redact
        ? redactChunk(value)
        : value;

      // Format based on stream format
      if (route.streamFormat === 'sse') {
        response.write(`data: ${JSON.stringify(chunk)}\n\n`);
      } else {
        response.write(JSON.stringify(chunk) + '\x1E');
      }
    }

    response.write('data: [DONE]\n\n');
    response.end();
  } catch (error) {
    reader.cancel();
    throw error;
  }
}
```

## Helper methods

The base class provides these helper methods:

| Method | Description |
|--------|-------------|
| `parsePathParams(route, params)` | Validate path params with Zod schema |
| `parseQueryParams(route, params)` | Validate query params with Zod schema |
| `parseBody(route, body)` | Validate body with Zod schema |
| `mergeRequestContext({ paramsRequestContext, bodyRequestContext })` | Merge request context from multiple sources |
| `registerRoutes()` | Register all Mastra routes (calls `registerRoute` for each) |
| `registerOpenAPIRoute(app, config, { prefix })` | Register OpenAPI spec endpoint |

## Constructor

Call `super()` with the required options:

```typescript copy
constructor(options: {
  app: MyApp;
  mastra: Mastra;
  prefix?: string;
  openapiPath?: string;
  bodyLimitOptions?: BodyLimitOptions;
  streamOptions?: StreamOptions;
  customRouteAuthConfig?: Map<string, boolean>;
}) {
  super(options);
}
```

## Full example

```typescript copy title="my-framework-adapter.ts"
import { MastraServer, ServerRoute } from '@mastra/server';
import type { Mastra } from '@mastra/core';

export class MyFrameworkServer extends MastraServer<MyApp, MyRequest, MyResponse> {
  constructor(options: { app: MyApp; mastra: Mastra; prefix?: string }) {
    super(options);
  }

  registerContextMiddleware(): void {
    this.app.use('*', (req, res, next) => {
      res.locals.mastra = this.mastra;
      res.locals.requestContext = this.mergeRequestContext({
        paramsRequestContext: req.query.requestContext,
        bodyRequestContext: req.body?.requestContext,
      });
      res.locals.tools = this.tools ?? {};
      res.locals.abortSignal = createAbortSignal(req);
      next();
    });
  }

  registerAuthMiddleware(): void {
    const authConfig = this.mastra.getServer()?.auth;
    if (!authConfig) return;
    // ... implement auth middleware
  }

  async registerRoute(app: MyApp, route: ServerRoute, { prefix }: { prefix?: string }): Promise<void> {
    // ... implement route registration
  }

  async getParams(route: ServerRoute, request: MyRequest) {
    return {
      urlParams: request.params,
      queryParams: request.query,
      body: request.body,
    };
  }

  async sendResponse(route: ServerRoute, response: MyResponse, result: unknown) {
    if (route.responseType === 'stream') {
      return this.stream(route, response, result);
    }
    return response.json(result);
  }

  async stream(route: ServerRoute, response: MyResponse, result: unknown) {
    // ... implement streaming
  }
}
```

## Usage

```typescript copy
import { MyFrameworkServer } from './my-framework-adapter';
import { mastra } from './mastra';

const app = createMyFrameworkApp();
const server = new MyFrameworkServer({ app, mastra });

await server.init();

app.listen(4111);
```

## Related

- [Server Adapters](/docs/server-db/server-adapters) - Overview and shared concepts
- [Hono Adapter](/docs/server-db/hono-adapter) - Reference implementation
- [Express Adapter](/docs/server-db/express-adapter) - Reference implementation
