---
title: "Agent Memory | Agents | Mastra Docs"
description: Learn how to add memory to agents to store conversation history and maintain context across interactions.
---

import { Steps } from "nextra/components";

# Agent Memory

Agents can use memory to store conversation history, recall relevant information, and maintain context across interactions. This enables more natural, stateful conversations throughout a user’s session.

## When to use memory

Use memory when an agent needs to retain information across multiple interactions. This includes recalling user-specific details, facts, or the results of tool calls. Without memory, the agent handles each request in isolation, without awareness of earlier messages or responses.

## Getting started

To enable memory in Mastra, install the `@mastra/memory` package along with a storage provider.

```bash npm2yarn copy
npm install @mastra/memory@latest @mastra/libsql@latest
```

## Storage providers

Memory requires a storage provider to persist conversation history, including user messages and agent responses. For more details on available providers and how storage works in Mastra, see the [Storage](../server-db/storage.mdx) documentation.

## Configuring memory

<Steps>

### Agent memory

Enable memory by creating a `Memory` instance and passing it to the agent’s `memory` option.

```typescript {6-9} filename="src/mastra/agents/memory-agent.ts" showLineNumbers copy
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";

export const memoryAgent = new Agent({
  // ...
  memory: new Memory({
    options: {
      lastMessages: 10
    }
  })
});
```

> See the [Memory Class](../../reference/memory/Memory.mdx) for a full list of configuration options.

### Mastra storage

Add a storage provider to your main Mastra instance to enable memory across all configured agents.

```typescript {6-8} filename="src/mastra/index.ts" showLineNumbers copy
import { Mastra } from "@mastra/core/mastra";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  // ..
  storage: new LibSQLStore({
    url: ":memory:"
  }),
});
```

> See the [LibSQL Storage](../../reference/storage/libsql.mdx) for a full list of configuration options.

</Steps>

Alternatively, add storage directly to an agent’s memory to keep data separate or use different providers per agent.

```typescript {7-10} filename="src/mastra/agents/memory-agent.ts" showLineNumbers copy
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";

export const memoryAgent = new Agent({
  // ...
  memory: new Memory({
    storage: new LibSQLStore({
      url: "file:../../memory-agent.db"
    })
  })
});
```

## Conversation history

Include a `memory` object with both `resource` and `thread` to track conversation history during agent calls.

- `resource`: A stable identifier for the user or entity.
- `thread`: An ID that isolates a specific conversation or session.

These fields tell the agent where to store and retrieve context, enabling persistent, thread-aware memory across a conversation.

```typescript {3-4}
const response = await memoryAgent.generate("Remember my favorite color is blue.", {
  memory: {
    thread: "user-123",
    resource: "test-123"
  }
});
```

To recall information stored in memory, call the agent with the same `resource` and `thread` values used in the original conversation.

```typescript {3-4}
const response = await memoryAgent.generate("What's my favorite color?", {
  memory: {
    thread: "user-123",
    resource: "test-123"
  }
});
```

To learn more about memory see the [Memory](../memory/overview.mdx) documentation.

## Using `RuntimeContext`

Use [RuntimeContext](../server-db/runtime-context.mdx) to access request-specific values. This lets you conditionally select different memory or storage configurations based on the context of the request.

```typescript filename="src/mastra/agents/memory-agent.ts" showLineNumbers
export type UserTier = {
  "user-tier": "enterprise" | "pro";
};

const premiumMemory = new Memory({
 // ...
});

const standardMemory = new Memory({
  // ...
});

export const memoryAgent = new Agent({
  // ...
  memory: ({ runtimeContext }) => {
    const userTier = runtimeContext.get("user-tier") as UserTier["user-tier"];

    return userTier === "enterprise"
      ? premiumMemory
      : standardMemory;
  }
});
```

## Related

- [Working Memory](../memory/working-memory.mdx)
- [Semantic Recall](../memory/semantic-recall.mdx)
- [Threads and Resources](../memory/threads-and-resources.mdx)
- [Runtime Context](../server-db/runtime-context.mdx)
