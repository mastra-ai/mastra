---
title: "Agent Memory | Agents | Mastra Docs"
description: Learn how to add memory to agents to store conversation history and maintain context across interactions.
---

import { Steps } from "nextra/components";

## Agent memory

Agents use memory to maintain context across interactions. LLMs are stateless and don't retain information between calls, so agents need memory to track conversation history and recall relevant information.

Mastra agents can be configured to store conversation history, with optional [working memory](../memory/working-memory) to maintain recent context or [semantic recall](../memory/semantic-recall) to retrieve past messages based on meaning.

## When to use memory

Use memory when your agent needs to maintain multi-turn conversations that reference prior exchanges, recall user preferences or facts from earlier in a session, or build context over time within a conversation thread. Skip memory for single-turn requests where each interaction is independent.

## Setting up memory

To enable memory in Mastra, install the `@mastra/memory` package along with a storage provider.

```bash npm2yarn copy
npm install @mastra/memory@latest @mastra/libsql@latest
```

## Storage providers

Memory requires a storage provider to persist conversation history, including user messages and agent responses. For more details on available providers and how storage works in Mastra, see the [Storage](../server-db/storage.mdx) documentation.

## Configuring memory

<Steps>

### Agent memory

Enable memory by creating a `Memory` instance and passing it to the agent’s `memory` option.

```typescript {6-9} filename="src/mastra/agents/memory-agent.ts" showLineNumbers copy
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";

export const memoryAgent = new Agent({
  // ...
  memory: new Memory({
    options: {
      lastMessages: 20
    }
  })
});
```

> See the [Memory Class](../../reference/memory/Memory.mdx) for a full list of configuration options.

### Mastra storage

Add a storage provider to your main Mastra instance to enable memory across all configured agents.

```typescript {6-8} filename="src/mastra/index.ts" showLineNumbers copy
import { Mastra } from "@mastra/core/mastra";
import { LibSQLStore } from "@mastra/libsql";

export const mastra = new Mastra({
  // ..
  storage: new LibSQLStore({
    url: ":memory:"
  }),
});
```

> See the [LibSQL Storage](../../reference/storage/libsql.mdx) for a full list of configuration options.

</Steps>

Alternatively, add storage directly to an agent’s memory to keep data separate or use different providers per agent.

```typescript {7-10} filename="src/mastra/agents/memory-agent.ts" showLineNumbers copy
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";

export const memoryAgent = new Agent({
  // ...
  memory: new Memory({
    storage: new LibSQLStore({
      url: ":memory:"
    })
  })
});
```

## Conversation history

Include a `memory` object with both `resource` and `thread` to track conversation history during agent calls.

- `resource`: A stable identifier for the user or entity.
- `thread`: An ID that isolates a specific conversation or session.

These fields tell the agent where to store and retrieve context, enabling persistent, thread-aware memory across a conversation.

```typescript {3-4}
const response = await memoryAgent.generate("Remember my favorite color is blue.", {
  memory: {
    thread: "user-123",
    resource: "test-123"
  }
});
```

To recall information stored in memory, call the agent with the same `resource` and `thread` values used in the original conversation.

```typescript {3-4}
const response = await memoryAgent.generate("What's my favorite color?", {
  memory: {
    thread: "user-123",
    resource: "test-123"
  }
});
```

To learn more about memory see the [Memory](../memory/overview.mdx) documentation.

## Using `RuntimeContext`

Use [RuntimeContext](../server-db/runtime-context.mdx) to access request-specific values. This lets you conditionally select different memory or storage configurations based on the context of the request.

```typescript filename="src/mastra/agents/memory-agent.ts" showLineNumbers
export type UserTier = {
  "user-tier": "enterprise" | "pro";
};

const premiumMemory = new Memory({
 // ...
});

const standardMemory = new Memory({
  // ...
});

export const memoryAgent = new Agent({
  // ...
  memory: ({ runtimeContext }) => {
    const userTier = runtimeContext.get("user-tier") as UserTier["user-tier"];

    return userTier === "enterprise"
      ? premiumMemory
      : standardMemory;
  }
});
```

> See [Runtime Context](../server-db/runtime-context.mdx) for more information.

## Related

- [Working Memory](../memory/working-memory.mdx)
- [Semantic Recall](../memory/semantic-recall.mdx)
- [Threads and Resources](../memory/threads-and-resources.mdx)
- [Runtime Context](../server-db/runtime-context.mdx)
