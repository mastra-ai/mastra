---
title: "Structured Output | Agents"
description: "Learn how to generate structured data from agents using schemas and validation."
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Structured Output

Structured output lets an agent return an object that matches the shape defined by a schema instead of returning text. The schema tells the model what fields to produce, and the model ensures the final result fits that shape.

## When to use structured output

Use structured output when you need an agent to return a data object rather than text. Having well defined fields can make it simpler to pull out the values you need for API calls, UI rendering, or application logic.

## Defining schemas

Agents can return structured data by defining the expected output with either [Zod](https://zod.dev/) or [JSON Schema](https://json-schema.org/). Zod is recommended because it provides TypeScript type inference and runtime validation, while JSON Schema is useful when you need a language agnostic format.

<Tabs>
  <TabItem value="zod" label="Zod">

Define the `output` shape using [Zod](https://zod.dev/):

```typescript showLineNumbers copy
import { z } from "zod";

const response = await testAgent.generate("Help me plan my day.", {
  structuredOutput: {
    schema: z.array(
      z.object({
        name: z.string(),
        activities: z.array(z.string()),
      }),
    ),
  },
});

console.log(response.object);
```

  </TabItem>
  <TabItem value="json-schema" label="JSON Schema">

You can also use JSON Schema to define your output structure:

```typescript showLineNumbers copy
const response = await testAgent.generate("Help me plan my day.", {
  structuredOutput: {
    schema: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: { type: "string" },
          activities: {
            type: "array",
            items: { type: "string" },
          },
        },
        required: ["name", "activities"],
      },
    },
  },
});

console.log(response.object);
```

  </TabItem>
</Tabs>


> See [.generate()](/reference/v1/agents/generate#structuredoutput) for a full list of configuration options.

### Example output

The `response.object` will contain the structured data as defined by the schema.

```json
[
  {
    "name": "Morning Routine",
    "activities": ["Wake up at 7am", "Exercise", "Shower", "Breakfast"]
  },
  {
    "name": "Work",
    "activities": ["Check emails", "Team meeting", "Lunch break"]
  },
  {
    "name": "Evening",
    "activities": ["Dinner", "Relax", "Read a book", "Sleep by 10pm"]
  }
]
```

## Streaming

Streaming also supports structured output. The final structured object is available on `stream.object` after the stream completes. Text stream chunks are still emitted, but they contain natural language text rather than structured data.

```typescript showLineNumbers copy
import { z } from "zod";

const stream = await testAgent.stream("Help me plan my day.", {
  structuredOutput: {
    schema: z.array(
      z.object({
        name: z.string(),
        activities: z.array(z.string())
      })
    ),
  },
});

for await (const chunk of stream.textStream) {
  process.stdout.write(chunk);
}

console.log(await stream.object)
```

## Structuring agent

For more complex data shapes, using a structuring agent works better. When you provide a `model` to `structuredOutput`, Mastra uses a second agent under the hood to extract structured data from the main agent's natural language response. This makes two LLM calls, one to generate the response and another to turn that response into the structured object, which adds some latency and cost but can improve accuracy for complex schemas.

```typescript showLineNumbers copy
import { z } from "zod";

const response = await testAgent.generate("Analyze the TypeScript programming language.", {
  structuredOutput: {
    schema: z.object({
      overview: z.string(),
      strengths: z.array(z.string()),
      weaknesses: z.array(z.string()),
      useCases: z.array(z.object({
        scenario: z.string(),
        reasoning: z.string(),
      })),
      comparison: z.object({
        similarTo: z.array(z.string()),
        differentiators: z.array(z.string()),
      }),
    }),
    model: "openai/gpt-4o",
  },
});

console.log(response.object);
```

## Response format

By default, Mastra passes the schema to the model provider using the `response_format` API parameter. Most model providers have built-in support for this, which reliably enforces the schema.

If your model provider doesn't support `response_format`, you'll get an error from the API. When this happens, set `jsonPromptInjection: true`. This adds the schema to the system prompt instead, instructing the model to output JSON. This is less reliable than the API parameter approach.

```typescript showLineNumbers copy
import { z } from "zod";

const response = await testAgent.generate("Help me plan my day.", {
  structuredOutput: {
    schema: z.array(
      z.object({
        name: z.string(),
        activities: z.array(z.string()),
      }),
    ),
    jsonPromptInjection: true,
  },
});

console.log(response.object);
```

## Error handling

When schema validation fails, you can control how errors are handled using `errorStrategy`. The default `strict` strategy throws an error, while `warn` logs a warning and continues. The `fallback` strategy returns the values provided using `fallbackValue`.

```typescript showLineNumbers copy
import { z } from "zod";

const response = await testAgent.generate("Tell me about TypeScript.", {
  structuredOutput: {
    schema: z.object({
      summary: z.string(),
      keyFeatures: z.array(z.string())
    }),
    errorStrategy: "fallback",
    fallbackValue: {
      summary: "TypeScript is a typed superset of JavaScript",
      keyFeatures: ["Static typing", "Compiles to JavaScript", "Better tooling"]
    }
  }
});

console.log(response.object);
```

## Related

- [Using Tools](/docs/v1/agents/using-tools)
- [Agent Memory](/docs/v1/agents/agent-memory)
