---
title: "Agent Networks | Agents"
description: Learn how to coordinate multiple agents, workflows, and tools using agent networks for complex, non-deterministic task execution.
packages:
  - "@mastra/core"
  - "@mastra/libsql"
  - "@mastra/memory"
---

# Agent Networks

:::warning[Supervisor Pattern Recommended]

**The supervisor pattern using `agent.stream()` or `agent.generate()` is now the recommended approach for coordinating multiple agents.** It provides the same multi-agent coordination capabilities as `.network()` with significant improvements:

- **Better control** - Iteration hooks, delegation hooks, and completion scoring give you fine-grained control over execution
- **Simpler API** - Uses familiar `stream()` and `generate()` methods instead of a separate `.network()` API
- **More flexible** - Stop execution early, modify delegations, filter context, and provide feedback to guide the agent
- **Type-safe** - Full TypeScript support for all hooks and callbacks
- **Easier debugging** - Monitor progress with `onIterationComplete`, track delegations with `onDelegationStart`/`onDelegationComplete`

See [Supervisor Pattern Comparison](#supervisor-pattern-comparison) below for migration details.

:::

Agent networks in Mastra coordinate multiple agents, workflows, and tools to handle tasks that aren't clearly defined upfront but can be inferred from the user's message or context. A top-level **routing agent** (a Mastra agent with other agents, workflows, and tools configured) uses an LLM to interpret the request and decide which primitives (subagents, workflows, or tools) to call, in what order, and with what data.

## When to use networks

Use networks for complex tasks that require coordination across multiple primitives. Unlike workflows, which follow a predefined sequence, networks rely on LLM reasoning to interpret the request and decide what to run.

## Core principles

Mastra agent networks operate using these principles:

- Memory is required when using `.network()` and is used to store task history and determine when a task is complete.
- Primitives are selected based on their descriptions. Clear, specific descriptions improve routing. For workflows and tools, the input schema helps determine the right inputs at runtime.
- If multiple primitives have overlapping functionality, the agent favors the more specific one, using a combination of schema and descriptions to decide which to run.

## Creating an agent network

An agent network is built around a top-level routing agent that delegates tasks to subagents, workflows, and tools defined in its configuration. Memory is configured on the routing agent using the `memory` option, and `instructions` define the agent's routing behavior.

```typescript {22-23,26,29} title="src/mastra/agents/routing-agent.ts"
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";

import { researchAgent } from "./research-agent";
import { writingAgent } from "./writing-agent";

import { cityWorkflow } from "../workflows/city-workflow";
import { weatherTool } from "../tools/weather-tool";

export const routingAgent = new Agent({
  id: "routing-agent",
  name: "Routing Agent",
  instructions: `
      You are a network of writers and researchers.
      The user will ask you to research a topic.
      Always respond with a complete reportâ€”no bullet points.
      Write in full paragraphs, like a blog post.
      Do not answer with incomplete or uncertain information.`,
  model: "openai/gpt-5.1",
  agents: {
    researchAgent,
    writingAgent,
  },
  workflows: {
    cityWorkflow,
  },
  tools: {
    weatherTool,
  },
  memory: new Memory({
    storage: new LibSQLStore({
      id: 'mastra-storage',
      url: "file:../mastra.db",
    }),
  }),
});
```

### Writing descriptions for network primitives

When configuring a Mastra agent network, each primitive (agent, workflow, or tool) needs a clear description to help the routing agent decide which to use. The routing agent uses each primitive's description and schema to determine what it does and how to use it. Clear descriptions and well-defined input and output schemas improve routing accuracy.

#### Agent descriptions

Each subagent in a network should include a clear `description` that explains what the agent does.

```typescript title="src/mastra/agents/research-agent.ts"
export const researchAgent = new Agent({
  id: "research-agent",
  name: "Research Agent",
  description: `This agent gathers concise research insights in bullet-point form.
    It's designed to extract key facts without generating full
    responses or narrative content.`,
});
```

```typescript title="src/mastra/agents/writing-agent.ts"
export const writingAgent = new Agent({
  id: "writing-agent",
  name: "Writing Agent",
  description: `This agent turns researched material into well-structured
    written content. It produces full-paragraph reports with no bullet points,
    suitable for use in articles, summaries, or blog posts.`,
});
```

#### Workflow descriptions

Workflows in a network should include a `description` to explain their purpose, along with `inputSchema` and `outputSchema` to describe the expected data.

```typescript title="src/mastra/workflows/city-workflow.ts"
export const cityWorkflow = createWorkflow({
  id: "city-workflow",
  description: `This workflow handles city-specific research tasks.
    It first gathers factual information about the city, then synthesizes
    that research into a full written report. Use it when the user input
    includes a city to be researched.`,
  inputSchema: z.object({
    city: z.string(),
  }),
  outputSchema: z.object({
    text: z.string(),
  }),
});
```

#### Tool descriptions

Tools in a network should include a `description` to explain their purpose, along with `inputSchema` and `outputSchema` to describe the expected data.

```typescript title="src/mastra/tools/weather-tool.ts"
export const weatherTool = createTool({
  id: "weather-tool",
  description: ` Retrieves current weather information using the wttr.in API.
    Accepts a city or location name as input and returns a short weather summary.
    Use this tool whenever up-to-date weather data is requested.
  `,
  inputSchema: z.object({
    location: z.string(),
  }),
  outputSchema: z.object({
    weather: z.string(),
  }),
});
```

## Calling agent networks

Call a Mastra agent network using `.network()` with a user message. The method returns a stream of events that you can iterate over to track execution progress and retrieve the final result.

### Agent example

In this example, the network interprets the message and would route the request to both the `researchAgent` and `writingAgent` to generate a complete response.

```typescript
const result = await routingAgent.network(
  "Tell me three cool ways to use Mastra",
);

for await (const chunk of result) {
  console.log(chunk.type);
  if (chunk.type === "network-execution-event-step-finish") {
    console.log(chunk.payload.result);
  }
}
```

#### Agent output

The following `chunk.type` events are emitted during this request:

```text
routing-agent-start
routing-agent-end
agent-execution-start
agent-execution-event-start
agent-execution-event-step-start
agent-execution-event-text-start
agent-execution-event-text-delta
agent-execution-event-text-end
agent-execution-event-step-finish
agent-execution-event-finish
agent-execution-end
network-execution-event-step-finish
```

## Workflow example

In this example, the routing agent recognizes the city name in the message and runs the `cityWorkflow`. The workflow defines steps that call the `researchAgent` to gather facts, then the `writingAgent` to generate the final text.

```typescript
const result = await routingAgent.network(
  "Tell me some historical facts about London",
);

for await (const chunk of result) {
  console.log(chunk.type);
  if (chunk.type === "network-execution-event-step-finish") {
    console.log(chunk.payload.result);
  }
}
```

#### Workflow output

The following `chunk.type` events are emitted during this request:

```text
routing-agent-end
workflow-execution-start
workflow-execution-event-workflow-start
workflow-execution-event-workflow-step-start
workflow-execution-event-workflow-step-result
workflow-execution-event-workflow-finish
workflow-execution-end
routing-agent-start
network-execution-event-step-finish
```

### Tool example

In this example, the routing agent skips the `researchAgent`, `writingAgent`, and `cityWorkflow`, and calls the `weatherTool` directly to complete the task.

```typescript
const result = await routingAgent.network("What's the weather in London?");

for await (const chunk of result) {
  console.log(chunk.type);
  if (chunk.type === "network-execution-event-step-finish") {
    console.log(chunk.payload.result);
  }
}
```

#### Tool output

The following `chunk.type` events are emitted during this request:

```text
routing-agent-start
routing-agent-end
tool-execution-start
tool-execution-end
network-execution-event-step-finish
```

## Structured output

When you need typed, validated results from a network, use the `structuredOutput` option. After the network completes its task, it generates a structured response matching your schema.

```typescript
import { z } from "zod";

const resultSchema = z.object({
  summary: z.string().describe("A brief summary of the findings"),
  recommendations: z.array(z.string()).describe("List of recommendations"),
  confidence: z.number().min(0).max(1).describe("Confidence score"),
});

const stream = await routingAgent.network("Research AI trends", {
  structuredOutput: {
    schema: resultSchema,
  },
});

// Consume the stream
for await (const chunk of stream) {
  if (chunk.type === "network-object") {
    // Partial object during generation
    console.log("Partial:", chunk.payload.object);
  }
  if (chunk.type === "network-object-result") {
    // Final structured object
    console.log("Final:", chunk.payload.object);
  }
}

// Get the typed result
const result = await stream.object;
console.log(result?.summary);
console.log(result?.recommendations);
console.log(result?.confidence);
```

### Streaming partial objects

For real-time updates during structured output generation, use `objectStream`:

```typescript
const stream = await routingAgent.network("Analyze market data", {
  structuredOutput: { schema: resultSchema },
});

// Stream partial objects as they're generated
for await (const partial of stream.objectStream) {
  console.log("Building result:", partial);
}

// Get the final typed result
const final = await stream.object;
```

## Supervisor Pattern Comparison

The supervisor pattern provides a modern, more powerful alternative to `.network()` for multi-agent coordination. Instead of a separate API, it uses the familiar `stream()` and `generate()` methods with enhanced options for controlling delegation.

### Key Improvements

| Feature | `.network()` | Supervisor Pattern (`.stream()` / `.generate()`) |
|---------|--------------|--------------------------------------------------|
| **API** | Separate `.network()` method | Uses existing `stream()` / `generate()` methods |
| **Progress Monitoring** | Limited event streaming | `onIterationComplete` hook with full context |
| **Delegation Control** | No control over delegations | `onDelegationStart` to modify/reject delegations |
| **Error Handling** | Basic error events | `onDelegationComplete` with bail mechanism |
| **Context Filtering** | All context passed to sub-agents | `contextFilter` to control what context is shared |
| **Task Completion** | `completion` with automatic scoring  | `completion` with automatic scoring |
| **Early Stopping** | Not available | Return `{ continue: false }` from iteration hook |
| **Feedback Loop** | Not available | Provide feedback to guide next iteration |
| **TypeScript Support** | Basic types | Full type safety for all hooks and callbacks |

### Migration Example

**Before (using `.network()`):**

```typescript
const routingAgent = new Agent({
  id: "routing-agent",
  name: "Routing Agent",
  instructions: "You are a network of researchers and writers...",
  model: "openai/gpt-5.1",
  agents: { researchAgent, writingAgent },
  workflows: { cityWorkflow },
  tools: { weatherTool },
  memory,
});

// Limited control over execution
const result = await routingAgent.network(
  "Research AI in education"
);

for await (const chunk of result) {
  if (chunk.type === "network-execution-event-step-finish") {
    console.log(chunk.payload.result);
  }
}
```

**After (using supervisor pattern):**

```typescript
// Same agent setup - just use it differently
const supervisorAgent = new Agent({
  id: "supervisor-agent",
  name: "Research Supervisor",
  instructions: "You coordinate research and writing tasks...",
  model: "openai/gpt-5.1",
  agents: { researchAgent, writingAgent },
  workflows: { cityWorkflow },
  tools: { weatherTool },
  memory,
});

// Full control with hooks and completion scoring
const stream = await supervisorAgent.stream(
  "Research AI in education",
  {
    maxSteps: 10,

    // Monitor progress after each iteration
    onIterationComplete: async (context) => {
      console.log(`Iteration ${context.iteration}: ${context.finishReason}`);

      // Provide feedback to guide the agent
      if (!context.text.includes('recommendations')) {
        return {
          continue: true,
          feedback: 'Please include specific recommendations.',
        };
      }

      return { continue: true };
    },

    // Control sub-agent delegations
    delegation: {
      onDelegationStart: async (context) => {
        console.log(`Delegating to: ${context.primitiveId}`);

        // Add extra instructions for specific agents
        if (context.primitiveId === 'research-agent') {
          return {
            proceed: true,
            modifiedPrompt: `${context.prompt}\n\nFocus on 2024-2025 data.`,
          };
        }

        return { proceed: true };
      },

      onDelegationComplete: async (context) => {
        console.log(`Completed: ${context.primitiveId}`);

        // Bail out on errors
        if (context.error) {
          context.bail();
        }
      },

      // Filter what context is passed to sub-agents
      contextFilter: {
        maxMessages: 10,
        includeSystem: false,
        filter: (message) => {
          // Remove sensitive data
          const content = typeof message.content === 'string'
            ? message.content
            : JSON.stringify(message.content);
          return !content.includes('confidential');
        },
      },
    },

    // Automatic completion validation
    completion: {
      scorers: [taskCompleteScorer],
      strategy: 'all',
      onComplete: (result) => {
        console.log('Task complete:', result.complete);
      },
    },
  }
);

// Process the stream
for await (const chunk of stream.textStream) {
  console.log(chunk);
}
```

### When to Migrate

**Migrate now if you:**
- Need better control over sub-agent execution
- Want to monitor and debug multi-agent coordination
- Need to filter context passed to sub-agents
- Prefer type-safe hooks and callbacks

**Migrate as soon as possible:**
`.network()` is deprecated and will be removed in a future release. Existing code will continue to work until then, but no new features will be added to it.

### Migration Checklist

- [ ] Update agent configuration (same structure, no changes needed)
- [ ] Replace `.network()` calls with `.stream()` or `.generate()`
- [ ] Add `maxSteps` option to limit iterations
- [ ] (Optional) Add `onIterationComplete` for progress monitoring
- [ ] (Optional) Add `delegation` hooks for sub-agent control
- [ ] (Optional) Add `completion` scorers for automatic validation
- [ ] (Optional) Add `contextFilter` to control context sharing
- [ ] Update event handling from network events to stream chunks
- [ ] Test thoroughly with your specific use cases

See the [stream() reference](/reference/streaming/agents/stream#supervisor-pattern-with-delegation-and-completion) for complete API documentation.

## Related

- [Agent Memory](./agent-memory)
- [Workflows Overview](../workflows/overview)
- [Request Context](/docs/server/request-context)
- [Supervisor example](https://github.com/mastra-ai/mastra/tree/main/examples/supervisor-agent)
