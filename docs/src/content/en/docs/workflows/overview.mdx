---
title: "Handling Complex LLM Operations | Workflows | Mastra"
description: "Workflows in Mastra help you orchestrate complex sequences of tasks with features like branching, parallel execution, resource suspension, and more."
---

import { Steps, Callout, Tabs } from "nextra/components";

# Workflows overview

Workflows let you define complex sequences of tasks using clear, structured steps. Rather than relying on the reasoning of a single agent, workflows give you full control over how tasks are broken down, how data moves between them, and what gets executed when. This approach provides more control and predictability, making workflows ideal for building repeatable systems with reliable results.

![Workflows overview](/image/workflows/workflows-overview.jpg)

## When to use workflows

Use workflows when a task involves multiple steps that must run in a specific order. Theyâ€™re best suited to processes that require structure, branching logic, or transformation of data between steps. Each task is defined as a **step**, giving you precise control over execution order, data flow, and side effects.

> **ðŸ“¹ Watch**:  â†’ An introduction to workflows, and how they compare to agents [YouTube (7 minutes)](https://youtu.be/0jg2g3sNvgw)

## Core principles

Mastra workflows operate using these principles:

- Defining **steps** with `createStep`, specifying input/output schemas and business logic.
- Composing **steps** with `createWorkflow` to define the execution flow.
- Running **workflows** to execute the entire sequence, with built-in support for suspension, resumption, and streaming results.

This structure provides full type safety and runtime validation, ensuring data integrity across the entire workflow.


## Creating a workflow step

Steps are the building blocks of workflows. Create a step using `createStep()` with `inputSchema` and `outputSchema` to define the data it accepts and returns.

```typescript {6,9} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createStep } from "@mastra/core/workflows";

const step1 = createStep({
  id: "step-1",
  inputSchema: z.object({
    message: z.string()
  }),
  outputSchema: z.object({
    formatted: z.string()
  }),
  execute: async ({ inputData }) => {
    const { message } = inputData;
    return {
      formatted: message.toUpperCase()
    };
  }
});
```

> See the [Step Class](../../reference/workflows/step.mdx) for a full list of configuration options.

## Creating a workflow

Create a workflow using `createWorkflow()` with `inputSchema` and `outputSchema` to define the data it accepts and returns. Add steps using `.then()` and complete the workflow with `.commit()`.

```typescript {9,12,15,16} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({...});

export const testWorkflow = createWorkflow({
  id: "test-workflow",
  inputSchema: z.object({
    message: z.string()
  }),
  outputSchema: z.object({
    output: z.string()
  })
})
  .then(step1)
  .commit();

```

> See the [Workflow Class](../../reference/workflows/workflow.mdx) for a full list of configuration options.

### Understanding workflow steps

Each step has an `inputSchema` and `outputSchema` that define the data it receives and returns. For steps to run in sequence, the output of one must match the input of the next.

The workflowâ€™s `outputSchema` can differ from the final stepâ€™s output, allowing you to shape the final result independently.

```typescript {16,17} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
const step1 = createStep({
  //...
  inputSchema: z.object({
    message: z.string()
  }),
  outputSchema: z.object({
    formatted: z.string()
  })
});

const step2 = createStep({
  // ...
  inputSchema: z.object({
    formatted: z.string()
  }),
  outputSchema: z.object({
    emphasized: z.string()
  })
});

export const testWorkflow = createWorkflow({
  // ...
  inputSchema: z.object({
    message: z.string()
  }),
  outputSchema: z.object({
    output: z.string()
  })
})
  .then(step1)
  .then(step2)
  .commit();
```

> Steps can be composed using a number of different methods. See [Control Flow](./control-flow.mdx)  for more information.

### Registering a workflow

Register a workflow using `workflows` in the main Mastra instance:

```typescript {6} filename="src/mastra/index.ts" showLineNumbers copy
import { Mastra } from "@mastra/core/mastra";
import { testWorkflow } from "./workflows/test-workflow";

export const mastra = new Mastra({
  // ...
  workflows: { testWorkflow },
});
```

## Referencing a workflow

You can run workflows from agents, tools, the Mastra Client, or the command line. Get a reference by calling `.getWorkflow()` on your `mastra` or `mastraClient` instance, depending on your setup:

```typescript showLineNumbers copy
const testWorkflow = mastra.getWorkflow("testWorkflow");
```
<Callout type="info">
  <p>
    `mastra.getWorkflow()` is preferred over a direct import, since it provides access to the Mastra instance configuration (logger, telemetry, storage, registered agents, and vector stores).
  </p>
</Callout>

> See [Running Workflows](../../examples/workflows/running-workflows.mdx) for more information.

## Running workflows

Workflows can run in two modes: `.start()` returns the final result after all steps complete, while `.stream()` emits events as each step runs. Use `.start()` for batch jobs or when only the final output matters, and `.stream()` when you want to track progress or trigger actions during execution.

<Tabs items={["Start", "Stream"]}>
  <Tabs.Tab>
Create a workflow run instance using `createRunAsync()`, then call `.start()` with `inputData` matching the workflow's `inputSchema`. The workflow executes all steps and returns the final result.

```typescript showLineNumbers copy
const run = await testWorkflow.createRunAsync();

const result = await run.start({
  inputData: {
    input: "initial data"
  }
});

console.log(result);
```
  </Tabs.Tab>
  <Tabs.Tab>
Create a workflow run instance using `.createRunAsync()`, then call `.stream()` with `inputData` matching the workflow's `inputSchema`. The workflow emits events as each step executes, which you can iterate over to track progress.

```typescript showLineNumbers copy
const run = await testWorkflow.createRunAsync();

const result = await run.stream({
  inputData: {
    input: "initial data"
  }
});

for await (const chunk of result.stream) {
  console.log(chunk);
}
```
  </Tabs.Tab>
</Tabs>

## Using `RuntimeContext`

Use `RuntimeContext` to access request-specific values. This lets you conditionally adjust behavior based on the context of the request.

```typescript filename="src/mastra/workflows/test-workflow.ts" showLineNumbers
export type UserTier = {
  "user-tier": "enterprise" | "pro";
};

const step1 = createStep({
  // ...
  execute: async ({ runtimeContext }) => {
    const userTier = runtimeContext.get("user-tier") as UserTier["user-tier"];

    const maxResults = userTier === "enterprise"
      ? 1000
      : 50;

    return { maxResults };
  }
});
```

## Testing workflows locally

TODO: Replace with sentence about [Playground](../server-db/local-dev-playground.mdx).

## Related

- The [Workflow Guide](../../guides/guide/ai-recruiter.mdx) in the Guides section is a tutorial that covers the main concepts.
- [Parallel Steps workflow example](../../examples/workflows/parallel-steps.mdx)
- [Conditional Branching workflow example](../../examples/workflows/conditional-branching.mdx)
- [Inngest workflow example](../../examples/workflows/inngest-workflow.mdx)
- [Suspend and Resume workflow example](../../examples/workflows/human-in-the-loop.mdx)


## Workflows (Legacy)

For legacy workflow documentation, see [Workflows (Legacy)](../workflows-legacy/overview.mdx).

