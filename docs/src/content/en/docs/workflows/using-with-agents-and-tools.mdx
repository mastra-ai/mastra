---
title: "Using Workflows with Agents and Tools | Workflows | Mastra Docs"
description: "Steps in Mastra workflows provide a structured way to manage operations by defining inputs, outputs, and execution logic."
---

# Agents and Tools

Workflow steps can call agents to leverage LLM reasoning or run custom functions from your codebase. You can either invoke them from within a step's `execute` function or compose them directly as steps using `createStep()`.

## When to use agents and tools

Use agents in workflow steps when you need to solve open-ended tasks that require reasoning or language generation. Use tools when you need to call APIs, query databases, or run custom functions that perform specific operations.

### Calling agents from steps

Call agents inside a step’s `execute` function using `.generate()` or `.stream()`. This allows you to process input and return a result that will be passed to the next step.


```typescript {7,10} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
const step1 = createStep({
  // ...
  execute: async ({ inputData, mastra }) => {
    const { message } = inputData;

    const testAgent = mastra.getAgent("testAgent");
    const response = await testAgent.generate(`Convert this to uppercase: ${message}`);

    return {
      formatted: response.text
    };
  }
});
```

> See [Calling Agents](../../examples/agents/calling-agents.mdx) for more information.

### Using agents as steps

When using an agent as a step, it expects a `prompt` as input. Use `.map()` to transform the workflow input or previous step’s output into this shape before invoking the agent.

![Agent as step](/image/workflows/workflows-agent-tools-agent-step.jpg)

```typescript {1,3,11} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { testAgent } from "../agents/test-agent";

const step1 = createStep(testAgent);

export const testWorkflow = createWorkflow({
  // ...
})
  .map(async ({ inputData }) => {
    const { message } = inputData;
    return {
      prompt: `Convert this to uppercase: ${message}`
    };
  })
  .then(step1)
  .then(step2)
  .commit();
```

> See [Input Data Mapping](./input-data-mapping.mdx) for more information.


### Calling tools from steps

Call tools inside a step’s `execute` function using `.execute()`. This lets you process input and return a result that will be passed to the next step.

```typescript {8-13,16} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { testTool } from "../tools/test-tool";

const step2 = createStep({
  // ...
  execute: async ({ inputData, runtimeContext }) => {
    const { message } = inputData;

    const response = await testTool.execute({
      context: {
        formatted: message
      },
      runtimeContext
    });

    return {
      formatted: response.formatted
    };
  }
});
```

> See [Calling Tools](../../examples/tools/calling-tools.mdx) for more information.

### Using tools as steps

When using a tool as a step, it must be wrapped with `createStep()`. The tool's input must match the shape expected by its schema. Use `.map()` to transform the workflow input or previous step’s output as needed before invoking the tool.

![Tool as step](/image/workflows/workflows-agent-tools-tool-step.jpg)

```typescript {1,3,12} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { testTool } from "../tools/test-tool";

const step2 = createStep(testTool);

export const testWorkflow = createWorkflow({
  // ...
})
  .then(step1)
  .map(async ({ inputData }) => {
    const { formatted } = inputData;
    return {
      text: `Convert this to uppercase: ${formatted}`
    };
  })
  .then(step2)
  .commit();
```

> See [Input Data Mapping](./input-data-mapping.mdx) for more information.

## Related

- [Using Agents](../agents/overview.mdx)
- [Using Tools](../tools-mcp/overview.mdx)
