---
title: "Branching, Merging, Conditions | Workflows | Mastra Docs"
description: "Control flow in Mastra workflows allows you to manage branching, merging, and conditions to construct workflows that meet your logic requirements."
---

# Control Flow

When you build a workflow, you typically break down operations into smaller tasks that can be linked and reused. **Steps** provide a structured way to manage these tasks by defining inputs, outputs, and execution logic.

- If the schemas match, the `outputSchema` from each step is automatically passed to the `inputSchema` of the next step.
- If the schemas don't match, use [Input data mapping](./input-data-mapping.mdx) to transform the `outputSchema` into the expected `inputSchema`.

## Chaining steps with `.then()`

Many workflows involve executing steps one after another in a defined order. This example demonstrates how to use `.then()` to build a simple sequential workflow where the output of one step becomes the input of the next.

![Chaining steps with .then()](/image/workflows/workflows-control-flow-then.jpg)

```typescript filename="src/mastra/workflows/chaining-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";
 
const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});
const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});
 
export const sequentialSteps = createWorkflow({
  id: "sequential-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(step2)
  .commit();
```

## Parallel Execution

Workflows often need to run multiple operations at the same time. These examples demonstrate how to use `.parallel()` to execute steps or workflows concurrently and merge their results.

### Parallel execution using steps

In this example, the workflow runs `step1` and `step2` using `.parallel()`. Each step receives the same input and runs independently. Their outputs are namespaced by step `id` and passed together to `step3`, which combines the results and returns the final value.

```typescript filename="src/mastra/workflows/example-parallel-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step3 = createStep({
  id: "step-3",
  description: "sums values from step-1 and step-2",
  inputSchema: z.object({
    "step-1": z.object({ value: z.number() }),
    "step-2": z.object({ value: z.number() })
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return {
      value: inputData["step-1"].value + inputData["step-2"].value
    };
  }
});

export const parallelSteps = createWorkflow({
  id: "parallel-workflow",
  description: "A workflow that runs steps in parallel plus a final step",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .parallel([step1, step2])
  .then(step3)
  .commit();
```

### Parallel execution using workflows

In this example, the workflow uses `.parallel()` to run two workflowsâ€”`workflow1` and `workflow2` at the same time. Each workflow contains a single step that returns the input value. Their outputs are namespaced by workflow `id` and passed to `step3`, which combines the results and returns the final value.

```typescript filename="src/mastra/workflows/example-parallel-workflows.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step3 = createStep({
  id: "step-3",
  description: "sums values from step-1 and step-2",
  inputSchema: z.object({
    "workflow-1": z.object({ value: z.number() }),
    "workflow-2": z.object({ value: z.number() })
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return {
      value: inputData["workflow-1"].value + inputData["workflow-2"].value
    };
  }
});

export const workflow1 = createWorkflow({
  id: "workflow-1",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .commit();

export const workflow2 = createWorkflow({
  id: "workflow-2",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step2)
  .commit();

export const parallelWorkflows = createWorkflow({
  id: "parallel-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .parallel([workflow1, workflow2])
  .then(step3)
  .commit();
```

> ðŸ“¹ Watch: How to run steps in parallel and optimize your Mastra workflow â†’ [YouTube (3 minutes)](https://youtu.be/GQJxve5Hki4)

## Conditional Branching

Workflows often need to follow different paths based on a condition. Use `.branch()` to create conditional flows using both steps and workflows.

Branch conditions are evaluated sequentially, but steps with matching conditions are executed in parallel.

### Conditional logic using steps

In this example, the workflow uses `.branch()` to execute one of two steps based on a condition. If the input `value` is less than or equal to 10, it runs `lessThanStep` and returns `0`. If the value is greater than 10, it runs `greaterThanStep` and returns `20`. Only the first matching branch is executed, and its output becomes the output of the workflow.

```typescript filename="src/mastra/workflows/example-branch-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const lessThanStep = createStep({
  id: "less-than-step",
  description: "if value is <=10, return 0",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 0
    };
  }
});
const greaterThanStep = createStep({
  id: "greater-than-step",
  description: "if value is >10, return 20",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 20
    };
  }
});

export const branchSteps = createWorkflow({
  id: "branch-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .branch([
    [async ({ inputData: { value } }) => value <= 10, lessThanStep],
    [async ({ inputData: { value } }) => value > 10, greaterThanStep]
  ])
  .commit();
```

### Conditional logic using workflows

In this example, the workflow uses `.branch()` to execute one of two nested workflows based on a condition. If the input `value` is less than or equal to 10, it runs `lessThanWorkflow`, which runs the `lessThanStep`. If the value is greater than 10, it runs `greaterThanWorkflow`, which runs the `greaterThanStep`.

```typescript filename="src/mastra/workflows/example-branch-workflows.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const lessThanStep = createStep({
  id: "less-than-step",
  description: "if value is <=10, return 0",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 0
    };
  }
});
const greaterThanStep = createStep({
  id: "greater-than-step",
  description: "if value is >10, return 20",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 20
    };
  }
});

export const lessThanWorkflow = createWorkflow({
  id: "less-than-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(lessThanStep)
  .commit();

export const greaterThanWorkflow = createWorkflow({
  id: "greater-than-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(greaterThanStep)
  .commit();

export const branchWorkflows = createWorkflow({
  id: "branch-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .branch([
    [async ({ inputData: { value } }) => value <= 10, lessThanWorkflow],
    [async ({ inputData: { value } }) => value > 10, greaterThanWorkflow]
  ])
  .commit();
```

## Looping steps

Workflows support two types of loops. When looping a step, or any step-compatible construct like a nested workflow, the initial `inputData` is sourced from the output of the previous step.

To ensure compatibility, the loopâ€™s initial input must either match the shape of the previous stepâ€™s output, or be explicitly transformed using the `map` function.

- Match the shape of the previous stepâ€™s output, or
- Be explicitly transformed using the `map` function.

### Repeating with `.dowhile()`

Executes step repeatedly while a condition is true.

![Repeating with .dowhile()](/image/workflows/workflows-control-flow-dowhile.jpg)

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const counterStep = createStep({...});

export const testWorkflow = createWorkflow({...})
  .dowhile(counterStep, async ({ inputData: { number } }) => number < 10)
  .commit();
```

### Repeating with `.dountil()`

Executes step repeatedly until a condition becomes true.

![Repeating with .dountil()](/image/workflows/workflows-control-flow-dountil.jpg)

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const counterStep = createStep({...});

export const testWorkflow = createWorkflow({...})
  .dountil(counterStep, async ({ inputData: { number } }) => number > 10)
  .commit();
```

### Loop management

Loop conditions can be implemented in different ways depending on how you want the loop to end. Common patterns include checking values returned in `inputData`, setting a maximum number of iterations, or aborting execution when a limit is reached.

#### Conditional loops

The `inputData` for a loop step is the output of a previous step. Use the values in `inputData` to determine whether the loop should continue or stop.

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const counterStep = createStep({...});

export const testWorkflow = createWorkflow({...})
.dountil(nestedWorkflowStep, async ({ inputData: { userResponse } }) => userResponse === "yes")
.commit();
```

#### Limiting loops

The `iterationCount` tracks how many times the loop step has run. You can use this to limit the number of iterations and prevent infinite loops. Combine it with `inputData` values to stop the loop after a set number of attempts.

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const counterStep = createStep({...});

export const testWorkflow = createWorkflow({...})
.dountil(nestedWorkflowStep, async ({ inputData: { userResponse, iterationCount } }) => userResponse === "yes" || iterationCount >= 10)
.commit();
```

#### Aborting loops

Use `iterationCount` to limit how many times a loop runs. If the count exceeds your threshold, throw an error to fail the step and stop the workflow.

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const counterStep = createStep({...});

export const testWorkflow = createWorkflow({...})
.dountil(nestedWorkflowStep, async ({ inputData: { userResponse, iterationCount } }) => {
  if (iterationCount >= 10) {
    throw new Error("Maximum iterations reached");
  }
  return userResponse === "yes";
})
.commit();
```

### Repeating with `.foreach()`

Some workflows need to perform the same operation on every item in an array. You can use `.foreach()` to iterate over a list of inputs and apply the same step to each one, producing a transformed array as the output.

`.foreach()` sequentially executes the same step for each item from the `inputSchema`.

![Repeating with .foreach()](/image/workflows/workflows-control-flow-foreach.jpg)

In this example, the workflow uses `.foreach()` to apply the `mapStep` step to each string in the input array. For each item, it appends the text `mapStep` to the original value. After all items are processed, `step2` runs to pass the updated array to the output.

```typescript filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";
 
const mapStep = createStep({
  id: "map-step",
  description: "adds mapStep suffix to input value",
  inputSchema: z.string(),
  outputSchema: z.object({
    value: z.string()
  }),
  execute: async ({ inputData }) => {
    return {
      value: `${inputData} mapStep`
    };
  }
});
 
const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.array(
    z.object({
      value: z.string()
    })
  ),
  outputSchema: z.array(
    z.object({
      value: z.string()
    })
  ),
  execute: async ({ inputData }) => {
    return inputData.map(({ value }) => ({
      value: value
    }));
  }
});
 
export const loopingForeach = createWorkflow({
  id: "foreach-workflow",
  inputSchema: z.array(z.string()),
  outputSchema: z.array(
    z.object({
      value: z.string()
    })
  )
})
  .foreach(mapStep)
  .then(step2)
  .commit();
```

#### Setting concurrency limits

Use `concurrency` to execute steps in parallel with a limit on the number of concurrent executions.

```typescript {7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const mapStep = createStep({...})

export const testWorkflow = createWorkflow({...})
  .foreach(mapStep, { concurrency: 2 })
  .commit();
```

## Using a nested workflow

Use a nested workflow as a step by passing it to `.then()`. This runs each of its steps in sequence as part of the parent workflow.

```typescript {4,7} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

export const nestedWorkflow = createWorkflow({...})

export const testWorkflow = createWorkflow({...})
  .then(nestedWorkflow)
  .commit();
```

## Cloning a workflow

Use `cloneWorkflow` to duplicate an existing workflow. This lets you reuse its structure while overriding parameters like `id`.

```typescript {6,10} filename="src/mastra/workflows/test-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep, cloneWorkflow } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({...});
const parentWorkflow = createWorkflow({...})
const clonedWorkflow = cloneWorkflow(parentWorkflow, { id: "cloned-workflow" });

export const testWorkflow = createWorkflow({...})
  .then(step1)
  .then(clonedWorkflow)
  .commit();
```

## Example Run Instance

The following example demonstrates how to start a run with multiple inputs. Each input will pass through the `mapStep` sequentially.

```typescript {6} filename="src/test-workflow.ts" showLineNumbers copy
import { mastra } from "./mastra";

const run = await mastra.getWorkflow("testWorkflow").createRunAsync();

const result = await run.start({
  inputData: [{ number: 10 }, { number: 100 }, { number: 200 }]
});
```

To execute this run from your terminal:

```bash copy
npx tsx src/test-workflow.ts
```
