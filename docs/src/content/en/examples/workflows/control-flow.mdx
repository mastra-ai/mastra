---
title: "Example: Control Flow | Workflows | Mastra Docs"
description: Example of using Mastra to create workflows with loops based on provided conditions.
---

# Control Flow

When you build a workflow, you typically break down operations into smaller tasks that can be linked and reused. Steps provide a structured way to manage these tasks by defining inputs, outputs, and execution logic. Data is passed from one step to the next using these schemas. By default, the output schema of one step must match the input schema of the next.

## Chaining steps with `.then()`

In this example, the workflow runs `step1` and `step2` in sequence, passing the input through each step and returning the final result from `step2`.


```typescript filename="src/mastra/workflows/example-sequential-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});
const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

export const sequentialSteps = createWorkflow({
  id: "sequential-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(step2)
  .commit();
```


## Simultaneous steps with `.parallel()`

In this example, the workflow runs `step1` and `step2` using `.parallel()`. Each step receives the same input and runs independently. Their outputs are namespaced by step `id` and passed together to `step3`, which combines the results and returns the final value.

```typescript filename="src/mastra/workflows/example-parallel-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

const step3 = createStep({
  id: "step-3",
  description: "sums values from step-1 and step-2",
  inputSchema: z.object({
    "step-1": z.object({ value: z.number() }),
    "step-2": z.object({ value: z.number() })
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return {
      value: inputData["step-1"].value + inputData["step-2"].value
    };
  }
});

export const parallelSteps = createWorkflow({
  id: "parallel-workflow",
  description: "A workflow that runs steps in parallel plus a final step",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .parallel([step1, step2])
  .then(step3)
  .commit();
```

## Conditional logic with `.branch()`

In this example, the workflow uses `.branch()` to execute one of two steps based on a condition. If the input `value` is less than or equal to 10, it runs `lessThanStep` and returns `0`. If the value is greater than 10, it runs `greaterThanStep` and returns `20`. Only the first matching branch is executed, and its output becomes the output of the workflow.

```typescript filename="src/mastra/workflows/example-branch-steps.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const lessThanStep = createStep({
  id: "less-than-step",
  description: "if value is <=10, return 0",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 0
    };
  }
});
const greaterThanStep = createStep({
  id: "greater-than-step",
  description: "if value is >10, return 20",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async () => {
    return {
      value: 20
    };
  }
});

export const branchSteps = createWorkflow({
  id: "branch-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .branch([
    [async ({ inputData: { value } }) => value <= 10, lessThanStep],
    [async ({ inputData: { value } }) => value > 10, greaterThanStep]
  ])
  .commit();
```

## Looping steps
...
### Repeating with `.dowhile()`

In this example, the workflow uses `.dowhile()` to increment a value until it reaches 10. It starts with `step1`, which passes the input through unchanged. Then `step2` runs repeatedly, adding 1 to the value every 500ms. The loop continues until the value is no longer less than 10, at which point the final result is returned.

```typescript filename="src/mastra/workflows/example-looping-dowhile.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return {
      value: inputData.value
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "increments the input value by 1",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    await delay(500);
    return {
      value: inputData.value + 1
    };
  }
});

export const loopingDowhile = createWorkflow({
  id: "dowhile-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .dowhile(step2, async ({ inputData }) => inputData.value < 10)
  .commit();
```

> Run this example with a starting input value less than 10.

### Repeating with `.dountil()`

In this example, the workflow uses `.dountil()` to decrement a value until it drops below 10. `step1` runs repeatedly, subtracting 1 from the input every 500ms. Once the value is less than 10, the loop exits and `step2` runs to pass the final value through to the output.

```typescript filename="src/mastra/workflows/example-looping-dountil.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const step1 = createStep({
  id: "step-1",
  description: "deincrements the input value by 1",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    await delay(500);
    return {
      value: inputData.value - 1
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return {
      value: inputData.value
    };
  }
});

export const loopingDountil = createWorkflow({
  id: "dountil-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .dountil(step1, async ({ inputData }) => inputData.value < 10)
  .then(step2)
  .commit();

```

> Run this example with a starting input value greater than 10.

### Repeating with `.foreach()`

In this example, the workflow uses `.foreach()` to apply the `mapStep` step to each string in the input array. For each item, it appends the text `" mapStep"` to the original value. After all items are processed, `step2` runs to pass the updated array to the output.

```typescript filename="src/mastra/workflows/example-looping-foreach.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const mapStep = createStep({
  id: "map-step",
  description: "adds mapStep suffix to input value",
  inputSchema: z.string(),
  outputSchema: z.object({
    value: z.string()
  }),
  execute: async ({ inputData }) => {
    return {
      value: `${inputData} mapStep`
    };
  }
});

const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.array(
    z.object({
      value: z.string()
    })
  ),
  outputSchema: z.array(
    z.object({
      value: z.string()
    })
  ),
  execute: async ({ inputData }) => {
    return inputData.map(({ value }) => ({
      value: value
    }));
  }
});

export const loopingForeach = createWorkflow({
  id: "foreach-workflow",
  inputSchema: z.array(z.string()),
  outputSchema: z.array(
    z.object({
      value: z.string()
    })
  )
})
  .foreach(mapStep)
  .then(step2)
  .commit();

```

> Run this example with multiple string inputs.

## Using a nested workflow

In this example, the workflow demonstrates how to use a nested workflow as a step. After running `step1`, it calls the `nestedWorkflowChild` workflow, which executes its own internal step and returns a result. Nested workflows behave like regular steps and can be chained using `.then()`.

```typescript filename="src/mastra/workflows/example-nested-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1Child = createStep({
  id: "step-1-child",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value: value
    };
  }
});

export const nestedWorkflowChild = createWorkflow({
  id: "nested-workflow-child",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1Child)
  .commit();

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value: value
    };
  }
});

export const nestedWorkflow = createWorkflow({
  id: "nested-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(nestedWorkflowChild)
  .commit();
```

## Cloning a workflow

In this example, the workflow uses `cloneWorkflow()` to reuse the structure of an existing workflow. `childClonedWorkflow` defines a simple sequence with `step1`. That structure is then duplicated using `cloneWorkflow()`, creating `clonedWorkflow` with a new `id`. The cloned workflow is extended with another step and used inside `parentClonedWorkflow`.

```typescript filename="src/mastra/workflows/example-cloned-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep, cloneWorkflow } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

export const childClonedWorkflow = createWorkflow({
  id: "workflow-parent",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .commit();

export const clonedWorkflow = cloneWorkflow(childClonedWorkflow, { id: "cloned-workflow" }).then(step1).commit();

export const parentClonedWorkflow = createWorkflow({
  id: "parent-cloned-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(clonedWorkflow)
  .commit();
```

## Exiting early with `bail()`

In this example, the workflow demonstrates how to exit early using `bail()`. `step1` immediately returns a result and ends the workflow without executing any further steps. Although `step2` is defined in the sequence, it is skipped entirely once `bail()` is called.

```typescript filename="src/mastra/workflows/example-bail-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "returns bail and result object",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ bail }) => {
    return bail({ result: "bailed" });
  }
});
const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

export const bailWorkflow = createWorkflow({
  id: "bail-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(step2)
  .commit();
```

## Exiting early with `Error()`

In this example, the workflow shows how to exit early by throwing an error. `step1` throws a new `Error`, which stops the workflow and returns an error result. As a result, `step2` is never executed. This pattern is useful when you need to halt execution due to invalid conditions or unexpected input.

```typescript filename="src/mastra/workflows/example-error-workflow.ts" showLineNumbers copy
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const step1 = createStep({
  id: "step-1",
  description: "throws new Error with message",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;

    if (value <= 10) {
      throw new Error("inputData.value <= 10");
    }

    return {
      value
    };
  }
});
const step2 = createStep({
  id: "step-2",
  description: "passes value from input to output",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    const { value } = inputData;
    return {
      value
    };
  }
});

export const errorWorkflow = createWorkflow({
  id: "error-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
})
  .then(step1)
  .then(step2)
  .commit();
```

## Workflows (Legacy)

The following links provide example documentation for legacy workflows:

- [Workflow (Legacy) with Sequential Steps](/examples/workflows_legacy/sequential-steps)
- [Parallel Execution with Steps](/examples/workflows_legacy/parallel-steps)
- [Branching Paths](/examples/workflows_legacy/branching-paths)
- [Workflow (Legacy) with Conditional Branching (experimental)](/examples/workflows_legacy/conditional-branching)
- [Data Mapping with Workflow Variables (Legacy)](/examples/workflows_legacy/workflow-variables)
