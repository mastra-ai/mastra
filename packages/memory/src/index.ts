import {
  MastraMemory,
  MastraStorage,
  MastraVector,
  MessageType,
  StorageGetMessagesArg,
  ThreadConfig,
  ThreadType,
} from '@mastra/core';
import { Message as AiMessage } from 'ai';

export * from './postgres';
export * from './kv/upstash';

/**
 * Concrete implementation of MastraMemory that adds support for thread configuration
 * and message injection.
 */
export class Memory extends MastraMemory {
  constructor(
    config: {
      threads?: ThreadConfig;
    } & ({ storage: MastraStorage; vector?: MastraVector } | { storage: MastraStorage; vector: MastraVector }),
  ) {
    super({ name: 'Memory', ...config });
  }

  async getMessages({
    threadId,
    selectBy,
  }: StorageGetMessagesArg): Promise<{ messages: MessageType[]; uiMessages: AiMessage[] }> {
    // Get raw messages from storage
    const rawMessages = await this.storage.getMessages<MessageType[]>({ threadId });

    // If vector search is requested, filter messages using vector similarity
    let filteredMessages = rawMessages;
    if (selectBy?.vectorSearchString && this.vector) {
      // TODO: this was generated by windsurf - this is not the correct implementation
      // const searchResults = await this.vector.search({
      //   query: selectBy.vectorSearchString,
      //   collection: threadId,
      //   limit: selectBy.last,
      // });
      //
      // // Filter messages based on vector search results
      // filteredMessages = rawMessages.filter(msg => searchResults.some(result => result.id === msg.id));
    }

    // Apply message limit if specified
    if (selectBy?.last && !selectBy.vectorSearchString) {
      filteredMessages = filteredMessages.slice(-selectBy.last);
    }

    // Parse and convert messages
    const messages = this.parseMessages(filteredMessages);
    const uiMessages = this.convertToUIMessages(messages);

    return { messages, uiMessages };
  }

  async getThreadById({ threadId }: { threadId: string }): Promise<ThreadType | null> {
    return this.storage.getThreadById({ threadId });
  }

  async getThreadsByResourceId({ resourceid }: { resourceid: string }): Promise<ThreadType[]> {
    return this.storage.getThreadsByResourceId({ resourceid });
  }

  async saveThread({ thread }: { thread: ThreadType }): Promise<ThreadType> {
    return this.storage.saveThread({ thread });
  }

  async saveMessages({ messages }: { messages: MessageType[] }): Promise<MessageType[]> {
    return this.storage.saveMessages({ messages });
  }

  async deleteThread(threadId: string): Promise<void> {
    await this.storage.deleteThread(threadId);

    // TODO: Also clean up vector storage if it exists
    // if (this.vector) {
    //   await this.vector.deleteThread(threadId); ?? filter by thread attributes and delete all returned messages?
    // }
  }
}
