/**
 * Generates type-safe permission types from SERVER_ROUTES.
 *
 * This script imports the actual route definitions and derives all valid permissions
 * by iterating over SERVER_ROUTES and extracting resources from paths.
 *
 * Usage: pnpm generate:permissions (from packages/server)
 *
 * Note: This requires the server package to be built first, or use tsx to run directly.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';

// Import directly from source (tsx handles TypeScript)
import { SERVER_ROUTES } from '../src/server/server-adapter/routes/index.js';
import { extractResource, deriveAction } from '../src/server/server-adapter/routes/permissions.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Derive resources and permissions directly from SERVER_ROUTES
const resourceSet = new Set<string>();
const permissionSet = new Set<string>();

for (const route of SERVER_ROUTES) {
  // Skip routes with ALL method (MCP transports)
  if (route.method === 'ALL') continue;

  const resource = extractResource(route.path);
  if (resource) {
    resourceSet.add(resource);
    const action = deriveAction(route.method, route.path);
    permissionSet.add(`${resource}:${action}`);
  }
}

// Add Studio-specific resources that don't have routes but are used in role definitions
const STUDIO_RESOURCES = ['studio', 'users', 'settings'];
for (const resource of STUDIO_RESOURCES) {
  resourceSet.add(resource);
}

// Convert to sorted arrays
const resources = [...resourceSet].sort();

// Actions: derive from routes + add Studio-specific actions
const routeActions = new Set<string>();
for (const route of SERVER_ROUTES) {
  if (route.method !== 'ALL') {
    routeActions.add(deriveAction(route.method, route.path));
  }
}
// Add Studio-specific actions not derived from HTTP methods
const STUDIO_ACTIONS = ['admin', 'invite'];
const actions = [...new Set([...routeActions, ...STUDIO_ACTIONS])].sort();

// Generate all permission combinations (resource x action matrix)
// This ensures all valid combinations exist for wildcards to work correctly
for (const resource of resources) {
  for (const action of actions) {
    permissionSet.add(`${resource}:${action}`);
  }
}

const permissions = [...permissionSet].sort();

// Generate the TypeScript file content
const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file is generated by packages/server/scripts/generate-permissions.ts
 * Run \`pnpm generate:permissions\` from packages/server to regenerate.
 *
 * Source of truth: SERVER_ROUTES in @mastra/server
 */

/**
 * All known API resources.
 * Derived from SERVER_ROUTES paths in @mastra/server.
 */
export const RESOURCES = [
${resources.map(r => `  '${r}',`).join('\n')}
] as const;

/**
 * Resource type union.
 */
export type Resource = (typeof RESOURCES)[number];

/**
 * All permission actions.
 * Derived from METHOD_TO_ACTION mapping:
 * - GET → read
 * - POST → write or execute (context-dependent)
 * - PUT/PATCH → write
 * - DELETE → delete
 * Plus Studio-specific actions: admin, invite
 */
export const ACTIONS = [${actions.map(a => `'${a}'`).join(', ')}] as const;

/**
 * Action type union.
 */
export type Action = (typeof ACTIONS)[number];

/**
 * All valid resource:action permission combinations.
 */
export const PERMISSIONS = [
${permissions.map(p => `  '${p}',`).join('\n')}
] as const;

/**
 * Specific permission type (e.g., 'agents:read', 'workflows:execute').
 */
export type Permission = (typeof PERMISSIONS)[number];

/**
 * Permission pattern that can be used in role definitions.
 * Supports:
 * - Specific permissions: 'agents:read', 'workflows:execute'
 * - Resource wildcards: 'agents:*', 'workflows:*'
 * - Global wildcard: '*'
 */
export type PermissionPattern = Permission | '*' | \`\${Resource}:*\`;

/**
 * Type-safe role mapping configuration.
 *
 * Maps role names (from your identity provider) to Mastra permission patterns.
 *
 * @example
 * \`\`\`typescript
 * const roleMapping: TypedRoleMapping = {
 *   "Engineering": ["agents:*", "workflows:*"],
 *   "Product": ["agents:read", "workflows:read"],
 *   "Admin": ["*"],
 *   "_default": [],
 * };
 * \`\`\`
 */
export type TypedRoleMapping = {
  [role: string]: PermissionPattern[];
};

/**
 * Validates that a string is a valid permission pattern.
 * Useful for runtime validation of permission strings.
 */
export function isValidPermissionPattern(pattern: string): pattern is PermissionPattern {
  if (pattern === '*') return true;
  if (pattern.endsWith(':*')) {
    const resource = pattern.slice(0, -2);
    return (RESOURCES as readonly string[]).includes(resource);
  }
  return (PERMISSIONS as readonly string[]).includes(pattern);
}

/**
 * Validates that all permissions in an array are valid patterns.
 */
export function validatePermissions(permissions: string[]): permissions is PermissionPattern[] {
  return permissions.every(isValidPermissionPattern);
}
`;

// Write to @mastra/core/auth
const outputPath = path.join(__dirname, '../../core/src/auth/interfaces/permissions.generated.ts');
fs.writeFileSync(outputPath, output);

console.info(`✓ Generated ${outputPath}`);
console.info(`  - ${resources.length} resources`);
console.info(`  - ${actions.length} actions`);
console.info(`  - ${permissions.length} permission combinations`);
