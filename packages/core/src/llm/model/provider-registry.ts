/**
 * Runtime provider registry loader
 * Loads provider data from JSON file and exports typed interfaces
 */

import fs from 'fs';
import os from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import type { ProviderConfig } from './gateways/base.js';
import type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels } from './provider-types.generated.js';

// Re-export types for convenience
export type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels };

interface RegistryData {
  providers: Record<string, ProviderConfig>;
  models: Record<string, string[]>;
  generatedAt: string;
  version: string;
}

let registryData: RegistryData | null = null;

// Cache file helpers
const CACHE_DIR = path.join(os.homedir(), '.cache', 'mastra');
const CACHE_FILE = path.join(CACHE_DIR, 'gateway-refresh-time');

let modelRouterCacheFailed = false;

function getLastRefreshTimeFromDisk(): Date | null {
  try {
    if (!fs.existsSync(CACHE_FILE)) {
      return null;
    }
    const timestamp = fs.readFileSync(CACHE_FILE, 'utf-8').trim();
    return new Date(parseInt(timestamp, 10));
  } catch (err) {
    console.warn('[ModelRegistry] Failed to read cache file:', err);
    modelRouterCacheFailed = true;
    return null;
  }
}

function saveLastRefreshTimeToDisk(date: Date): void {
  try {
    if (!fs.existsSync(CACHE_DIR)) {
      fs.mkdirSync(CACHE_DIR, { recursive: true });
    }
    fs.writeFileSync(CACHE_FILE, date.getTime().toString(), 'utf-8');
  } catch (err) {
    modelRouterCacheFailed = true;
    console.warn('[ModelRegistry] Failed to write cache file:', err);
  }
}

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function loadRegistry(): RegistryData {
  if (registryData) {
    return registryData;
  }

  const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';

  // Prioritize production paths (built package)
  const possiblePaths = [
    // Built: relative to this file (production)
    path.join(__dirname, 'provider-registry.json'),
  ];

  // Only check development paths if MASTRA_DEV=1
  if (isDev) {
    possiblePaths.push(
      // Development: from source
      path.join(process.cwd(), 'packages/core/src/llm/model/provider-registry.json'),
      path.join(process.cwd(), 'src/llm/model/provider-registry.json'),
      path.join(__dirname, '../../../src/llm/model/provider-registry.json'),
    );
  }

  const errors: string[] = [];

  for (const jsonPath of possiblePaths) {
    try {
      const content = fs.readFileSync(jsonPath, 'utf-8');
      registryData = JSON.parse(content);
      return registryData!;
    } catch (err) {
      errors.push(`${jsonPath}: ${err instanceof Error ? err.message : String(err)}`);
      continue;
    }
  }

  throw new Error(
    `Failed to load provider registry. Make sure provider-registry.json is generated by running: npm run generate:providers\n\nTried paths:\n${errors.join('\n')}`,
  );
}

// Export registry data via Proxy for lazy loading
export const PROVIDER_REGISTRY = new Proxy({} as Record<string, ProviderConfig>, {
  get(_target, prop: string) {
    const data = loadRegistry();
    return data.providers[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.providers);
  },
  has(_target, prop: string) {
    const data = loadRegistry();
    return prop in data.providers;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const data = loadRegistry();
    if (prop in data.providers) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
}) as Record<Provider, ProviderConfig>;

export const PROVIDER_MODELS = new Proxy({} as ProviderModels, {
  get(_target, prop: string) {
    const data = loadRegistry();
    return data.models[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.models);
  },
  has(_target, prop: string) {
    const data = loadRegistry();
    return prop in data.models;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const data = loadRegistry();
    if (prop in data.models) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
});

/**
 * Parse a model string to extract provider and model ID
 * Examples:
 *   "openai/gpt-4o" -> { provider: "openai", modelId: "gpt-4o" }
 *   "fireworks/accounts/etc/model" -> { provider: "fireworks", modelId: "accounts/etc/model" }
 *   "gpt-4o" -> { provider: null, modelId: "gpt-4o" }
 */
export function parseModelString(modelString: string): { provider: string | null; modelId: string } {
  const firstSlashIndex = modelString.indexOf('/');

  if (firstSlashIndex !== -1) {
    // Has at least one slash - extract everything before first slash as provider
    const provider = modelString.substring(0, firstSlashIndex);
    const modelId = modelString.substring(firstSlashIndex + 1);

    if (provider && modelId) {
      return {
        provider,
        modelId,
      };
    }
  }

  // No slash or invalid format
  return {
    provider: null,
    modelId: modelString,
  };
}

/**
 * Get provider configuration by provider ID
 */
export function getProviderConfig(providerId: string): ProviderConfig | undefined {
  const data = loadRegistry();
  return data.providers[providerId];
}

/**
 * Check if a provider is registered
 */
export function isProviderRegistered(providerId: string): boolean {
  const data = loadRegistry();
  return providerId in data.providers;
}

/**
 * Get all registered provider IDs
 */
export function getRegisteredProviders(): string[] {
  const data = loadRegistry();
  return Object.keys(data.providers);
}

/**
 * Type guard to check if a string is a valid OpenAI-compatible model ID
 */
export function isValidModelId(modelId: string): modelId is ModelRouterModelId {
  const { provider } = parseModelString(modelId);
  return provider !== null && isProviderRegistered(provider);
}

/**
 * ModelRegistry - Manages dynamic loading and refreshing of provider data
 * Singleton class that handles runtime updates to the provider registry
 */
export class ModelRegistry {
  private static instance: ModelRegistry | null = null;
  private lastRefreshTime: Date | null = null;
  private refreshInterval: NodeJS.Timeout | null = null;
  private isRefreshing = false;

  private constructor() {
    // Private constructor for singleton pattern
  }

  /**
   * Get the singleton instance
   */
  static getInstance(): ModelRegistry {
    if (!ModelRegistry.instance) {
      ModelRegistry.instance = new ModelRegistry();
    }
    return ModelRegistry.instance;
  }

  /**
   * Sync providers from all gateways
   * @param forceRefresh - Force refresh even if recently synced
   */
  async syncGateways(forceRefresh = false): Promise<void> {
    if (this.isRefreshing && !forceRefresh) {
      // console.debug('[ModelRegistry] Sync already in progress, skipping...');
      return;
    }

    this.isRefreshing = true;

    try {
      // console.debug('[ModelRegistry] Starting gateway sync...');

      // Import gateway classes and generation functions
      const { ModelsDevGateway } = await import('./gateways/models-dev.js');
      const { NetlifyGateway } = await import('./gateways/netlify.js');
      const { fetchProvidersFromGateways, writeRegistryFiles } = await import('./registry-generator.js');

      // Initialize gateways
      const gateways = [new ModelsDevGateway({}), new NetlifyGateway()];

      // Fetch provider data
      const { providers, models } = await fetchProvidersFromGateways(gateways);

      // Write to dist/ (the bundled location that gets distributed)
      // Find the dist root by looking for provider-registry.json
      let distRoot = __dirname;
      while (distRoot !== path.dirname(distRoot)) {
        if (fs.existsSync(path.join(distRoot, 'provider-registry.json'))) {
          break;
        }
        distRoot = path.dirname(distRoot);
      }

      const distJsonPath = path.join(distRoot, 'provider-registry.json');
      const distTypesPath = path.join(distRoot, 'provider-types.generated.d.ts');

      await writeRegistryFiles(distJsonPath, distTypesPath, providers, models);
      // console.debug(`[ModelRegistry] ✅ Updated registry files in dist/`);

      // Also copy to src/ when in dev mode
      const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';
      if (isDev) {
        // Find the package root by looking for package.json
        let packageRoot = __dirname;
        while (packageRoot !== path.dirname(packageRoot)) {
          if (fs.existsSync(path.join(packageRoot, 'package.json'))) {
            const pkgJson = JSON.parse(fs.readFileSync(path.join(packageRoot, 'package.json'), 'utf-8'));
            if (pkgJson.name === '@mastra/core') {
              break;
            }
          }
          packageRoot = path.dirname(packageRoot);
        }

        const srcDir = path.join(packageRoot, 'src/llm/model');
        const srcJsonPath = path.join(srcDir, 'provider-registry.json');
        const srcTypesPath = path.join(srcDir, 'provider-types.generated.d.ts');

        // Copy the already-generated files
        await fs.promises.copyFile(distJsonPath, srcJsonPath);
        await fs.promises.copyFile(distTypesPath, srcTypesPath);
        // console.debug(`[ModelRegistry] ✅ Copied registry files to src/ (dev mode)`);
      }

      // Clear the in-memory cache to force reload
      registryData = null;

      this.lastRefreshTime = new Date();
      saveLastRefreshTimeToDisk(this.lastRefreshTime);
      // console.debug(`[ModelRegistry] ✅ Gateway sync completed at ${this.lastRefreshTime.toISOString()}`);
    } catch (error) {
      console.error('[ModelRegistry] ❌ Gateway sync failed:', error);
      throw error;
    } finally {
      this.isRefreshing = false;
    }
  }

  /**
   * Get the last refresh time (from memory or disk cache)
   */
  getLastRefreshTime(): Date | null {
    return this.lastRefreshTime || getLastRefreshTimeFromDisk();
  }

  /**
   * Start auto-refresh on an interval
   * @param intervalMs - Interval in milliseconds (default: 1 hour)
   */
  startAutoRefresh(intervalMs = 60 * 60 * 1000): void {
    if (this.refreshInterval) {
      // console.debug('[ModelRegistry] Auto-refresh already running');
      return;
    }

    // console.debug(`[ModelRegistry] Starting auto-refresh (interval: ${intervalMs}ms)`);

    // Check if we need to run an immediate sync
    const lastRefresh = getLastRefreshTimeFromDisk();
    const now = Date.now();
    const shouldRefresh = !modelRouterCacheFailed && (!lastRefresh || now - lastRefresh.getTime() > intervalMs);

    if (shouldRefresh) {
      // console.debug(
      //   `[ModelRegistry] Running immediate sync (last refresh: ${lastRefresh ? lastRefresh.toISOString() : 'never'})`,
      // );
      this.syncGateways().catch(err => {
        console.error('[ModelRegistry] Initial auto-refresh failed:', err);
      });
    } else {
      // console.debug( `[ModelRegistry] Skipping immediate sync (last refresh: ${lastRefresh.toISOString()}, next in ${Math.round((intervalMs - (now - lastRefresh.getTime())) / 1000)}s)`,
      // );
    }

    this.refreshInterval = setInterval(() => {
      if (modelRouterCacheFailed && this.refreshInterval) {
        clearInterval(this.refreshInterval);
        this.refreshInterval = null;
        return;
      }
      this.syncGateways().catch(err => {
        console.error('[ModelRegistry] Auto-refresh failed:', err);
      });
    }, intervalMs);

    // Prevent the interval from keeping the process alive
    if (this.refreshInterval.unref) {
      this.refreshInterval.unref();
    }
  }

  /**
   * Stop auto-refresh
   */
  stopAutoRefresh(): void {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
      // console.debug('[ModelRegistry] Auto-refresh stopped');
    }
  }

  /**
   * Get provider configuration by ID
   */
  getProviderConfig(providerId: string): ProviderConfig | undefined {
    return getProviderConfig(providerId);
  }

  /**
   * Check if a provider is registered
   */
  isProviderRegistered(providerId: string): boolean {
    return isProviderRegistered(providerId);
  }

  /**
   * Get all registered providers
   */
  getProviders(): Record<string, ProviderConfig> {
    const data = loadRegistry();
    return data.providers;
  }

  /**
   * Get all models
   */
  getModels(): Record<string, string[]> {
    const data = loadRegistry();
    return data.models;
  }
}

// Auto-start refresh if enabled
const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';
const autoRefreshEnabled =
  process.env.MASTRA_AUTO_REFRESH_PROVIDERS === 'true' ||
  (process.env.MASTRA_AUTO_REFRESH_PROVIDERS !== 'false' && isDev);

if (autoRefreshEnabled && isDev) {
  // console.debug('[ModelRegistry] Auto-refresh enabled (dev mode)');
  ModelRegistry.getInstance().startAutoRefresh();
}
