/**
 * Runtime provider registry loader
 * Loads provider data from JSON file and exports typed interfaces
 */

import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import type { ProviderConfig } from './gateways/base.js';
import type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels } from './provider-types.generated.js';

// Re-export types for convenience
export type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels };

interface RegistryData {
  providers: Record<string, ProviderConfig>;
  models: Record<string, string[]>;
  generatedAt: string;
  version: string;
}

let registryData: RegistryData | null = null;

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function loadRegistry(): RegistryData {
  if (registryData) {
    return registryData;
  }

  // Try multiple paths for different environments
  const possiblePaths = [
    // Development: from source
    path.join(process.cwd(), 'packages/core/src/llm/model/provider-registry.json'),
    path.join(process.cwd(), 'src/llm/model/provider-registry.json'),
    // Built: relative to this file
    path.join(__dirname, 'provider-registry.json'),
    path.join(__dirname, '../../../src/llm/model/provider-registry.json'),
  ];

  const errors: string[] = [];

  for (const jsonPath of possiblePaths) {
    try {
      const content = fs.readFileSync(jsonPath, 'utf-8');
      registryData = JSON.parse(content);
      return registryData!;
    } catch (err) {
      errors.push(`${jsonPath}: ${err instanceof Error ? err.message : String(err)}`);
      continue;
    }
  }

  throw new Error(
    `Failed to load provider registry. Make sure provider-registry.json is generated by running: npm run generate:providers\n\nTried paths:\n${errors.join('\n')}`,
  );
}

// Export registry data via Proxy for lazy loading
export const PROVIDER_REGISTRY = new Proxy({} as Record<string, ProviderConfig>, {
  get(target, prop: string) {
    const data = loadRegistry();
    return data.providers[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.providers);
  },
  has(target, prop: string) {
    const data = loadRegistry();
    return prop in data.providers;
  },
  getOwnPropertyDescriptor(target, prop) {
    const data = loadRegistry();
    if (prop in data.providers) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
}) as Record<Provider, ProviderConfig>;

export const PROVIDER_MODELS = new Proxy({} as ProviderModels, {
  get(target, prop: string) {
    const data = loadRegistry();
    return data.models[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.models);
  },
  has(target, prop: string) {
    const data = loadRegistry();
    return prop in data.models;
  },
  getOwnPropertyDescriptor(target, prop) {
    const data = loadRegistry();
    if (prop in data.models) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
});

/**
 * Parse a model string to extract provider and model ID
 * Examples:
 *   "openai/gpt-4o" -> { provider: "openai", modelId: "gpt-4o" }
 *   "fireworks/accounts/etc/model" -> { provider: "fireworks", modelId: "accounts/etc/model" }
 *   "gpt-4o" -> { provider: null, modelId: "gpt-4o" }
 */
export function parseModelString(modelString: string): { provider: string | null; modelId: string } {
  const firstSlashIndex = modelString.indexOf('/');

  if (firstSlashIndex !== -1) {
    // Has at least one slash - extract everything before first slash as provider
    const provider = modelString.substring(0, firstSlashIndex);
    const modelId = modelString.substring(firstSlashIndex + 1);

    if (provider && modelId) {
      return {
        provider,
        modelId,
      };
    }
  }

  // No slash or invalid format
  return {
    provider: null,
    modelId: modelString,
  };
}

/**
 * Get provider configuration by provider ID
 */
export function getProviderConfig(providerId: string): ProviderConfig | undefined {
  const data = loadRegistry();
  return data.providers[providerId];
}

/**
 * Check if a provider is registered
 */
export function isProviderRegistered(providerId: string): boolean {
  const data = loadRegistry();
  return providerId in data.providers;
}

/**
 * Get all registered provider IDs
 */
export function getRegisteredProviders(): string[] {
  const data = loadRegistry();
  return Object.keys(data.providers);
}

/**
 * Type guard to check if a string is a valid OpenAI-compatible model ID
 */
export function isValidModelId(modelId: string): modelId is ModelRouterModelId {
  const { provider } = parseModelString(modelId);
  return provider !== null && isProviderRegistered(provider);
}
