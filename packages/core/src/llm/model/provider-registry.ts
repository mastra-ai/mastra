/**
 * Runtime provider registry loader
 * Loads provider data from JSON file and exports typed interfaces
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import type { ProviderConfig } from './gateways/base.js';
import type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels } from './provider-types.generated.js';

// Re-export types for convenience
export type { Provider, ModelForProvider, ModelRouterModelId, ProviderModels };

interface RegistryData {
  providers: Record<string, ProviderConfig>;
  models: Record<string, string[]>;
  generatedAt: string;
  version: string;
}

let registryData: RegistryData | null = null;

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function loadRegistry(): RegistryData {
  if (registryData) {
    return registryData;
  }

  const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';

  // Prioritize production paths (built package)
  const possiblePaths = [
    // Built: relative to this file (production)
    path.join(__dirname, 'provider-registry.json'),
  ];

  // Only check development paths if MASTRA_DEV=1
  if (isDev) {
    possiblePaths.push(
      // Development: from source
      path.join(process.cwd(), 'packages/core/src/llm/model/provider-registry.json'),
      path.join(process.cwd(), 'src/llm/model/provider-registry.json'),
      path.join(__dirname, '../../../src/llm/model/provider-registry.json'),
    );
  }

  const errors: string[] = [];

  for (const jsonPath of possiblePaths) {
    try {
      const content = fs.readFileSync(jsonPath, 'utf-8');
      registryData = JSON.parse(content);
      return registryData!;
    } catch (err) {
      errors.push(`${jsonPath}: ${err instanceof Error ? err.message : String(err)}`);
      continue;
    }
  }

  throw new Error(
    `Failed to load provider registry. Make sure provider-registry.json is generated by running: npm run generate:providers\n\nTried paths:\n${errors.join('\n')}`,
  );
}

// Export registry data via Proxy for lazy loading
export const PROVIDER_REGISTRY = new Proxy({} as Record<string, ProviderConfig>, {
  get(_target, prop: string) {
    const data = loadRegistry();
    return data.providers[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.providers);
  },
  has(_target, prop: string) {
    const data = loadRegistry();
    return prop in data.providers;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const data = loadRegistry();
    if (prop in data.providers) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
}) as Record<Provider, ProviderConfig>;

export const PROVIDER_MODELS = new Proxy({} as ProviderModels, {
  get(_target, prop: string) {
    const data = loadRegistry();
    return data.models[prop];
  },
  ownKeys() {
    const data = loadRegistry();
    return Object.keys(data.models);
  },
  has(_target, prop: string) {
    const data = loadRegistry();
    return prop in data.models;
  },
  getOwnPropertyDescriptor(_target, prop) {
    const data = loadRegistry();
    if (prop in data.models) {
      return {
        enumerable: true,
        configurable: true,
      };
    }
    return undefined;
  },
});

/**
 * Parse a model string to extract provider and model ID
 * Examples:
 *   "openai/gpt-4o" -> { provider: "openai", modelId: "gpt-4o" }
 *   "fireworks/accounts/etc/model" -> { provider: "fireworks", modelId: "accounts/etc/model" }
 *   "gpt-4o" -> { provider: null, modelId: "gpt-4o" }
 */
export function parseModelString(modelString: string): { provider: string | null; modelId: string } {
  const firstSlashIndex = modelString.indexOf('/');

  if (firstSlashIndex !== -1) {
    // Has at least one slash - extract everything before first slash as provider
    const provider = modelString.substring(0, firstSlashIndex);
    const modelId = modelString.substring(firstSlashIndex + 1);

    if (provider && modelId) {
      return {
        provider,
        modelId,
      };
    }
  }

  // No slash or invalid format
  return {
    provider: null,
    modelId: modelString,
  };
}

/**
 * Get provider configuration by provider ID
 */
export function getProviderConfig(providerId: string): ProviderConfig | undefined {
  const data = loadRegistry();
  return data.providers[providerId];
}

/**
 * Check if a provider is registered
 */
export function isProviderRegistered(providerId: string): boolean {
  const data = loadRegistry();
  return providerId in data.providers;
}

/**
 * Get all registered provider IDs
 */
export function getRegisteredProviders(): string[] {
  const data = loadRegistry();
  return Object.keys(data.providers);
}

/**
 * Type guard to check if a string is a valid OpenAI-compatible model ID
 */
export function isValidModelId(modelId: string): modelId is ModelRouterModelId {
  const { provider } = parseModelString(modelId);
  return provider !== null && isProviderRegistered(provider);
}

/**
 * ModelRegistry - Manages dynamic loading and refreshing of provider data
 * Singleton class that handles runtime updates to the provider registry
 */
export class ModelRegistry {
  private static instance: ModelRegistry | null = null;
  private lastRefreshTime: Date | null = null;
  private refreshInterval: NodeJS.Timeout | null = null;
  private isRefreshing = false;

  private constructor() {
    // Private constructor for singleton pattern
  }

  /**
   * Get the singleton instance
   */
  static getInstance(): ModelRegistry {
    if (!ModelRegistry.instance) {
      ModelRegistry.instance = new ModelRegistry();
    }
    return ModelRegistry.instance;
  }

  /**
   * Sync providers from all gateways
   * @param forceRefresh - Force refresh even if recently synced
   */
  async syncGateways(forceRefresh = false): Promise<void> {
    if (this.isRefreshing && !forceRefresh) {
      console.debug('[ModelRegistry] Sync already in progress, skipping...');
      return;
    }

    this.isRefreshing = true;

    try {
      console.debug('[ModelRegistry] Starting gateway sync...');

      // Import gateway classes and generation functions
      const { ModelsDevGateway } = await import('./gateways/models-dev.js');
      const { NetlifyGateway } = await import('./gateways/netlify.js');
      const { fetchProvidersFromGateways, writeRegistryFiles } = await import('./registry-generator.js');

      // Initialize gateways
      const gateways = [new ModelsDevGateway({}), new NetlifyGateway()];

      // Fetch provider data
      const { providers, models } = await fetchProvidersFromGateways(gateways);

      // Determine write paths based on environment
      const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';

      // Always write to dist/ (production location)
      const distDir = path.join(__dirname);
      const distJsonPath = path.join(distDir, 'provider-registry.json');
      const distTypesPath = path.join(distDir, 'provider-types.generated.d.ts');

      await writeRegistryFiles(distJsonPath, distTypesPath, providers, models);
      console.debug(`[ModelRegistry] ✅ Updated registry in dist/`);

      // Also write to src/ when in dev mode
      if (isDev) {
        const srcDir = path.join(__dirname, '../../../src/llm/model');
        const srcJsonPath = path.join(srcDir, 'provider-registry.json');
        const srcTypesPath = path.join(srcDir, 'provider-types.generated.d.ts');

        await writeRegistryFiles(srcJsonPath, srcTypesPath, providers, models);
        console.debug(`[ModelRegistry] ✅ Updated registry in src/ (dev mode)`);
      }

      // Clear the in-memory cache to force reload
      registryData = null;

      this.lastRefreshTime = new Date();
      console.debug(`[ModelRegistry] ✅ Gateway sync completed at ${this.lastRefreshTime.toISOString()}`);
    } catch (error) {
      console.error('[ModelRegistry] ❌ Gateway sync failed:', error);
      throw error;
    } finally {
      this.isRefreshing = false;
    }
  }

  /**
   * Get the last refresh time
   */
  getLastRefreshTime(): Date | null {
    return this.lastRefreshTime;
  }

  /**
   * Start auto-refresh on an interval
   * @param intervalMs - Interval in milliseconds (default: 1 hour)
   */
  startAutoRefresh(intervalMs = 60 * 60 * 1000): void {
    if (this.refreshInterval) {
      console.debug('[ModelRegistry] Auto-refresh already running');
      return;
    }

    console.debug(`[ModelRegistry] Starting auto-refresh (interval: ${intervalMs}ms)`);

    this.refreshInterval = setInterval(() => {
      this.syncGateways().catch(err => {
        console.error('[ModelRegistry] Auto-refresh failed:', err);
      });
    }, intervalMs);

    // Prevent the interval from keeping the process alive
    if (this.refreshInterval.unref) {
      this.refreshInterval.unref();
    }
  }

  /**
   * Stop auto-refresh
   */
  stopAutoRefresh(): void {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
      console.debug('[ModelRegistry] Auto-refresh stopped');
    }
  }

  /**
   * Get provider configuration by ID
   */
  getProviderConfig(providerId: string): ProviderConfig | undefined {
    return getProviderConfig(providerId);
  }

  /**
   * Check if a provider is registered
   */
  isProviderRegistered(providerId: string): boolean {
    return isProviderRegistered(providerId);
  }

  /**
   * Get all registered providers
   */
  getProviders(): Record<string, ProviderConfig> {
    const data = loadRegistry();
    return data.providers;
  }

  /**
   * Get all models
   */
  getModels(): Record<string, string[]> {
    const data = loadRegistry();
    return data.models;
  }
}

// Auto-start refresh if enabled
if (process.env.MASTRA_AUTO_REFRESH_PROVIDERS === 'true') {
  const isDev = process.env.MASTRA_DEV === 'true' || process.env.MASTRA_DEV === '1';

  if (isDev) {
    console.debug('[ModelRegistry] Auto-refresh enabled (dev mode)');
    ModelRegistry.getInstance().startAutoRefresh();
  }
}
