import { ErrorCategory, ErrorDomain, MastraError } from '../error';
import type { Mastra } from '../mastra';
import type { StoredScorerType } from '../storage/types';
import { createScorer } from './base';
import type { MastraScorer } from './base';

/**
 * Interpolates template variables in the prompt.
 *
 * Supported variables:
 * - {{minScore}} - Minimum score from scoreRange
 * - {{maxScore}} - Maximum score from scoreRange
 * - {{input}} - JSON-stringified run input
 * - {{output}} - JSON-stringified run output
 *
 * @param template - The prompt template with {{variable}} placeholders
 * @param context - Object containing values to interpolate
 * @returns The interpolated string
 */
function interpolateTemplate(
  template: string,
  context: {
    minScore: number;
    maxScore: number;
    input: unknown;
    output: unknown;
  },
): string {
  return template
    .replace(/\{\{minScore\}\}/g, String(context.minScore))
    .replace(/\{\{maxScore\}\}/g, String(context.maxScore))
    .replace(
      /\{\{input\}\}/g,
      typeof context.input === 'string' ? context.input : JSON.stringify(context.input, null, 2),
    )
    .replace(
      /\{\{output\}\}/g,
      typeof context.output === 'string' ? context.output : JSON.stringify(context.output, null, 2),
    );
}

/**
 * Resolves a stored scorer configuration to a runnable MastraScorer instance.
 *
 * This function takes a scorer definition stored in the database (StoredScorerType)
 * and converts it to a fully functional MastraScorer that can be used to evaluate
 * agent runs using the LLM-as-judge pattern.
 *
 * The stored scorer uses a simplified single-step design with:
 * - A model configuration (provider + name)
 * - A prompt template with template variables
 * - A score range (min/max)
 *
 * Template variables supported in the prompt:
 * - {{minScore}} - Minimum score from scoreRange
 * - {{maxScore}} - Maximum score from scoreRange
 * - {{input}} - The input provided to the agent
 * - {{output}} - The output generated by the agent
 *
 * @param storedScorer - The stored scorer configuration from the database
 * @param mastra - Optional Mastra instance for model resolution
 * @returns A MastraScorer instance ready to run
 *
 * @example
 * ```typescript
 * const storage = mastra.getStorage();
 * const store = await storage.getStore('storedScorers');
 * const storedScorer = await store.getScorerByIdResolved({ id: 'my-scorer' });
 *
 * if (storedScorer) {
 *   const scorer = resolveStoredScorer(storedScorer, mastra);
 *   const result = await scorer.run({
 *     input: agentRun.input,
 *     output: agentRun.output,
 *   });
 * }
 * ```
 */
export function resolveStoredScorer(
  storedScorer: StoredScorerType,
  mastra?: Mastra,
): MastraScorer<string, any, any, any> {
  // Validate required fields
  if (!storedScorer.model || !storedScorer.model.provider || !storedScorer.model.name) {
    throw new MastraError({
      id: 'MASTR_STORED_SCORER_MISSING_MODEL',
      domain: ErrorDomain.SCORER,
      category: ErrorCategory.USER,
      text: `Stored scorer "${storedScorer.id}" requires a model configuration with provider and name`,
      details: {
        scorerId: storedScorer.id,
        modelProvider: storedScorer.model?.provider ?? 'undefined',
        modelName: storedScorer.model?.name ?? 'undefined',
      },
    });
  }

  if (!storedScorer.prompt) {
    throw new MastraError({
      id: 'MASTR_STORED_SCORER_MISSING_PROMPT',
      domain: ErrorDomain.SCORER,
      category: ErrorCategory.USER,
      text: `Stored scorer "${storedScorer.id}" requires a prompt template`,
      details: {
        scorerId: storedScorer.id,
      },
    });
  }

  // Extract score range with defaults
  const minScore = storedScorer.scoreRange?.min ?? 0;
  const maxScore = storedScorer.scoreRange?.max ?? 1;

  // Build the model string in the format "provider/name"
  const modelString = `${storedScorer.model.provider}/${storedScorer.model.name}`;

  // Create the base scorer with judge configuration
  const scorer = createScorer({
    id: storedScorer.id,
    name: storedScorer.name,
    description: storedScorer.description ?? `LLM-as-judge scorer: ${storedScorer.name}`,
    judge: {
      model: modelString,
      instructions: storedScorer.prompt,
    },
    type: 'agent',
  }).generateScore({
    description: `Evaluate using ${storedScorer.name}`,
    judge: {
      model: modelString,
      instructions: storedScorer.prompt,
    },
    createPrompt: ({ run }) => {
      // Interpolate template variables
      return interpolateTemplate(storedScorer.prompt, {
        minScore,
        maxScore,
        input: run.input,
        output: run.output,
      });
    },
  });

  // Register Mastra instance if provided
  if (mastra) {
    scorer.__registerMastra(mastra);
  }

  return scorer;
}

/**
 * Resolves multiple stored scorer configurations to MastraScorer instances.
 *
 * @param storedScorers - Array of stored scorer configurations
 * @param mastra - Optional Mastra instance for model resolution
 * @returns Map of scorer ID to MastraScorer instance
 */
export function resolveStoredScorers(
  storedScorers: StoredScorerType[],
  mastra?: Mastra,
): Map<string, MastraScorer<string, any, any, any>> {
  const scorers = new Map<string, MastraScorer<string, any, any, any>>();

  for (const storedScorer of storedScorers) {
    try {
      scorers.set(storedScorer.id, resolveStoredScorer(storedScorer, mastra));
    } catch (error) {
      // Log warning but continue with other scorers
      console.warn(`Failed to resolve stored scorer "${storedScorer.id}":`, error);
    }
  }

  return scorers;
}
