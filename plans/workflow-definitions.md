# Workflow Definitions Implementation Plan

This document outlines the implementation plan for "Workflow Definitions" - a feature that enables users to create, edit, and manage workflows declaratively through the UI or programmatically, without writing code.

## Overview

### Vision

Make workflows accessible to everyone by providing a declarative JSON format that can be:

- Created/edited in Mastra Studio UI
- Generated by coding agents
- Stored, versioned, and resolved to executable workflows at runtime

### Key Concepts

1. **Workflow Definition** - A JSON-serializable representation of a workflow stored in the database
2. **Declarative Steps** - Steps defined by type (agent, tool, workflow, transform, suspend) rather than code
3. **Variable References** - Path-based references (`$ref`) to wire data between steps
4. **Conditions** - Declarative condition definitions for branching and loops
5. **Resolution** - Converting a stored definition to an executable `Workflow` instance

### Design Decisions

| Decision     | Choice                                                   |
| ------------ | -------------------------------------------------------- |
| Naming       | "Workflow Definitions"                                   |
| Storage      | LibSQL first, then PostgreSQL, MongoDB                   |
| Step Types   | agent, tool, workflow, transform, suspend                |
| Data Mapping | Path-based refs (`$ref`) - no arithmetic initially       |
| Conditions   | Hybrid (declarative operators + expression escape hatch) |
| Validation   | At save time (strict)                                    |
| Execution    | Resolve to `Workflow` -> existing execution engine       |
| Step Sources | Both code-defined AND stored (agents, workflows)         |

---

## Type Definitions

### Variable References

```typescript
// Path-based reference to data
type VariableRef = { $ref: string };
// Examples: "input.userId", "steps.step1.output.name", "state.counter"

// Static value
type LiteralValue = { $literal: unknown };

// Either a reference or literal
type ValueOrRef = VariableRef | LiteralValue;
```

### Condition Definitions

```typescript
type ConditionOperator =
  | 'equals'
  | 'notEquals'
  | 'gt'
  | 'gte'
  | 'lt'
  | 'lte'
  | 'contains'
  | 'startsWith'
  | 'endsWith'
  | 'matches'
  | 'in'
  | 'isNull'
  | 'isNotNull';

type ConditionDef =
  | { type: 'compare'; field: VariableRef; operator: ConditionOperator; value?: ValueOrRef }
  | { type: 'and'; conditions: ConditionDef[] }
  | { type: 'or'; conditions: ConditionDef[] }
  | { type: 'not'; condition: ConditionDef }
  | { type: 'expr'; expression: string }; // Escape hatch for complex logic
```

### Declarative Step Definitions

```typescript
interface AgentStepDef {
  type: 'agent';
  agentId: string; // Code-defined or stored agent ID
  input: {
    prompt: VariableRef;
    instructions?: string | VariableRef;
  };
  structuredOutput?: Record<string, unknown>; // JSON Schema
}

interface ToolStepDef {
  type: 'tool';
  toolId: string;
  input: Record<string, ValueOrRef>;
}

interface WorkflowStepDef {
  type: 'workflow';
  workflowId: string; // Code-defined or workflow definition ID
  input: Record<string, ValueOrRef>;
}

interface TransformStepDef {
  type: 'transform';
  output: Record<string, ValueOrRef>;
  outputSchema: Record<string, unknown>; // JSON Schema
  stateUpdates?: Record<string, ValueOrRef>;
}

interface SuspendStepDef {
  type: 'suspend';
  resumeSchema: Record<string, unknown>; // JSON Schema
  payload?: Record<string, ValueOrRef>;
}

type DeclarativeStepDefinition = AgentStepDef | ToolStepDef | WorkflowStepDef | TransformStepDef | SuspendStepDef;
```

### Step Graph Entries

```typescript
type DefinitionStepFlowEntry =
  | { type: 'step'; step: { id: string; description?: string } }
  | { type: 'sleep'; id: string; duration: number }
  | { type: 'sleepUntil'; id: string; timestamp: ValueOrRef }
  | { type: 'parallel'; steps: Array<{ type: 'step'; step: { id: string } }> }
  | { type: 'conditional'; branches: Array<{ condition: ConditionDef; stepId: string }>; default?: string }
  | { type: 'loop'; stepId: string; condition: ConditionDef; loopType: 'dowhile' | 'dountil' }
  | { type: 'foreach'; stepId: string; collection: VariableRef; concurrency?: number }
  | { type: 'map'; output: Record<string, ValueOrRef> };
```

### Main Storage Types

```typescript
interface StorageWorkflowDefinitionType {
  id: string;
  name: string;
  description?: string;
  inputSchema: Record<string, unknown>; // JSON Schema
  outputSchema: Record<string, unknown>; // JSON Schema
  stateSchema?: Record<string, unknown>; // JSON Schema
  stepGraph: DefinitionStepFlowEntry[];
  steps: Record<string, DeclarativeStepDefinition>;
  retryConfig?: { attempts?: number; delay?: number };
  ownerId?: string;
  activeVersionId?: string;
  metadata?: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
}

interface StorageWorkflowDefinitionVersionType {
  id: string;
  workflowDefinitionId: string;
  versionNumber: number;
  name?: string;
  snapshot: StorageWorkflowDefinitionType;
  changedFields?: string[];
  changeMessage?: string;
  createdAt: Date;
}
```

---

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│  Playground UI                                              │
│  - Workflow definitions list                                │
│  - Create/Edit dialogs                                      │
│  - Step palette & visual editor                             │
│  - Version management                                       │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Client SDK                                                 │
│  - MastraClient.listWorkflowDefinitions()                   │
│  - MastraClient.createWorkflowDefinition()                  │
│  - WorkflowDefinition resource (CRUD, versions, execute)    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Server Layer                                               │
│  - handlers/workflow-definitions.ts (CRUD)                  │
│  - handlers/workflow-definition-versions.ts                 │
│  - schemas/*.ts (Zod validation)                            │
│  - routes/*.ts                                              │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Mastra Core                                                │
│  - getWorkflowDefinitionById() -> resolves to Workflow      │
│  - listWorkflowDefinitions()                                │
│  - WorkflowDefinitionResolver                               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Resolution Engine                                          │
│  - evaluateRef() - resolve variable references              │
│  - evaluateCondition() - evaluate conditions                │
│  - resolveStep() - convert declarative -> executable Step   │
│  - jsonSchemaToZod() - convert schemas                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Storage Layer                                              │
│  - WorkflowDefinitionsStorage (abstract base)               │
│  - InMemoryWorkflowDefinitionsStorage                       │
│  - WorkflowDefinitionsLibSQL                                │
│  - WorkflowDefinitionsPG (future)                           │
└─────────────────────────────────────────────────────────────┘
```

---

## Parallel Execution Plan

### Phase 1: Foundation (All Parallel)

All Phase 1 tasks can start immediately with no dependencies.

| Agent | Task               | Description                               | Files                                                                   |
| ----- | ------------------ | ----------------------------------------- | ----------------------------------------------------------------------- |
| **A** | Core Types         | Type definitions and constants            | `packages/core/src/storage/types.ts`, `constants.ts`                    |
| **B** | Zod Schemas        | Server validation schemas                 | `packages/server/src/server/schemas/workflow-definitions.ts`            |
| **C** | Ref Evaluator      | Variable reference & condition evaluation | `packages/core/src/workflows/definition-resolver/evaluate-*.ts`         |
| **D** | JSON Schema to Zod | Schema conversion utility                 | `packages/core/src/workflows/definition-resolver/json-schema-to-zod.ts` |
| **E** | UI Hooks           | React Query hooks (scaffold)              | `packages/playground-ui/src/domains/workflow-definitions/hooks/`        |

### Phase 2: Implementation (After Phase 1 Types)

| Agent | Task                  | Description                 | Files                                                                 | Depends On |
| ----- | --------------------- | --------------------------- | --------------------------------------------------------------------- | ---------- |
| **F** | Storage Base Class    | Abstract base class         | `packages/core/src/storage/domains/workflow-definitions/base.ts`      | A          |
| **G** | LibSQL Implementation | Database implementation     | `stores/libsql/src/storage/domains/workflow-definitions/`             | F          |
| **H** | Server Handlers       | API handlers                | `packages/server/src/server/handlers/workflow-definitions.ts`         | B, F       |
| **I** | Step Resolvers        | Declarative -> executable   | `packages/core/src/workflows/definition-resolver/resolve-steps.ts`    | C, D       |
| **J** | UI List & Create      | Table and dialog components | `packages/playground-ui/src/domains/workflow-definitions/components/` | E          |

### Phase 3: Integration (After Phase 2)

| Agent | Task              | Description                 | Files                                                                 | Depends On |
| ----- | ----------------- | --------------------------- | --------------------------------------------------------------------- | ---------- |
| **K** | In-Memory Storage | For testing                 | `packages/core/src/storage/domains/workflow-definitions/inmemory.ts`  | F          |
| **L** | Server Routes     | Route registration          | `packages/server/src/server/server-adapter/routes/`                   | H          |
| **M** | Resolver Class    | Main resolver orchestration | `packages/core/src/workflows/definition-resolver/index.ts`            | I          |
| **N** | Client SDK        | Client library              | `client-sdks/client-js/src/resources/workflow-definition.ts`          | A          |
| **O** | UI Step Palette   | Step selection component    | `packages/playground-ui/src/domains/workflow-definitions/components/` | J          |

### Phase 4: Testing & Polish (After Phase 3)

| Agent | Task                  | Description                   | Files                                                                 | Depends On |
| ----- | --------------------- | ----------------------------- | --------------------------------------------------------------------- | ---------- |
| **P** | Mastra Integration    | Core integration              | `packages/core/src/mastra/index.ts`                                   | M, G       |
| **Q** | Parity Tests          | Code vs definition comparison | `packages/core/src/workflows/__tests__/definition-parity.test.ts`     | P          |
| **R** | Storage Tests         | Database tests                | `stores/libsql/src/__tests__/workflow-definitions.test.ts`            | G          |
| **S** | UI Wiring             | Connect UI to backend         | `packages/playground/src/pages/workflows/`                            | L, N, O    |
| **T** | Version Management UI | Version components            | `packages/playground-ui/src/domains/workflow-definitions/components/` | S          |

---

## Detailed Task Specifications

### PHASE 1: Foundation

---

#### AGENT A: Core Types & Constants

**Goal:** Define all TypeScript types and database schema constants.

**Files to create/modify:**

- `packages/core/src/storage/types.ts` (modify - add types)
- `packages/core/src/storage/constants.ts` (modify - add tables)
- `packages/core/src/storage/index.ts` (modify - export new types)

**Types to add (see Type Definitions section above):**

- `VariableRef`, `LiteralValue`, `ValueOrRef`
- `ConditionOperator`, `ConditionDef`
- `AgentStepDef`, `ToolStepDef`, `WorkflowStepDef`, `TransformStepDef`, `SuspendStepDef`
- `DeclarativeStepDefinition`
- `DefinitionStepFlowEntry`
- `StorageWorkflowDefinitionType`, `StorageWorkflowDefinitionVersionType`
- CRUD input/output types

**Constants to add:**

- `TABLE_WORKFLOW_DEFINITIONS = 'mastra_workflow_definitions'`
- `TABLE_WORKFLOW_DEFINITION_VERSIONS = 'mastra_workflow_definition_versions'`
- `WORKFLOW_DEFINITIONS_SCHEMA` - column definitions
- `WORKFLOW_DEFINITION_VERSIONS_SCHEMA` - column definitions

**Acceptance Criteria:**

- All types compile without errors
- Types are exported from index.ts
- Follow existing patterns in the file (look at `StorageAgentType`, etc.)

---

#### AGENT B: Zod Schemas

**Goal:** Create Zod validation schemas for API requests/responses.

**Files to create:**

- `packages/server/src/server/schemas/workflow-definitions.ts`
- `packages/server/src/server/schemas/workflow-definition-versions.ts`

**Files to modify:**

- `packages/server/src/server/schemas/index.ts` (add exports)

**Schemas to create:**

- `variableRefSchema`, `literalValueSchema`, `valueOrRefSchema`
- `conditionOperatorSchema`, `conditionDefSchema` (recursive)
- Step definition schemas (agent, tool, workflow, transform, suspend)
- `declarativeStepDefSchema` (discriminated union)
- `definitionStepFlowEntrySchema`
- Request/response schemas (create, update, list, get)
- Path param schemas
- Version schemas

**Reference:** Follow `packages/server/src/server/schemas/stored-agents.ts`

**Acceptance Criteria:**

- All schemas validate correctly
- Recursive condition schema works
- Exported from index.ts

---

#### AGENT C: Reference & Condition Evaluator

**Goal:** Create utilities to evaluate variable references and conditions at runtime.

**Files to create:**

- `packages/core/src/workflows/definition-resolver/evaluate-ref.ts`
- `packages/core/src/workflows/definition-resolver/evaluate-condition.ts`
- `packages/core/src/workflows/definition-resolver/__tests__/evaluate-ref.test.ts`
- `packages/core/src/workflows/definition-resolver/__tests__/evaluate-condition.test.ts`

**Functions to implement:**

```typescript
// evaluate-ref.ts
interface EvaluationContext {
  input: Record<string, unknown>;
  steps: Record<string, { output: unknown }>;
  state: Record<string, unknown>;
}

function evaluateRef(ref: string, context: EvaluationContext): unknown;
function evaluateValueOrRef(valueOrRef: ValueOrRef, context: EvaluationContext): unknown;
function evaluateInputMapping(mapping: Record<string, ValueOrRef>, context: EvaluationContext): Record<string, unknown>;

// evaluate-condition.ts
function evaluateCondition(condition: ConditionDef, context: EvaluationContext): boolean;
```

**Acceptance Criteria:**

- `evaluateRef` correctly navigates nested paths
- `evaluateCondition` handles all operator types
- Unit tests cover edge cases (null values, missing paths)
- Expression evaluation works with security considerations

---

#### AGENT D: JSON Schema to Zod Converter

**Goal:** Convert JSON Schema objects to Zod schemas at runtime.

**Files to create:**

- `packages/core/src/workflows/definition-resolver/json-schema-to-zod.ts`
- `packages/core/src/workflows/definition-resolver/__tests__/json-schema-to-zod.test.ts`

**Function to implement:**

```typescript
function jsonSchemaToZod(schema: Record<string, unknown>): ZodType;
```

**Supported types:**

- string (with minLength, maxLength, pattern, enum)
- number, integer (with minimum, maximum)
- boolean, null
- array (with items, minItems, maxItems)
- object (with properties, required)
- anyOf, oneOf unions

**Acceptance Criteria:**

- Handles all common JSON Schema types
- Unit tests for each type
- Returns `z.unknown()` for unsupported schemas

---

#### AGENT E: UI Hooks (Scaffold)

**Goal:** Create React Query hooks for workflow definitions.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/hooks/use-workflow-definitions.ts`
- `packages/playground-ui/src/domains/workflow-definitions/hooks/use-workflow-definition.ts`
- `packages/playground-ui/src/domains/workflow-definitions/hooks/use-workflow-definition-mutations.ts`
- `packages/playground-ui/src/domains/workflow-definitions/hooks/use-workflow-definition-versions.ts`
- `packages/playground-ui/src/domains/workflow-definitions/hooks/index.ts`
- `packages/playground-ui/src/domains/workflow-definitions/index.ts`

**Hooks to implement:**

- `useWorkflowDefinitions(params?)` - list with pagination
- `useWorkflowDefinition(id)` - single definition
- `useWorkflowDefinitionMutations()` - create, update, delete
- `useWorkflowDefinitionVersions(id)` - version management hooks

**Reference:** Follow `packages/playground-ui/src/domains/agents/hooks/use-stored-agents.ts`

**Acceptance Criteria:**

- Hooks follow existing patterns
- Query keys properly structured
- requestContext passed through
- Exports from index.ts

---

### PHASE 2: Implementation

---

#### AGENT F: Storage Base Class

**Goal:** Create the abstract base class for workflow definitions storage.

**Files to create:**

- `packages/core/src/storage/domains/workflow-definitions/base.ts`
- `packages/core/src/storage/domains/workflow-definitions/index.ts`

**Files to modify:**

- `packages/core/src/storage/domains/index.ts` (add export)

**Class to implement:**

```typescript
abstract class WorkflowDefinitionsStorage extends StorageDomain {
  // CRUD methods
  abstract createWorkflowDefinition(input): Promise<StorageWorkflowDefinitionType>;
  abstract getWorkflowDefinitionById(input): Promise<StorageWorkflowDefinitionType | null>;
  abstract updateWorkflowDefinition(input): Promise<StorageWorkflowDefinitionType>;
  abstract deleteWorkflowDefinition(input): Promise<void>;
  abstract listWorkflowDefinitions(input?): Promise<StorageListWorkflowDefinitionsOutput>;

  // Version methods
  abstract createVersion(input): Promise<WorkflowDefinitionVersion>;
  abstract getVersion(id): Promise<WorkflowDefinitionVersion | null>;
  abstract getVersionByNumber(workflowDefinitionId, versionNumber): Promise<WorkflowDefinitionVersion | null>;
  abstract getLatestVersion(workflowDefinitionId): Promise<WorkflowDefinitionVersion | null>;
  abstract listVersions(input): Promise<ListVersionsOutput>;
  abstract deleteVersion(id): Promise<void>;
  abstract deleteVersionsByWorkflowDefinitionId(workflowDefinitionId): Promise<void>;
  abstract countVersions(workflowDefinitionId): Promise<number>;

  // Concrete resolved getters
  async getWorkflowDefinitionByIdResolved(input): Promise<StorageWorkflowDefinitionType | null>;
  async listWorkflowDefinitionsResolved(input?): Promise<StorageListWorkflowDefinitionsOutput>;
}
```

**Reference:** Follow `packages/core/src/storage/domains/agents/base.ts`

**Acceptance Criteria:**

- Extends StorageDomain correctly
- All abstract methods defined
- Resolved getters implemented
- Exported from index files

---

#### AGENT G: LibSQL Implementation

**Goal:** Implement workflow definitions storage for LibSQL.

**Files to create:**

- `stores/libsql/src/storage/domains/workflow-definitions/index.ts`

**Files to modify:**

- `stores/libsql/src/storage/index.ts` (register in getStore)

**Reference:** Follow `stores/libsql/src/storage/domains/agents/index.ts`

**Implementation details:**

- `MANAGED_TABLES` static property
- `init()` - create tables with proper schema
- Index definitions (workflowDefinitionId, unique version constraint)
- All CRUD methods with proper SQL
- All version methods
- Cascade delete (versions deleted when definition deleted)
- JSON serialization/deserialization

**Acceptance Criteria:**

- All abstract methods implemented
- Tables created correctly
- Cascade delete works
- Registered in getStore()

---

#### AGENT H: Server Handlers

**Goal:** Create API handlers for workflow definitions CRUD and versions.

**Files to create:**

- `packages/server/src/server/handlers/workflow-definitions.ts`
- `packages/server/src/server/handlers/workflow-definition-versions.ts`

**Handlers to implement:**

CRUD routes:

- `LIST_WORKFLOW_DEFINITIONS_ROUTE` - GET /api/workflow-definitions
- `CREATE_WORKFLOW_DEFINITION_ROUTE` - POST /api/workflow-definitions
- `GET_WORKFLOW_DEFINITION_ROUTE` - GET /api/workflow-definitions/:workflowDefinitionId
- `UPDATE_WORKFLOW_DEFINITION_ROUTE` - PATCH /api/workflow-definitions/:workflowDefinitionId
- `DELETE_WORKFLOW_DEFINITION_ROUTE` - DELETE /api/workflow-definitions/:workflowDefinitionId

Version routes:

- `LIST_DEFINITION_VERSIONS_ROUTE` - GET /api/workflow-definitions/:id/versions
- `CREATE_DEFINITION_VERSION_ROUTE` - POST /api/workflow-definitions/:id/versions
- `GET_DEFINITION_VERSION_ROUTE` - GET /api/workflow-definitions/:id/versions/:versionId
- `ACTIVATE_DEFINITION_VERSION_ROUTE` - POST /api/workflow-definitions/:id/versions/:versionId/activate
- `DELETE_DEFINITION_VERSION_ROUTE` - DELETE /api/workflow-definitions/:id/versions/:versionId
- `COMPARE_DEFINITION_VERSIONS_ROUTE` - GET /api/workflow-definitions/:id/versions/compare

**Include validation:**

```typescript
async function validateWorkflowDefinition(mastra, definition): Promise<{ valid: boolean; errors: string[] }> {
  // Validate agent/tool/workflow references exist
  // Validate stepGraph references valid step IDs
}
```

**Reference:** Follow `packages/server/src/server/handlers/stored-agents.ts`

**Acceptance Criteria:**

- All handlers follow existing patterns
- Validation runs at save time
- Auto-versioning on update
- Proper error handling

---

#### AGENT I: Step Resolvers

**Goal:** Create functions to resolve declarative step definitions to executable Step objects.

**Files to create:**

- `packages/core/src/workflows/definition-resolver/resolve-steps.ts`
- `packages/core/src/workflows/definition-resolver/__tests__/resolve-steps.test.ts`

**Functions to implement:**

```typescript
function resolveStep(mastra, stepId, definition: DeclarativeStepDefinition): Step;
function resolveAgentStep(mastra, stepId, def: AgentStepDef): Step;
function resolveToolStep(mastra, stepId, def: ToolStepDef): Step;
function resolveWorkflowStep(mastra, stepId, def: WorkflowStepDef): Step;
function resolveTransformStep(stepId, def: TransformStepDef): Step;
function resolveSuspendStep(stepId, def: SuspendStepDef): Step;
```

**Implementation notes:**

- Agent steps: Try code-defined first, then stored agents
- Workflow steps: Try code-defined first, then workflow definitions
- Transform steps: Handle stateUpdates
- Suspend steps: Handle suspend/resume flow

**Acceptance Criteria:**

- All step types resolve correctly
- Works with both code-defined and stored primitives
- Unit tests for each step type

---

#### AGENT J: UI List & Create Dialog

**Goal:** Create the workflow definitions list and create dialog components.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/components/workflow-definitions-table.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/create-workflow-definition-dialog.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/delete-workflow-definition-confirm.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/index.ts`

**Reference:** Follow `packages/playground-ui/src/domains/agents/components/`

**Acceptance Criteria:**

- Table shows definitions with name, description, step count
- Source badge for "code" vs "stored"
- Create dialog with basic fields
- Delete confirmation
- Integrates with hooks

---

### PHASE 3: Integration

---

#### AGENT K: In-Memory Storage

**Goal:** Implement in-memory storage for testing.

**Files to create:**

- `packages/core/src/storage/domains/workflow-definitions/inmemory.ts`

**Files to modify:**

- `packages/core/src/storage/domains/inmemory-db.ts` (add maps)
- `packages/core/src/storage/domains/workflow-definitions/index.ts` (export)

**Reference:** Follow `packages/core/src/storage/domains/agents/inmemory.ts`

**Acceptance Criteria:**

- All abstract methods implemented
- Deep cloning for immutability
- Cascade delete works
- Exported from index

---

#### AGENT L: Server Routes

**Goal:** Create and register route definitions.

**Files to create:**

- `packages/server/src/server/server-adapter/routes/workflow-definitions.ts`
- `packages/server/src/server/server-adapter/routes/workflow-definition-versions.ts`

**Files to modify:**

- `packages/server/src/server/server-adapter/routes/index.ts` (register routes)

**Reference:** Follow stored-agents and agent-versions routes

**Acceptance Criteria:**

- All routes exported
- Proper ordering (COMPARE before GET for versions)
- Registered in routes index

---

#### AGENT M: Resolver Class

**Goal:** Create the main WorkflowDefinitionResolver class.

**Files to create:**

- `packages/core/src/workflows/definition-resolver/index.ts`

**Files to modify:**

- `packages/core/src/workflows/index.ts` (export resolver)

**Class to implement:**

```typescript
class WorkflowDefinitionResolver {
  constructor(private mastra: Mastra) {}

  resolve(definition: StorageWorkflowDefinitionType): Workflow {
    // 1. Convert JSON schemas to Zod
    // 2. Resolve all step definitions to Steps
    // 3. Build step graph using workflow builder methods
    // 4. Commit and return workflow
  }

  private buildStepGraph(workflow, stepGraph, resolvedSteps): void {
    // Convert DefinitionStepFlowEntry[] to .then()/.parallel()/.branch() calls
  }
}
```

**Include:**

- Cycle detection for nested workflow definitions
- Error handling with helpful messages

**Acceptance Criteria:**

- Resolves definitions to executable Workflows
- Handles all step graph entry types
- Cycle detection prevents infinite loops

---

#### AGENT N: Client SDK

**Goal:** Create client SDK support for workflow definitions.

**Files to create:**

- `client-sdks/client-js/src/resources/workflow-definition.ts`

**Files to modify:**

- `client-sdks/client-js/src/types.ts` (add types)
- `client-sdks/client-js/src/client.ts` (add methods)
- `client-sdks/client-js/src/resources/index.ts` (export)

**Types to add:**

- `WorkflowDefinitionResponse`
- `CreateWorkflowDefinitionInput`
- `UpdateWorkflowDefinitionInput`
- `WorkflowDefinitionVersionResponse`
- `ListWorkflowDefinitionsResponse`

**WorkflowDefinition resource:**

- `details(requestContext?)` - get definition
- `update(params, requestContext?)` - update
- `delete(requestContext?)` - delete
- `createRun(params, requestContext?)` - execute
- Version methods (list, create, get, activate, delete)

**Client methods:**

- `listWorkflowDefinitions(params?, requestContext?)`
- `getWorkflowDefinition(id)` - returns WorkflowDefinition resource
- `createWorkflowDefinition(params, requestContext?)`

**Reference:** Follow `client-sdks/client-js/src/resources/stored-agent.ts`

**Acceptance Criteria:**

- All methods implemented
- requestContext support
- Types match server responses

---

#### AGENT O: UI Step Palette

**Goal:** Create step selection component for workflow editor.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/components/step-palette.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/step-config-panel.tsx`

**StepPalette component:**

- Lists available agents (code + stored)
- Lists available tools
- Lists available workflows (code + definitions)
- Search/filter capability
- Categorized sections

**StepConfigPanel component:**

- Configure step inputs
- Input mapping editor
- Shows input/output schemas

**Acceptance Criteria:**

- Shows all available primitives
- Integrates with agent/tool/workflow lists
- Basic input configuration works

---

### PHASE 4: Testing & Polish

---

#### AGENT P: Mastra Integration

**Goal:** Add workflow definition methods to Mastra class.

**Files to modify:**

- `packages/core/src/mastra/index.ts`

**Methods to add:**

```typescript
class Mastra {
  #workflowDefinitionResolver?: WorkflowDefinitionResolver;

  async getWorkflowDefinitionById(
    id: string,
    options?: { raw?: boolean; versionId?: string; versionNumber?: number }
  ): Promise<Workflow | StorageWorkflowDefinitionType | null>;

  async listWorkflowDefinitions(args?: {
    page?: number;
    perPage?: number | false;
    orderBy?: StorageOrderBy;
    raw?: boolean;
  }): Promise<{ definitions: (Workflow | StorageWorkflowDefinitionType)[]; ... }>;

  #getWorkflowDefinitionResolver(): WorkflowDefinitionResolver;
}
```

**Acceptance Criteria:**

- Methods follow existing patterns
- Resolver lazily initialized
- Raw vs resolved options work

---

#### AGENT Q: Parity Tests

**Goal:** Verify workflow definitions produce identical behavior to code-defined workflows.

**Files to create:**

- `packages/core/src/workflows/__tests__/definition-parity.test.ts`

**Test cases:**

1. Sequential agent/tool steps
2. Parallel steps
3. Conditional/branch
4. Loops (dowhile/dountil)
5. Foreach
6. Suspend/resume
7. Nested workflows
8. State management
9. Input mapping variations

**Test pattern:**

```typescript
it('sequential steps produce same output', async () => {
  // Create code-defined workflow
  const codeWorkflow = new Workflow({...}).then(step1).then(step2).commit();

  // Create equivalent definition
  const definition = { stepGraph: [...], steps: {...} };
  const resolvedWorkflow = resolver.resolve(definition);

  // Run both with same input
  const input = { ... };
  const codeResult = await codeWorkflow.createRun().start({ input });
  const defResult = await resolvedWorkflow.createRun().start({ input });

  // Verify same output
  expect(defResult.result).toEqual(codeResult.result);
});
```

**Acceptance Criteria:**

- All test cases pass
- Edge cases covered
- Clear failure messages

---

#### AGENT R: Storage Tests

**Goal:** Test storage implementations.

**Files to create:**

- `packages/core/src/storage/domains/workflow-definitions/__tests__/inmemory.test.ts`
- `stores/libsql/src/__tests__/workflow-definitions.test.ts`

**Test cases:**

- CRUD operations
- Version operations
- Cascade delete
- Pagination
- Filtering (ownerId, metadata)
- Resolved getters

**Acceptance Criteria:**

- All operations tested
- Edge cases covered
- Run with `pnpm test`

---

#### AGENT S: UI Wiring

**Goal:** Connect UI components to backend and integrate with workflows page.

**Files to modify:**

- `packages/playground/src/pages/workflows/index.tsx`
- Or create new page for workflow definitions

**Integration:**

- Show workflow definitions in list (alongside code-defined)
- "Create Definition" button
- Navigation to definition editor
- Connect hooks to real API

**Acceptance Criteria:**

- Definitions appear in UI
- Create/edit/delete works
- Navigation works

---

#### AGENT T: Version Management UI

**Goal:** Add version management components.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/components/workflow-definition-versions.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/version-compare-dialog.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/save-version-dialog.tsx`

**Reference:** Follow agent version components

**Acceptance Criteria:**

- Version list with timestamps
- Activate version action
- Compare versions dialog
- Save version with name/message

---

## API Endpoints

### Workflow Definitions CRUD

| Method | Path                            | Description                |
| ------ | ------------------------------- | -------------------------- |
| GET    | `/api/workflow-definitions`     | List workflow definitions  |
| POST   | `/api/workflow-definitions`     | Create workflow definition |
| GET    | `/api/workflow-definitions/:id` | Get workflow definition    |
| PATCH  | `/api/workflow-definitions/:id` | Update workflow definition |
| DELETE | `/api/workflow-definitions/:id` | Delete workflow definition |

### Workflow Definition Versions

| Method | Path                                                         | Description      |
| ------ | ------------------------------------------------------------ | ---------------- |
| GET    | `/api/workflow-definitions/:id/versions`                     | List versions    |
| POST   | `/api/workflow-definitions/:id/versions`                     | Create version   |
| GET    | `/api/workflow-definitions/:id/versions/compare`             | Compare versions |
| GET    | `/api/workflow-definitions/:id/versions/:versionId`          | Get version      |
| POST   | `/api/workflow-definitions/:id/versions/:versionId/activate` | Activate version |
| DELETE | `/api/workflow-definitions/:id/versions/:versionId`          | Delete version   |

### Execution

| Method | Path                                       | Description          |
| ------ | ------------------------------------------ | -------------------- |
| POST   | `/api/workflow-definitions/:id/create-run` | Create and start run |
| POST   | `/api/workflow-definitions/:id/stream`     | Stream execution     |
| POST   | `/api/workflow-definitions/:id/resume`     | Resume suspended     |

---

## Example Workflow Definition

```json
{
  "id": "customer-support-workflow",
  "name": "Customer Support",
  "description": "Classify and respond to customer requests",
  "inputSchema": {
    "type": "object",
    "properties": {
      "request": { "type": "string" },
      "customerId": { "type": "string" }
    },
    "required": ["request", "customerId"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "response": { "type": "string" },
      "category": { "type": "string" }
    }
  },
  "stepGraph": [
    { "type": "step", "step": { "id": "classify" } },
    {
      "type": "conditional",
      "branches": [
        {
          "condition": {
            "type": "compare",
            "field": { "$ref": "steps.classify.output.category" },
            "operator": "equals",
            "value": { "$literal": "billing" }
          },
          "stepId": "billing-agent"
        },
        {
          "condition": {
            "type": "compare",
            "field": { "$ref": "steps.classify.output.category" },
            "operator": "equals",
            "value": { "$literal": "technical" }
          },
          "stepId": "tech-agent"
        }
      ],
      "default": "general-agent"
    }
  ],
  "steps": {
    "classify": {
      "type": "agent",
      "agentId": "classifier-agent",
      "input": {
        "prompt": { "$ref": "input.request" }
      },
      "structuredOutput": {
        "type": "object",
        "properties": {
          "category": { "type": "string", "enum": ["billing", "technical", "general"] }
        }
      }
    },
    "billing-agent": {
      "type": "agent",
      "agentId": "billing-support",
      "input": {
        "prompt": { "$ref": "input.request" }
      }
    },
    "tech-agent": {
      "type": "agent",
      "agentId": "technical-support",
      "input": {
        "prompt": { "$ref": "input.request" }
      }
    },
    "general-agent": {
      "type": "agent",
      "agentId": "general-support",
      "input": {
        "prompt": { "$ref": "input.request" }
      }
    }
  }
}
```

---

## Testing Strategy

### Unit Tests

- `evaluate-ref.test.ts` - Variable reference evaluation
- `evaluate-condition.test.ts` - Condition evaluation
- `json-schema-to-zod.test.ts` - Schema conversion
- `resolve-steps.test.ts` - Step resolution

### Integration Tests

- `inmemory.test.ts` - In-memory storage
- `workflow-definitions.test.ts` - LibSQL storage
- `workflow-definitions.test.ts` - Server handlers

### Parity Tests

- `definition-parity.test.ts` - Code vs definition comparison

### E2E Tests

- Create definition via API
- Execute definition
- Verify output matches code-defined workflow

---

## Future Enhancements

1. **PostgreSQL & MongoDB implementations** - After LibSQL is stable
2. **Visual workflow editor** - Drag-and-drop step graph builder
3. **JSONata expressions** - For complex data transformations
4. **Arithmetic in state updates** - `{ $expr: 'state.counter + 1' }`
5. **Import/Export** - Share workflow definitions as files
6. **Templates** - Pre-built workflow definition templates
7. **Validation UI** - Real-time validation feedback in editor

---

## Detailed Task Specifications: Phase 3

### AGENT K: In-Memory Storage

**Goal:** Implement in-memory storage for testing and development.

**Files to create:**

- `packages/core/src/storage/domains/workflow-definitions/inmemory.ts`

**Files to modify:**

- `packages/core/src/storage/domains/inmemory-db.ts` (add maps)
- `packages/core/src/storage/domains/workflow-definitions/index.ts` (export)

**Implementation:**

```typescript
// inmemory-db.ts additions
export const inMemoryWorkflowDefinitions = new Map<string, StorageWorkflowDefinitionType>();
export const inMemoryWorkflowDefinitionVersions = new Map<string, StorageWorkflowDefinitionVersionType>();

// inmemory.ts
import {
  WorkflowDefinitionsStorage,
  type WorkflowDefinitionVersion,
  type CreateVersionInput,
  type ListVersionsInput,
  type ListVersionsOutput,
} from './base';
import { inMemoryWorkflowDefinitions, inMemoryWorkflowDefinitionVersions } from '../inmemory-db';
import type {
  StorageWorkflowDefinitionType,
  StorageCreateWorkflowDefinitionInput,
  StorageUpdateWorkflowDefinitionInput,
  StorageListWorkflowDefinitionsInput,
  StorageListWorkflowDefinitionsOutput,
} from '../../types';

export class InMemoryWorkflowDefinitionsStorage extends WorkflowDefinitionsStorage {
  async createWorkflowDefinition(input: {
    definition: StorageCreateWorkflowDefinitionInput;
  }): Promise<StorageWorkflowDefinitionType> {
    const now = new Date();
    const definition: StorageWorkflowDefinitionType = {
      ...structuredClone(input.definition),
      createdAt: now,
      updatedAt: now,
    };
    inMemoryWorkflowDefinitions.set(definition.id, definition);
    return structuredClone(definition);
  }

  async getWorkflowDefinitionById(input: { id: string }): Promise<StorageWorkflowDefinitionType | null> {
    const definition = inMemoryWorkflowDefinitions.get(input.id);
    return definition ? structuredClone(definition) : null;
  }

  async updateWorkflowDefinition(input: StorageUpdateWorkflowDefinitionInput): Promise<StorageWorkflowDefinitionType> {
    const existing = inMemoryWorkflowDefinitions.get(input.id);
    if (!existing) {
      throw new Error(`Workflow definition ${input.id} not found`);
    }

    const { id, ...updates } = input;
    const updated: StorageWorkflowDefinitionType = {
      ...existing,
      ...updates,
      updatedAt: new Date(),
    };
    inMemoryWorkflowDefinitions.set(id, updated);
    return structuredClone(updated);
  }

  async deleteWorkflowDefinition(input: { id: string }): Promise<void> {
    // Cascade delete versions
    await this.deleteVersionsByWorkflowDefinitionId(input.id);
    inMemoryWorkflowDefinitions.delete(input.id);
  }

  async listWorkflowDefinitions(
    input?: StorageListWorkflowDefinitionsInput,
  ): Promise<StorageListWorkflowDefinitionsOutput> {
    let definitions = Array.from(inMemoryWorkflowDefinitions.values());

    // Filter by ownerId
    if (input?.ownerId) {
      definitions = definitions.filter(d => d.ownerId === input.ownerId);
    }

    // Filter by metadata
    if (input?.metadata) {
      definitions = definitions.filter(d => {
        if (!d.metadata) return false;
        return Object.entries(input.metadata!).every(([key, value]) => d.metadata![key] === value);
      });
    }

    // Sort
    const direction = input?.orderBy?.direction === 'ASC' ? 1 : -1;
    const field = input?.orderBy?.field || 'createdAt';
    definitions.sort((a, b) => {
      const aVal = a[field as keyof StorageWorkflowDefinitionType];
      const bVal = b[field as keyof StorageWorkflowDefinitionType];
      if (aVal < bVal) return -1 * direction;
      if (aVal > bVal) return 1 * direction;
      return 0;
    });

    // Paginate
    const total = definitions.length;
    const perPage = input?.perPage === false ? total : input?.perPage || 10;
    const page = input?.page || 0;
    const start = page * (perPage as number);
    const paged = definitions.slice(start, start + (perPage as number));

    return {
      definitions: paged.map(d => structuredClone(d)),
      total,
      page,
      perPage,
      hasMore: start + paged.length < total,
    };
  }

  // Version methods - similar pattern
  async createVersion(input: CreateVersionInput): Promise<WorkflowDefinitionVersion> {
    const version: StorageWorkflowDefinitionVersionType = {
      ...structuredClone(input),
      createdAt: new Date(),
    };
    inMemoryWorkflowDefinitionVersions.set(version.id, version);
    return structuredClone(version) as WorkflowDefinitionVersion;
  }

  async getVersion(id: string): Promise<WorkflowDefinitionVersion | null> {
    const version = inMemoryWorkflowDefinitionVersions.get(id);
    return version ? (structuredClone(version) as WorkflowDefinitionVersion) : null;
  }

  async getVersionByNumber(
    workflowDefinitionId: string,
    versionNumber: number,
  ): Promise<WorkflowDefinitionVersion | null> {
    for (const version of inMemoryWorkflowDefinitionVersions.values()) {
      if (version.workflowDefinitionId === workflowDefinitionId && version.versionNumber === versionNumber) {
        return structuredClone(version) as WorkflowDefinitionVersion;
      }
    }
    return null;
  }

  async getLatestVersion(workflowDefinitionId: string): Promise<WorkflowDefinitionVersion | null> {
    let latest: StorageWorkflowDefinitionVersionType | null = null;
    for (const version of inMemoryWorkflowDefinitionVersions.values()) {
      if (version.workflowDefinitionId === workflowDefinitionId) {
        if (!latest || version.versionNumber > latest.versionNumber) {
          latest = version;
        }
      }
    }
    return latest ? (structuredClone(latest) as WorkflowDefinitionVersion) : null;
  }

  async listVersions(input: ListVersionsInput): Promise<ListVersionsOutput> {
    let versions = Array.from(inMemoryWorkflowDefinitionVersions.values()).filter(
      v => v.workflowDefinitionId === input.workflowDefinitionId,
    );

    // Sort
    const direction = input.orderBy?.direction === 'ASC' ? 1 : -1;
    const field = input.orderBy?.field || 'versionNumber';
    versions.sort((a, b) => {
      const aVal = a[field as keyof StorageWorkflowDefinitionVersionType];
      const bVal = b[field as keyof StorageWorkflowDefinitionVersionType];
      if (aVal < bVal) return -1 * direction;
      if (aVal > bVal) return 1 * direction;
      return 0;
    });

    // Paginate
    const total = versions.length;
    const perPage = input.perPage === false ? total : input.perPage || 10;
    const page = input.page || 0;
    const start = page * (perPage as number);
    const paged = versions.slice(start, start + (perPage as number));

    return {
      versions: paged.map(v => structuredClone(v)) as WorkflowDefinitionVersion[],
      total,
      page,
      perPage,
      hasMore: start + paged.length < total,
    };
  }

  async deleteVersion(id: string): Promise<void> {
    inMemoryWorkflowDefinitionVersions.delete(id);
  }

  async deleteVersionsByWorkflowDefinitionId(workflowDefinitionId: string): Promise<void> {
    for (const [id, version] of inMemoryWorkflowDefinitionVersions) {
      if (version.workflowDefinitionId === workflowDefinitionId) {
        inMemoryWorkflowDefinitionVersions.delete(id);
      }
    }
  }

  async countVersions(workflowDefinitionId: string): Promise<number> {
    let count = 0;
    for (const version of inMemoryWorkflowDefinitionVersions.values()) {
      if (version.workflowDefinitionId === workflowDefinitionId) {
        count++;
      }
    }
    return count;
  }
}
```

**Reference:** Follow `packages/core/src/storage/domains/agents/inmemory.ts`

**Acceptance Criteria:**

- All abstract methods implemented
- Deep cloning with `structuredClone()` for immutability
- Cascade delete works (deleting definition deletes its versions)
- Filtering by ownerId and metadata works
- Pagination and sorting work correctly
- Exported from index files

---

### AGENT L: Server Routes

**Goal:** Create and register route definitions for workflow definitions.

**Files to create:**

- `packages/server/src/server/server-adapter/routes/workflow-definitions.ts`
- `packages/server/src/server/server-adapter/routes/workflow-definition-versions.ts`

**Files to modify:**

- `packages/server/src/server/server-adapter/routes/index.ts` (register routes)

**Implementation:**

```typescript
// workflow-definitions.ts
import {
  LIST_WORKFLOW_DEFINITIONS_ROUTE,
  CREATE_WORKFLOW_DEFINITION_ROUTE,
  GET_WORKFLOW_DEFINITION_ROUTE,
  UPDATE_WORKFLOW_DEFINITION_ROUTE,
  DELETE_WORKFLOW_DEFINITION_ROUTE,
} from '../../handlers/workflow-definitions';

export const workflowDefinitionRoutes = [
  LIST_WORKFLOW_DEFINITIONS_ROUTE,
  CREATE_WORKFLOW_DEFINITION_ROUTE,
  GET_WORKFLOW_DEFINITION_ROUTE,
  UPDATE_WORKFLOW_DEFINITION_ROUTE,
  DELETE_WORKFLOW_DEFINITION_ROUTE,
];

export {
  LIST_WORKFLOW_DEFINITIONS_ROUTE,
  CREATE_WORKFLOW_DEFINITION_ROUTE,
  GET_WORKFLOW_DEFINITION_ROUTE,
  UPDATE_WORKFLOW_DEFINITION_ROUTE,
  DELETE_WORKFLOW_DEFINITION_ROUTE,
};

// workflow-definition-versions.ts
import {
  LIST_DEFINITION_VERSIONS_ROUTE,
  CREATE_DEFINITION_VERSION_ROUTE,
  COMPARE_DEFINITION_VERSIONS_ROUTE, // Must come before GET to avoid path collision
  GET_DEFINITION_VERSION_ROUTE,
  ACTIVATE_DEFINITION_VERSION_ROUTE,
  DELETE_DEFINITION_VERSION_ROUTE,
} from '../../handlers/workflow-definition-versions';

// Order matters: more specific routes first
export const workflowDefinitionVersionRoutes = [
  LIST_DEFINITION_VERSIONS_ROUTE,
  CREATE_DEFINITION_VERSION_ROUTE,
  COMPARE_DEFINITION_VERSIONS_ROUTE, // /compare before /:versionId
  GET_DEFINITION_VERSION_ROUTE,
  ACTIVATE_DEFINITION_VERSION_ROUTE,
  DELETE_DEFINITION_VERSION_ROUTE,
];

export {
  LIST_DEFINITION_VERSIONS_ROUTE,
  CREATE_DEFINITION_VERSION_ROUTE,
  COMPARE_DEFINITION_VERSIONS_ROUTE,
  GET_DEFINITION_VERSION_ROUTE,
  ACTIVATE_DEFINITION_VERSION_ROUTE,
  DELETE_DEFINITION_VERSION_ROUTE,
};

// index.ts additions
import { workflowDefinitionRoutes } from './workflow-definitions';
import { workflowDefinitionVersionRoutes } from './workflow-definition-versions';

// Add to allRoutes array
export const allRoutes = [
  // ... existing routes
  ...workflowDefinitionRoutes,
  ...workflowDefinitionVersionRoutes,
];
```

**Reference:** Follow `packages/server/src/server/server-adapter/routes/stored-agents.ts` and `agent-versions.ts`

**Acceptance Criteria:**

- All routes exported
- COMPARE route comes before GET (path collision avoidance)
- Registered in routes index
- Routes accessible via server

---

### AGENT M: Resolver Class

**Goal:** Create the main WorkflowDefinitionResolver class that orchestrates resolution.

**Files to create:**

- `packages/core/src/workflows/definition-resolver/index.ts`

**Files to modify:**

- `packages/core/src/workflows/index.ts` (export resolver)

**Implementation:**

```typescript
// index.ts
import type { Mastra } from '../../mastra';
import type { StorageWorkflowDefinitionType, DefinitionStepFlowEntry } from '../../storage/types';
import { Workflow } from '../workflow';
import { type Step } from '../step';
import { resolveStep } from './resolve-steps';
import { jsonSchemaToZod } from './json-schema-to-zod';
import { evaluateCondition } from './evaluate-condition';
import type { EvaluationContext } from './evaluate-ref';

export { evaluateRef, evaluateValueOrRef, evaluateInputMapping, type EvaluationContext } from './evaluate-ref';
export { evaluateCondition } from './evaluate-condition';
export { jsonSchemaToZod } from './json-schema-to-zod';
export { resolveStep } from './resolve-steps';

/**
 * Resolves a stored workflow definition to an executable Workflow instance.
 */
export class WorkflowDefinitionResolver {
  #mastra: Mastra;
  #resolutionStack: Set<string> = new Set(); // For cycle detection

  constructor(mastra: Mastra) {
    this.#mastra = mastra;
  }

  /**
   * Resolves a workflow definition to an executable Workflow.
   *
   * @param definition - The stored workflow definition
   * @returns An executable Workflow instance
   * @throws Error if resolution fails or circular dependency detected
   */
  resolve(definition: StorageWorkflowDefinitionType): Workflow {
    // Check for circular dependencies
    if (this.#resolutionStack.has(definition.id)) {
      const cycle = Array.from(this.#resolutionStack).join(' -> ') + ' -> ' + definition.id;
      throw new Error(`Circular workflow definition dependency detected: ${cycle}`);
    }

    this.#resolutionStack.add(definition.id);

    try {
      // 1. Convert JSON schemas to Zod
      const inputSchema = jsonSchemaToZod(definition.inputSchema);
      const outputSchema = jsonSchemaToZod(definition.outputSchema);
      const stateSchema = definition.stateSchema ? jsonSchemaToZod(definition.stateSchema) : undefined;

      // 2. Resolve all step definitions to executable Steps
      const resolvedSteps: Record<string, Step> = {};
      for (const [stepId, stepDef] of Object.entries(definition.steps)) {
        resolvedSteps[stepId] = resolveStep(this.#mastra, stepId, stepDef, this);
      }

      // 3. Create workflow with resolved configuration
      const workflow = new Workflow({
        id: definition.id,
        description: definition.description,
        inputSchema,
        outputSchema,
        stateSchema,
        retryConfig: definition.retryConfig,
        mastra: this.#mastra,
      });

      // 4. Build step graph from stepGraph entries
      this.#buildStepGraph(workflow, definition.stepGraph, resolvedSteps);

      // 5. Commit and return
      workflow.commit();
      return workflow;
    } finally {
      this.#resolutionStack.delete(definition.id);
    }
  }

  /**
   * Converts the declarative step graph to workflow builder method calls.
   */
  #buildStepGraph(workflow: Workflow, stepGraph: DefinitionStepFlowEntry[], resolvedSteps: Record<string, Step>): void {
    for (const entry of stepGraph) {
      switch (entry.type) {
        case 'step': {
          const step = resolvedSteps[entry.step.id];
          if (!step) {
            throw new Error(`Step "${entry.step.id}" not found in steps definition`);
          }
          workflow.then(step);
          break;
        }

        case 'parallel': {
          const parallelSteps = entry.steps.map(s => {
            const step = resolvedSteps[s.step.id];
            if (!step) {
              throw new Error(`Parallel step "${s.step.id}" not found in steps definition`);
            }
            return step;
          });
          workflow.parallel(parallelSteps);
          break;
        }

        case 'conditional': {
          // Build condition functions from declarative conditions
          const branches: Array<[(...args: any[]) => Promise<boolean>, Step]> = [];

          for (const branch of entry.branches) {
            const step = resolvedSteps[branch.stepId];
            if (!step) {
              throw new Error(`Conditional step "${branch.stepId}" not found in steps definition`);
            }

            const conditionDef = branch.condition;
            const conditionFn = async (params: {
              inputData: any;
              getInitData: () => any;
              getStepResult: (step: any) => any;
              state: any;
            }) => {
              const context: EvaluationContext = {
                input: params.getInitData?.() || {},
                steps: this.#buildStepsContext(params.getStepResult),
                state: params.state || {},
              };
              return evaluateCondition(conditionDef, context);
            };

            branches.push([conditionFn, step]);
          }

          // Add default branch if specified
          if (entry.default) {
            const defaultStep = resolvedSteps[entry.default];
            if (defaultStep) {
              branches.push([async () => true, defaultStep]);
            }
          }

          workflow.branch(branches);
          break;
        }

        case 'loop': {
          const step = resolvedSteps[entry.stepId];
          if (!step) {
            throw new Error(`Loop step "${entry.stepId}" not found in steps definition`);
          }

          const conditionDef = entry.condition;
          const conditionFn = async (params: {
            inputData: any;
            getInitData: () => any;
            getStepResult: (step: any) => any;
            state: any;
          }) => {
            const context: EvaluationContext = {
              input: params.getInitData?.() || {},
              steps: this.#buildStepsContext(params.getStepResult),
              state: params.state || {},
            };
            return evaluateCondition(conditionDef, context);
          };

          if (entry.loopType === 'dowhile') {
            workflow.dowhile(step, conditionFn);
          } else {
            workflow.dountil(step, conditionFn);
          }
          break;
        }

        case 'foreach': {
          const step = resolvedSteps[entry.stepId];
          if (!step) {
            throw new Error(`Foreach step "${entry.stepId}" not found in steps definition`);
          }

          // Note: foreach needs special handling for collection evaluation
          // This is a simplified implementation
          workflow.foreach(step, { concurrency: entry.concurrency || 1 });
          break;
        }

        case 'sleep': {
          workflow.sleep(entry.duration);
          break;
        }

        case 'sleepUntil': {
          // sleepUntil with dynamic timestamp needs special handling
          // For now, skip if it's a variable ref
          if ('$literal' in entry.timestamp) {
            workflow.sleepUntil(new Date(entry.timestamp.$literal as string));
          }
          break;
        }

        case 'map': {
          // Map entries transform data between steps
          // This is handled through the transform step type instead
          break;
        }

        default:
          throw new Error(`Unknown step graph entry type: ${(entry as any).type}`);
      }
    }
  }

  /**
   * Builds a steps context object for condition evaluation.
   * This is a helper to extract step results.
   */
  #buildStepsContext(getStepResult: (step: any) => any): Record<string, { output: unknown }> {
    // This needs access to the actual step references
    // For now, return empty - will need refinement
    return {};
  }

  /**
   * Get the Mastra instance for nested resolution.
   */
  getMastra(): Mastra {
    return this.#mastra;
  }
}
```

**Acceptance Criteria:**

- Resolves definitions to executable Workflows
- Handles all step graph entry types (step, parallel, conditional, loop, foreach, sleep)
- Cycle detection prevents infinite loops in nested definitions
- Error messages are helpful for debugging
- Exported from workflows index

---

### AGENT N: Client SDK

**Goal:** Create client SDK support for workflow definitions.

**Files to create:**

- `client-sdks/client-js/src/resources/workflow-definition.ts`

**Files to modify:**

- `client-sdks/client-js/src/types.ts` (add types)
- `client-sdks/client-js/src/client.ts` (add methods)
- `client-sdks/client-js/src/resources/index.ts` (export)

**Types to add (types.ts):**

```typescript
// Workflow Definition Types
export interface WorkflowDefinitionResponse {
  id: string;
  name: string;
  description?: string;
  inputSchema: Record<string, unknown>;
  outputSchema: Record<string, unknown>;
  stateSchema?: Record<string, unknown>;
  stepGraph: unknown[]; // DefinitionStepFlowEntry[]
  steps: Record<string, unknown>; // DeclarativeStepDefinition
  retryConfig?: { attempts?: number; delay?: number };
  ownerId?: string;
  activeVersionId?: string;
  metadata?: Record<string, unknown>;
  createdAt: string;
  updatedAt: string;
}

export interface CreateWorkflowDefinitionInput {
  id: string;
  name: string;
  description?: string;
  inputSchema: Record<string, unknown>;
  outputSchema: Record<string, unknown>;
  stateSchema?: Record<string, unknown>;
  stepGraph: unknown[];
  steps: Record<string, unknown>;
  retryConfig?: { attempts?: number; delay?: number };
  metadata?: Record<string, unknown>;
}

export interface UpdateWorkflowDefinitionInput {
  name?: string;
  description?: string;
  inputSchema?: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  stateSchema?: Record<string, unknown>;
  stepGraph?: unknown[];
  steps?: Record<string, unknown>;
  retryConfig?: { attempts?: number; delay?: number };
  metadata?: Record<string, unknown>;
}

export interface ListWorkflowDefinitionsParams {
  page?: number;
  perPage?: number;
  ownerId?: string;
}

export interface ListWorkflowDefinitionsResponse {
  definitions: WorkflowDefinitionResponse[];
  total: number;
  page: number;
  perPage: number;
  hasMore: boolean;
}

export interface WorkflowDefinitionVersionResponse {
  id: string;
  workflowDefinitionId: string;
  versionNumber: number;
  name?: string;
  snapshot: WorkflowDefinitionResponse;
  changedFields?: string[];
  changeMessage?: string;
  createdAt: string;
}

export interface ListWorkflowDefinitionVersionsParams {
  page?: number;
  perPage?: number;
}

export interface ListWorkflowDefinitionVersionsResponse {
  versions: WorkflowDefinitionVersionResponse[];
  total: number;
  page: number;
  perPage: number;
  hasMore: boolean;
}

export interface CreateWorkflowDefinitionVersionInput {
  name?: string;
  changeMessage?: string;
}

export interface CompareWorkflowDefinitionVersionsResponse {
  version1: WorkflowDefinitionVersionResponse;
  version2: WorkflowDefinitionVersionResponse;
  changedFields: string[];
}
```

**Resource class (workflow-definition.ts):**

```typescript
import type { MastraClient } from '../client';
import type {
  WorkflowDefinitionResponse,
  UpdateWorkflowDefinitionInput,
  WorkflowDefinitionVersionResponse,
  ListWorkflowDefinitionVersionsParams,
  ListWorkflowDefinitionVersionsResponse,
  CreateWorkflowDefinitionVersionInput,
  CompareWorkflowDefinitionVersionsResponse,
  RequestContext,
} from '../types';

export class WorkflowDefinition {
  #client: MastraClient;
  #id: string;

  constructor(client: MastraClient, id: string) {
    this.#client = client;
    this.#id = id;
  }

  get id(): string {
    return this.#id;
  }

  /**
   * Get the workflow definition details.
   */
  async details(requestContext?: RequestContext): Promise<WorkflowDefinitionResponse> {
    return this.#client.request<WorkflowDefinitionResponse>(
      `/api/workflow-definitions/${this.#id}`,
      { method: 'GET' },
      requestContext,
    );
  }

  /**
   * Update the workflow definition.
   */
  async update(
    params: UpdateWorkflowDefinitionInput,
    requestContext?: RequestContext,
  ): Promise<WorkflowDefinitionResponse> {
    return this.#client.request<WorkflowDefinitionResponse>(
      `/api/workflow-definitions/${this.#id}`,
      { method: 'PATCH', body: params },
      requestContext,
    );
  }

  /**
   * Delete the workflow definition.
   */
  async delete(requestContext?: RequestContext): Promise<void> {
    await this.#client.request<void>(`/api/workflow-definitions/${this.#id}`, { method: 'DELETE' }, requestContext);
  }

  /**
   * Create a run for this workflow definition.
   */
  async createRun(params: { input: Record<string, unknown> }, requestContext?: RequestContext): Promise<unknown> {
    return this.#client.request(
      `/api/workflow-definitions/${this.#id}/create-run`,
      { method: 'POST', body: params },
      requestContext,
    );
  }

  // ==================== Version Methods ====================

  /**
   * List versions of this workflow definition.
   */
  async listVersions(
    params?: ListWorkflowDefinitionVersionsParams,
    requestContext?: RequestContext,
  ): Promise<ListWorkflowDefinitionVersionsResponse> {
    const searchParams = new URLSearchParams();
    if (params?.page !== undefined) searchParams.set('page', String(params.page));
    if (params?.perPage !== undefined) searchParams.set('perPage', String(params.perPage));

    const query = searchParams.toString();
    const url = `/api/workflow-definitions/${this.#id}/versions${query ? `?${query}` : ''}`;

    return this.#client.request<ListWorkflowDefinitionVersionsResponse>(url, { method: 'GET' }, requestContext);
  }

  /**
   * Create a new version of this workflow definition.
   */
  async createVersion(
    params?: CreateWorkflowDefinitionVersionInput,
    requestContext?: RequestContext,
  ): Promise<WorkflowDefinitionVersionResponse> {
    return this.#client.request<WorkflowDefinitionVersionResponse>(
      `/api/workflow-definitions/${this.#id}/versions`,
      { method: 'POST', body: params || {} },
      requestContext,
    );
  }

  /**
   * Get a specific version.
   */
  async getVersion(versionId: string, requestContext?: RequestContext): Promise<WorkflowDefinitionVersionResponse> {
    return this.#client.request<WorkflowDefinitionVersionResponse>(
      `/api/workflow-definitions/${this.#id}/versions/${versionId}`,
      { method: 'GET' },
      requestContext,
    );
  }

  /**
   * Activate a specific version.
   */
  async activateVersion(versionId: string, requestContext?: RequestContext): Promise<WorkflowDefinitionResponse> {
    return this.#client.request<WorkflowDefinitionResponse>(
      `/api/workflow-definitions/${this.#id}/versions/${versionId}/activate`,
      { method: 'POST' },
      requestContext,
    );
  }

  /**
   * Delete a specific version.
   */
  async deleteVersion(versionId: string, requestContext?: RequestContext): Promise<void> {
    await this.#client.request<void>(
      `/api/workflow-definitions/${this.#id}/versions/${versionId}`,
      { method: 'DELETE' },
      requestContext,
    );
  }

  /**
   * Compare two versions.
   */
  async compareVersions(
    versionId1: string,
    versionId2: string,
    requestContext?: RequestContext,
  ): Promise<CompareWorkflowDefinitionVersionsResponse> {
    const searchParams = new URLSearchParams();
    searchParams.set('version1', versionId1);
    searchParams.set('version2', versionId2);

    return this.#client.request<CompareWorkflowDefinitionVersionsResponse>(
      `/api/workflow-definitions/${this.#id}/versions/compare?${searchParams.toString()}`,
      { method: 'GET' },
      requestContext,
    );
  }
}
```

**Client methods (client.ts additions):**

```typescript
import { WorkflowDefinition } from './resources/workflow-definition';
import type {
  CreateWorkflowDefinitionInput,
  ListWorkflowDefinitionsParams,
  ListWorkflowDefinitionsResponse,
  WorkflowDefinitionResponse,
} from './types';

// Add to MastraClient class:

/**
 * List all workflow definitions.
 */
async listWorkflowDefinitions(
  params?: ListWorkflowDefinitionsParams,
  requestContext?: RequestContext
): Promise<ListWorkflowDefinitionsResponse> {
  const searchParams = new URLSearchParams();
  if (params?.page !== undefined) searchParams.set('page', String(params.page));
  if (params?.perPage !== undefined) searchParams.set('perPage', String(params.perPage));
  if (params?.ownerId) searchParams.set('ownerId', params.ownerId);

  const query = searchParams.toString();
  const url = `/api/workflow-definitions${query ? `?${query}` : ''}`;

  return this.request<ListWorkflowDefinitionsResponse>(url, { method: 'GET' }, requestContext);
}

/**
 * Get a workflow definition resource by ID.
 */
getWorkflowDefinition(id: string): WorkflowDefinition {
  return new WorkflowDefinition(this, id);
}

/**
 * Create a new workflow definition.
 */
async createWorkflowDefinition(
  params: CreateWorkflowDefinitionInput,
  requestContext?: RequestContext
): Promise<WorkflowDefinition> {
  const response = await this.request<WorkflowDefinitionResponse>(
    '/api/workflow-definitions',
    { method: 'POST', body: params },
    requestContext
  );
  return new WorkflowDefinition(this, response.id);
}
```

**Reference:** Follow `client-sdks/client-js/src/resources/stored-agent.ts`

**Acceptance Criteria:**

- All methods implemented following existing patterns
- requestContext support on all methods
- Types match server responses
- Exported from resources index

---

### AGENT O: UI Step Palette

**Goal:** Create step selection component for workflow editor.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/components/step-palette.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/step-config-panel.tsx`

**StepPalette Implementation:**

```typescript
// step-palette.tsx
import React, { useMemo, useState } from 'react';
import { useAgents } from '../../agents/hooks/use-agents';
import { useStoredAgents } from '../../agents/hooks/use-stored-agents';
import { useTools } from '../../tools/hooks/use-tools';
import { useWorkflows } from '../../workflows/hooks/use-workflows';
import { useWorkflowDefinitions } from '../hooks/use-workflow-definitions';
import { Input } from '../../../components/ui/input';
import { ScrollArea } from '../../../components/ui/scroll-area';
import { Badge } from '../../../components/ui/badge';
import { Bot, Wrench, Workflow, ArrowRightLeft, Pause, Search } from 'lucide-react';

interface StepPaletteProps {
  onSelectStep: (step: StepPaletteItem) => void;
}

interface StepPaletteItem {
  type: 'agent' | 'tool' | 'workflow' | 'transform' | 'suspend';
  id: string;
  name: string;
  description?: string;
  source: 'code' | 'stored';
}

export function StepPalette({ onSelectStep }: StepPaletteProps) {
  const [search, setSearch] = useState('');

  // Fetch all available primitives
  const { data: agents } = useAgents();
  const { data: storedAgents } = useStoredAgents();
  const { data: tools } = useTools();
  const { data: workflows } = useWorkflows();
  const { data: workflowDefinitions } = useWorkflowDefinitions();

  // Combine and categorize items
  const items = useMemo(() => {
    const result: StepPaletteItem[] = [];

    // Code-defined agents
    if (agents) {
      Object.entries(agents).forEach(([id, agent]) => {
        result.push({
          type: 'agent',
          id,
          name: agent.name || id,
          description: agent.description,
          source: 'code',
        });
      });
    }

    // Stored agents
    if (storedAgents?.agents) {
      storedAgents.agents.forEach(agent => {
        result.push({
          type: 'agent',
          id: agent.id,
          name: agent.name,
          description: agent.description,
          source: 'stored',
        });
      });
    }

    // Tools
    if (tools) {
      Object.entries(tools).forEach(([id, tool]) => {
        result.push({
          type: 'tool',
          id,
          name: tool.name || id,
          description: tool.description,
          source: 'code',
        });
      });
    }

    // Code-defined workflows
    if (workflows) {
      Object.entries(workflows).forEach(([id, workflow]) => {
        result.push({
          type: 'workflow',
          id,
          name: workflow.name || id,
          description: workflow.description,
          source: 'code',
        });
      });
    }

    // Workflow definitions
    if (workflowDefinitions?.definitions) {
      workflowDefinitions.definitions.forEach(def => {
        result.push({
          type: 'workflow',
          id: def.id,
          name: def.name,
          description: def.description,
          source: 'stored',
        });
      });
    }

    // Built-in step types
    result.push({
      type: 'transform',
      id: 'transform',
      name: 'Transform',
      description: 'Transform data between steps',
      source: 'code',
    });

    result.push({
      type: 'suspend',
      id: 'suspend',
      name: 'Suspend',
      description: 'Wait for external input',
      source: 'code',
    });

    return result;
  }, [agents, storedAgents, tools, workflows, workflowDefinitions]);

  // Filter by search
  const filteredItems = useMemo(() => {
    if (!search) return items;
    const lower = search.toLowerCase();
    return items.filter(
      item =>
        item.name.toLowerCase().includes(lower) ||
        item.description?.toLowerCase().includes(lower) ||
        item.id.toLowerCase().includes(lower)
    );
  }, [items, search]);

  // Group by type
  const groupedItems = useMemo(() => {
    const groups: Record<string, StepPaletteItem[]> = {
      agent: [],
      tool: [],
      workflow: [],
      transform: [],
      suspend: [],
    };
    filteredItems.forEach(item => {
      groups[item.type].push(item);
    });
    return groups;
  }, [filteredItems]);

  const typeIcons = {
    agent: Bot,
    tool: Wrench,
    workflow: Workflow,
    transform: ArrowRightLeft,
    suspend: Pause,
  };

  const typeLabels = {
    agent: 'Agents',
    tool: 'Tools',
    workflow: 'Workflows',
    transform: 'Transform',
    suspend: 'Suspend',
  };

  return (
    <div className="flex flex-col h-full">
      <div className="p-3 border-b">
        <div className="relative">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search steps..."
            value={search}
            onChange={e => setSearch(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      <ScrollArea className="flex-1">
        <div className="p-3 space-y-4">
          {Object.entries(groupedItems).map(([type, typeItems]) => {
            if (typeItems.length === 0) return null;

            const Icon = typeIcons[type as keyof typeof typeIcons];

            return (
              <div key={type}>
                <h3 className="text-sm font-medium text-muted-foreground mb-2 flex items-center gap-2">
                  <Icon className="h-4 w-4" />
                  {typeLabels[type as keyof typeof typeLabels]}
                </h3>
                <div className="space-y-1">
                  {typeItems.map(item => (
                    <button
                      key={`${item.type}-${item.id}`}
                      onClick={() => onSelectStep(item)}
                      className="w-full text-left p-2 rounded-md hover:bg-accent transition-colors"
                    >
                      <div className="flex items-center justify-between">
                        <span className="font-medium text-sm">{item.name}</span>
                        {item.source === 'stored' && (
                          <Badge variant="outline" className="text-xs">
                            stored
                          </Badge>
                        )}
                      </div>
                      {item.description && (
                        <p className="text-xs text-muted-foreground mt-0.5 line-clamp-2">
                          {item.description}
                        </p>
                      )}
                    </button>
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      </ScrollArea>
    </div>
  );
}
```

**StepConfigPanel Implementation:**

```typescript
// step-config-panel.tsx
import React from 'react';
import { Input } from '../../../components/ui/input';
import { Label } from '../../../components/ui/label';
import { Textarea } from '../../../components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../../components/ui/select';

interface StepConfigPanelProps {
  step: {
    id: string;
    type: 'agent' | 'tool' | 'workflow' | 'transform' | 'suspend';
    config: Record<string, unknown>;
  };
  availableSteps: Array<{ id: string; name: string }>;
  onChange: (config: Record<string, unknown>) => void;
}

export function StepConfigPanel({ step, availableSteps, onChange }: StepConfigPanelProps) {
  const updateConfig = (key: string, value: unknown) => {
    onChange({ ...step.config, [key]: value });
  };

  return (
    <div className="p-4 space-y-4">
      <h3 className="text-lg font-semibold">Configure Step: {step.id}</h3>

      {step.type === 'agent' && (
        <AgentStepConfig
          config={step.config}
          availableSteps={availableSteps}
          onChange={updateConfig}
        />
      )}

      {step.type === 'tool' && (
        <ToolStepConfig
          config={step.config}
          availableSteps={availableSteps}
          onChange={updateConfig}
        />
      )}

      {step.type === 'workflow' && (
        <WorkflowStepConfig
          config={step.config}
          availableSteps={availableSteps}
          onChange={updateConfig}
        />
      )}

      {step.type === 'transform' && (
        <TransformStepConfig
          config={step.config}
          availableSteps={availableSteps}
          onChange={updateConfig}
        />
      )}

      {step.type === 'suspend' && (
        <SuspendStepConfig
          config={step.config}
          onChange={updateConfig}
        />
      )}
    </div>
  );
}

function AgentStepConfig({ config, availableSteps, onChange }: any) {
  return (
    <div className="space-y-4">
      <div>
        <Label>Prompt Source</Label>
        <Select
          value={config.input?.prompt?.$ref || ''}
          onValueChange={value => onChange('input', { ...config.input, prompt: { $ref: value } })}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select prompt source" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="input.prompt">Workflow Input: prompt</SelectItem>
            <SelectItem value="input.message">Workflow Input: message</SelectItem>
            {availableSteps.map(s => (
              <SelectItem key={s.id} value={`steps.${s.id}.output.text`}>
                Step {s.name}: output.text
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        <Label>Custom Instructions (optional)</Label>
        <Textarea
          value={typeof config.input?.instructions === 'string' ? config.input.instructions : ''}
          onChange={e => onChange('input', { ...config.input, instructions: e.target.value || undefined })}
          placeholder="Override agent instructions for this step..."
        />
      </div>
    </div>
  );
}

function ToolStepConfig({ config, availableSteps, onChange }: any) {
  return (
    <div className="space-y-4">
      <p className="text-sm text-muted-foreground">
        Configure input mappings for the tool. Each input field should reference
        data from the workflow input or previous steps.
      </p>
      {/* Tool-specific input mapping UI */}
    </div>
  );
}

function WorkflowStepConfig({ config, availableSteps, onChange }: any) {
  return (
    <div className="space-y-4">
      <p className="text-sm text-muted-foreground">
        Configure input mappings for the nested workflow.
      </p>
      {/* Workflow-specific input mapping UI */}
    </div>
  );
}

function TransformStepConfig({ config, availableSteps, onChange }: any) {
  return (
    <div className="space-y-4">
      <p className="text-sm text-muted-foreground">
        Define output mappings to transform data between steps.
      </p>
      {/* Transform mapping UI */}
    </div>
  );
}

function SuspendStepConfig({ config, onChange }: any) {
  return (
    <div className="space-y-4">
      <div>
        <Label>Resume Schema (JSON)</Label>
        <Textarea
          value={JSON.stringify(config.resumeSchema || {}, null, 2)}
          onChange={e => {
            try {
              onChange('resumeSchema', JSON.parse(e.target.value));
            } catch {
              // Invalid JSON, ignore
            }
          }}
          placeholder='{ "type": "object", "properties": { ... } }'
          className="font-mono text-sm"
          rows={6}
        />
      </div>
    </div>
  );
}

export { StepConfigPanel };
```

**Acceptance Criteria:**

- Shows all available agents (code + stored)
- Shows all available tools
- Shows all available workflows (code + definitions)
- Search/filter capability
- Categorized sections with icons
- Basic input configuration for each step type
- Integrates with existing hooks

---

## Detailed Task Specifications: Phase 4

### AGENT P: Mastra Integration

**Goal:** Add workflow definition methods to Mastra class.

**Files to modify:**

- `packages/core/src/mastra/index.ts`

**Implementation:**

```typescript
// Add to Mastra class

import { WorkflowDefinitionResolver } from '../workflows/definition-resolver';
import type { StorageWorkflowDefinitionType, StorageListWorkflowDefinitionsInput } from '../storage/types';

// Private field
#workflowDefinitionResolver?: WorkflowDefinitionResolver;

/**
 * Get a workflow definition by ID.
 *
 * @param id - The workflow definition ID
 * @param options - Options for retrieval
 * @param options.raw - If true, return the raw storage type instead of resolving to Workflow
 * @param options.versionId - Get a specific version by ID
 * @param options.versionNumber - Get a specific version by number
 * @returns The workflow (resolved) or definition (raw), or null if not found
 */
async getWorkflowDefinitionById(
  id: string,
  options?: { raw?: boolean; versionId?: string; versionNumber?: number }
): Promise<Workflow | StorageWorkflowDefinitionType | null> {
  const storage = this.getStorage();
  if (!storage) {
    throw new Error('Storage not configured');
  }

  const store = await storage.getStore('workflowDefinitions');
  if (!store) {
    throw new Error('Workflow definitions storage not available');
  }

  let definition: StorageWorkflowDefinitionType | null;

  if (options?.versionId) {
    const version = await store.getVersion(options.versionId);
    definition = version?.snapshot ?? null;
  } else if (options?.versionNumber !== undefined) {
    const version = await store.getVersionByNumber(id, options.versionNumber);
    definition = version?.snapshot ?? null;
  } else {
    definition = await store.getWorkflowDefinitionByIdResolved({ id });
  }

  if (!definition) {
    return null;
  }

  if (options?.raw) {
    return definition;
  }

  // Resolve to executable Workflow
  return this.#getWorkflowDefinitionResolver().resolve(definition);
}

/**
 * List workflow definitions.
 *
 * @param args - List options
 * @param args.raw - If true, return raw storage types instead of resolving
 * @returns Paginated list of workflow definitions
 */
async listWorkflowDefinitions(args?: StorageListWorkflowDefinitionsInput & { raw?: boolean }): Promise<{
  definitions: (Workflow | StorageWorkflowDefinitionType)[];
  total: number;
  page: number;
  perPage: number | false;
  hasMore: boolean;
}> {
  const storage = this.getStorage();
  if (!storage) {
    throw new Error('Storage not configured');
  }

  const store = await storage.getStore('workflowDefinitions');
  if (!store) {
    throw new Error('Workflow definitions storage not available');
  }

  const { raw, ...listArgs } = args || {};
  const result = await store.listWorkflowDefinitionsResolved(listArgs);

  if (raw) {
    return result;
  }

  // Resolve each definition to executable Workflow
  const resolver = this.#getWorkflowDefinitionResolver();
  const definitions = result.definitions.map(def => resolver.resolve(def));

  return {
    ...result,
    definitions,
  };
}

/**
 * Get the workflow definition resolver (lazy initialization).
 */
#getWorkflowDefinitionResolver(): WorkflowDefinitionResolver {
  if (!this.#workflowDefinitionResolver) {
    this.#workflowDefinitionResolver = new WorkflowDefinitionResolver(this);
  }
  return this.#workflowDefinitionResolver;
}
```

**Acceptance Criteria:**

- Methods follow existing patterns (like getStoredAgentById)
- Resolver lazily initialized
- Raw vs resolved options work
- Version retrieval works
- Proper error handling

---

### AGENT Q: Parity Tests

**Goal:** Verify workflow definitions produce identical behavior to code-defined workflows.

**Files to create:**

- `packages/core/src/workflows/__tests__/definition-parity.test.ts`

**Test Implementation:**

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { Mastra } from '../../mastra';
import { Workflow, createStep } from '../index';
import { WorkflowDefinitionResolver } from '../definition-resolver';
import { Agent } from '../../agent';
import { createTool } from '../../tools';
import { z } from 'zod';
import type { StorageWorkflowDefinitionType } from '../../storage/types';

describe('Workflow Definition Parity Tests', () => {
  let mastra: Mastra;
  let resolver: WorkflowDefinitionResolver;

  // Mock agent for testing
  const mockAgent = new Agent({
    name: 'test-agent',
    instructions: 'You are a test agent',
    model: { provider: 'openai', name: 'gpt-4' },
  });

  // Mock tool for testing
  const mockTool = createTool({
    id: 'test-tool',
    description: 'A test tool',
    inputSchema: z.object({ input: z.string() }),
    outputSchema: z.object({ output: z.string() }),
    execute: async ({ context }) => {
      return { output: `processed: ${context.input}` };
    },
  });

  beforeEach(() => {
    mastra = new Mastra({
      agents: { 'test-agent': mockAgent },
      tools: { 'test-tool': mockTool },
    });
    resolver = new WorkflowDefinitionResolver(mastra);
  });

  describe('Sequential Steps', () => {
    it('sequential tool steps produce same output', async () => {
      // Code-defined workflow
      const step1 = createStep({
        id: 'step1',
        inputSchema: z.object({ input: z.string() }),
        outputSchema: z.object({ output: z.string() }),
        execute: async ({ inputData }) => ({ output: `step1: ${inputData.input}` }),
      });

      const step2 = createStep({
        id: 'step2',
        inputSchema: z.object({ output: z.string() }),
        outputSchema: z.object({ result: z.string() }),
        execute: async ({ inputData }) => ({ result: `step2: ${inputData.output}` }),
      });

      const codeWorkflow = new Workflow({
        id: 'code-sequential',
        inputSchema: z.object({ input: z.string() }),
        outputSchema: z.object({ result: z.string() }),
      })
        .then(step1)
        .then(step2)
        .commit();

      // Equivalent definition
      const definition: StorageWorkflowDefinitionType = {
        id: 'def-sequential',
        name: 'Definition Sequential',
        inputSchema: { type: 'object', properties: { input: { type: 'string' } }, required: ['input'] },
        outputSchema: { type: 'object', properties: { result: { type: 'string' } } },
        stepGraph: [
          { type: 'step', step: { id: 'step1' } },
          { type: 'step', step: { id: 'step2' } },
        ],
        steps: {
          step1: {
            type: 'transform',
            output: { output: { $ref: 'input.input' } },
            outputSchema: { type: 'object', properties: { output: { type: 'string' } } },
          },
          step2: {
            type: 'transform',
            output: { result: { $ref: 'steps.step1.output.output' } },
            outputSchema: { type: 'object', properties: { result: { type: 'string' } } },
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // Note: This is a simplified test - actual parity would need
      // the steps to have identical logic, which is hard with definitions
      const resolvedWorkflow = resolver.resolve(definition);

      expect(resolvedWorkflow).toBeDefined();
      expect(resolvedWorkflow.id).toBe('def-sequential');
    });
  });

  describe('Parallel Steps', () => {
    it('parallel steps are resolved correctly', async () => {
      const definition: StorageWorkflowDefinitionType = {
        id: 'def-parallel',
        name: 'Definition Parallel',
        inputSchema: { type: 'object', properties: { input: { type: 'string' } } },
        outputSchema: { type: 'object', properties: { result: { type: 'string' } } },
        stepGraph: [
          { type: 'step', step: { id: 'start' } },
          {
            type: 'parallel',
            steps: [
              { type: 'step', step: { id: 'branch1' } },
              { type: 'step', step: { id: 'branch2' } },
            ],
          },
          { type: 'step', step: { id: 'end' } },
        ],
        steps: {
          start: { type: 'transform', output: { data: { $ref: 'input.input' } }, outputSchema: {} },
          branch1: { type: 'transform', output: { result1: { $literal: 'branch1' } }, outputSchema: {} },
          branch2: { type: 'transform', output: { result2: { $literal: 'branch2' } }, outputSchema: {} },
          end: { type: 'transform', output: { result: { $literal: 'done' } }, outputSchema: {} },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const resolvedWorkflow = resolver.resolve(definition);
      expect(resolvedWorkflow).toBeDefined();
    });
  });

  describe('Conditional Steps', () => {
    it('conditional branches are resolved correctly', async () => {
      const definition: StorageWorkflowDefinitionType = {
        id: 'def-conditional',
        name: 'Definition Conditional',
        inputSchema: { type: 'object', properties: { value: { type: 'number' } } },
        outputSchema: { type: 'object', properties: { result: { type: 'string' } } },
        stepGraph: [
          { type: 'step', step: { id: 'start' } },
          {
            type: 'conditional',
            branches: [
              {
                condition: { type: 'compare', field: { $ref: 'input.value' }, operator: 'gt', value: { $literal: 10 } },
                stepId: 'high',
              },
              {
                condition: {
                  type: 'compare',
                  field: { $ref: 'input.value' },
                  operator: 'lte',
                  value: { $literal: 10 },
                },
                stepId: 'low',
              },
            ],
          },
        ],
        steps: {
          start: { type: 'transform', output: {}, outputSchema: {} },
          high: { type: 'transform', output: { result: { $literal: 'high' } }, outputSchema: {} },
          low: { type: 'transform', output: { result: { $literal: 'low' } }, outputSchema: {} },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const resolvedWorkflow = resolver.resolve(definition);
      expect(resolvedWorkflow).toBeDefined();
    });
  });

  describe('Loop Steps', () => {
    it('dowhile loops are resolved correctly', async () => {
      const definition: StorageWorkflowDefinitionType = {
        id: 'def-loop',
        name: 'Definition Loop',
        inputSchema: { type: 'object', properties: { count: { type: 'number' } } },
        outputSchema: { type: 'object', properties: { result: { type: 'number' } } },
        stateSchema: { type: 'object', properties: { counter: { type: 'number' } } },
        stepGraph: [
          {
            type: 'loop',
            stepId: 'increment',
            condition: {
              type: 'compare',
              field: { $ref: 'state.counter' },
              operator: 'lt',
              value: { $ref: 'input.count' },
            },
            loopType: 'dowhile',
          },
        ],
        steps: {
          increment: {
            type: 'transform',
            output: { current: { $ref: 'state.counter' } },
            outputSchema: {},
            stateUpdates: { counter: { $ref: 'state.counter' } },
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const resolvedWorkflow = resolver.resolve(definition);
      expect(resolvedWorkflow).toBeDefined();
    });
  });

  describe('Suspend/Resume', () => {
    it('suspend steps are resolved correctly', async () => {
      const definition: StorageWorkflowDefinitionType = {
        id: 'def-suspend',
        name: 'Definition Suspend',
        inputSchema: { type: 'object', properties: { data: { type: 'string' } } },
        outputSchema: { type: 'object', properties: { result: { type: 'string' } } },
        stepGraph: [
          { type: 'step', step: { id: 'prepare' } },
          { type: 'step', step: { id: 'wait-for-approval' } },
          { type: 'step', step: { id: 'complete' } },
        ],
        steps: {
          prepare: { type: 'transform', output: { prepared: { $ref: 'input.data' } }, outputSchema: {} },
          'wait-for-approval': {
            type: 'suspend',
            resumeSchema: { type: 'object', properties: { approved: { type: 'boolean' } } },
            payload: { awaiting: { $literal: 'approval' } },
          },
          complete: { type: 'transform', output: { result: { $literal: 'done' } }, outputSchema: {} },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const resolvedWorkflow = resolver.resolve(definition);
      expect(resolvedWorkflow).toBeDefined();
    });
  });

  describe('Nested Workflows', () => {
    it('nested workflow definitions are resolved correctly', async () => {
      // Would need storage setup for this test
      // Simplified for now
      expect(true).toBe(true);
    });

    it('detects circular dependencies', async () => {
      // Create a definition that references itself
      const selfReferencing: StorageWorkflowDefinitionType = {
        id: 'self-ref',
        name: 'Self Referencing',
        inputSchema: { type: 'object' },
        outputSchema: { type: 'object' },
        stepGraph: [{ type: 'step', step: { id: 'loop' } }],
        steps: {
          loop: { type: 'workflow', workflowId: 'self-ref', input: {} },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      expect(() => resolver.resolve(selfReferencing)).toThrow(/circular/i);
    });
  });
});
```

**Acceptance Criteria:**

- All major step graph types tested (sequential, parallel, conditional, loop, suspend)
- Cycle detection tested
- Clear test structure
- Run with `pnpm test`

---

### AGENT R: Storage Tests

**Goal:** Test storage implementations.

**Files to create:**

- `packages/core/src/storage/domains/workflow-definitions/__tests__/inmemory.test.ts`
- `stores/libsql/src/__tests__/workflow-definitions.test.ts`

**Test cases to cover:**

- CRUD operations (create, read, update, delete)
- List with pagination
- List with filtering (ownerId, metadata)
- Version operations (create, get, list, delete)
- Cascade delete (versions deleted with definition)
- Version number uniqueness
- Active version resolution

**Reference:** Follow `stores/libsql/src/__tests__/agents.test.ts`

---

### AGENT S: UI Wiring

**Goal:** Connect UI components to backend and integrate with workflows page.

**Files to modify:**

- `packages/playground/src/pages/workflows/index.tsx` (or create new page)

**Implementation notes:**

- Show workflow definitions alongside code-defined workflows
- Add "Create Definition" button
- Connect to real API endpoints
- Navigation to definition details

---

### AGENT T: Version Management UI

**Goal:** Add version management components.

**Files to create:**

- `packages/playground-ui/src/domains/workflow-definitions/components/workflow-definition-versions.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/version-compare-dialog.tsx`
- `packages/playground-ui/src/domains/workflow-definitions/components/save-version-dialog.tsx`

**Reference:** Follow agent version components:

- `packages/playground-ui/src/domains/agents/components/agent-versions/`

**Features:**

- Version list with timestamps and changed fields
- Activate version action
- Compare two versions side-by-side
- Save version with name/message
- Delete version with confirmation
