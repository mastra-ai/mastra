---
phase: 17-split-pane-layout
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - packages/playground-ui/src/domains/agents/components/agent-layout.tsx
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-panel.tsx
  - packages/playground-ui/src/domains/agents/context/browser-session-context.tsx
autonomous: false

must_haves:
  truths:
    - "When agent launches a browser session, the browser panel auto-expands to show side-by-side layout without user intervention"
    - "When browser session is closed via the close button, the browser panel collapses and chat reclaims full width"
    - "User can collapse the browser panel via the header close button and chat reclaims full width"
    - "User can re-trigger the panel to expand by starting a new browser session (agent runs another browser tool)"
    - "BrowserViewFrame WebSocket connection stays alive through collapse/expand cycles (never unmounts)"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/context/browser-session-context.tsx"
      provides: "BrowserSessionContext extended with panelRef for imperative expand/collapse"
      contains: "panelRef"
    - path: "packages/playground-ui/src/domains/agents/components/agent-layout.tsx"
      provides: "AgentLayout with useEffect that reacts to isActive to expand/collapse browser panel"
      contains: "browserPanelRef"
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-panel.tsx"
      provides: "BrowserViewPanel with close button that hides session and collapses panel"
  key_links:
    - from: "BrowserViewPanel handleStatusChange"
      to: "BrowserSessionContext.show()"
      via: "When streaming starts, show() sets isActive=true"
      pattern: "show\\(\\)"
    - from: "AgentLayout useEffect"
      to: "browserPanelRef.expand()/collapse()"
      via: "React to isActive changes from BrowserSessionContext"
      pattern: "isActive.*expand|isActive.*collapse"
    - from: "BrowserViewPanel handleClose"
      to: "BrowserSessionContext.hide()"
      via: "Close button calls hide() which sets isActive=false, triggering AgentLayout collapse"
      pattern: "hide\\(\\)"
---

<objective>
Wire automatic expand/collapse behavior: browser panel expands when agent starts a browser session (isActive becomes true) and collapses when the user clicks close or the session ends. Add panelRef to BrowserSessionContext so both AgentLayout and BrowserViewPanel can coordinate panel state.

Purpose: This completes the split-pane layout by making it reactive -- the layout automatically adapts when browser sessions start and stop, without requiring user intervention to open the panel. The close button on BrowserViewHeader collapses the panel back, and the WebSocket stays alive throughout.

Output: Fully functional auto-expand/collapse side-by-side browser layout.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-split-pane-layout/17-01-SUMMARY.md

Key source files:
@packages/playground-ui/src/domains/agents/components/agent-layout.tsx
@packages/playground-ui/src/domains/agents/components/browser-view/browser-view-panel.tsx
@packages/playground-ui/src/domains/agents/context/browser-session-context.tsx
@packages/playground-ui/src/lib/resize/collapsible-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BrowserSessionContext with panelRef and wire AgentLayout expand/collapse</name>
  <files>
    packages/playground-ui/src/domains/agents/context/browser-session-context.tsx
    packages/playground-ui/src/domains/agents/components/agent-layout.tsx
  </files>
  <action>
Two coordinated changes:

**A) BrowserSessionContext (browser-session-context.tsx) -- Add panelRef:**
- Import `useRef` and `type MutableRefObject` from React
- Import `PanelImperativeHandle` from `react-resizable-panels`
- Add `panelRef: MutableRefObject<PanelImperativeHandle | null>` to the BrowserSessionContextValue interface
- In BrowserSessionProvider, create: `const panelRef = useRef<PanelImperativeHandle | null>(null)`
- Add `panelRef` to the context value object and to the useMemo dependency array

This lets AgentLayout write the ref and BrowserViewPanel (or any descendant) can read it to call expand/collapse.

**B) AgentLayout (agent-layout.tsx) -- Wire panelRef and auto-expand/collapse:**
- Import `useBrowserSession` from the browser session context
- Import `useEffect, useRef` from React
- Import `usePanelRef` from `react-resizable-panels` (already available in the library)

Inside the AgentLayout component (only when browserSlot is provided):
1. Call `const { isActive, panelRef: sessionPanelRef } = useBrowserSession()` to read session state
2. Create `const browserPanelRef = usePanelRef()` for the browser Panel component
3. In a `useEffect` that runs once (empty deps), write the panel handle to context: `sessionPanelRef.current = browserPanelRef.current`. BUT since `usePanelRef` returns a ref object and Panel attaches to it via `panelRef={browserPanelRef}`, the ref won't be populated until after mount. Instead, use a simpler approach:
   - Use a regular `useRef<PanelImperativeHandle | null>(null)` instead of `usePanelRef()`
   - Attach it to the Panel via `panelRef={localPanelRef}` using a ref callback or the panelRef prop
   - Actually, `usePanelRef()` returns a `{ current: PanelImperativeHandle | null }` ref. The Panel component populates `.current` after mount. So we can safely assign in a mount effect.

   Simplest correct approach:
   - `const browserPanelRef = usePanelRef()`
   - Pass `panelRef={browserPanelRef}` to the browser Panel
   - In a useEffect with `[browserPanelRef]` deps: `sessionPanelRef.current = browserPanelRef.current`

4. Add a `useEffect` reacting to `isActive`:
   ```typescript
   useEffect(() => {
     if (!browserPanelRef.current) return;
     if (isActive) {
       browserPanelRef.current.expand();
     } else {
       browserPanelRef.current.collapse();
     }
   }, [isActive]);
   ```

IMPORTANT: The `useBrowserSession()` call and the expand/collapse useEffects should only run when browserSlot is provided. Since hooks can't be called conditionally, there are two approaches:
- **Option A (preferred):** Always call `useBrowserSession()` but gate the useEffect logic on `browserSlot` being truthy. This is valid because AgentLayout is always inside BrowserSessionProvider (established in Phase 16).
- **Option B:** Extract the browser panel logic into a separate component. This adds unnecessary complexity for now.

Go with Option A: Always call `useBrowserSession()`, but in the expand/collapse useEffect, add `if (!browserSlot) return;` as an early exit.

Similarly, `usePanelRef()` can always be called (it just creates a ref), and the Panel that uses it only renders when browserSlot is truthy.
  </action>
  <verify>
Run `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools && pnpm build:cli` and confirm zero type errors. Test manually: start an agent with browser tools, send a prompt that triggers browser navigation. The browser panel should auto-expand to ~40% width showing the live view. Click the X close button -- panel should collapse back to 0 width.
  </verify>
  <done>
BrowserSessionContext provides panelRef for imperative panel control. AgentLayout auto-expands browser panel when isActive becomes true and auto-collapses when isActive becomes false. Build passes with zero errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire BrowserViewPanel close button to collapse panel via context</name>
  <files>
    packages/playground-ui/src/domains/agents/components/browser-view/browser-view-panel.tsx
  </files>
  <action>
Update BrowserViewPanel to ensure the close flow correctly collapses the panel:

1. The existing `handleClose` callback already calls `hide()` which sets `isActive=false` in BrowserSessionContext. The AgentLayout useEffect (from Task 1) reacts to `isActive=false` and calls `browserPanelRef.current.collapse()`. This means the close button flow is: User clicks X -> handleClose -> hide() -> isActive=false -> AgentLayout effect -> collapse(). **No additional wiring needed for close.**

2. Remove the `isCollapsed` local state and the `handleToggleCollapse` callback. The internal collapse/expand of the browser content area is no longer needed -- the resizable panel itself handles collapse to 0 width. The BrowserViewHeader's chevron toggle button was for the overlay-style mini-collapse; in the panel layout, the user just drags the separator or clicks X to close entirely.

3. Update BrowserViewHeader props: remove `isCollapsed` and `onToggleCollapse` from the JSX (pass `undefined` / remove them). The header still shows URL, status badge, and close button. The chevron up/down toggle can be removed from the header in a future pass (it's harmless if it stays since `onToggleCollapse` won't be passed).

4. Simplify the frame wrapper: Since we removed isCollapsed gating in 17-01, the frame wrapper should use `className="flex-1 min-h-0 p-2"` (confirming the 17-01 change is in place). If not already done in 17-01, ensure this is the case.

5. Verify the `handleStatusChange` callback: when `newStatus === 'streaming'`, it calls `show()` which sets `isActive=true`. The AgentLayout useEffect then calls `expand()`. This is the auto-expand path. **No changes needed to handleStatusChange -- it already works correctly via the context.**
  </action>
  <verify>
Run `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools && pnpm build:cli` and confirm zero type errors. Test the full flow:
1. Start agent with browser tools, send prompt triggering navigation -- panel should auto-expand
2. Click X close button on browser header -- panel should collapse, chat reclaims full width
3. Send another prompt triggering navigation -- panel should auto-expand again
4. Drag the separator to resize -- panel should resize smoothly
5. After resize, collapse and re-expand -- panel should still work
  </verify>
  <done>
BrowserViewPanel close button collapses panel via hide() -> isActive=false -> AgentLayout collapse. Internal collapse state removed. Auto-expand on new sessions works via show() -> isActive=true -> AgentLayout expand. Build passes with zero errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete split-pane browser layout with auto-expand/collapse:
- Browser panel renders side-by-side with chat when agent uses browser tools
- Panel auto-expands when streaming starts, auto-collapses when user clicks close
- Separator handle allows drag-to-resize between chat and browser
- Chat reclaims full width when browser panel is closed
- WebSocket connection stays alive through collapse/expand cycles
  </what-built>
  <how-to-verify>
1. Run `pnpm dev:playground` from monorepo root
2. Open an agent with browser tools configured in Studio
3. Send a prompt that triggers browser navigation (e.g., "navigate to https://example.com")
4. Verify: Layout splits into chat on left, browser on right (auto-expand)
5. Verify: Browser shows live screencast, tool call history visible
6. Verify: Drag the separator between chat and browser to resize
7. Click the X close button on browser panel header
8. Verify: Panel collapses, chat takes full width
9. Send another browser prompt
10. Verify: Panel auto-expands again showing new session
11. Verify: No WebSocket reconnection messages in console (connection stayed alive)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm build:cli` passes with zero TypeScript errors
2. BrowserSessionContext includes panelRef in its interface and value
3. AgentLayout has useEffect that expands/collapses browser panel based on isActive
4. BrowserViewPanel close button triggers hide() -> collapse chain
5. Browser panel auto-expands when streaming starts (show() -> expand chain)
6. Separator between chat and browser panel is draggable
7. WebSocket connection survives collapse/expand cycles (BrowserViewFrame never unmounts)
</verification>

<success_criteria>
- Agent launches browser -> layout auto-splits into side-by-side chat + browser
- User clicks X -> panel collapses, chat reclaims full width
- User can drag separator to resize browser panel width
- New browser session after close -> panel auto-expands again
- No WebSocket disconnection during collapse/expand cycles
</success_criteria>

<output>
After completion, create `.planning/phases/17-split-pane-layout/17-02-SUMMARY.md`
</output>
