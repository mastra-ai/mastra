---
phase: 01-state-object-support
plan: 02
type: execute
wave: 2
depends_on: ['01-01']
files_modified:
  - packages/core/src/workflows/evented/workflow-event-processor/index.ts
  - packages/core/src/workflows/evented/step-executor.ts
  - packages/core/src/workflows/evented/workflow.ts
autonomous: true

must_haves:
  truths:
    - 'Steps can read state via state parameter'
    - 'Steps can write state via setState function'
    - 'State persists across step boundaries'
    - 'State persists across suspend/resume cycles'
    - 'State is available in workflow result'
  artifacts:
    - path: 'packages/core/src/workflows/evented/step-executor.ts'
      provides: 'State parameter injection into step execute'
      contains: 'state'
    - path: 'packages/core/src/workflows/evented/workflow-event-processor/index.ts'
      provides: 'State tracking across event boundaries'
      contains: 'state'
  key_links:
    - from: 'workflow-event-processor/index.ts'
      to: 'step-executor.ts'
      via: 'state parameter passing'
      pattern: 'state:'
    - from: 'step-executor.ts'
      to: 'step.execute'
      via: 'state and setState injection'
      pattern: 'setState'
---

<objective>
Implement state object support in the evented workflow runtime to make all 12 ported state tests pass.

Purpose: Complete the GREEN phase of TDD - implement the state functionality to satisfy the test specifications. State must persist across event boundaries (unlike the default runtime's in-memory approach).

Output: Working state implementation that passes all 12 state tests while maintaining backward compatibility with existing 119 tests.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-object-support/01-CONTEXT.md
@.planning/phases/01-state-object-support/01-01-SUMMARY.md

@packages/core/src/workflows/evented/step-executor.ts
@packages/core/src/workflows/evented/workflow-event-processor/index.ts
@packages/core/src/workflows/evented/workflow.ts
@packages/core/src/workflows/workflow.ts (reference - default runtime state handling)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement state tracking in workflow event processor</name>
  <files>packages/core/src/workflows/evented/workflow-event-processor/index.ts</files>
  <action>
Implement state persistence across event boundaries in the WorkflowEventProcessor:

1. **Add state to ProcessorArgs type** (around line 24):
   - Add `state?: Record<string, any>` to the ProcessorArgs type
   - This allows state to flow through all workflow events

2. **Initialize state in processWorkflowStart** (around line 180):
   - Accept `initialState` from the event data
   - Store state in the workflow snapshot context alongside stepResults
   - Pattern: `context: { ...stepResults, __state: initialState ?? {} }`

3. **Pass state through processWorkflowStepRun** (around line 436):
   - Load current state from snapshot context
   - Pass state to step executor (line 836 currently passes `state: {}`)
   - Pattern: `state: snapshot?.context?.__state ?? {}`

4. **Update state after step execution** (in processWorkflowStepEnd, around line 965):
   - After step execution, retrieve updated state from step result
   - Persist updated state back to snapshot
   - Use updateWorkflowResults or a new helper to persist state changes

5. **Include state in workflow result** (in endWorkflow, around line 249):
   - Ensure final state is included in workflow completion event
   - State should be accessible via `result.state`

Key implementation notes:

- State is stored in snapshot context as `__state` to avoid collision with step results
- State must survive across pub/sub event boundaries
- Each step execution should see the latest state from previous steps
- Parallel steps may update state concurrently - use merge semantics (last write wins per key)

Reference the default runtime's workflow.ts for state handling patterns.
</action>
<verify>
Run `cd packages/core && pnpm test evented-workflow.test.ts -t "single step workflow successfully with state"` - this basic state test should now pass.
</verify>
<done>
State tracking infrastructure exists in workflow-event-processor. State flows through event boundaries and is persisted in snapshots.
</done>
</task>

<task type="auto">
  <name>Task 2: Implement setState function in step executor</name>
  <files>packages/core/src/workflows/evented/step-executor.ts</files>
  <action>
Complete the state implementation in StepExecutor to allow steps to read and write state:

1. **Fix the setState implementation** (around line 103-106):
   Current code has a TODO and just assigns:

   ```typescript
   setState: async (state: any) => {
     // TODO
     params.state = state;
   },
   ```

   Update to:

   ```typescript
   setState: async (newState: Record<string, any>) => {
     // Merge new state with existing state (preserves other keys)
     Object.assign(params.state, newState);
   },
   ```

2. **Return updated state in step result**:
   The step executor needs to return the updated state so it can be persisted.
   After step execution completes, include state in the result:
   - Add `state: params.state` to the finalResult object
   - This allows workflow-event-processor to persist the updated state

3. **Fix state in resolveSleep and resolveSleepUntil** (around lines 356-357 and 430-432):
   These methods also have `state: {}` hardcoded with TODO comments.
   Update to use the actual state passed in params:

   ```typescript
   state: params.state ?? {},
   setState: async (newState: Record<string, any>) => {
     Object.assign(params.state, newState);
   },
   ```

4. **Fix state in evaluateCondition** (around line 292):
   The evaluateCondition method already accepts state in params and passes it.
   Verify it's using the actual state, not hardcoded empty object.

Key behavior requirements:

- `state` parameter gives step read access to current state
- `setState({ key: value })` merges into existing state (not replaces)
- State changes are immediately visible to the current step
- State changes persist for subsequent steps
  </action>
  <verify>
  Run `cd packages/core && pnpm test evented-workflow.test.ts -t "state"` - multiple state tests should now pass. Focus on tests that use setState within steps.
  </verify>
  <done>
  setState function correctly merges state, and state is properly passed to and from step executions.
  </done>
  </task>

<task type="auto">
  <name>Task 3: Wire state through workflow run lifecycle</name>
  <files>
    packages/core/src/workflows/evented/workflow.ts
    packages/core/src/workflows/evented/workflow-event-processor/index.ts
  </files>
  <action>
Complete the state wiring to ensure state flows from workflow start through to completion:

1. **Update EventedRun.start()** in workflow.ts (around line 1165):
   - Accept `initialState` parameter (already in type signature)
   - Pass initialState through to the workflow.start event
   - Add to event data: `initialState: initialStateToUse`

2. **Update EventedRun.resume()** in workflow.ts (around line 1317):
   - Load existing state from snapshot when resuming
   - Pass state through resume event data
   - State should persist across suspend/resume cycles

3. **Update processWorkflowStart** in workflow-event-processor/index.ts:
   - Extract initialState from event data
   - Store in snapshot: `context: { ...stepResults, __state: data.initialState ?? {} }`

4. **Update processWorkflowEnd** in workflow-event-processor/index.ts:
   - Include final state in the workflow completion
   - Ensure `result.state` contains the accumulated state

5. **Handle nested workflow state inheritance**:
   - When starting a nested workflow, pass parent state
   - When nested workflow completes, merge state changes back to parent
   - Pattern: nested workflows inherit state but can't break parent isolation

6. **Add state to outputOptions handling**:
   - Check if `outputOptions.includeState` is true
   - Only include state in result when requested (matches default runtime behavior)

Test specifically:

- State initialization from initialState parameter
- State persistence across multiple steps
- State persistence across suspend/resume
- Nested workflow state inheritance
  </action>
  <verify>
  Run `cd packages/core && pnpm test evented-workflow.test.ts -t "state"` - all 12 state tests should now pass.
  Run `cd packages/core && pnpm test evented-workflow.test.ts` - all 119 existing tests should still pass (no regressions).
  </verify>
  <done>
  All 12 state tests pass. State correctly flows through the entire workflow lifecycle including nested workflows and suspend/resume cycles. No regressions in existing tests.
  </done>
  </task>

</tasks>

<verification>
After all tasks complete:
1. Run state tests: `cd packages/core && pnpm test evented-workflow.test.ts -t "state"` - all 12 should pass
2. Run full evented suite: `cd packages/core && pnpm test evented-workflow.test.ts` - should show 131 passing (119 + 12), 6 skipped
3. Verify no TypeScript errors: `cd packages/core && pnpm typecheck`
4. Run default runtime tests to ensure parity: `cd packages/core && pnpm test workflow.test.ts -t "state"` - compare results
</verification>

<success_criteria>

- All 12 state-related tests pass
- Existing 119 tests continue to pass (no regressions)
- State correctly persists across event boundaries
- State correctly persists across suspend/resume cycles
- setState merges into existing state (doesn't replace)
- Nested workflows properly inherit and can modify state
- No TypeScript errors introduced
- State behavior matches default runtime behavior
  </success_criteria>

<output>
After completion, create `.planning/phases/01-state-object-support/01-02-SUMMARY.md`
</output>
