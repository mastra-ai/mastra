---
phase: 11-server-input-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/deployer/src/server/browser-stream/input-handler.ts
  - packages/deployer/src/server/browser-stream/browser-stream.ts
  - packages/deployer/src/server/browser-stream/index.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket text messages with type 'mouse' route to toolset.injectMouseEvent()"
    - "WebSocket text messages with type 'keyboard' route to toolset.injectKeyboardEvent()"
    - "Malformed JSON, invalid structure, or unknown type messages are silently ignored"
    - "Input injection is fire-and-forget with no acknowledgment sent to client"
    - "Missing toolset (no browser session) silently discards input"
    - "Injection errors are caught and logged, not propagated"
  artifacts:
    - path: "packages/deployer/src/server/browser-stream/input-handler.ts"
      provides: "Message parsing, validation, and routing to CDP injection"
      exports: ["handleInputMessage"]
      contains: "isValidInputMessage"
    - path: "packages/deployer/src/server/browser-stream/browser-stream.ts"
      provides: "WebSocket onMessage wired to input handler"
      contains: "handleInputMessage"
    - path: "packages/deployer/src/server/browser-stream/index.ts"
      provides: "Public exports including handleInputMessage"
  key_links:
    - from: "browser-stream.ts onMessage"
      to: "input-handler.ts handleInputMessage"
      via: "function call with (data, config.getToolset, agentId)"
      pattern: "handleInputMessage\\("
    - from: "input-handler.ts routeMouseEvent"
      to: "toolset.injectMouseEvent"
      via: "msg.eventType mapped to CDP type parameter"
      pattern: "toolset\\.injectMouseEvent\\("
    - from: "input-handler.ts routeKeyboardEvent"
      to: "toolset.injectKeyboardEvent"
      via: "msg.eventType mapped to CDP type parameter"
      pattern: "toolset\\.injectKeyboardEvent\\("
---

<objective>
Implement the WebSocket onMessage handler that parses client input messages and routes them to CDP injection methods on BrowserToolsetLike.

Purpose: This is the server-side bridge between client input events (mouse clicks, keyboard presses) and the browser's CDP injection API. Without this, the client has no way to send input to the remote browser.

Output: A new `input-handler.ts` module with message parsing, type-guard validation, and fire-and-forget routing; `browser-stream.ts` wired to call the handler from onMessage.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-server-input-routing/11-RESEARCH.md

@packages/deployer/src/server/browser-stream/browser-stream.ts
@packages/deployer/src/server/browser-stream/types.ts
@packages/deployer/src/server/browser-stream/index.ts
@packages/core/src/agent/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input-handler.ts with validation and routing</name>
  <files>packages/deployer/src/server/browser-stream/input-handler.ts</files>
  <action>
Create `input-handler.ts` in the browser-stream module with these components:

**Exported function: `handleInputMessage(data, getToolset, agentId)`**
- Signature: `(data: string, getToolset: (agentId: string) => BrowserToolsetLike | undefined, agentId: string) => void`
- Parse `data` with `JSON.parse` in try/catch -- return silently on parse failure
- Validate with `isValidInputMessage()` type guard -- return silently on invalid
- Look up toolset via `getToolset(agentId)` -- return silently if undefined
- Switch on `message.type`:
  - `'mouse'`: call `void injectMouse(toolset, message).catch(err => console.warn('[InputHandler] Mouse injection error:', err))`
  - `'keyboard'`: call `void injectKeyboard(toolset, message).catch(err => console.warn('[InputHandler] Keyboard injection error:', err))`

**Type guard: `isValidInputMessage(msg: unknown): msg is ClientInputMessage`**
- Check `typeof msg === 'object' && msg !== null`
- Cast to `Record<string, unknown>` for field access
- Dispatch to `isValidMouseMessage` or `isValidKeyboardMessage` based on `obj.type`
- Return false for any other type value

**Type guard: `isValidMouseMessage(obj): obj is MouseInputMessage`**
- `eventType` is string AND in Set `{'mousePressed', 'mouseReleased', 'mouseMoved', 'mouseWheel'}`
- `x` is number, `isFinite(x)`, `x >= 0`
- `y` is number, `isFinite(y)`, `y >= 0`
- Use `const VALID_MOUSE_EVENTS = new Set([...])` for O(1) lookup

**Type guard: `isValidKeyboardMessage(obj): obj is KeyboardInputMessage`**
- `eventType` is string AND in Set `{'keyDown', 'keyUp', 'char'}`
- Use `const VALID_KEYBOARD_EVENTS = new Set([...])` for O(1) lookup

**Injection: `injectMouse(toolset, msg)` (not exported, async)**
- Map `msg.eventType` to CDP `type` parameter: `toolset.injectMouseEvent({ type: msg.eventType, x: msg.x, y: msg.y, button: msg.button, clickCount: msg.clickCount, deltaX: msg.deltaX, deltaY: msg.deltaY, modifiers: msg.modifiers })`

**Injection: `injectKeyboard(toolset, msg)` (not exported, async)**
- Map `msg.eventType` to CDP `type` parameter: `toolset.injectKeyboardEvent({ type: msg.eventType, key: msg.key, code: msg.code, text: msg.text, modifiers: msg.modifiers })`

**Imports:**
- `import type { BrowserToolsetLike } from '@mastra/core/agent';`
- `import type { ClientInputMessage, MouseInputMessage, KeyboardInputMessage } from './types.js';`

**Critical: Do NOT build multi-event sequences.** Each message maps to exactly one inject call. The client (Phase 12/13) composes sequences. The server is a pass-through router.

**Critical: Do NOT await in handleInputMessage.** The function is synchronous (returns void). Inject calls are fire-and-forget via `void ... .catch()`.
  </action>
  <verify>
Run `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools && npx tsc --noEmit -p packages/deployer/tsconfig.json` -- no type errors in the new file.

Verify the file exists and exports handleInputMessage:
`grep -n "export function handleInputMessage" packages/deployer/src/server/browser-stream/input-handler.ts`
  </verify>
  <done>
input-handler.ts exists with handleInputMessage export, type guard validation (mouse and keyboard), fire-and-forget injection routing with .catch() error handling, and all TypeScript checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire onMessage handler and update exports</name>
  <files>
    packages/deployer/src/server/browser-stream/browser-stream.ts
    packages/deployer/src/server/browser-stream/index.ts
  </files>
  <action>
**Modify browser-stream.ts:**

1. Add import at top: `import { handleInputMessage } from './input-handler.js';`

2. Replace the existing onMessage placeholder:
```
onMessage(_event, _ws) {
  // Future: handle input events for Phase 10+ (mouse/keyboard injection)
},
```
With:
```
onMessage(event, _ws) {
  const data = typeof event.data === 'string' ? event.data : null;
  if (data) {
    handleInputMessage(data, config.getToolset, agentId);
  }
},
```

**Why `typeof event.data === 'string'` check:** Hono's WSMessageReceive type is `string | Blob | ArrayBufferLike`. Input messages are JSON text, so reject non-string data early. Do NOT attempt to convert Blob/ArrayBuffer -- those would be binary frames, not input messages.

**Why no `void` prefix on handleInputMessage call:** The function itself returns void (synchronous). The fire-and-forget void is inside handleInputMessage on the inject calls.

**Modify index.ts:**

Add export for handleInputMessage so downstream consumers (tests, other modules) can access it:
```
export { handleInputMessage } from './input-handler.js';
```

Keep all existing exports unchanged.
  </action>
  <verify>
Run full typecheck: `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools && npx tsc --noEmit -p packages/deployer/tsconfig.json`

Verify onMessage is wired:
`grep -n "handleInputMessage" packages/deployer/src/server/browser-stream/browser-stream.ts`

Verify export exists:
`grep -n "handleInputMessage" packages/deployer/src/server/browser-stream/index.ts`

Verify no placeholder comment remains:
`grep -c "Future: handle input events" packages/deployer/src/server/browser-stream/browser-stream.ts` should return 0.
  </verify>
  <done>
browser-stream.ts onMessage handler calls handleInputMessage with string data, config.getToolset, and agentId. index.ts exports handleInputMessage. TypeScript checks pass across deployer package. Old placeholder comment is gone.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit -p packages/deployer/tsconfig.json`
2. input-handler.ts exports handleInputMessage
3. browser-stream.ts onMessage calls handleInputMessage (not placeholder)
4. index.ts re-exports handleInputMessage
5. No await in onMessage or handleInputMessage (fire-and-forget pattern)
6. .catch() on inject promises prevents unhandled rejections
7. All three requirements covered:
   - ROUTE-01: onMessage parses JSON, switches on type, routes to inject methods
   - ROUTE-02: malformed messages silently ignored (JSON parse catch, validation guard, missing toolset check)
   - ROUTE-03: fire-and-forget via void + .catch(), no acknowledgment sent
</verification>

<success_criteria>
- input-handler.ts created with handleInputMessage, type guards, and injection routing
- browser-stream.ts onMessage wired to handleInputMessage
- index.ts exports handleInputMessage
- TypeScript compilation passes with no errors
- Fire-and-forget pattern: no await in message handling path
- Silent discard: malformed JSON, invalid structure, missing toolset all return without response
- Error resilience: .catch() on inject promises logs warnings instead of crashing
</success_criteria>

<output>
After completion, create `.planning/phases/11-server-input-routing/11-01-SUMMARY.md`
</output>
