---
phase: 01-storage-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - stores/libsql/src/storage/domains/datasets/index.ts
  - stores/libsql/src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "DatasetsLibSQL implements all abstract methods from DatasetsStorage"
    - "LibSQL uses atomic version increment (UPDATE SET version = version + 1)"
    - "LibSQLStore includes datasets domain in stores"
    - "init() creates both mastra_datasets and mastra_dataset_items tables"
  artifacts:
    - path: "stores/libsql/src/storage/domains/datasets/index.ts"
      provides: "DatasetsLibSQL class"
      exports: ["DatasetsLibSQL"]
    - path: "stores/libsql/src/storage/index.ts"
      provides: "DatasetsLibSQL in LibSQLStore"
      contains: "DatasetsLibSQL"
  key_links:
    - from: "stores/libsql/src/storage/domains/datasets/index.ts"
      to: "@mastra/core/storage"
      via: "imports DatasetsStorage, TABLE_DATASETS"
      pattern: "DatasetsStorage"
    - from: "stores/libsql/src/storage/index.ts"
      to: "stores/libsql/src/storage/domains/datasets/index.ts"
      via: "import DatasetsLibSQL"
      pattern: "DatasetsLibSQL"
---

<objective>
Implement DatasetsLibSQL class for persistent storage with LibSQL/Turso backend.

Purpose: Provide production-ready persistent storage for datasets with atomic versioning.
Output: DatasetsLibSQL implementation, integrated into LibSQLStore
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md
@.planning/phases/01-storage-foundation/01-02-SUMMARY.md

# Patterns to follow
@stores/libsql/src/storage/domains/scores/index.ts
@stores/libsql/src/storage/index.ts
@stores/libsql/src/storage/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatasetsLibSQL implementation</name>
  <files>stores/libsql/src/storage/domains/datasets/index.ts</files>
  <action>
Create new directory `stores/libsql/src/storage/domains/datasets/` with index.ts.

Follow ScoresLibSQL pattern exactly. Key implementation details:

```typescript
import type { Client, InValue } from '@libsql/client';
import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';
import {
  createStorageErrorId,
  TABLE_DATASETS,
  TABLE_DATASET_ITEMS,
  DATASETS_SCHEMA,
  DATASET_ITEMS_SCHEMA,
  DatasetsStorage,
  calculatePagination,
  normalizePerPage,
  safelyParseJSON,
  ensureDate,
} from '@mastra/core/storage';
import type {
  Dataset,
  DatasetItem,
  CreateDatasetInput,
  UpdateDatasetInput,
  AddDatasetItemInput,
  UpdateDatasetItemInput,
  ListDatasetsInput,
  ListDatasetsOutput,
  ListDatasetItemsInput,
  ListDatasetItemsOutput,
} from '@mastra/core/storage';
import { LibSQLDB, resolveClient } from '../../db';
import type { LibSQLDomainConfig } from '../../db';
import { buildSelectColumns } from '../../db/utils';

export class DatasetsLibSQL extends DatasetsStorage {
  #db: LibSQLDB;
  #client: Client;

  constructor(config: LibSQLDomainConfig) {
    super();
    const client = resolveClient(config);
    this.#client = client;
    this.#db = new LibSQLDB({ client, maxRetries: config.maxRetries, initialBackoffMs: config.initialBackoffMs });
  }

  async init(): Promise<void> {
    await this.#db.createTable({ tableName: TABLE_DATASETS, schema: DATASETS_SCHEMA });
    await this.#db.createTable({ tableName: TABLE_DATASET_ITEMS, schema: DATASET_ITEMS_SCHEMA });
  }

  async dangerouslyClearAll(): Promise<void> {
    await this.#db.deleteData({ tableName: TABLE_DATASET_ITEMS });
    await this.#db.deleteData({ tableName: TABLE_DATASETS });
  }

  // Helper to transform row to Dataset
  private transformDatasetRow(row: Record<string, any>): Dataset {
    return {
      id: row.id as string,
      name: row.name as string,
      description: row.description as string | undefined,
      metadata: row.metadata ? safelyParseJSON(row.metadata) : undefined,
      version: Number(row.version),
      createdAt: ensureDate(row.createdAt),
      updatedAt: ensureDate(row.updatedAt),
    };
  }

  // Helper to transform row to DatasetItem
  private transformItemRow(row: Record<string, any>): DatasetItem {
    return {
      id: row.id as string,
      datasetId: row.datasetId as string,
      version: Number(row.version),
      input: safelyParseJSON(row.input),
      expectedOutput: row.expectedOutput ? safelyParseJSON(row.expectedOutput) : undefined,
      context: row.context ? safelyParseJSON(row.context) : undefined,
      createdAt: ensureDate(row.createdAt),
      updatedAt: ensureDate(row.updatedAt),
    };
  }

  // Dataset CRUD
  async createDataset(input: CreateDatasetInput): Promise<Dataset> {
    try {
      const id = crypto.randomUUID();
      const now = new Date().toISOString();

      await this.#db.insert({
        tableName: TABLE_DATASETS,
        record: {
          id,
          name: input.name,
          description: input.description ?? null,
          metadata: input.metadata ? JSON.stringify(input.metadata) : null,
          version: 1,
          createdAt: now,
          updatedAt: now,
        },
      });

      return {
        id,
        name: input.name,
        description: input.description,
        metadata: input.metadata,
        version: 1,
        createdAt: new Date(now),
        updatedAt: new Date(now),
      };
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'CREATE_DATASET', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async getDatasetById({ id }: { id: string }): Promise<Dataset | null> {
    try {
      const result = await this.#client.execute({
        sql: `SELECT ${buildSelectColumns(TABLE_DATASETS)} FROM ${TABLE_DATASETS} WHERE id = ?`,
        args: [id],
      });
      return result.rows?.[0] ? this.transformDatasetRow(result.rows[0]) : null;
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'GET_DATASET', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async updateDataset(args: UpdateDatasetInput): Promise<Dataset> {
    try {
      const existing = await this.getDatasetById({ id: args.id });
      if (!existing) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'UPDATE_DATASET', 'NOT_FOUND'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { datasetId: args.id },
        });
      }

      const now = new Date().toISOString();
      const updates: string[] = ['updatedAt = ?'];
      const values: InValue[] = [now];

      if (args.name !== undefined) {
        updates.push('name = ?');
        values.push(args.name);
      }
      if (args.description !== undefined) {
        updates.push('description = ?');
        values.push(args.description);
      }
      if (args.metadata !== undefined) {
        updates.push('metadata = ?');
        values.push(JSON.stringify(args.metadata));
      }

      values.push(args.id);

      await this.#client.execute({
        sql: `UPDATE ${TABLE_DATASETS} SET ${updates.join(', ')} WHERE id = ?`,
        args: values,
      });

      return {
        ...existing,
        name: args.name ?? existing.name,
        description: args.description ?? existing.description,
        metadata: args.metadata ?? existing.metadata,
        updatedAt: new Date(now),
      };
    } catch (error) {
      if (error instanceof MastraError) throw error;
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'UPDATE_DATASET', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async deleteDataset({ id }: { id: string }): Promise<void> {
    try {
      // Delete items first (foreign key semantics)
      await this.#client.execute({
        sql: `DELETE FROM ${TABLE_DATASET_ITEMS} WHERE datasetId = ?`,
        args: [id],
      });
      await this.#client.execute({
        sql: `DELETE FROM ${TABLE_DATASETS} WHERE id = ?`,
        args: [id],
      });
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'DELETE_DATASET', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async listDatasets(args: ListDatasetsInput): Promise<ListDatasetsOutput> {
    try {
      const { page, perPage: perPageInput } = args.pagination;

      // Get total count
      const countResult = await this.#client.execute({
        sql: `SELECT COUNT(*) as count FROM ${TABLE_DATASETS}`,
        args: [],
      });
      const total = Number(countResult.rows?.[0]?.count ?? 0);

      if (total === 0) {
        return {
          datasets: [],
          pagination: { total: 0, page, perPage: perPageInput, hasMore: false },
        };
      }

      const perPage = normalizePerPage(perPageInput, 100);
      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
      const limitValue = perPageInput === false ? total : perPage;
      const end = perPageInput === false ? total : start + perPage;

      const result = await this.#client.execute({
        sql: `SELECT ${buildSelectColumns(TABLE_DATASETS)} FROM ${TABLE_DATASETS} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
        args: [limitValue, start],
      });

      return {
        datasets: result.rows?.map(row => this.transformDatasetRow(row)) ?? [],
        pagination: {
          total,
          page,
          perPage: perPageForResponse,
          hasMore: end < total,
        },
      };
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'LIST_DATASETS', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  // Item CRUD with atomic versioning
  async addItem(args: AddDatasetItemInput): Promise<DatasetItem> {
    try {
      const now = new Date().toISOString();

      // Atomic version increment
      await this.#client.execute({
        sql: `UPDATE ${TABLE_DATASETS} SET version = version + 1, updatedAt = ? WHERE id = ?`,
        args: [now, args.datasetId],
      });

      // Get new version
      const versionResult = await this.#client.execute({
        sql: `SELECT version FROM ${TABLE_DATASETS} WHERE id = ?`,
        args: [args.datasetId],
      });

      if (!versionResult.rows?.[0]) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'ADD_ITEM', 'DATASET_NOT_FOUND'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { datasetId: args.datasetId },
        });
      }

      const newVersion = Number(versionResult.rows[0].version);

      // Insert item
      const id = crypto.randomUUID();
      await this.#db.insert({
        tableName: TABLE_DATASET_ITEMS,
        record: {
          id,
          datasetId: args.datasetId,
          version: newVersion,
          input: JSON.stringify(args.input),
          expectedOutput: args.expectedOutput !== undefined ? JSON.stringify(args.expectedOutput) : null,
          context: args.context ? JSON.stringify(args.context) : null,
          createdAt: now,
          updatedAt: now,
        },
      });

      return {
        id,
        datasetId: args.datasetId,
        version: newVersion,
        input: args.input,
        expectedOutput: args.expectedOutput,
        context: args.context,
        createdAt: new Date(now),
        updatedAt: new Date(now),
      };
    } catch (error) {
      if (error instanceof MastraError) throw error;
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'ADD_ITEM', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async updateItem(args: UpdateDatasetItemInput): Promise<DatasetItem> {
    try {
      // Verify item exists and belongs to dataset
      const existing = await this.getItemById({ id: args.id });
      if (!existing) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'UPDATE_ITEM', 'NOT_FOUND'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { itemId: args.id },
        });
      }
      if (existing.datasetId !== args.datasetId) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'UPDATE_ITEM', 'DATASET_MISMATCH'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { itemId: args.id, expectedDatasetId: args.datasetId, actualDatasetId: existing.datasetId },
        });
      }

      const now = new Date().toISOString();

      // Atomic version increment
      await this.#client.execute({
        sql: `UPDATE ${TABLE_DATASETS} SET version = version + 1, updatedAt = ? WHERE id = ?`,
        args: [now, args.datasetId],
      });

      // Get new version
      const versionResult = await this.#client.execute({
        sql: `SELECT version FROM ${TABLE_DATASETS} WHERE id = ?`,
        args: [args.datasetId],
      });
      const newVersion = Number(versionResult.rows?.[0]?.version);

      // Update item
      const updates: string[] = ['version = ?', 'updatedAt = ?'];
      const values: InValue[] = [newVersion, now];

      if (args.input !== undefined) {
        updates.push('input = ?');
        values.push(JSON.stringify(args.input));
      }
      if (args.expectedOutput !== undefined) {
        updates.push('expectedOutput = ?');
        values.push(JSON.stringify(args.expectedOutput));
      }
      if (args.context !== undefined) {
        updates.push('context = ?');
        values.push(JSON.stringify(args.context));
      }

      values.push(args.id);

      await this.#client.execute({
        sql: `UPDATE ${TABLE_DATASET_ITEMS} SET ${updates.join(', ')} WHERE id = ?`,
        args: values,
      });

      return {
        ...existing,
        version: newVersion,
        input: args.input ?? existing.input,
        expectedOutput: args.expectedOutput ?? existing.expectedOutput,
        context: args.context ?? existing.context,
        updatedAt: new Date(now),
      };
    } catch (error) {
      if (error instanceof MastraError) throw error;
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'UPDATE_ITEM', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async deleteItem({ id, datasetId }: { id: string; datasetId: string }): Promise<void> {
    try {
      // Verify item exists
      const existing = await this.getItemById({ id });
      if (!existing) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'DELETE_ITEM', 'NOT_FOUND'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { itemId: id },
        });
      }
      if (existing.datasetId !== datasetId) {
        throw new MastraError({
          id: createStorageErrorId('LIBSQL', 'DELETE_ITEM', 'DATASET_MISMATCH'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.USER,
          details: { itemId: id, expectedDatasetId: datasetId, actualDatasetId: existing.datasetId },
        });
      }

      const now = new Date().toISOString();

      // Atomic version increment
      await this.#client.execute({
        sql: `UPDATE ${TABLE_DATASETS} SET version = version + 1, updatedAt = ? WHERE id = ?`,
        args: [now, datasetId],
      });

      // Delete item
      await this.#client.execute({
        sql: `DELETE FROM ${TABLE_DATASET_ITEMS} WHERE id = ?`,
        args: [id],
      });
    } catch (error) {
      if (error instanceof MastraError) throw error;
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'DELETE_ITEM', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async getItemById({ id }: { id: string }): Promise<DatasetItem | null> {
    try {
      const result = await this.#client.execute({
        sql: `SELECT ${buildSelectColumns(TABLE_DATASET_ITEMS)} FROM ${TABLE_DATASET_ITEMS} WHERE id = ?`,
        args: [id],
      });
      return result.rows?.[0] ? this.transformItemRow(result.rows[0]) : null;
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'GET_ITEM', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async listItems(args: ListDatasetItemsInput): Promise<ListDatasetItemsOutput> {
    try {
      const { page, perPage: perPageInput } = args.pagination;

      // Build WHERE clause
      const conditions: string[] = ['datasetId = ?'];
      const queryParams: InValue[] = [args.datasetId];

      if (args.version !== undefined) {
        conditions.push('version <= ?');
        queryParams.push(args.version);
      }

      const whereClause = `WHERE ${conditions.join(' AND ')}`;

      // Get total count
      const countResult = await this.#client.execute({
        sql: `SELECT COUNT(*) as count FROM ${TABLE_DATASET_ITEMS} ${whereClause}`,
        args: queryParams,
      });
      const total = Number(countResult.rows?.[0]?.count ?? 0);

      if (total === 0) {
        return {
          items: [],
          pagination: { total: 0, page, perPage: perPageInput, hasMore: false },
        };
      }

      const perPage = normalizePerPage(perPageInput, 100);
      const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);
      const limitValue = perPageInput === false ? total : perPage;
      const end = perPageInput === false ? total : start + perPage;

      const result = await this.#client.execute({
        sql: `SELECT ${buildSelectColumns(TABLE_DATASET_ITEMS)} FROM ${TABLE_DATASET_ITEMS} ${whereClause} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
        args: [...queryParams, limitValue, start],
      });

      return {
        items: result.rows?.map(row => this.transformItemRow(row)) ?? [],
        pagination: {
          total,
          page,
          perPage: perPageForResponse,
          hasMore: end < total,
        },
      };
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'LIST_ITEMS', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }

  async getItemsByVersion({ datasetId, version }: { datasetId: string; version: number }): Promise<DatasetItem[]> {
    try {
      const result = await this.#client.execute({
        sql: `SELECT ${buildSelectColumns(TABLE_DATASET_ITEMS)} FROM ${TABLE_DATASET_ITEMS} WHERE datasetId = ? AND version <= ? ORDER BY createdAt DESC`,
        args: [datasetId, version],
      });
      return result.rows?.map(row => this.transformItemRow(row)) ?? [];
    } catch (error) {
      throw new MastraError(
        {
          id: createStorageErrorId('LIBSQL', 'GET_ITEMS_BY_VERSION', 'FAILED'),
          domain: ErrorDomain.STORAGE,
          category: ErrorCategory.THIRD_PARTY,
        },
        error,
      );
    }
  }
}
```
  </action>
  <verify>
File exists: stores/libsql/src/storage/domains/datasets/index.ts
Grep for `class DatasetsLibSQL` confirms implementation.
Grep for `version = version + 1` confirms atomic versioning.
  </verify>
  <done>
DatasetsLibSQL implements all CRUD methods with atomic version increments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate DatasetsLibSQL into LibSQLStore</name>
  <files>stores/libsql/src/storage/index.ts</files>
  <action>
Update LibSQLStore to include datasets domain:

1. Add import at top (with other domain imports):
```typescript
import { DatasetsLibSQL } from './domains/datasets';
```

2. Add to exports:
```typescript
export { AgentsLibSQL, DatasetsLibSQL, MemoryLibSQL, ObservabilityLibSQL, ScoresLibSQL, WorkflowsLibSQL };
```

3. In constructor, instantiate DatasetsLibSQL:
```typescript
const datasets = new DatasetsLibSQL(domainConfig);
```

4. Add to this.stores object:
```typescript
this.stores = {
  scores,
  workflows,
  memory,
  observability,
  agents,
  datasets,
};
```
  </action>
  <verify>
Grep for `DatasetsLibSQL` in stores/libsql/src/storage/index.ts confirms import.
Grep for `datasets,` in stores object confirms integration.
`pnpm typecheck` from stores/libsql passes.
  </verify>
  <done>
LibSQLStore includes datasets domain, exports DatasetsLibSQL.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` from stores/libsql passes
2. DatasetsLibSQL is importable: `import { DatasetsLibSQL } from '@mastra/libsql'`
3. LibSQLStore.stores includes datasets
4. init() creates mastra_datasets and mastra_dataset_items tables
5. addItem/updateItem/deleteItem use atomic version increment
</verification>

<success_criteria>
- [ ] DatasetsLibSQL class exists at stores/libsql/src/storage/domains/datasets/index.ts
- [ ] DatasetsLibSQL implements all abstract methods from DatasetsStorage
- [ ] init() creates both tables with correct schemas
- [ ] Atomic versioning: `UPDATE ... SET version = version + 1`
- [ ] JSON fields properly stringified on write, parsed on read
- [ ] Error handling follows MastraError pattern
- [ ] DatasetsLibSQL exported from stores/libsql/src/storage/index.ts
- [ ] LibSQLStore.stores includes datasets domain
- [ ] Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-03-SUMMARY.md`
</output>
