---
phase: 01-storage-foundation
plan: 04
type: execute
wave: 4
depends_on: [01-03]
files_modified:
  - packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts
  - stores/libsql/src/storage/domains/datasets/index.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests pass for both in-memory and LibSQL backends"
    - "CRUD operations verified for datasets and items"
    - "Timestamp versioning behavior confirmed on item mutations"
    - "Version query semantics validated (snapshot behavior with Date timestamps)"
  artifacts:
    - path: "packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts"
      provides: "Test suite for DatasetsInMemory"
      min_lines: 150
    - path: "stores/libsql/src/storage/domains/datasets/index.test.ts"
      provides: "Test suite for DatasetsLibSQL"
      min_lines: 150
  key_links:
    - from: "packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts"
      to: "packages/core/src/storage/domains/datasets/inmemory.ts"
      via: "instantiates DatasetsInMemory"
      pattern: "new DatasetsInMemory"
    - from: "stores/libsql/src/storage/domains/datasets/index.test.ts"
      to: "stores/libsql/src/storage/domains/datasets/index.ts"
      via: "instantiates DatasetsLibSQL"
      pattern: "new DatasetsLibSQL"
---

<objective>
Create test suite validating DatasetsStorage contract for both in-memory and LibSQL backends.

Purpose: Verify all CRUD operations, auto-versioning behavior, and version query semantics work correctly across both storage backends.
Output: Passing test suite that catches contract mismatches between implementations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md

# Implementation to test
@packages/core/src/storage/domains/datasets/base.ts
@packages/core/src/storage/domains/datasets/inmemory.ts
@stores/libsql/src/storage/domains/datasets/index.ts

# Existing test patterns
@packages/core/src/storage/domains/scores/__tests__/scores.test.ts
@stores/libsql/src/storage/index.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatasetsInMemory test suite</name>
  <files>packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts</files>
  <action>
Create test file for DatasetsInMemory following existing core test patterns.

Structure:
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { DatasetsInMemory } from '../inmemory';
import { InMemoryDB } from '../../inmemory-db';

describe('DatasetsInMemory', () => {
  let storage: DatasetsInMemory;
  let db: InMemoryDB;

  beforeEach(() => {
    db = new InMemoryDB();
    storage = new DatasetsInMemory({ db });
  });

  // Test groups below
});
```

**Test groups to include:**

1. **Dataset CRUD**
   - createDataset: creates with name, description, metadata, version starts at 1
   - getDatasetById: returns dataset or null
   - updateDataset: updates fields, updatedAt changes
   - deleteDataset: removes dataset
   - listDatasets: pagination works, filters by name if supported

2. **Item CRUD**
   - addItem: creates item with input, expectedOutput, context (all JSON types)
   - updateItem: modifies item fields
   - deleteItem: removes item
   - listItems: pagination, filters by datasetId

3. **Timestamp versioning (CRITICAL)**
   - addItem updates dataset.version to new timestamp
   - updateItem updates dataset.version to new timestamp
   - deleteItem updates dataset.version to new timestamp
   - Item stores version timestamp when added/modified
   - version is a Date instance (not number)

4. **Version query semantics**
   - getItemsByVersion returns items at or before that version
   - listItems with version filter uses snapshot semantics
   - Items added after version N not returned for version N query

5. **Edge cases**
   - getDatasetById with non-existent ID returns null
   - deleteDataset with non-existent ID (behavior: no-op or error)
   - addItem to non-existent dataset throws
   - JSON input/expectedOutput with nested objects, arrays, null values

**Assertions:**
- Use `expect(dataset.version).toBeInstanceOf(Date)` for versioning
- Use `expect(v2.getTime()).toBeGreaterThan(v1.getTime())` for version progression
- Verify timestamps are Date objects (version, createdAt, updatedAt)
- Verify JSON roundtrip (input stored = input retrieved)
  </action>
  <verify>
Run tests:
```bash
cd packages/core && pnpm test src/storage/domains/datasets
```
All tests pass.
  </verify>
  <done>
Test suite covers all CRUD operations, auto-versioning behavior, and version query semantics. Tests pass for DatasetsInMemory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify auto-versioning behavior specifically</name>
  <files>packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts</files>
  <action>
Add dedicated timestamp versioning test block if not already comprehensive:

```typescript
describe('timestamp versioning', () => {
  it('version is Date instance on create', async () => {
    const dataset = await storage.createDataset({ name: 'test' });
    expect(dataset.version).toBeInstanceOf(Date);
  });

  it('updates version timestamp on addItem', async () => {
    const dataset = await storage.createDataset({ name: 'test' });
    const initialVersion = dataset.version;

    // Small delay to ensure timestamp difference
    await new Promise(r => setTimeout(r, 10));

    await storage.addItem({ datasetId: dataset.id, input: { prompt: 'hello' } });
    const updated = await storage.getDatasetById({ id: dataset.id });
    expect(updated?.version).toBeInstanceOf(Date);
    expect(updated?.version.getTime()).toBeGreaterThan(initialVersion.getTime());
  });

  it('updates version timestamp on updateItem', async () => {
    const dataset = await storage.createDataset({ name: 'test' });
    const item = await storage.addItem({ datasetId: dataset.id, input: { a: 1 } });
    const afterAddVersion = (await storage.getDatasetById({ id: dataset.id }))?.version;

    await new Promise(r => setTimeout(r, 10));

    await storage.updateItem({ id: item.id, datasetId: dataset.id, input: { a: 2 } });
    const updated = await storage.getDatasetById({ id: dataset.id });
    expect(updated?.version.getTime()).toBeGreaterThan(afterAddVersion!.getTime());
  });

  it('updates version timestamp on deleteItem', async () => {
    const dataset = await storage.createDataset({ name: 'test' });
    const item = await storage.addItem({ datasetId: dataset.id, input: {} });
    const afterAddVersion = (await storage.getDatasetById({ id: dataset.id }))?.version;

    await new Promise(r => setTimeout(r, 10));

    await storage.deleteItem({ id: item.id, datasetId: dataset.id });
    const updated = await storage.getDatasetById({ id: dataset.id });
    expect(updated?.version.getTime()).toBeGreaterThan(afterAddVersion!.getTime());
  });

  it('item stores version timestamp when added', async () => {
    const dataset = await storage.createDataset({ name: 'test' });

    const item1 = await storage.addItem({ datasetId: dataset.id, input: { n: 1 } });
    expect(item1.version).toBeInstanceOf(Date);
    const v1 = item1.version;

    await new Promise(r => setTimeout(r, 10));

    const item2 = await storage.addItem({ datasetId: dataset.id, input: { n: 2 } });
    expect(item2.version).toBeInstanceOf(Date);
    expect(item2.version.getTime()).toBeGreaterThan(v1.getTime());
  });

  it('getItemsByVersion returns snapshot at timestamp', async () => {
    const dataset = await storage.createDataset({ name: 'test' });
    const item1 = await storage.addItem({ datasetId: dataset.id, input: { n: 1 } });
    const item1Version = item1.version;

    await new Promise(r => setTimeout(r, 10));

    const item2 = await storage.addItem({ datasetId: dataset.id, input: { n: 2 } });

    // Query at item1's version timestamp should only return item1
    const itemsAtV1 = await storage.getItemsByVersion({ datasetId: dataset.id, version: item1Version });
    expect(itemsAtV1).toHaveLength(1);
    expect(itemsAtV1[0].id).toBe(item1.id);

    // Query at item2's version timestamp should return both
    const itemsAtV2 = await storage.getItemsByVersion({ datasetId: dataset.id, version: item2.version });
    expect(itemsAtV2).toHaveLength(2);
  });
});
```

Run and ensure all versioning tests pass.
  </action>
  <verify>
```bash
cd packages/core && pnpm test src/storage/domains/datasets --grep "timestamp versioning"
```
All timestamp versioning tests pass.
  </verify>
  <done>
Timestamp versioning behavior is thoroughly tested: addItem, updateItem, deleteItem all update version timestamp, items track their version timestamp, and snapshot queries work correctly with Date comparisons.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DatasetsLibSQL test suite</name>
  <files>stores/libsql/src/storage/domains/datasets/index.test.ts</files>
  <action>
Create test file for DatasetsLibSQL following existing libsql test patterns. Use in-memory SQLite (no Docker needed).

Structure:
```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createClient } from '@libsql/client';
import { DatasetsLibSQL } from './index';

vi.setConfig({ testTimeout: 60_000, hookTimeout: 60_000 });

const TEST_DB_URL = 'file::memory:?cache=shared';

describe('DatasetsLibSQL', () => {
  let storage: DatasetsLibSQL;
  let client: ReturnType<typeof createClient>;

  beforeEach(async () => {
    client = createClient({ url: TEST_DB_URL });
    storage = new DatasetsLibSQL({ client });
    await storage.init(); // Creates tables
  });

  afterEach(async () => {
    await storage.dangerouslyClearAll();
  });

  // Same test groups as InMemory tests
});
```

**Include same test groups as Task 1:**

1. **Dataset CRUD** - create, get, update, delete, list
2. **Item CRUD** - add, update, delete, list
3. **Auto-versioning** - version increments on item mutations
4. **Version query semantics** - snapshot behavior
5. **Edge cases** - null handling, JSON roundtrip

**LibSQL-specific checks:**
- Verify timestamp versioning (`UPDATE ... SET version = ?` with ISO timestamp)
- Verify JSON columns properly serialize/deserialize
- Verify timestamps (version, createdAt, updatedAt) stored as ISO strings, returned as Dates
  </action>
  <verify>
```bash
cd stores/libsql && pnpm test src/storage/domains/datasets
```
All tests pass.
  </verify>
  <done>
DatasetsLibSQL passes same tests as DatasetsInMemory, confirming contract parity between backends.
  </done>
</task>

</tasks>

<verification>
- [ ] InMemory test file created at packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts
- [ ] LibSQL test file created at stores/libsql/src/storage/domains/datasets/index.test.ts
- [ ] Both test suites cover Dataset CRUD (create, get, update, delete, list)
- [ ] Both test suites cover Item CRUD (add, update, delete, list)
- [ ] Both test suites verify timestamp versioning on all item mutations
- [ ] Both test suites verify version query semantics (snapshot behavior)
- [ ] Both test suites verify JSON handling for input/expectedOutput/context
- [ ] `cd packages/core && pnpm test src/storage/domains/datasets` passes
- [ ] `cd stores/libsql && pnpm test src/storage/domains/datasets` passes
</verification>

<success_criteria>
- Both test suites exist and run
- All tests pass for DatasetsInMemory
- All tests pass for DatasetsLibSQL
- Timestamp versioning behavior verified in both backends
- Version query snapshot semantics (Date comparison) verified in both backends
- JSON roundtrip verified in both backends
- Contract parity confirmed: same tests pass on both implementations
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-04-SUMMARY.md`
</output>
