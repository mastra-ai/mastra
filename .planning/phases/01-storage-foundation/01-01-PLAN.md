---
phase: 01-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/storage/constants.ts
  - packages/core/src/storage/types.ts
  - packages/core/src/storage/domains/datasets/base.ts
  - packages/core/src/storage/domains/datasets/index.ts
autonomous: true

must_haves:
  truths:
    - "Dataset and DatasetItem types are defined with all required fields"
    - "Table schemas follow existing patterns (SCORERS_SCHEMA, AGENTS_SCHEMA)"
    - "DatasetsStorage base class defines all abstract CRUD methods"
  artifacts:
    - path: "packages/core/src/storage/constants.ts"
      provides: "TABLE_DATASETS, TABLE_DATASET_ITEMS constants and schemas"
      contains: "DATASETS_SCHEMA"
    - path: "packages/core/src/storage/types.ts"
      provides: "Dataset, DatasetItem, CreateDatasetInput types"
      contains: "Dataset"
    - path: "packages/core/src/storage/domains/datasets/base.ts"
      provides: "DatasetsStorage abstract class"
      exports: ["DatasetsStorage"]
    - path: "packages/core/src/storage/domains/datasets/index.ts"
      provides: "Re-exports"
      exports: ["DatasetsStorage"]
  key_links:
    - from: "packages/core/src/storage/domains/datasets/base.ts"
      to: "packages/core/src/storage/constants.ts"
      via: "imports TABLE_DATASETS"
      pattern: "TABLE_DATASETS"
---

<objective>
Create type definitions, table schemas, and abstract base class for DatasetsStorage domain.

Purpose: Establish the contract and data structures that in-memory and LibSQL implementations will fulfill.
Output: Dataset/DatasetItem types, DATASETS_SCHEMA/DATASET_ITEMS_SCHEMA, DatasetsStorage base class
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md

# Existing patterns to follow
@packages/core/src/storage/constants.ts
@packages/core/src/storage/types.ts
@packages/core/src/storage/domains/scores/base.ts
@packages/core/src/storage/domains/base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Dataset types to storage/types.ts</name>
  <files>packages/core/src/storage/types.ts</files>
  <action>
Add the following types for datasets domain:

```typescript
// Dataset entity
export interface Dataset {
  id: string;
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
  version: Date;  // Timestamp-based versioning (Langfuse pattern)
  createdAt: Date;
  updatedAt: Date;
}

// Dataset item entity
export interface DatasetItem {
  id: string;
  datasetId: string;
  version: Date;  // Timestamp when item was added/modified
  input: unknown;   // Any JSON - string for simple prompts, object for structured
  expectedOutput?: unknown;  // Any JSON
  context?: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
}

// Input types for CRUD operations
export interface CreateDatasetInput {
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

export interface UpdateDatasetInput {
  id: string;
  name?: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

export interface AddDatasetItemInput {
  datasetId: string;
  input: unknown;
  expectedOutput?: unknown;
  context?: Record<string, unknown>;
}

export interface UpdateDatasetItemInput {
  id: string;
  datasetId: string;
  input?: unknown;
  expectedOutput?: unknown;
  context?: Record<string, unknown>;
}

// List response types
export interface ListDatasetsInput {
  pagination: StoragePagination;
}

export interface ListDatasetsOutput {
  datasets: Dataset[];
  pagination: PaginationInfo;
}

export interface ListDatasetItemsInput {
  datasetId: string;
  pagination: StoragePagination;
  version?: Date;  // Optional: filter items at or before this version timestamp
}

export interface ListDatasetItemsOutput {
  items: DatasetItem[];
  pagination: PaginationInfo;
}
```

Place after existing type definitions. Follow the naming patterns from existing types (StorageThreadType, etc).
  </action>
  <verify>
Run `pnpm typecheck` from packages/core - no new type errors.
Grep for `export interface Dataset` in types.ts confirms types exist.
  </verify>
  <done>
Dataset, DatasetItem, and all input/output types are exported from storage/types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add table schemas to storage/constants.ts</name>
  <files>packages/core/src/storage/constants.ts</files>
  <action>
Add table name constants and schemas following SCORERS_SCHEMA pattern:

```typescript
export const TABLE_DATASETS = 'mastra_datasets';
export const TABLE_DATASET_ITEMS = 'mastra_dataset_items';

// Add to TABLE_NAMES type union
// After existing TABLE_NAMES type, add:
// | typeof TABLE_DATASETS
// | typeof TABLE_DATASET_ITEMS

export const DATASETS_SCHEMA: Record<string, StorageColumn> = {
  id: { type: 'text', nullable: false, primaryKey: true },
  name: { type: 'text', nullable: false },
  description: { type: 'text', nullable: true },
  metadata: { type: 'jsonb', nullable: true },
  version: { type: 'timestamp', nullable: false },  // Timestamp-based versioning
  createdAt: { type: 'timestamp', nullable: false },
  updatedAt: { type: 'timestamp', nullable: false },
};

export const DATASET_ITEMS_SCHEMA: Record<string, StorageColumn> = {
  id: { type: 'text', nullable: false, primaryKey: true },
  datasetId: { type: 'text', nullable: false },
  version: { type: 'timestamp', nullable: false },  // Timestamp when item was added/modified
  input: { type: 'jsonb', nullable: false },
  expectedOutput: { type: 'jsonb', nullable: true },
  context: { type: 'jsonb', nullable: true },
  createdAt: { type: 'timestamp', nullable: false },
  updatedAt: { type: 'timestamp', nullable: false },
};
```

Also add both schemas to TABLE_SCHEMAS map at the bottom of file:
```typescript
[TABLE_DATASETS]: DATASETS_SCHEMA,
[TABLE_DATASET_ITEMS]: DATASET_ITEMS_SCHEMA,
```
  </action>
  <verify>
Grep for `TABLE_DATASETS` in constants.ts confirms constants exist.
Grep for `DATASETS_SCHEMA` confirms schema definitions exist.
  </verify>
  <done>
TABLE_DATASETS, TABLE_DATASET_ITEMS constants and their schemas are defined and registered.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DatasetsStorage base class</name>
  <files>
packages/core/src/storage/domains/datasets/base.ts
packages/core/src/storage/domains/datasets/index.ts
  </files>
  <action>
Create new directory `packages/core/src/storage/domains/datasets/` with two files:

**base.ts** - Abstract base class following ScoresStorage pattern:

```typescript
import { StorageDomain } from '../base';
import type {
  Dataset,
  DatasetItem,
  CreateDatasetInput,
  UpdateDatasetInput,
  AddDatasetItemInput,
  UpdateDatasetItemInput,
  ListDatasetsInput,
  ListDatasetsOutput,
  ListDatasetItemsInput,
  ListDatasetItemsOutput,
} from '../../types';

export abstract class DatasetsStorage extends StorageDomain {
  constructor() {
    super({
      component: 'STORAGE',
      name: 'DATASETS',
    });
  }

  async dangerouslyClearAll(): Promise<void> {
    // Default no-op - subclasses override
  }

  // Dataset CRUD
  abstract createDataset(input: CreateDatasetInput): Promise<Dataset>;
  abstract getDatasetById(args: { id: string }): Promise<Dataset | null>;
  abstract updateDataset(args: UpdateDatasetInput): Promise<Dataset>;
  abstract deleteDataset(args: { id: string }): Promise<void>;
  abstract listDatasets(args: ListDatasetsInput): Promise<ListDatasetsOutput>;

  // Item CRUD - these auto-increment dataset version
  abstract addItem(args: AddDatasetItemInput): Promise<DatasetItem>;
  abstract updateItem(args: UpdateDatasetItemInput): Promise<DatasetItem>;
  abstract deleteItem(args: { id: string; datasetId: string }): Promise<void>;
  abstract listItems(args: ListDatasetItemsInput): Promise<ListDatasetItemsOutput>;
  abstract getItemById(args: { id: string }): Promise<DatasetItem | null>;

  // Version-aware queries (snapshot semantics: items at or before version timestamp)
  abstract getItemsByVersion(args: { datasetId: string; version: Date }): Promise<DatasetItem[]>;
}
```

**index.ts** - Re-export:

```typescript
export * from './base';
```
  </action>
  <verify>
File exists: packages/core/src/storage/domains/datasets/base.ts
File exists: packages/core/src/storage/domains/datasets/index.ts
Import DatasetsStorage compiles: `import { DatasetsStorage } from './domains/datasets'`
  </verify>
  <done>
DatasetsStorage abstract class exists with all required CRUD method signatures.
Index file re-exports the base class.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` from packages/core passes
2. All new types are exported from packages/core/src/storage/types.ts
3. All new constants are exported from packages/core/src/storage/constants.ts
4. DatasetsStorage base class is importable from packages/core/src/storage/domains/datasets
</verification>

<success_criteria>
- [ ] Dataset, DatasetItem types defined in types.ts
- [ ] CreateDatasetInput, UpdateDatasetInput, AddDatasetItemInput, UpdateDatasetItemInput defined
- [ ] ListDatasetsInput/Output, ListDatasetItemsInput/Output defined
- [ ] TABLE_DATASETS, TABLE_DATASET_ITEMS constants defined
- [ ] DATASETS_SCHEMA, DATASET_ITEMS_SCHEMA defined and registered in TABLE_SCHEMAS
- [ ] DatasetsStorage abstract class with all CRUD methods
- [ ] datasets/index.ts re-exports base
- [ ] Typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-01-SUMMARY.md`
</output>
