---
phase: 11-dataset-schema-validation
plan: 04
type: execute
wave: 3
depends_on: ['11-02']
files_modified:
  - packages/playground-ui/src/domains/datasets/utils/csv-validation.ts
  - packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx
  - packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx
autonomous: true

must_haves:
  truths:
    - 'CSV import validates rows against dataset schemas before import'
    - 'Invalid rows are skipped during import'
    - 'Import reports count of skipped rows with reasons'
    - 'User can see which rows failed and why before confirming import'
  artifacts:
    - path: 'packages/playground-ui/src/domains/datasets/utils/csv-validation.ts'
      provides: 'CSV row validation against JSON Schema'
      exports: ['validateCsvRows', 'CsvValidationResult']
    - path: 'packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx'
      provides: 'UI component showing validation failures'
      exports: ['ValidationReport']
  key_links:
    - from: 'packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx'
      to: 'packages/playground-ui/src/domains/datasets/utils/csv-validation.ts'
      via: 'validateCsvRows call before import'
      pattern: 'validateCsvRows'
---

<objective>
Add CSV import validation against dataset schemas with failure reporting.

Purpose: Prevent invalid data from entering datasets via CSV import.
Output: CSV validation utility, validation report component, integrated into import dialog.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@.planning/phases/11-dataset-schema-validation/11-02-SUMMARY.md
@packages/playground-ui/src/domains/datasets/components/csv-import
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSV validation utility with Ajv</name>
  <files>
    packages/playground-ui/src/domains/datasets/utils/csv-validation.ts
    packages/playground-ui/package.json
  </files>
  <action>
1. Install Ajv in playground-ui if not already present:
   `cd packages/playground-ui && pnpm add ajv ajv-formats`

2. Create packages/playground-ui/src/domains/datasets/utils/csv-validation.ts:

   ```typescript
   import Ajv, { ErrorObject } from 'ajv';
   import addFormats from 'ajv-formats';

   /** Field-level validation error */
   export interface FieldError {
     path: string;
     keyword: string;
     message: string;
   }

   /** Validation result for a single row */
   export interface RowValidationResult {
     rowNumber: number; // 1-indexed, +1 for header
     field: 'input' | 'expectedOutput';
     errors: FieldError[];
     data: unknown;
   }

   /** Overall CSV validation result */
   export interface CsvValidationResult {
     validCount: number;
     invalidCount: number;
     validRows: Array<{ rowNumber: number; input: unknown; expectedOutput?: unknown }>;
     invalidRows: RowValidationResult[];
     totalRows: number;
   }

   // Singleton Ajv instance for performance
   let ajvInstance: Ajv | null = null;

   function getAjv(): Ajv {
     if (!ajvInstance) {
       ajvInstance = new Ajv({ allErrors: true });
       addFormats(ajvInstance);
     }
     return ajvInstance;
   }

   function formatErrors(errors: ErrorObject[] | null | undefined): FieldError[] {
     return (errors || []).slice(0, 5).map(err => ({
       path: err.instancePath || '/',
       keyword: err.keyword,
       message: err.message || 'Validation failed',
     }));
   }

   /**
    * Validate CSV rows against dataset schemas.
    *
    * @param rows Mapped rows from CSV (with input/expectedOutput fields)
    * @param inputSchema JSON Schema for input field (null = skip validation)
    * @param outputSchema JSON Schema for expectedOutput field (null = skip validation)
    * @param maxErrors Maximum number of invalid rows to collect (default 10)
    */
   export function validateCsvRows(
     rows: Array<{ input: unknown; expectedOutput?: unknown }>,
     inputSchema: Record<string, unknown> | null | undefined,
     outputSchema: Record<string, unknown> | null | undefined,
     maxErrors = 10,
   ): CsvValidationResult {
     const ajv = getAjv();

     // Pre-compile schemas for performance
     const inputValidator = inputSchema ? ajv.compile(inputSchema) : null;
     const outputValidator = outputSchema ? ajv.compile(outputSchema) : null;

     const validRows: CsvValidationResult['validRows'] = [];
     const invalidRows: CsvValidationResult['invalidRows'] = [];

     for (let i = 0; i < rows.length; i++) {
       const row = rows[i];
       const rowNumber = i + 2; // +1 for 0-index, +1 for header row
       let isValid = true;

       // Validate input
       if (inputValidator) {
         if (!inputValidator(row.input)) {
           invalidRows.push({
             rowNumber,
             field: 'input',
             errors: formatErrors(inputValidator.errors),
             data: row.input,
           });
           isValid = false;
         }
       }

       // Validate expectedOutput (only if schema enabled and value provided)
       if (isValid && outputValidator && row.expectedOutput !== undefined) {
         if (!outputValidator(row.expectedOutput)) {
           invalidRows.push({
             rowNumber,
             field: 'expectedOutput',
             errors: formatErrors(outputValidator.errors),
             data: row.expectedOutput,
           });
           isValid = false;
         }
       }

       if (isValid) {
         validRows.push({ rowNumber, ...row });
       }

       // Stop collecting errors after maxErrors
       if (invalidRows.length >= maxErrors && i < rows.length - 1) {
         // We'll still count remaining rows but not collect details
         break;
       }
     }

     return {
       validCount: validRows.length,
       invalidCount: rows.length - validRows.length,
       validRows,
       invalidRows,
       totalRows: rows.length,
     };
   }
   ```

     </action>
     <verify>
       - `pnpm typecheck` passes in playground-ui
       - validateCsvRows returns valid/invalid split
       - Row numbers are correctly 1-indexed with header offset
     </verify>
     <done>CSV validation utility created with Ajv integration and row tracking</done>
   </task>

<task type="auto">
  <name>Task 2: Add ValidationReport component and integrate into CSV import</name>
  <files>
    packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx
    packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx
    packages/playground-ui/src/domains/datasets/components/csv-import/index.ts
  </files>
  <action>
1. Create packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx:
   ```typescript
   import { Icon } from '@/ds/icons';
   import { cn } from '@/lib/utils';
   import type { CsvValidationResult, RowValidationResult } from '../../utils/csv-validation';

interface ValidationReportProps {
result: CsvValidationResult;
className?: string;
}

export function ValidationReport({ result, className }: ValidationReportProps) {
const { validCount, invalidCount, totalRows, invalidRows } = result;

     if (invalidCount === 0) {
       return (
         <div className={cn('flex items-center gap-2 text-sm text-success', className)}>
           <Icon name="check-circle" className="w-4 h-4" />
           All {totalRows} rows are valid
         </div>
       );
     }

     return (
       <div className={cn('space-y-3', className)}>
         <div className="flex items-center gap-2 text-sm text-warning">
           <Icon name="alert-triangle" className="w-4 h-4" />
           {invalidCount} of {totalRows} rows will be skipped (validation failed)
         </div>

         {validCount > 0 && (
           <div className="text-sm text-muted-foreground">
             {validCount} rows will be imported
           </div>
         )}

         {/* Show up to 10 failing rows */}
         <div className="max-h-48 overflow-y-auto border rounded-md">
           <table className="w-full text-xs">
             <thead className="bg-muted sticky top-0">
               <tr>
                 <th className="px-2 py-1 text-left font-medium">Row</th>
                 <th className="px-2 py-1 text-left font-medium">Field</th>
                 <th className="px-2 py-1 text-left font-medium">Error</th>
               </tr>
             </thead>
             <tbody>
               {invalidRows.map((row, idx) => (
                 <ValidationRow key={idx} row={row} />
               ))}
               {invalidCount > invalidRows.length && (
                 <tr>
                   <td colSpan={3} className="px-2 py-1 text-muted-foreground italic">
                     ... and {invalidCount - invalidRows.length} more
                   </td>
                 </tr>
               )}
             </tbody>
           </table>
         </div>
       </div>
     );

}

function ValidationRow({ row }: { row: RowValidationResult }) {
const errorMessage = row.errors[0]?.message || 'Validation failed';
const errorPath = row.errors[0]?.path || '/';

     return (
       <tr className="border-t">
         <td className="px-2 py-1 text-muted-foreground">{row.rowNumber}</td>
         <td className="px-2 py-1">
           <code className="text-xs bg-muted px-1 rounded">
             {row.field}{errorPath !== '/' ? errorPath : ''}
           </code>
         </td>
         <td className="px-2 py-1 text-destructive">{errorMessage}</td>
       </tr>
     );

}

````

2. Update csv-import-dialog.tsx to use validation:

Read the existing file and add:
- Import dataset to check for schemas
- Call validateCsvRows after column mapping
- Show ValidationReport before final import step
- Only import validRows (skip invalid)

Key additions:
```typescript
import { validateCsvRows, CsvValidationResult } from '../../utils/csv-validation';
import { ValidationReport } from './validation-report';
import { useDataset } from '../../hooks/use-datasets';

// In component:
const { data: dataset } = useDataset(datasetId);

// State for validation result
const [validationResult, setValidationResult] = useState<CsvValidationResult | null>(null);

// After mapping, before import step, validate:
const handleValidate = () => {
  const mappedRows = /* your existing row mapping logic */;

  const result = validateCsvRows(
    mappedRows,
    dataset?.inputSchema,
    dataset?.outputSchema,
    10
  );

  setValidationResult(result);

  // If no valid rows, show error
  if (result.validCount === 0) {
    // Show error state
  } else {
    // Proceed to confirmation step
  }
};

// In import handler, use only valid rows:
const handleImport = async () => {
  const rowsToImport = validationResult?.validRows ?? [];
  // ... existing import logic using rowsToImport
};

// In dialog UI, show ValidationReport:
{validationResult && (
  <ValidationReport result={validationResult} className="my-4" />
)}
````

3. Export ValidationReport from index.ts if needed:
   ```typescript
   export { ValidationReport } from './validation-report';
   ```
     </action>
     <verify>
       - `pnpm typecheck` passes
       - `pnpm build` succeeds for playground-ui
       - CSV import shows validation results before confirming
       - Only valid rows are imported
     </verify>
     <done>ValidationReport component created and integrated into CSV import flow</done>
   </task>

</tasks>

<verification>
1. `cd packages/playground-ui && pnpm build` succeeds
2. CSV import with schema-enabled dataset validates rows
3. Invalid rows show row number, field, and error message
4. User can see valid/invalid counts before confirming
5. Only valid rows are actually imported
</verification>

<success_criteria>

- validateCsvRows splits rows into valid/invalid arrays
- Row numbers are correct (accounting for header row)
- ValidationReport shows clear table of failures
- Import proceeds with only valid rows
- User sees summary: "X of Y rows will be skipped"
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-04-SUMMARY.md`
</output>
