---
phase: 11-dataset-schema-validation
plan: 04
type: execute
wave: 3
depends_on: ['11-02']
files_modified:
  - packages/playground-ui/src/domains/datasets/utils/csv-validation.ts
  - packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx
  - packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx
autonomous: true

must_haves:
  truths:
    - 'CSV import validates rows against dataset schemas before import'
    - 'Invalid rows are skipped during import'
    - 'Import reports count of skipped rows with reasons'
    - 'User can see which rows failed and why before confirming import'
  artifacts:
    - path: 'packages/playground-ui/src/domains/datasets/utils/csv-validation.ts'
      provides: 'CSV row validation against JSON Schema'
      exports: ['validateCsvRows', 'CsvValidationResult']
    - path: 'packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx'
      provides: 'UI component showing validation failures'
      exports: ['ValidationReport']
  key_links:
    - from: 'packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx'
      to: 'packages/playground-ui/src/domains/datasets/utils/csv-validation.ts'
      via: 'validateCsvRows call before import'
      pattern: 'validateCsvRows'
---

<objective>
Add CSV import validation against dataset schemas with failure reporting.

Purpose: Prevent invalid data from entering datasets via CSV import.
Output: CSV validation utility, validation report component, integrated into import dialog.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@.planning/phases/11-dataset-schema-validation/11-02-SUMMARY.md
@packages/playground-ui/src/domains/datasets/components/csv-import
@packages/playground-ui/src/lib/form/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSV validation utility with @mastra/schema-compat + Zod</name>
  <files>
    packages/playground-ui/src/domains/datasets/utils/csv-validation.ts
  </files>
  <action>
Create packages/playground-ui/src/domains/datasets/utils/csv-validation.ts:

Uses existing pattern from playground-ui - see `packages/playground-ui/src/lib/form/utils.ts` for `resolveSerializedZodOutput`.

```typescript
import { z, ZodSchema, ZodError, ZodIssue } from 'zod';
import { jsonSchemaToZod } from '@mastra/schema-compat/json-to-zod';
import { resolveSerializedZodOutput } from '@/lib/form/utils';

/** Field-level validation error */
export interface FieldError {
  path: string;
  code: string;
  message: string;
}

/** Validation result for a single row */
export interface RowValidationResult {
  rowNumber: number; // 1-indexed, +1 for header
  field: 'input' | 'expectedOutput';
  errors: FieldError[];
  data: unknown;
}

/** Overall CSV validation result */
export interface CsvValidationResult {
  validCount: number;
  invalidCount: number;
  validRows: Array<{ rowNumber: number; input: unknown; expectedOutput?: unknown }>;
  invalidRows: RowValidationResult[];
  totalRows: number;
}

/**
 * Convert JSON Schema to runtime Zod schema.
 * Uses existing resolveSerializedZodOutput from lib/form/utils.
 */
function compileSchema(jsonSchema: Record<string, unknown>): ZodSchema {
  const zodString = jsonSchemaToZod(jsonSchema);
  return resolveSerializedZodOutput(zodString);
}

function formatErrors(error: ZodError): FieldError[] {
  return error.issues.slice(0, 5).map((issue: ZodIssue) => ({
    // Convert Zod path array to JSON Pointer string
    path: issue.path.length > 0 ? '/' + issue.path.join('/') : '/',
    code: issue.code,
    message: issue.message,
  }));
}

/**
 * Validate CSV rows against dataset schemas.
 *
 * @param rows Mapped rows from CSV (with input/expectedOutput fields)
 * @param inputSchema JSON Schema for input field (null = skip validation)
 * @param outputSchema JSON Schema for expectedOutput field (null = skip validation)
 * @param maxErrors Maximum number of invalid rows to collect (default 10)
 */
export function validateCsvRows(
  rows: Array<{ input: unknown; expectedOutput?: unknown }>,
  inputSchema: Record<string, unknown> | null | undefined,
  outputSchema: Record<string, unknown> | null | undefined,
  maxErrors = 10,
): CsvValidationResult {
  // Pre-compile schemas for performance
  const inputValidator = inputSchema ? compileSchema(inputSchema) : null;
  const outputValidator = outputSchema ? compileSchema(outputSchema) : null;

  const validRows: CsvValidationResult['validRows'] = [];
  const invalidRows: CsvValidationResult['invalidRows'] = [];

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rowNumber = i + 2; // +1 for 0-index, +1 for header row
    let isValid = true;

    // Validate input
    if (inputValidator) {
      const result = inputValidator.safeParse(row.input);
      if (!result.success) {
        invalidRows.push({
          rowNumber,
          field: 'input',
          errors: formatErrors(result.error),
          data: row.input,
        });
        isValid = false;
      }
    }

    // Validate expectedOutput (only if schema enabled and value provided)
    if (isValid && outputValidator && row.expectedOutput !== undefined) {
      const result = outputValidator.safeParse(row.expectedOutput);
      if (!result.success) {
        invalidRows.push({
          rowNumber,
          field: 'expectedOutput',
          errors: formatErrors(result.error),
          data: row.expectedOutput,
        });
        isValid = false;
      }
    }

    if (isValid) {
      validRows.push({ rowNumber, ...row });
    }

    // Stop collecting errors after maxErrors
    if (invalidRows.length >= maxErrors && i < rows.length - 1) {
      // We'll still count remaining rows but not collect details
      break;
    }
  }

  return {
    validCount: validRows.length,
    invalidCount: rows.length - validRows.length,
    validRows,
    invalidRows,
    totalRows: rows.length,
  };
}
```

Note: No new dependencies needed - uses existing `@mastra/schema-compat` and Zod already in playground-ui.
</action>
<verify> - `pnpm typecheck` passes in playground-ui - validateCsvRows returns valid/invalid split - Row numbers are correctly 1-indexed with header offset
</verify>
<done>CSV validation utility created with Zod integration and row tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add ValidationReport component and integrate into CSV import</name>
  <files>
    packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx
    packages/playground-ui/src/domains/datasets/components/csv-import/csv-import-dialog.tsx
    packages/playground-ui/src/domains/datasets/components/csv-import/index.ts
  </files>
  <action>
1. Create packages/playground-ui/src/domains/datasets/components/csv-import/validation-report.tsx:
   ```typescript
   import { Icon } from '@/ds/icons';
   import { cn } from '@/lib/utils';
   import type { CsvValidationResult, RowValidationResult } from '../../utils/csv-validation';

interface ValidationReportProps {
result: CsvValidationResult;
className?: string;
}

export function ValidationReport({ result, className }: ValidationReportProps) {
const { validCount, invalidCount, totalRows, invalidRows } = result;

     if (invalidCount === 0) {
       return (
         <div className={cn('flex items-center gap-2 text-sm text-success', className)}>
           <Icon name="check-circle" className="w-4 h-4" />
           All {totalRows} rows are valid
         </div>
       );
     }

     return (
       <div className={cn('space-y-3', className)}>
         <div className="flex items-center gap-2 text-sm text-warning">
           <Icon name="alert-triangle" className="w-4 h-4" />
           {invalidCount} of {totalRows} rows will be skipped (validation failed)
         </div>

         {validCount > 0 && (
           <div className="text-sm text-muted-foreground">
             {validCount} rows will be imported
           </div>
         )}

         {/* Show up to 10 failing rows */}
         <div className="max-h-48 overflow-y-auto border rounded-md">
           <table className="w-full text-xs">
             <thead className="bg-muted sticky top-0">
               <tr>
                 <th className="px-2 py-1 text-left font-medium">Row</th>
                 <th className="px-2 py-1 text-left font-medium">Field</th>
                 <th className="px-2 py-1 text-left font-medium">Error</th>
               </tr>
             </thead>
             <tbody>
               {invalidRows.map((row, idx) => (
                 <ValidationRow key={idx} row={row} />
               ))}
               {invalidCount > invalidRows.length && (
                 <tr>
                   <td colSpan={3} className="px-2 py-1 text-muted-foreground italic">
                     ... and {invalidCount - invalidRows.length} more
                   </td>
                 </tr>
               )}
             </tbody>
           </table>
         </div>
       </div>
     );

}

function ValidationRow({ row }: { row: RowValidationResult }) {
const errorMessage = row.errors[0]?.message || 'Validation failed';
const errorPath = row.errors[0]?.path || '/';

     return (
       <tr className="border-t">
         <td className="px-2 py-1 text-muted-foreground">{row.rowNumber}</td>
         <td className="px-2 py-1">
           <code className="text-xs bg-muted px-1 rounded">
             {row.field}{errorPath !== '/' ? errorPath : ''}
           </code>
         </td>
         <td className="px-2 py-1 text-destructive">{errorMessage}</td>
       </tr>
     );

}

````

2. Update csv-import-dialog.tsx to use validation:

Read the existing file and add:
- Import dataset to check for schemas
- Call validateCsvRows after column mapping
- Show ValidationReport before final import step
- Only import validRows (skip invalid)

Key additions:
```typescript
import { validateCsvRows, CsvValidationResult } from '../../utils/csv-validation';
import { ValidationReport } from './validation-report';
import { useDataset } from '../../hooks/use-datasets';

// In component:
const { data: dataset } = useDataset(datasetId);

// State for validation result
const [validationResult, setValidationResult] = useState<CsvValidationResult | null>(null);

// After mapping, before import step, validate:
const handleValidate = () => {
const mappedRows = /* your existing row mapping logic */;

const result = validateCsvRows(
 mappedRows,
 dataset?.inputSchema,
 dataset?.outputSchema,
 10
);

setValidationResult(result);

// If no valid rows, show error
if (result.validCount === 0) {
 // Show error state
} else {
 // Proceed to confirmation step
}
};

// In import handler, use only valid rows:
const handleImport = async () => {
const rowsToImport = validationResult?.validRows ?? [];
// ... existing import logic using rowsToImport
};

// In dialog UI, show ValidationReport:
{validationResult && (
<ValidationReport result={validationResult} className="my-4" />
)}
````

3. Export ValidationReport from index.ts if needed:
   ```typescript
   export { ValidationReport } from './validation-report';
   ```
     </action>
     <verify>
       - `pnpm typecheck` passes
       - `pnpm build` succeeds for playground-ui
       - CSV import shows validation results before confirming
       - Only valid rows are imported
     </verify>
     <done>ValidationReport component created and integrated into CSV import flow</done>
   </task>

</tasks>

<verification>
1. `cd packages/playground-ui && pnpm build` succeeds
2. CSV import with schema-enabled dataset validates rows
3. Invalid rows show row number, field, and error message
4. User can see valid/invalid counts before confirming
5. Only valid rows are actually imported
</verification>

<success_criteria>

- validateCsvRows splits rows into valid/invalid arrays
- Row numbers are correct (accounting for header row)
- ValidationReport shows clear table of failures
- Import proceeds with only valid rows
- User sees summary: "X of Y rows will be skipped"
- Uses existing @mastra/schema-compat (no new dependencies added)
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-04-SUMMARY.md`
</output>
