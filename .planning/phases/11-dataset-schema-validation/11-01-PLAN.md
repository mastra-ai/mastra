---
phase: 11-dataset-schema-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/storage/types.ts
  - packages/core/src/datasets/validation/index.ts
  - packages/core/src/datasets/validation/errors.ts
  - packages/core/src/datasets/validation/validator.ts
  - packages/core/src/datasets/index.ts
autonomous: true

must_haves:
  truths:
    - 'Dataset type includes optional inputSchema and outputSchema fields'
    - 'Zod-based validator can compile and validate against JSON Schema'
    - 'Validation errors include field path and human-readable messages'
  artifacts:
    - path: 'packages/core/src/storage/types.ts'
      provides: 'Dataset type with inputSchema/outputSchema fields'
      contains: 'inputSchema'
    - path: 'packages/core/src/datasets/validation/validator.ts'
      provides: 'Zod-based schema validator with caching'
      exports: ['SchemaValidator', 'createValidator']
    - path: 'packages/core/src/datasets/validation/errors.ts'
      provides: 'Validation error types'
      exports: ['SchemaValidationError']
  key_links:
    - from: 'packages/core/src/datasets/validation/validator.ts'
      to: '@mastra/schema-compat'
      via: "import { jsonSchemaToZod } from '@mastra/schema-compat/json-to-zod'"
      pattern: 'jsonSchemaToZod'
---

<objective>
Add JSON Schema types to Dataset entity and create Zod-based validation utilities using existing @mastra/schema-compat.

Purpose: Foundation for schema validation - types and validation engine must exist before storage/API can use them.
Output: Extended Dataset type, SchemaValidator class with compilation caching, validation error types.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@packages/core/src/storage/types.ts
@packages/core/src/datasets/index.ts
@packages/core/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Dataset type with schema fields</name>
  <files>
    packages/core/src/storage/types.ts
  </files>
  <action>
1. Extend Dataset interface in types.ts to add optional schema fields:

```typescript
import type { JSONSchema7 } from 'json-schema';

export interface Dataset {
  id: string;
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
  version: Date;
  // Optional JSON Schema validation (null = explicitly disabled, undefined = not configured)
  inputSchema?: JSONSchema7 | null;
  outputSchema?: JSONSchema7 | null;
  createdAt: Date;
  updatedAt: Date;
}
```

2. Update CreateDatasetInput and UpdateDatasetInput to include optional schema fields:

   ```typescript
   export interface CreateDatasetInput {
     name: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: JSONSchema7 | null;
     outputSchema?: JSONSchema7 | null;
   }

   export interface UpdateDatasetInput {
     id: string;
     name?: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: JSONSchema7 | null;
     outputSchema?: JSONSchema7 | null;
   }
   ```

Note: json-schema types package should already be available as @types/json-schema is a common transitive dep.
</action>
<verify> - `pnpm typecheck` passes in packages/core - Dataset interface includes inputSchema and outputSchema fields
</verify>
<done>Dataset type extended with optional JSON Schema fields</done>
</task>

<task type="auto">
  <name>Task 2: Create SchemaValidator class using @mastra/schema-compat + Zod</name>
  <files>
    packages/core/src/datasets/validation/errors.ts
    packages/core/src/datasets/validation/validator.ts
    packages/core/src/datasets/validation/index.ts
    packages/core/src/datasets/index.ts
  </files>
  <action>
1. Create packages/core/src/datasets/validation/errors.ts:
   ```typescript
   /** Field-level validation error */
   export interface FieldError {
     /** JSON Pointer path, e.g., "/name" or "/address/city" */
     path: string;
     /** Zod error code, e.g., "invalid_type", "too_small" */
     code: string;
     /** Human-readable error message */
     message: string;
   }

/\*_ Schema validation error with field details _/
export class SchemaValidationError extends Error {
constructor(
public readonly field: 'input' | 'expectedOutput',
public readonly errors: FieldError[]
) {
const summary = errors.slice(0, 3).map(e => e.message).join('; ');
super(`Validation failed for ${field}: ${summary}`);
this.name = 'SchemaValidationError';
}
}

/\*_ Batch validation result for multiple items _/
export interface BatchValidationResult {
valid: Array<{ index: number; data: unknown }>;
invalid: Array<{
index: number;
data: unknown;
field: 'input' | 'expectedOutput';
errors: FieldError[];
}>;
}

````

2. Create packages/core/src/datasets/validation/validator.ts:
```typescript
import { z, ZodSchema, ZodError, ZodIssue } from 'zod';
import { jsonSchemaToZod } from '@mastra/schema-compat/json-to-zod';
import type { JSONSchema7 } from 'json-schema';
import { SchemaValidationError, FieldError, BatchValidationResult } from './errors';

/**
 * Convert JSON Schema string to runtime Zod schema.
 * Uses Function() to evaluate the generated Zod code - same pattern as workflow validation.
 */
function resolveZodSchema(zodString: string): ZodSchema {
  return Function('z', `"use strict";return (${zodString});`)(z);
}

/** Schema validator with compilation caching */
export class SchemaValidator {
  private cache = new Map<string, ZodSchema>();

  /** Get or compile validator for schema */
  private getValidator(schema: JSONSchema7, cacheKey: string): ZodSchema {
    let zodSchema = this.cache.get(cacheKey);
    if (!zodSchema) {
      const zodString = jsonSchemaToZod(schema);
      zodSchema = resolveZodSchema(zodString);
      this.cache.set(cacheKey, zodSchema);
    }
    return zodSchema;
  }

  /** Clear cached validator (call when schema changes) */
  clearCache(cacheKey: string): void {
    this.cache.delete(cacheKey);
  }

  /** Validate data against schema */
  validate(
    data: unknown,
    schema: JSONSchema7,
    field: 'input' | 'expectedOutput',
    cacheKey: string
  ): void {
    const zodSchema = this.getValidator(schema, cacheKey);
    const result = zodSchema.safeParse(data);
    if (!result.success) {
      throw new SchemaValidationError(field, this.formatErrors(result.error));
    }
  }

  /** Validate multiple items, returning valid/invalid split */
  validateBatch(
    items: Array<{ input: unknown; expectedOutput?: unknown }>,
    inputSchema: JSONSchema7 | null | undefined,
    outputSchema: JSONSchema7 | null | undefined,
    cacheKeyPrefix: string,
    maxErrors = 10
  ): BatchValidationResult {
    const result: BatchValidationResult = { valid: [], invalid: [] };

    // Pre-compile schemas for performance
    const inputValidator = inputSchema
      ? this.getValidator(inputSchema, `${cacheKeyPrefix}:input`)
      : null;
    const outputValidator = outputSchema
      ? this.getValidator(outputSchema, `${cacheKeyPrefix}:output`)
      : null;

    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      let hasError = false;

      // Validate input if schema enabled
      if (inputValidator) {
        const inputResult = inputValidator.safeParse(item.input);
        if (!inputResult.success) {
          result.invalid.push({
            index: i,
            data: item,
            field: 'input',
            errors: this.formatErrors(inputResult.error),
          });
          hasError = true;
          if (result.invalid.length >= maxErrors) break;
        }
      }

      // Validate expectedOutput if schema enabled and value provided
      if (!hasError && outputValidator && item.expectedOutput !== undefined) {
        const outputResult = outputValidator.safeParse(item.expectedOutput);
        if (!outputResult.success) {
          result.invalid.push({
            index: i,
            data: item,
            field: 'expectedOutput',
            errors: this.formatErrors(outputResult.error),
          });
          hasError = true;
          if (result.invalid.length >= maxErrors) break;
        }
      }

      if (!hasError) {
        result.valid.push({ index: i, data: item });
      }
    }

    return result;
  }

  /** Format Zod errors to FieldError array */
  private formatErrors(error: ZodError): FieldError[] {
    return error.issues.slice(0, 5).map((issue: ZodIssue) => ({
      // Convert Zod path array to JSON Pointer string
      path: issue.path.length > 0 ? '/' + issue.path.join('/') : '/',
      code: issue.code,
      message: issue.message,
    }));
  }
}

/** Singleton validator instance */
let validatorInstance: SchemaValidator | null = null;

/** Get or create validator instance */
export function getSchemaValidator(): SchemaValidator {
  if (!validatorInstance) {
    validatorInstance = new SchemaValidator();
  }
  return validatorInstance;
}

/** Create new validator (for testing) */
export function createValidator(): SchemaValidator {
  return new SchemaValidator();
}
````

3. Create packages/core/src/datasets/validation/index.ts:

   ```typescript
   export { SchemaValidator, getSchemaValidator, createValidator } from './validator';
   export { SchemaValidationError, type FieldError, type BatchValidationResult } from './errors';
   ```

4. Update packages/core/src/datasets/index.ts to export validation:
   Add: `export * from './validation';`
   </action>
   <verify> - `pnpm typecheck` passes - `pnpm test` passes in packages/core - SchemaValidator class can be imported from '@mastra/core/datasets'
   </verify>
   <done>SchemaValidator class created with Zod integration via @mastra/schema-compat, compilation caching, and batch validation support</done>
   </task>

</tasks>

<verification>
1. `cd packages/core && pnpm typecheck` passes
2. Dataset type in storage/types.ts includes inputSchema and outputSchema
3. SchemaValidator exports are available from @mastra/core/datasets
4. No existing tests broken
</verification>

<success_criteria>

- Dataset interface has inputSchema?: JSONSchema7 | null and outputSchema?: JSONSchema7 | null
- SchemaValidator.validate() throws SchemaValidationError with field-level errors
- SchemaValidator.validateBatch() returns valid/invalid split with up to maxErrors failures
- Validation caching works (same schema compiles once)
- Uses existing @mastra/schema-compat (no new dependencies added)
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-01-SUMMARY.md`
</output>
