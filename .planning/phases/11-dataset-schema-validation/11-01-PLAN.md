---
phase: 11-dataset-schema-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/storage/types.ts
  - packages/core/src/datasets/validation/index.ts
  - packages/core/src/datasets/validation/errors.ts
  - packages/core/src/datasets/validation/validator.ts
  - packages/core/src/datasets/index.ts
  - packages/core/package.json
autonomous: true

must_haves:
  truths:
    - 'Dataset type includes optional inputSchema and outputSchema fields'
    - 'Ajv validator can compile and validate against JSON Schema'
    - 'Validation errors include field path and human-readable messages'
  artifacts:
    - path: 'packages/core/src/storage/types.ts'
      provides: 'Dataset type with inputSchema/outputSchema fields'
      contains: 'inputSchema'
    - path: 'packages/core/src/datasets/validation/validator.ts'
      provides: 'Ajv-based schema validator with caching'
      exports: ['SchemaValidator', 'createValidator']
    - path: 'packages/core/src/datasets/validation/errors.ts'
      provides: 'Validation error types'
      exports: ['SchemaValidationError']
  key_links:
    - from: 'packages/core/src/datasets/validation/validator.ts'
      to: 'ajv'
      via: "import Ajv from 'ajv'"
      pattern: 'import Ajv'
---

<objective>
Add JSON Schema types to Dataset entity and create Ajv-based validation utilities.

Purpose: Foundation for schema validation - types and validation engine must exist before storage/API can use them.
Output: Extended Dataset type, SchemaValidator class with compilation caching, validation error types.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@packages/core/src/storage/types.ts
@packages/core/src/datasets/index.ts
@packages/core/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Ajv and extend Dataset type</name>
  <files>
    packages/core/package.json
    packages/core/src/storage/types.ts
  </files>
  <action>
1. Install ajv and ajv-formats in packages/core:
   `pnpm add ajv ajv-formats`

2. Extend Dataset interface in types.ts to add optional schema fields:

   ```typescript
   import type { JSONSchema7 } from 'json-schema';

   export interface Dataset {
     id: string;
     name: string;
     description?: string;
     metadata?: Record<string, unknown>;
     version: Date;
     // Optional JSON Schema validation (null = explicitly disabled, undefined = not configured)
     inputSchema?: JSONSchema7 | null;
     outputSchema?: JSONSchema7 | null;
     createdAt: Date;
     updatedAt: Date;
   }
   ```

3. Update CreateDatasetInput and UpdateDatasetInput to include optional schema fields:

   ```typescript
   export interface CreateDatasetInput {
     name: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: JSONSchema7 | null;
     outputSchema?: JSONSchema7 | null;
   }

   export interface UpdateDatasetInput {
     id: string;
     name?: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: JSONSchema7 | null;
     outputSchema?: JSONSchema7 | null;
   }
   ```

Note: json-schema types package should already be available as @types/json-schema is a common transitive dep.
</action>
<verify> - `pnpm typecheck` passes in packages/core - Dataset interface includes inputSchema and outputSchema fields
</verify>
<done>Dataset type extended with optional JSON Schema fields, Ajv installed</done>
</task>

<task type="auto">
  <name>Task 2: Create SchemaValidator class with caching</name>
  <files>
    packages/core/src/datasets/validation/errors.ts
    packages/core/src/datasets/validation/validator.ts
    packages/core/src/datasets/validation/index.ts
    packages/core/src/datasets/index.ts
  </files>
  <action>
1. Create packages/core/src/datasets/validation/errors.ts:
   ```typescript
   /** Field-level validation error */
   export interface FieldError {
     /** JSON Pointer path, e.g., "/name" or "/address/city" */
     path: string;
     /** Validation keyword, e.g., "type", "required", "minLength" */
     keyword: string;
     /** Human-readable error message */
     message: string;
     /** Keyword-specific context params */
     params?: unknown;
   }

/\*_ Schema validation error with field details _/
export class SchemaValidationError extends Error {
constructor(
public readonly field: 'input' | 'expectedOutput',
public readonly errors: FieldError[]
) {
const summary = errors.slice(0, 3).map(e => e.message).join('; ');
super(`Validation failed for ${field}: ${summary}`);
this.name = 'SchemaValidationError';
}
}

/\*_ Batch validation result for multiple items _/
export interface BatchValidationResult {
valid: Array<{ index: number; data: unknown }>;
invalid: Array<{
index: number;
data: unknown;
field: 'input' | 'expectedOutput';
errors: FieldError[];
}>;
}

````

2. Create packages/core/src/datasets/validation/validator.ts:
```typescript
import Ajv, { ValidateFunction, ErrorObject } from 'ajv';
import addFormats from 'ajv-formats';
import type { JSONSchema7 } from 'json-schema';
import { SchemaValidationError, FieldError, BatchValidationResult } from './errors';

/** Schema validator with compilation caching */
export class SchemaValidator {
  private ajv: Ajv;
  private cache = new Map<string, ValidateFunction>();

  constructor() {
    this.ajv = new Ajv({ allErrors: true });
    addFormats(this.ajv);
  }

  /** Get or compile validator for schema */
  private getValidator(schema: JSONSchema7, cacheKey: string): ValidateFunction {
    let validate = this.cache.get(cacheKey);
    if (!validate) {
      validate = this.ajv.compile(schema);
      this.cache.set(cacheKey, validate);
    }
    return validate;
  }

  /** Clear cached validator (call when schema changes) */
  clearCache(cacheKey: string): void {
    this.cache.delete(cacheKey);
  }

  /** Validate data against schema */
  validate(
    data: unknown,
    schema: JSONSchema7,
    field: 'input' | 'expectedOutput',
    cacheKey: string
  ): void {
    const validate = this.getValidator(schema, cacheKey);
    if (!validate(data)) {
      throw new SchemaValidationError(field, this.formatErrors(validate.errors));
    }
  }

  /** Validate multiple items, returning valid/invalid split */
  validateBatch(
    items: Array<{ input: unknown; expectedOutput?: unknown }>,
    inputSchema: JSONSchema7 | null | undefined,
    outputSchema: JSONSchema7 | null | undefined,
    cacheKeyPrefix: string,
    maxErrors = 10
  ): BatchValidationResult {
    const result: BatchValidationResult = { valid: [], invalid: [] };

    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      let hasError = false;

      // Validate input if schema enabled
      if (inputSchema) {
        const validate = this.getValidator(inputSchema, `${cacheKeyPrefix}:input`);
        if (!validate(item.input)) {
          result.invalid.push({
            index: i,
            data: item,
            field: 'input',
            errors: this.formatErrors(validate.errors),
          });
          hasError = true;
          if (result.invalid.length >= maxErrors) break;
        }
      }

      // Validate expectedOutput if schema enabled and value provided
      if (!hasError && outputSchema && item.expectedOutput !== undefined) {
        const validate = this.getValidator(outputSchema, `${cacheKeyPrefix}:output`);
        if (!validate(item.expectedOutput)) {
          result.invalid.push({
            index: i,
            data: item,
            field: 'expectedOutput',
            errors: this.formatErrors(validate.errors),
          });
          hasError = true;
          if (result.invalid.length >= maxErrors) break;
        }
      }

      if (!hasError) {
        result.valid.push({ index: i, data: item });
      }
    }

    return result;
  }

  /** Format Ajv errors to FieldError array */
  private formatErrors(errors: ErrorObject[] | null | undefined): FieldError[] {
    return (errors || []).slice(0, 5).map(err => ({
      path: err.instancePath || '/',
      keyword: err.keyword,
      message: err.message || 'Validation failed',
      params: err.params,
    }));
  }
}

/** Singleton validator instance */
let validatorInstance: SchemaValidator | null = null;

/** Get or create validator instance */
export function getSchemaValidator(): SchemaValidator {
  if (!validatorInstance) {
    validatorInstance = new SchemaValidator();
  }
  return validatorInstance;
}

/** Create new validator (for testing) */
export function createValidator(): SchemaValidator {
  return new SchemaValidator();
}
````

3. Create packages/core/src/datasets/validation/index.ts:

   ```typescript
   export { SchemaValidator, getSchemaValidator, createValidator } from './validator';
   export { SchemaValidationError, type FieldError, type BatchValidationResult } from './errors';
   ```

4. Update packages/core/src/datasets/index.ts to export validation:
   Add: `export * from './validation';`
   </action>
   <verify> - `pnpm typecheck` passes - `pnpm test` passes in packages/core - SchemaValidator class can be imported from '@mastra/core/datasets'
   </verify>
   <done>SchemaValidator class created with Ajv integration, compilation caching, and batch validation support</done>
   </task>

</tasks>

<verification>
1. `cd packages/core && pnpm typecheck` passes
2. Dataset type in storage/types.ts includes inputSchema and outputSchema
3. SchemaValidator exports are available from @mastra/core/datasets
4. No existing tests broken
</verification>

<success_criteria>

- Dataset interface has inputSchema?: JSONSchema7 | null and outputSchema?: JSONSchema7 | null
- SchemaValidator.validate() throws SchemaValidationError with field-level errors
- SchemaValidator.validateBatch() returns valid/invalid split with up to maxErrors failures
- Validation caching works (same schema compiles once)
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-01-SUMMARY.md`
</output>
