---
phase: 11-dataset-schema-validation
plan: 02
type: execute
wave: 2
depends_on: ['11-01']
files_modified:
  - packages/core/src/storage/domains/datasets/base.ts
  - packages/core/src/storage/domains/datasets/inmemory.ts
  - packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts
autonomous: true

must_haves:
  truths:
    - "Adding item validates input against dataset's inputSchema if enabled"
    - "Adding item validates expectedOutput against dataset's outputSchema if enabled"
    - 'Updating item validates against schemas'
    - 'Schema validation errors include field path for UI display'
  artifacts:
    - path: 'packages/core/src/storage/domains/datasets/inmemory.ts'
      provides: 'DatasetsInMemory with schema validation'
      contains: 'SchemaValidator'
    - path: 'packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts'
      provides: 'Tests for schema validation on add/update'
      contains: 'inputSchema'
  key_links:
    - from: 'packages/core/src/storage/domains/datasets/inmemory.ts'
      to: 'packages/core/src/datasets/validation/validator.ts'
      via: 'import { getSchemaValidator }'
      pattern: 'getSchemaValidator'
---

<objective>
Add schema validation to DatasetsStorage addItem and updateItem methods.

Purpose: Enforce data quality at storage boundary - invalid data never persists.
Output: DatasetsInMemory validates items against dataset schemas before storage.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@.planning/phases/11-dataset-schema-validation/11-01-SUMMARY.md
@packages/core/src/storage/domains/datasets/base.ts
@packages/core/src/storage/domains/datasets/inmemory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema validation to DatasetsInMemory addItem/updateItem</name>
  <files>
    packages/core/src/storage/domains/datasets/inmemory.ts
  </files>
  <action>
1. Import the schema validator at top:
   ```typescript
   import { getSchemaValidator, SchemaValidationError } from '../../../datasets/validation';
   ```

2. Update addItem method to validate before storage:

   ```typescript
   async addItem(args: AddDatasetItemInput): Promise<DatasetItem> {
     const dataset = this.db.datasets.get(args.datasetId);
     if (!dataset) {
       throw new Error(`Dataset not found: ${args.datasetId}`);
     }

     // Validate against schemas if enabled
     const validator = getSchemaValidator();
     const cacheKey = `dataset:${args.datasetId}`;

     if (dataset.inputSchema) {
       validator.validate(args.input, dataset.inputSchema, 'input', `${cacheKey}:input`);
     }

     if (dataset.outputSchema && args.expectedOutput !== undefined) {
       validator.validate(args.expectedOutput, dataset.outputSchema, 'expectedOutput', `${cacheKey}:output`);
     }

     // Rest of existing implementation...
   }
   ```

3. Update updateItem method similarly:

   ```typescript
   async updateItem(args: UpdateDatasetItemInput): Promise<DatasetItem> {
     const existing = this.db.datasetItems.get(args.id);
     if (!existing) {
       throw new Error(`Item not found: ${args.id}`);
     }
     if (existing.datasetId !== args.datasetId) {
       throw new Error(`Item ${args.id} does not belong to dataset ${args.datasetId}`);
     }

     const dataset = this.db.datasets.get(args.datasetId);
     if (!dataset) {
       throw new Error(`Dataset not found: ${args.datasetId}`);
     }

     // Validate new values against schemas if enabled
     const validator = getSchemaValidator();
     const cacheKey = `dataset:${args.datasetId}`;

     // Validate input if being updated
     if (args.input !== undefined && dataset.inputSchema) {
       validator.validate(args.input, dataset.inputSchema, 'input', `${cacheKey}:input`);
     }

     // Validate expectedOutput if being updated
     if (args.expectedOutput !== undefined && dataset.outputSchema) {
       validator.validate(args.expectedOutput, dataset.outputSchema, 'expectedOutput', `${cacheKey}:output`);
     }

     // Rest of existing implementation...
   }
   ```

Note: The SchemaValidationError thrown will bubble up to API handler which will return 400 with field-level errors.
</action>
<verify> - `pnpm typecheck` passes - Adding item with valid data succeeds - Adding item with invalid data throws SchemaValidationError
</verify>
<done>addItem and updateItem validate against dataset schemas before persisting</done>
</task>

<task type="auto">
  <name>Task 2: Add schema change validation and tests</name>
  <files>
    packages/core/src/storage/domains/datasets/inmemory.ts
    packages/core/src/storage/domains/datasets/__tests__/datasets.test.ts
  </files>
  <action>
1. Update updateDataset in DatasetsInMemory to validate existing items when schema changes:
   ```typescript
   async updateDataset(args: UpdateDatasetInput): Promise<Dataset> {
     const existing = this.db.datasets.get(args.id);
     if (!existing) {
       throw new Error(`Dataset not found: ${args.id}`);
     }

     // Check if schemas are being added or modified
     const inputSchemaChanging = args.inputSchema !== undefined &&
       JSON.stringify(args.inputSchema) !== JSON.stringify(existing.inputSchema);
     const outputSchemaChanging = args.outputSchema !== undefined &&
       JSON.stringify(args.outputSchema) !== JSON.stringify(existing.outputSchema);

     // If schemas changing, validate all existing items against new schemas
     if (inputSchemaChanging || outputSchemaChanging) {
       const items = Array.from(this.db.datasetItems.values())
         .filter(item => item.datasetId === args.id);

       if (items.length > 0) {
         const validator = getSchemaValidator();
         const newInputSchema = args.inputSchema !== undefined ? args.inputSchema : existing.inputSchema;
         const newOutputSchema = args.outputSchema !== undefined ? args.outputSchema : existing.outputSchema;

         const result = validator.validateBatch(
           items.map(i => ({ input: i.input, expectedOutput: i.expectedOutput })),
           newInputSchema,
           newOutputSchema,
           `dataset:${args.id}:schema-update`,
           10 // Max 10 errors to report
         );

         if (result.invalid.length > 0) {
           // Throw error with failing items
           throw new SchemaUpdateValidationError(result.invalid);
         }

         // Clear old cache since schema changed
         validator.clearCache(`dataset:${args.id}:input`);
         validator.clearCache(`dataset:${args.id}:output`);
       }
     }

     const updated: Dataset = {
       ...existing,
       name: args.name ?? existing.name,
       description: args.description ?? existing.description,
       metadata: args.metadata ?? existing.metadata,
       inputSchema: args.inputSchema !== undefined ? args.inputSchema : existing.inputSchema,
       outputSchema: args.outputSchema !== undefined ? args.outputSchema : existing.outputSchema,
       updatedAt: new Date(),
     };
     this.db.datasets.set(args.id, updated);
     return updated;

}

````

2. Add SchemaUpdateValidationError to errors.ts (in previous plan's validation folder):
```typescript
// Add to packages/core/src/datasets/validation/errors.ts:

export class SchemaUpdateValidationError extends Error {
  constructor(
    public readonly failingItems: Array<{
      index: number;
      data: unknown;
      field: 'input' | 'expectedOutput';
      errors: FieldError[];
    }>
  ) {
    const count = failingItems.length;
    super(`Cannot update schema: ${count} existing item(s) would fail validation`);
    this.name = 'SchemaUpdateValidationError';
  }
}
````

3. Add import for SchemaUpdateValidationError in inmemory.ts

4. Add tests to datasets.test.ts:

   ```typescript
   describe('schema validation', () => {
     it('validates input against inputSchema on addItem', async () => {
       const dataset = await storage.createDataset({
         name: 'test',
         inputSchema: {
           type: 'object',
           properties: { name: { type: 'string' } },
           required: ['name'],
         },
       });

       // Valid item succeeds
       const item = await storage.addItem({
         datasetId: dataset.id,
         input: { name: 'Alice' },
       });
       expect(item.input).toEqual({ name: 'Alice' });

       // Invalid item throws
       await expect(
         storage.addItem({
           datasetId: dataset.id,
           input: { name: 123 }, // wrong type
         }),
       ).rejects.toThrow('Validation failed for input');
     });

     it('validates expectedOutput against outputSchema on addItem', async () => {
       const dataset = await storage.createDataset({
         name: 'test',
         outputSchema: {
           type: 'object',
           properties: { score: { type: 'number' } },
           required: ['score'],
         },
       });

       // Valid item succeeds
       const item = await storage.addItem({
         datasetId: dataset.id,
         input: 'prompt',
         expectedOutput: { score: 0.9 },
       });
       expect(item.expectedOutput).toEqual({ score: 0.9 });

       // Invalid item throws
       await expect(
         storage.addItem({
           datasetId: dataset.id,
           input: 'prompt',
           expectedOutput: { score: 'high' }, // wrong type
         }),
       ).rejects.toThrow('Validation failed for expectedOutput');
     });

     it('validates existing items when schema is added', async () => {
       const dataset = await storage.createDataset({ name: 'test' });

       // Add items without schema
       await storage.addItem({ datasetId: dataset.id, input: { name: 'Alice' } });
       await storage.addItem({ datasetId: dataset.id, input: { name: 123 } }); // would fail with schema

       // Try to add schema - should fail due to invalid item
       await expect(
         storage.updateDataset({
           id: dataset.id,
           inputSchema: {
             type: 'object',
             properties: { name: { type: 'string' } },
             required: ['name'],
           },
         }),
       ).rejects.toThrow('Cannot update schema');
     });

     it('allows schema update when all items valid', async () => {
       const dataset = await storage.createDataset({ name: 'test' });

       await storage.addItem({ datasetId: dataset.id, input: { name: 'Alice' } });
       await storage.addItem({ datasetId: dataset.id, input: { name: 'Bob' } });

       // Add schema - should succeed
       const updated = await storage.updateDataset({
         id: dataset.id,
         inputSchema: {
           type: 'object',
           properties: { name: { type: 'string' } },
           required: ['name'],
         },
       });
       expect(updated.inputSchema).toBeDefined();
     });
   });
   ```

     </action>
     <verify>
       - `pnpm test` passes in packages/core
       - Schema validation tests pass
       - Schema update validation tests pass
     </verify>
     <done>Schema change validates existing items, tests verify add/update/schema-change scenarios</done>
   </task>

</tasks>

<verification>
1. `cd packages/core && pnpm test` passes
2. Adding item with invalid input throws SchemaValidationError with field='input'
3. Adding item with invalid expectedOutput throws SchemaValidationError with field='expectedOutput'
4. Updating dataset with new schema that invalidates existing items throws SchemaUpdateValidationError
5. Updating dataset with compatible schema succeeds
</verification>

<success_criteria>

- addItem validates input and expectedOutput against dataset schemas
- updateItem validates changed fields against schemas
- updateDataset validates all existing items before allowing schema change
- SchemaUpdateValidationError includes list of up to 10 failing items with errors
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-02-SUMMARY.md`
</output>
