---
phase: 11-dataset-schema-validation
plan: 03
type: execute
wave: 2
depends_on: ['11-01']
files_modified:
  - packages/server/src/server/schemas/datasets.ts
  - packages/server/src/server/handlers/datasets.ts
  - packages/server/src/server/handlers/workflows.ts
  - packages/server/src/server/index.ts
  - packages/client-js/src/resources/datasets.ts
  - packages/client-js/src/types.ts
autonomous: true

must_haves:
  truths:
    - 'PATCH /datasets/:id accepts inputSchema and outputSchema fields'
    - 'POST /datasets accepts inputSchema and outputSchema fields'
    - 'GET /workflows/:workflowId/schema returns input/output JSON schemas'
    - 'Client SDK includes schema fields in dataset types and methods'
  artifacts:
    - path: 'packages/server/src/server/schemas/datasets.ts'
      provides: 'Zod schemas with inputSchema/outputSchema fields'
      contains: 'inputSchema'
    - path: 'packages/server/src/server/handlers/workflows.ts'
      provides: 'GET workflow schema route'
      contains: 'GET_WORKFLOW_SCHEMA_ROUTE'
    - path: 'packages/server/src/server/index.ts'
      provides: 'Route registration including workflow schema route'
      contains: 'GET_WORKFLOW_SCHEMA_ROUTE'
    - path: 'packages/client-js/src/resources/datasets.ts'
      provides: 'Client methods for schema operations'
      contains: 'inputSchema'
  key_links:
    - from: 'packages/server/src/server/handlers/datasets.ts'
      to: 'datasetsStore.updateDataset'
      via: 'handler passes schema fields'
      pattern: 'inputSchema.*outputSchema'
    - from: 'packages/server/src/server/index.ts'
      to: 'packages/server/src/server/handlers/workflows.ts'
      via: 'route registration'
      pattern: 'GET_WORKFLOW_SCHEMA_ROUTE'
---

<objective>
Add API routes for dataset schema management and workflow schema extraction.

Purpose: Enable UI to read/write schema configuration and import from workflows.
Output: Extended dataset API with schema fields, new workflow schema route, updated client SDK.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dataset-schema-validation/11-RESEARCH.md
@packages/server/src/server/schemas/datasets.ts
@packages/server/src/server/handlers/datasets.ts
@packages/server/src/server/handlers/workflows.ts
@packages/server/src/server/index.ts
@packages/client-js/src/resources/datasets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend dataset API schemas and handlers for schema fields</name>
  <files>
    packages/server/src/server/schemas/datasets.ts
    packages/server/src/server/handlers/datasets.ts
  </files>
  <action>
1. Update packages/server/src/server/schemas/datasets.ts:

Add JSON Schema Zod type (a recursive type, use z.lazy):

```typescript
// JSON Schema type (simplified for storage - full spec too complex)
const jsonSchemaObject: z.ZodType<Record<string, unknown>> = z.lazy(() => z.record(z.unknown()));

// JSON Schema field (object or null to disable)
const jsonSchemaField = z.union([jsonSchemaObject, z.null()]).optional();
```

Update createDatasetBodySchema:

```typescript
export const createDatasetBodySchema = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
  inputSchema: jsonSchemaField,
  outputSchema: jsonSchemaField,
});
```

Update updateDatasetBodySchema:

```typescript
export const updateDatasetBodySchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
  inputSchema: jsonSchemaField,
  outputSchema: jsonSchemaField,
});
```

Update datasetResponseSchema to include schema fields:

```typescript
export const datasetResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional().nullable(),
  metadata: z.record(z.unknown()).optional().nullable(),
  inputSchema: z.record(z.unknown()).optional().nullable(),
  outputSchema: z.record(z.unknown()).optional().nullable(),
  version: z.coerce.date(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});
```

2. Update packages/server/src/server/handlers/datasets.ts:

   In CREATE_DATASET_ROUTE handler, pass schema fields:

   ```typescript
   const { name, description, metadata, inputSchema, outputSchema } = params as {
     name: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: Record<string, unknown> | null;
     outputSchema?: Record<string, unknown> | null;
   };

   const dataset = await datasetsStore.createDataset({
     name,
     description,
     metadata,
     inputSchema: inputSchema as any, // JSONSchema7
     outputSchema: outputSchema as any,
   });
   ```

   In UPDATE_DATASET_ROUTE handler, pass schema fields:

   ```typescript
   const { name, description, metadata, inputSchema, outputSchema } = params as {
     name?: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: Record<string, unknown> | null;
     outputSchema?: Record<string, unknown> | null;
   };

   const dataset = await datasetsStore.updateDataset({
     id: datasetId,
     name,
     description,
     metadata,
     inputSchema: inputSchema as any,
     outputSchema: outputSchema as any,
   });
   ```

   Handle SchemaUpdateValidationError in error handler:
   Add to imports:

   ```typescript
   import { SchemaValidationError, SchemaUpdateValidationError } from '@mastra/core/datasets';
   ```

   Update handleError or add specific catch in UPDATE_DATASET_ROUTE:

   ```typescript
   } catch (error) {
     if (error instanceof SchemaValidationError) {
       throw new HTTPException(400, {
         message: error.message,
         cause: { field: error.field, errors: error.errors },
       });
     }
     if (error instanceof SchemaUpdateValidationError) {
       throw new HTTPException(400, {
         message: error.message,
         cause: { failingItems: error.failingItems },
       });
     }
     return handleError(error, 'Error updating dataset');
   }
   ```

   Also update ADD_ITEM_ROUTE and UPDATE_ITEM_ROUTE to handle SchemaValidationError.
   </action>
   <verify> - `pnpm typecheck` passes in packages/server - POST /datasets accepts inputSchema field - PATCH /datasets/:id accepts inputSchema and outputSchema fields - Invalid schema data returns 400 with field-level errors
   </verify>
   <done>Dataset API routes support schema fields with validation error handling</done>
   </task>

<task type="auto">
  <name>Task 2: Add workflow schema route, register it, and update client SDK</name>
  <files>
    packages/server/src/server/handlers/workflows.ts
    packages/server/src/server/index.ts
    packages/client-js/src/resources/datasets.ts
    packages/client-js/src/types.ts
  </files>
  <action>
1. Add workflow schema route to packages/server/src/server/handlers/workflows.ts:

First check existing workflow routes and add new schema route:

```typescript
import { getWorkflowInfo } from '@mastra/core/workflows';

export const GET_WORKFLOW_SCHEMA_ROUTE = createRoute({
  method: 'GET',
  path: '/workflows/:workflowId/schema',
  responseType: 'json',
  pathParamSchema: z.object({ workflowId: z.string() }),
  responseSchema: z.object({
    inputSchema: z.record(z.unknown()).nullable(),
    outputSchema: z.record(z.unknown()).nullable(),
  }),
  summary: 'Get workflow input/output schemas',
  description: 'Returns the JSON Schema for workflow input and output',
  tags: ['Workflows'],
  requiresAuth: true,
  handler: async ({ mastra, workflowId }) => {
    try {
      const workflow = mastra.getWorkflowById(workflowId);
      if (!workflow) {
        throw new HTTPException(404, { message: `Workflow not found: ${workflowId}` });
      }

      const info = getWorkflowInfo(workflow);

      return {
        inputSchema: info.inputSchema ? JSON.parse(info.inputSchema) : null,
        outputSchema: info.outputSchema ? JSON.parse(info.outputSchema) : null,
      };
    } catch (error) {
      return handleError(error, 'Error getting workflow schema');
    }
  },
});
```

2. Register the route in packages/server/src/server/index.ts:

   Find where workflow routes are registered (look for existing workflow route imports and registrations).
   Add import:

   ```typescript
   import { GET_WORKFLOW_SCHEMA_ROUTE } from './handlers/workflows';
   ```

   Add to route registration (find the pattern used for other routes, typically an array or app.route calls):

   ```typescript
   // Add alongside other workflow routes
   GET_WORKFLOW_SCHEMA_ROUTE;
   ```

   NOTE: The exact registration pattern depends on existing code. Look for how other routes like
   GET_WORKFLOWS_ROUTE, GET_WORKFLOW_ROUTE, etc. are registered and follow that pattern.

3. Update packages/client-js/src/types.ts to add schema fields to Dataset:

   ```typescript
   export interface Dataset {
     id: string;
     name: string;
     description?: string | null;
     metadata?: Record<string, unknown> | null;
     inputSchema?: Record<string, unknown> | null;
     outputSchema?: Record<string, unknown> | null;
     version: Date;
     createdAt: Date;
     updatedAt: Date;
   }

   export interface CreateDatasetInput {
     name: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: Record<string, unknown> | null;
     outputSchema?: Record<string, unknown> | null;
   }

   export interface UpdateDatasetInput {
     name?: string;
     description?: string;
     metadata?: Record<string, unknown>;
     inputSchema?: Record<string, unknown> | null;
     outputSchema?: Record<string, unknown> | null;
   }
   ```

4. Add getWorkflowSchema method to client SDK (if not in datasets, add to workflows resource):

   ```typescript
   // In packages/client-js/src/resources/workflows.ts or similar
   async getSchema(workflowId: string): Promise<{
     inputSchema: Record<string, unknown> | null;
     outputSchema: Record<string, unknown> | null;
   }> {
     return this.client.get(`/workflows/${encodeURIComponent(workflowId)}/schema`);
   }
   ```

   Verify the existing create/update methods in datasets.ts pass schema fields through.
   </action>
   <verify> - `pnpm typecheck` passes in packages/server and packages/client-js - GET /workflows/:workflowId/schema returns schema objects - Route is registered and accessible (check server startup logs or test endpoint) - Client SDK Dataset type includes inputSchema and outputSchema
   </verify>
   <done>Workflow schema route added and registered, client SDK types and methods updated</done>
   </task>

</tasks>

<verification>
1. `cd packages/server && pnpm typecheck` passes
2. `cd packages/client-js && pnpm typecheck` passes
3. POST /datasets with inputSchema creates dataset with schema
4. PATCH /datasets/:id with inputSchema updates schema
5. GET /workflows/:workflowId/schema returns parsed JSON schemas
6. Invalid item data returns 400 with SchemaValidationError details
</verification>

<success_criteria>

- Dataset CRUD routes accept and return inputSchema/outputSchema
- Workflow schema route returns parsed JSON schemas (not stringified)
- Workflow schema route is registered in server/index.ts
- SchemaValidationError returns 400 with { field, errors } in response
- SchemaUpdateValidationError returns 400 with { failingItems } list
- Client SDK types match server response shape
  </success_criteria>

<output>
After completion, create `.planning/phases/11-dataset-schema-validation/11-03-SUMMARY.md`
</output>
