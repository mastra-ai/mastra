---
phase: 07-strict-permission-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/ee/defaults/roles.ts
  - packages/core/src/ee/interfaces/rbac.ts
autonomous: true

must_haves:
  truths:
    - "Invalid permission strings cause TypeScript compile errors"
    - "Wildcards like '*' and 'agents:*' are valid permission values"
    - "Resource-scoped permissions like 'agents:read:my-agent' are valid"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "packages/core/src/ee/defaults/roles.ts"
      provides: "Permission type definition"
      exports: ["Permission", "StudioPermission", "STUDIO_PERMISSIONS"]
      contains: "type Permission ="
    - path: "packages/core/src/ee/interfaces/rbac.ts"
      provides: "Updated RoleDefinition interface"
      contains: "permissions: Permission[]"
  key_links:
    - from: "packages/core/src/ee/interfaces/rbac.ts"
      to: "packages/core/src/ee/defaults/roles.ts"
      via: "imports Permission type"
      pattern: "import.*Permission.*from.*roles"
    - from: "packages/core/src/ee/defaults/roles.ts"
      to: "RoleDefinition interface"
      via: "resolvePermissions return type"
      pattern: "resolvePermissions.*Permission\\[\\]"
---

<objective>
Add strict typing to RoleDefinition.permissions field to catch invalid permission strings at compile time.

Purpose: Prevent typos and invalid permissions from reaching runtime by leveraging TypeScript's type system.
Output: Permission union type that validates all permission strings including wildcards.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-strict-permission-types/07-RESEARCH.md
@packages/core/src/ee/defaults/roles.ts
@packages/core/src/ee/interfaces/rbac.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Permission union type in roles.ts</name>
  <files>packages/core/src/ee/defaults/roles.ts</files>
  <action>
Add the Permission type after the existing StudioPermission type definition. The type must include:

1. Extract Resource type from StudioPermission using template literal inference:
   `type Resource = StudioPermission extends \`\${infer R}:\${string}\` ? R : never;`

2. Define wildcard types:
   - `type ResourceWildcard = \`\${Resource}:*\`;` for patterns like 'agents:*'
   - `type ResourceActionId = \`\${StudioPermission}:\${string}\`;` for patterns like 'agents:read:my-agent'

3. Create the Permission union:
   ```typescript
   export type Permission =
     | StudioPermission    // 'studio:read', 'agents:write', etc.
     | '*'                 // Global wildcard
     | ResourceWildcard    // 'studio:*', 'agents:*', etc.
     | ResourceActionId;   // 'agents:read:my-agent', etc.
   ```

4. Update resolvePermissions return type from `string[]` to `Permission[]`
   - Change the function signature
   - Cast the Set to `Set<Permission>` (type assertion needed for Set.add with union type)
   - Return type annotation already handles Array.from

5. DO NOT change RoleMapping - it intentionally uses string[] for external provider roles

Export the Permission type for use in rbac.ts.
  </action>
  <verify>
Run: `pnpm build:core`
Expected: Build succeeds, no TypeScript errors in roles.ts
  </verify>
  <done>
Permission type exported, resolvePermissions returns Permission[], DEFAULT_ROLES typecheck with Permission[].
  </done>
</task>

<task type="auto">
  <name>Task 2: Update RoleDefinition interface to use Permission type</name>
  <files>packages/core/src/ee/interfaces/rbac.ts</files>
  <action>
1. Import Permission type from '../defaults/roles':
   `import type { Permission } from '../defaults/roles';`

2. Update RoleDefinition interface:
   Change `permissions: string[];` to `permissions: Permission[];`

3. Keep RoleMapping unchanged - it uses string[] intentionally for external providers

4. Verify no other types in this file need updating (IRBACProvider.getPermissions returns string[] - this is correct as it's the runtime resolved set)

Note: IRBACProvider.getPermissions and related methods return string[] because they return resolved permissions at runtime which may include dynamically computed values. Only RoleDefinition.permissions (the static definition) should be strictly typed.
  </action>
  <verify>
Run: `pnpm build:core && pnpm typecheck`
Expected: Full build and typecheck pass, no errors
  </verify>
  <done>
RoleDefinition.permissions typed as Permission[], TypeScript catches invalid permission strings at compile time.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build:core` - Core package builds successfully
2. `pnpm typecheck` - Full monorepo typecheck passes
3. Verify invalid permission causes error:
   - Temporarily add `'invalid:perm'` to DEFAULT_ROLES permissions
   - Confirm TypeScript error on build
   - Remove the test string
</verification>

<success_criteria>
1. Permission type exists and exports from roles.ts
2. RoleDefinition.permissions uses Permission[] type
3. DEFAULT_ROLES typecheck without errors
4. Invalid permission strings cause TypeScript compile errors
5. Wildcards ('*', 'agents:*') and resource-scoped ('agents:read:id') are valid
6. No breaking changes to runtime behavior
7. pnpm build:core && pnpm typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-strict-permission-types/07-01-SUMMARY.md`
</output>
