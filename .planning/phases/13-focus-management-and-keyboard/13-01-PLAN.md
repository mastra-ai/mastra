---
phase: 13-focus-management-and-keyboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/playground-ui/src/domains/agents/utils/key-mapping.ts
  - packages/playground-ui/src/domains/agents/hooks/use-keyboard-interaction.ts
autonomous: true

must_haves:
  truths:
    - "isPrintableKey('a') returns true, isPrintableKey('Enter') returns false"
    - "Keyboard hook sends 3-event CDP sequence (keyDown, char, keyUp) for printable characters"
    - "Keyboard hook sends 2-event CDP sequence (keyDown, keyUp) for non-printable keys"
    - "IME composition events are skipped; composed text sent on compositionend"
    - "Escape key calls onEscape callback and is NOT forwarded to browser"
    - "All keyboard events call preventDefault and stopPropagation in capture phase"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/utils/key-mapping.ts"
      provides: "isPrintableKey utility function"
      exports: ["isPrintableKey"]
    - path: "packages/playground-ui/src/domains/agents/hooks/use-keyboard-interaction.ts"
      provides: "Keyboard event capture and CDP forwarding hook"
      exports: ["useKeyboardInteraction"]
  key_links:
    - from: "use-keyboard-interaction.ts"
      to: "coordinate-mapping.ts"
      via: "getModifiers import"
      pattern: "import.*getModifiers.*from.*coordinate-mapping"
    - from: "use-keyboard-interaction.ts"
      to: "key-mapping.ts"
      via: "isPrintableKey import"
      pattern: "import.*isPrintableKey.*from.*key-mapping"
    - from: "use-keyboard-interaction.ts"
      to: "WebSocket sendMessage"
      via: "sendRef.current(JSON.stringify(msg))"
      pattern: "sendRef\\.current\\(JSON\\.stringify"
---

<objective>
Create the key-mapping utility and useKeyboardInteraction hook that captures keyboard events in the DOM capture phase and forwards them as CDP keyboard messages over the existing WebSocket.

Purpose: This plan builds the keyboard event translation layer -- the core mechanism that converts DOM KeyboardEvents into CDP Input.dispatchKeyEvent sequences. It follows the exact same architectural pattern as useMouseInteraction from Phase 12 (side-effect-only hook, ref-based closure freshness, Record<string,unknown> CDP messages). The hook is gated by an `enabled` boolean but does NOT manage interactive mode state itself -- that is Plan 02's responsibility.

Output: Two new files -- a pure utility for printable key detection and a React hook for keyboard event capture and forwarding.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-focus-management-and-keyboard/13-CONTEXT.md
@.planning/phases/13-focus-management-and-keyboard/13-RESEARCH.md
@.planning/phases/12-client-coordinate-mapping-and-click/12-03-SUMMARY.md

# Source files to reference for patterns and imports
@packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts
@packages/playground-ui/src/domains/agents/utils/coordinate-mapping.ts
@packages/deployer/src/server/browser-stream/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create key-mapping utility</name>
  <files>packages/playground-ui/src/domains/agents/utils/key-mapping.ts</files>
  <action>
Create `key-mapping.ts` with a single exported pure function:

```typescript
/**
 * Determine if a KeyboardEvent.key value represents a printable character.
 *
 * Printable characters have key.length === 1 (single Unicode character).
 * Non-printable keys have multi-character names: 'Enter', 'ArrowLeft', 'Shift', etc.
 * Dead keys return 'Dead' (length > 1, correctly treated as non-printable).
 */
export function isPrintableKey(key: string): boolean {
  return key.length === 1;
}
```

This is a single-line pure function extracted to its own file for testability and consistency with the coordinate-mapping.ts pattern (pure utilities in utils/, hooks in hooks/).

No other exports in this file. No imports needed.
  </action>
  <verify>
Run: `cd packages/playground-ui && npx tsc --noEmit --strict key-mapping.ts 2>&1 || echo "tsc not available standalone"`

If tsc check not feasible standalone, verify by reading the file and confirming:
1. Single export: `isPrintableKey`
2. Takes `key: string`, returns `boolean`
3. Body is `return key.length === 1;`
  </verify>
  <done>
key-mapping.ts exists with isPrintableKey exported. isPrintableKey('a') would return true, isPrintableKey('Enter') would return false, isPrintableKey('Dead') would return false.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useKeyboardInteraction hook</name>
  <files>packages/playground-ui/src/domains/agents/hooks/use-keyboard-interaction.ts</files>
  <action>
Create `use-keyboard-interaction.ts` following the EXACT same architectural patterns as `use-mouse-interaction.ts`:

**Interface:**
```typescript
interface UseKeyboardInteractionOptions {
  sendMessage: (data: string) => void;
  enabled: boolean;
  onEscape: () => void;
}
```

**Hook signature:**
```typescript
export function useKeyboardInteraction(options: UseKeyboardInteractionOptions): void
```

**Implementation details:**

1. **Ref pattern** (same as useMouseInteraction):
   - `const sendRef = useRef(options.sendMessage);` with sync useEffect
   - `const onEscapeRef = useRef(options.onEscape);` with sync useEffect
   - This avoids re-attaching document listeners when callbacks change

2. **Main useEffect** gated by `options.enabled`:
   - If `!options.enabled`, return early (no listeners attached)
   - Deps array: `[options.enabled]` -- refs handle value freshness

3. **Internal helper** `sendKeyboardMsg`:
   ```typescript
   function sendKeyboardMsg(
     eventType: 'keyDown' | 'keyUp' | 'char',
     key?: string,
     code?: string,
     text?: string,
     modifiers?: number,
   ): void {
     const msg: Record<string, unknown> = { type: 'keyboard', eventType };
     if (key !== undefined) msg.key = key;
     if (code !== undefined) msg.code = code;
     if (text !== undefined) msg.text = text;
     if (modifiers) msg.modifiers = modifiers;
     sendRef.current(JSON.stringify(msg));
   }
   ```
   Matches the `sendMouseEvent` pattern from useMouseInteraction -- builds Record<string,unknown>, no server type imports.

4. **handleKeyDown** listener (capture phase):
   - FIRST: Check `e.isComposing || e.keyCode === 229` -- return early (skip IME)
   - SECOND: Check `e.key === 'Escape'` -- call `e.preventDefault()`, `e.stopPropagation()`, `onEscapeRef.current()`, return (consumed)
   - THIRD: Call `e.preventDefault()` and `e.stopPropagation()` (prevent host page leaking)
   - Compute modifiers: `const modifiers = getModifiers(e);`
   - Check printable: `const isPrintable = isPrintableKey(e.key);`
   - Send keyDown: `sendKeyboardMsg('keyDown', e.key, e.code, undefined, modifiers);`
   - If printable, also send char: `sendKeyboardMsg('char', e.key, undefined, e.key, modifiers);`

5. **handleKeyUp** listener (capture phase):
   - Check `e.isComposing || e.keyCode === 229` -- return early
   - Check `e.key === 'Escape'` -- return early (already handled in keyDown)
   - Call `e.preventDefault()` and `e.stopPropagation()`
   - Send keyUp: `sendKeyboardMsg('keyUp', e.key, e.code, undefined, getModifiers(e));`

6. **handleCompositionEnd** listener (bubble phase, not capture):
   - Get composed text: `const text = e.data;`
   - If empty, return
   - For each character in text: send 3-event sequence (keyDown, char, keyUp) with modifiers=0

7. **Listener attachment:**
   ```typescript
   document.addEventListener('keydown', handleKeyDown, { capture: true });
   document.addEventListener('keyup', handleKeyUp, { capture: true });
   document.addEventListener('compositionend', handleCompositionEnd);
   ```
   CRITICAL: keydown and keyup use `{ capture: true }` for FOCUS-03 (prevent leaking).
   compositionend uses bubble phase (standard).

8. **Cleanup:** Remove all three listeners in the same order.

**Imports:**
```typescript
import { useEffect, useRef } from 'react';
import { getModifiers } from '../utils/coordinate-mapping';
import { isPrintableKey } from '../utils/key-mapping';
```

**JSDoc comment** following useMouseInteraction style:
```
/**
 * Side-effect-only hook that captures keyboard events when interactive
 * mode is active and forwards them as CDP keyboard messages over WebSocket.
 *
 * Uses capture-phase document listeners to prevent keyboard events from
 * reaching host page handlers (chat input, Studio shortcuts).
 *
 * Printable characters: 3-event sequence (keyDown -> char -> keyUp)
 * Non-printable keys: 2-event sequence (keyDown -> keyUp)
 * IME composition: skipped during composition, final text sent on compositionend
 * Escape: consumed to exit interactive mode (not forwarded)
 */
```

DO NOT:
- Import any types from the deployer package (use Record<string,unknown> like useMouseInteraction)
- Use React onKeyDown props (use raw addEventListener)
- Forward Escape to the browser
- Send a char event for non-printable keys
- Track modifier state manually (read from each KeyboardEvent via getModifiers)
  </action>
  <verify>
Read the created file and verify:
1. Imports getModifiers from coordinate-mapping and isPrintableKey from key-mapping
2. sendRef and onEscapeRef pattern matches useMouseInteraction's viewportRef/sendRef pattern
3. handleKeyDown checks IME first, Escape second, then forwards
4. Printable keys get 3 messages (keyDown, char, keyUp)
5. Non-printable keys get 2 messages (keyDown in handleKeyDown, keyUp in handleKeyUp)
6. All listeners use capture: true for keydown/keyup
7. compositionend listener attached without capture
8. Cleanup removes all three listeners
9. No server type imports -- message built as Record<string,unknown>
  </verify>
  <done>
useKeyboardInteraction hook exists with:
- Capture-phase document listeners for keydown/keyup
- Bubble-phase listener for compositionend
- 3-event CDP sequence for printable characters (keyDown -> char -> keyUp)
- 2-event CDP sequence for non-printable keys (keyDown -> keyUp)
- IME composition events skipped, composed text sent on compositionend
- Escape consumed (calls onEscape, not forwarded to browser)
- preventDefault + stopPropagation on all handled events (prevents host page leaking)
- Ref-based closure freshness for sendMessage and onEscape callbacks
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File existence:** Both `key-mapping.ts` and `use-keyboard-interaction.ts` exist in their respective directories
2. **Import chain valid:** use-keyboard-interaction imports from both coordinate-mapping and key-mapping
3. **Pattern consistency:** Side-effect-only hook with void return, ref-based closure freshness, Record<string,unknown> message construction
4. **CDP sequence correctness:** Printable -> 3 events, non-printable -> 2 events, Escape -> onEscape callback only
5. **Capture phase listeners:** keydown and keyup use `{ capture: true }`
6. **IME handling:** isComposing/keyCode 229 guard in both keydown and keyup handlers
7. **No server type imports:** Messages built as Record<string,unknown>
</verification>

<success_criteria>
- key-mapping.ts exports isPrintableKey function
- use-keyboard-interaction.ts exports useKeyboardInteraction hook
- Hook follows identical architectural patterns as useMouseInteraction (refs, void return, capture phase listeners)
- CDP keyboard message shape matches KeyboardInputMessage interface (type, eventType, key, code, text, modifiers)
- Escape is consumed, not forwarded
- IME composition handled correctly
- No host page event leaking (capture phase + stopPropagation + preventDefault)
</success_criteria>

<output>
After completion, create `.planning/phases/13-focus-management-and-keyboard/13-01-SUMMARY.md`
</output>
