---
phase: 13-focus-management-and-keyboard
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking the live view frame when streaming enters interactive mode"
    - "Clicking outside the frame exits interactive mode"
    - "Pressing Escape exits interactive mode"
    - "Switching browser tabs or windows exits interactive mode"
    - "Keyboard events in interactive mode are forwarded to the remote browser via useKeyboardInteraction"
    - "Keyboard events do NOT reach the host page chat input or Studio shortcuts when interactive"
    - "Interactive mode has a visual indicator (border highlight or similar)"
    - "Interactive mode only activates when status is streaming"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx"
      provides: "Interactive mode state management and keyboard hook wiring"
      contains: "useKeyboardInteraction"
  key_links:
    - from: "browser-view-frame.tsx"
      to: "use-keyboard-interaction.ts"
      via: "useKeyboardInteraction hook call"
      pattern: "useKeyboardInteraction\\("
    - from: "browser-view-frame.tsx"
      to: "isInteractive state"
      via: "useState for interactive mode"
      pattern: "useState.*false.*isInteractive|isInteractive.*useState"
    - from: "browser-view-frame.tsx click handler"
      to: "setIsInteractive(true)"
      via: "Frame click enters interactive mode"
      pattern: "setIsInteractive\\(true\\)"
    - from: "browser-view-frame.tsx click-outside handler"
      to: "setIsInteractive(false)"
      via: "Document mousedown exits interactive mode"
      pattern: "setIsInteractive\\(false\\)"
---

<objective>
Add interactive mode state management to BrowserViewFrame and wire the useKeyboardInteraction hook so that clicking the live view frame enables keyboard capture and clicking outside (or pressing Escape, or window blur) disables it.

Purpose: This plan implements the focus management layer (FOCUS-01, FOCUS-02, FOCUS-03) and connects the keyboard hook (from Plan 01) to the component tree. After this plan, users can click the live view frame to enter interactive mode, type to forward keystrokes to the remote browser, and press Escape or click outside to exit.

Output: Modified browser-view-frame.tsx with interactive mode state, click-outside/blur/Escape exit behaviors, keyboard hook wiring, and a visual interactive mode indicator.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-focus-management-and-keyboard/13-CONTEXT.md
@.planning/phases/13-focus-management-and-keyboard/13-RESEARCH.md
@.planning/phases/13-focus-management-and-keyboard/13-01-PLAN.md

# Source files
@packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
@packages/playground-ui/src/domains/agents/hooks/use-keyboard-interaction.ts
@packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add interactive mode state and exit behaviors</name>
  <files>packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx</files>
  <action>
Modify `browser-view-frame.tsx` to add interactive mode state management. This task adds the state and exit behaviors but does NOT yet wire the keyboard hook (Task 2 does that).

**1. Add new imports:**
```typescript
// Add useRef to existing import (already has useCallback, useEffect, useRef, useState)
// No new React imports needed -- useRef already imported for imgRef
```

**2. Add containerRef:**
The outermost `<div>` needs a ref for click-outside detection. Add:
```typescript
const containerRef = useRef<HTMLDivElement>(null);
```

**3. Add isInteractive state:**
```typescript
const [isInteractive, setIsInteractive] = useState(false);
```

**4. Add exitInteractive callback:**
```typescript
const exitInteractive = useCallback(() => {
  setIsInteractive(false);
}, []);
```

**5. Add frame click handler for entering interactive mode:**
The existing `<img>` element needs an onClick handler. Add a handler that enters interactive mode only when streaming:
```typescript
const handleFrameClick = useCallback(() => {
  if (status === 'streaming') {
    setIsInteractive(true);
  }
}, [status]);
```
Wire this to the `<img>` element: `onClick={handleFrameClick}`

**6. Add click-outside and window blur useEffect:**
This effect only runs when isInteractive is true. It listens for:
- `mousedown` on document: if target is outside containerRef, exit interactive mode
- `blur` on window: exit interactive mode (user switched tabs/windows)

```typescript
useEffect(() => {
  if (!isInteractive) return;

  function handleDocumentMouseDown(e: MouseEvent) {
    if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
      setIsInteractive(false);
    }
  }

  function handleWindowBlur() {
    setIsInteractive(false);
  }

  document.addEventListener('mousedown', handleDocumentMouseDown);
  window.addEventListener('blur', handleWindowBlur);

  return () => {
    document.removeEventListener('mousedown', handleDocumentMouseDown);
    window.removeEventListener('blur', handleWindowBlur);
  };
}, [isInteractive]);
```

**7. Reset interactive mode when status changes away from streaming:**
If the browser disconnects or errors, exit interactive mode:
```typescript
useEffect(() => {
  if (status !== 'streaming') {
    setIsInteractive(false);
  }
}, [status]);
```

**8. Add ref to container div:**
Change the outermost div from:
```tsx
<div className={cn('relative w-full aspect-video bg-surface2 rounded-md overflow-hidden', className)}>
```
to:
```tsx
<div ref={containerRef} className={cn('relative w-full aspect-video bg-surface2 rounded-md overflow-hidden', className)}>
```

**9. Add visual interactive mode indicator:**
Add a ring/border highlight when interactive mode is active. Use Tailwind classes on the container div:
```tsx
<div
  ref={containerRef}
  className={cn(
    'relative w-full aspect-video bg-surface2 rounded-md overflow-hidden',
    isInteractive && 'ring-2 ring-accent1',
    className,
  )}
>
```
This adds a 2px ring in the accent color when interactive, providing immediate visual feedback that keyboard capture is active.

**10. Update cursor style on img:**
When interactive, change cursor from pointer to text (indicating typing is active):
```tsx
className={cn(
  'absolute inset-0 w-full h-full object-contain',
  hasFrame ? 'opacity-100' : 'opacity-0',
  status === 'streaming' && (isInteractive ? 'cursor-text' : 'cursor-pointer'),
)}
```

IMPORTANT ordering notes:
- Place `isInteractive` state after `hasFrame` state
- Place `exitInteractive` callback after `handleFrame` callback
- Place the click-outside/blur useEffect after the status notification useEffects
- Place the status-reset useEffect after the click-outside/blur useEffect
  </action>
  <verify>
Read the modified file and verify:
1. `containerRef` declared with `useRef<HTMLDivElement>(null)`
2. `isInteractive` state declared with `useState(false)`
3. `exitInteractive` callback declared with `useCallback`
4. `handleFrameClick` callback checks `status === 'streaming'` before setting interactive
5. Click-outside useEffect uses `document.addEventListener('mousedown', ...)` with `container.contains()` check
6. Window blur useEffect exits interactive mode
7. Status-change useEffect resets interactive mode when not streaming
8. Container div has `ref={containerRef}`
9. Container div has conditional `ring-2 ring-accent1` class when interactive
10. Img element has `onClick={handleFrameClick}`
11. Img cursor changes from pointer to text when interactive
  </verify>
  <done>
BrowserViewFrame has interactive mode state with:
- Click on frame enters interactive mode (only when streaming)
- Click outside frame exits interactive mode (mousedown + contains check)
- Window blur exits interactive mode
- Status change away from streaming exits interactive mode
- Visual ring indicator when interactive
- Cursor changes from pointer (clickable) to text (typing) when interactive
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire useKeyboardInteraction hook</name>
  <files>packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx</files>
  <action>
Wire the useKeyboardInteraction hook into BrowserViewFrame, connecting it to the interactive mode state from Task 1.

**1. Add import:**
```typescript
import { useKeyboardInteraction } from '../../hooks/use-keyboard-interaction';
```
Place this import right after the useMouseInteraction import.

**2. Call the hook:**
Place the useKeyboardInteraction call right after the useMouseInteraction call:
```typescript
useKeyboardInteraction({
  sendMessage,
  enabled: isInteractive,
  onEscape: exitInteractive,
});
```

This wiring means:
- `sendMessage` is the same WebSocket sender used by useMouseInteraction (from useBrowserStream)
- `enabled: isInteractive` -- keyboard capture only active when user has clicked into the frame
- `onEscape: exitInteractive` -- pressing Escape calls setIsInteractive(false), exiting interactive mode

Note: The hook's `enabled` flag is `isInteractive` (not `status === 'streaming'`). The status check is already handled by the interactive mode state -- you cannot be interactive if not streaming (the status-reset useEffect from Task 1 ensures this). This avoids redundant checks inside the hook.

DO NOT:
- Add any other logic beyond the import and hook call
- Change the useMouseInteraction call
- Modify any other part of the component
  </action>
  <verify>
Read the modified file and verify:
1. `useKeyboardInteraction` is imported from `../../hooks/use-keyboard-interaction`
2. The hook is called with `{ sendMessage, enabled: isInteractive, onEscape: exitInteractive }`
3. The hook call is placed after useMouseInteraction
4. useMouseInteraction call is unchanged
5. No other changes beyond the import and hook call
  </verify>
  <done>
useKeyboardInteraction wired into BrowserViewFrame with:
- sendMessage from useBrowserStream (same transport as mouse events)
- enabled gated by isInteractive state (keyboard capture only when interactive)
- onEscape wired to exitInteractive (Escape key exits interactive mode)
- Full keyboard input pipeline operational: frame click -> interactive mode -> keydown -> useKeyboardInteraction -> sendMessage -> WebSocket -> server -> CDP
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full interactive mode + keyboard pipeline:

1. **State management:** BrowserViewFrame has isInteractive state, enterred by frame click, exited by click-outside/Escape/blur/status-change
2. **Keyboard hook wired:** useKeyboardInteraction called with isInteractive as enabled flag
3. **Visual feedback:** Ring indicator on container when interactive, cursor changes from pointer to text
4. **No event leaking:** Keyboard hook uses capture-phase listeners (from Plan 01), interactive mode gates activation
5. **Exit behaviors:** Escape -> onEscape -> setIsInteractive(false), click-outside -> mousedown handler, blur -> window handler
6. **Full pipeline:** DOM keyboard event -> capture-phase listener -> CDP message -> sendMessage -> WebSocket -> server input handler -> CDP injectKeyboardEvent
7. **Build check:** `cd packages/playground-ui && pnpm build` completes without errors
</verification>

<success_criteria>
- Clicking the live view frame enters interactive mode (ring indicator visible)
- Pressing Escape exits interactive mode (ring disappears)
- Clicking outside the frame exits interactive mode
- Switching browser tabs exits interactive mode
- When interactive, keyboard events are forwarded to the remote browser
- When interactive, keyboard events do NOT reach the host page
- When not interactive, keyboard events are NOT captured
- Interactive mode cannot activate when status is not streaming
</success_criteria>

<output>
After completion, create `.planning/phases/13-focus-management-and-keyboard/13-02-SUMMARY.md`
</output>
