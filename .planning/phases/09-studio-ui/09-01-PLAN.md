---
phase: 09-studio-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-header.tsx
  - packages/playground-ui/src/domains/agents/components/browser-view/index.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket connects to /browser/:agentId/stream endpoint"
    - "Frame updates bypass React virtual DOM via useRef"
    - "Connection status is tracked (idle, connecting, streaming, disconnected, error)"
    - "Auto-reconnect happens with exponential backoff"
    - "Tab visibility changes trigger reconnection"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts"
      provides: "WebSocket management hook"
      exports: ["useBrowserStream", "StreamStatus"]
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx"
      provides: "Frame renderer with useRef pattern"
      exports: ["BrowserViewFrame"]
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-header.tsx"
      provides: "URL bar with status indicator"
      exports: ["BrowserViewHeader"]
  key_links:
    - from: "use-browser-stream.ts"
      to: "/browser/:agentId/stream"
      via: "new WebSocket()"
      pattern: "WebSocket.*browser.*stream"
    - from: "browser-view-frame.tsx"
      to: "use-browser-stream.ts"
      via: "onFrame callback updates imgRef.current.src"
      pattern: "imgRef\\.current\\.src.*base64"
---

<objective>
Create the browser stream hook and frame rendering components.

Purpose: Build the foundational WebSocket connection and performant frame display that will power the browser view panel.
Output: useBrowserStream hook + BrowserViewFrame/BrowserViewHeader components
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-studio-ui/09-CONTEXT.md
@.planning/phases/09-studio-ui/09-RESEARCH.md
@packages/deployer/src/server/browser-stream/types.ts
@packages/playground-ui/src/ds/components/StatusBadge/StatusBadge.tsx
@packages/playground-ui/src/ds/components/Skeleton/skeleton.tsx
@packages/playground-ui/src/domains/agents/hooks/use-agent.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBrowserStream hook</name>
  <files>packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts</files>
  <action>
Create a WebSocket management hook for browser screencast streaming.

**Type exports:**
```typescript
export type StreamStatus =
  | 'idle'           // Not connected
  | 'connecting'     // WebSocket connecting
  | 'connected'      // WebSocket open, waiting for stream
  | 'browser_starting' // Browser launching
  | 'streaming'      // Receiving frames
  | 'disconnected'   // Connection lost
  | 'error';         // Error state
```

**Hook signature:**
```typescript
interface UseBrowserStreamOptions {
  agentId: string;
  enabled?: boolean;
  onFrame?: (data: string) => void;
  maxReconnectAttempts?: number;
}

export function useBrowserStream(options: UseBrowserStreamOptions): {
  status: StreamStatus;
  error: string | null;
  currentUrl: string | null;
  connect: () => void;
  disconnect: () => void;
  isActive: boolean;
}
```

**Implementation requirements:**
1. WebSocket URL construction: Detect protocol (ws:/wss:) based on `window.location.protocol`
2. Store WebSocket in useRef (not useState) to avoid creating new connections on render
3. Parse incoming messages: JSON for status/error, plain text for base64 frames
4. Track reconnect attempts in useRef, reset on successful connect
5. Exponential backoff: `Math.min(1000 * Math.pow(2, attempt), 30000)` (1s, 2s, 4s... max 30s)
6. Handle `visibilitychange` event: reconnect when tab becomes visible AND status is disconnected
7. Cleanup: Clear timeout and close WebSocket in useEffect cleanup

**Message parsing logic:**
- If `data.startsWith('{')` -> try JSON.parse, extract `status`, `error`, `url` fields
- Otherwise -> treat as base64 frame data, call `onFrame?.(data)`

**Do NOT:**
- Store frames in state (would cause re-renders)
- Use dependencies that change on every render in useCallback
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd packages/playground-ui && pnpm tsc --noEmit
```
  </verify>
  <done>
Hook exports StreamStatus type and useBrowserStream function. TypeScript compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BrowserViewFrame and BrowserViewHeader components</name>
  <files>
packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
packages/playground-ui/src/domains/agents/components/browser-view/browser-view-header.tsx
packages/playground-ui/src/domains/agents/components/browser-view/index.ts
  </files>
  <action>
Create the frame rendering and header components for browser view.

**BrowserViewFrame (`browser-view-frame.tsx`):**

```typescript
interface BrowserViewFrameProps {
  agentId: string;
  className?: string;
  onStatusChange?: (status: StreamStatus) => void;
  onUrlChange?: (url: string | null) => void;
}
```

Implementation:
1. Use `useRef<HTMLImageElement>` for the img element
2. Use `useRef<boolean>` to track if any frame has been received (hasFrameRef)
3. Call useBrowserStream with `onFrame` callback that sets `imgRef.current.src = \`data:image/jpeg;base64,\${data}\``
4. When frame received, set `hasFrameRef.current = true`
5. Call `onStatusChange` and `onUrlChange` via useEffect when status/currentUrl change

**Conditional rendering inside the frame container:**
- If `status === 'connecting' || status === 'browser_starting'` -> show `<Skeleton className="absolute inset-0" />`
- If `status === 'disconnected' && hasFrameRef.current` -> show reconnecting overlay on last frame
- If `status === 'error'` -> show error overlay with error message
- Always render the img element (hidden until first frame via className toggle)

Use `cn()` from `@/lib/utils` for class merging. Container should be `relative w-full aspect-video bg-surface2 rounded-md overflow-hidden`.

**BrowserViewHeader (`browser-view-header.tsx`):**

```typescript
interface BrowserViewHeaderProps {
  url: string | null;
  status: StreamStatus;
  className?: string;
}
```

Implementation:
1. Display URL in truncated format (use `truncate` Tailwind class)
2. Show StatusBadge with appropriate variant based on status:
   - `idle`, `neutral` -> neutral variant, no pulse
   - `connecting`, `connected`, `browser_starting` -> warning variant, pulse: true
   - `streaming` -> success variant, label "Live"
   - `disconnected` -> error variant, pulse: true
   - `error` -> error variant, no pulse
3. Use `withDot` and `size="sm"` on StatusBadge

Layout: flex row with URL on left, status badge on right, padding, subtle border-bottom.

**Index file (`index.ts`):**
Export all components and the hook re-export for convenience:
```typescript
export { BrowserViewFrame } from './browser-view-frame';
export { BrowserViewHeader } from './browser-view-header';
export { useBrowserStream, type StreamStatus } from '../../hooks/use-browser-stream';
```

**Do NOT:**
- Use useState for the image src (defeats the purpose)
- Create new callback functions inside render (breaks useCallback memoization)
  </action>
  <verify>
1. TypeScript compiles:
```bash
cd packages/playground-ui && pnpm tsc --noEmit
```
2. Components export correctly:
```bash
grep -l "export.*BrowserViewFrame" packages/playground-ui/src/domains/agents/components/browser-view/*.tsx
```
  </verify>
  <done>
BrowserViewFrame renders img element with useRef pattern. BrowserViewHeader shows URL and StatusBadge. Both TypeScript compile and export correctly.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes in playground-ui
2. Hook file exports: `StreamStatus`, `useBrowserStream`
3. Components export: `BrowserViewFrame`, `BrowserViewHeader`
4. Frame component uses `imgRef.current.src` pattern (grep confirms)
5. No `useState` for frame data in BrowserViewFrame
</verification>

<success_criteria>
- useBrowserStream hook manages WebSocket lifecycle with auto-reconnect
- BrowserViewFrame uses useRef to update image without re-renders
- BrowserViewHeader displays URL and status with design system components
- All files TypeScript compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-studio-ui/09-01-SUMMARY.md`
</output>
