---
phase: 01-transport-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - auth/cloud/src/client.ts
autonomous: true

must_haves:
  truths:
    - 'request<T>() sends Authorization: Bearer <token> header when token provided'
    - 'request<T>() omits Authorization header when no token'
    - 'Successful responses unwrapped from { ok: true, data } envelope'
    - 'Failed responses throw CloudApiError with message, status, code'
  artifacts:
    - path: 'auth/cloud/src/client.ts'
      provides: 'Transport layer types and request helper'
      exports: ['CloudApiError']
      contains: 'CloudApiResponse'
  key_links:
    - from: 'request<T>()'
      to: 'CloudApiError'
      via: 'throws on !ok or !response.ok'
      pattern: 'throw new CloudApiError'
    - from: 'request<T>()'
      to: 'CloudApiResponse<T>'
      via: 'response parsing'
      pattern: 'as CloudApiResponse<T>'
---

<objective>
Add transport layer foundation to MastraCloudClient.

Purpose: All Cloud API methods will use this `request<T>()` helper for consistent auth headers and response unwrapping.
Output: Types (`CloudApiResponse<T>`, `CloudApiError`) and private `request<T>()` method in client.ts.
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@auth/cloud/IMPLEMENTATION_PLAN.md
@auth/cloud/src/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transport types and error class</name>
  <files>auth/cloud/src/client.ts</files>
  <action>
Add at top of file (after existing interface declarations):

1. `CloudApiResponse<T>` interface:

   ```typescript
   interface CloudApiResponse<T> {
     ok: boolean;
     data?: T;
     error?: {
       message: string;
       code?: string;
       status: number;
     };
   }
   ```

2. `CloudApiError` class (exported):

   ```typescript
   export class CloudApiError extends Error {
     public readonly status: number;
     public readonly code?: string;

     constructor(message: string, status: number, code?: string) {
       super(message);
       this.name = 'CloudApiError';
       this.status = status;
       this.code = code;
       Object.setPrototypeOf(this, CloudApiError.prototype);
     }
   }
   ```

Why `Object.setPrototypeOf`: Required for proper `instanceof` checks when extending Error in TypeScript.
</action>
<verify>
TypeScript compiles: `cd auth/cloud && pnpm exec tsc --noEmit`
</verify>
<done>
`CloudApiResponse<T>` interface exists, `CloudApiError` class exported.
</done>
</task>

<task type="auto">
  <name>Task 2: Add request helper method</name>
  <files>auth/cloud/src/client.ts</files>
  <action>
Add private method to `MastraCloudClient` class (before `verifyToken`):

```typescript
/**
 * Make authenticated request to Cloud API.
 * Handles Authorization header and response envelope unwrapping.
 */
private async request<T>(
  path: string,
  options: RequestInit = {},
  token?: string
): Promise<T> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'X-Project-ID': this.projectId,
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  // Merge with any provided headers
  const mergedHeaders = {
    ...headers,
    ...(options.headers as Record<string, string> || {}),
  };

  const response = await fetch(`${this.baseUrl}${path}`, {
    ...options,
    headers: mergedHeaders,
  });

  // Handle non-JSON responses (network errors, etc)
  let json: CloudApiResponse<T>;
  try {
    json = await response.json() as CloudApiResponse<T>;
  } catch {
    throw new CloudApiError(
      `HTTP ${response.status}: ${response.statusText}`,
      response.status
    );
  }

  // Check BOTH response.ok AND json.ok (Cloud returns 200 with ok:false for some errors)
  if (!response.ok || !json.ok) {
    throw new CloudApiError(
      json.error?.message ?? `Request failed: ${response.status}`,
      json.error?.status ?? response.status,
      json.error?.code
    );
  }

  if (json.data === undefined) {
    throw new CloudApiError('No data in response', 500);
  }

  return json.data;
}
```

Key behaviors:

- Always includes `Content-Type` and `X-Project-ID` headers
- Adds `Authorization: Bearer <token>` only when token provided
- Checks both `response.ok` AND `json.ok` (Cloud envelope semantics)
- Throws `CloudApiError` with structured info on any failure
- Returns unwrapped `data` on success
  </action>
  <verify>
  TypeScript compiles: `cd auth/cloud && pnpm exec tsc --noEmit`
  </verify>
  <done>
  `request<T>()` method exists with Bearer auth injection and envelope unwrapping.
  </done>
  </task>

</tasks>

<verification>
1. TypeScript compiles without errors:
   ```bash
   cd auth/cloud && pnpm exec tsc --noEmit
   ```

2. Grep confirms types exist:

   ```bash
   grep -n "CloudApiResponse" auth/cloud/src/client.ts
   grep -n "CloudApiError" auth/cloud/src/client.ts
   grep -n "private async request" auth/cloud/src/client.ts
   ```

3. Grep confirms Bearer pattern:
   ```bash
   grep -n "Bearer" auth/cloud/src/client.ts
   ```
   </verification>

<success_criteria>

- `CloudApiResponse<T>` interface defined with `ok`, `data`, `error` fields
- `CloudApiError` class exported with `status` and `code` properties
- `request<T>()` private method handles auth header and envelope unwrapping
- TypeScript compiles without errors
- Existing methods unchanged (they will be updated in Phase 2)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-transport-layer/01-01-SUMMARY.md`
</output>
