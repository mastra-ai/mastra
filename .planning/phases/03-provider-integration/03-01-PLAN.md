---
phase: 03-provider-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - auth/cloud/package.json
  - auth/cloud/src/client.ts
  - auth/cloud/src/index.ts
autonomous: true

must_haves:
  truths:
    - 'CloudUser type includes required sessionToken field'
    - 'CloudUser type does NOT include roles field'
    - 'handleCallback() decodes JWT locally and returns user with sessionToken'
    - 'getPermissions() extracts role from JWT and resolves via resolvePermissions()'
    - 'getCurrentUser() decodes sessionToken JWT locally to get user info (NO API call)'
    - 'createSession() throws CloudApiError with 501 status'
    - 'TypeScript compiles without errors'
  artifacts:
    - path: 'auth/cloud/package.json'
      provides: 'jose dependency'
      contains: '"jose"'
    - path: 'auth/cloud/src/client.ts'
      provides: 'CloudUser with sessionToken, exchangeCode returns jwt'
      contains: 'sessionToken: string'
    - path: 'auth/cloud/src/index.ts'
      provides: 'JWT-based provider methods'
      exports: ['MastraCloudAuth']
  key_links:
    - from: 'auth/cloud/src/index.ts'
      to: 'jose.decodeJwt'
      via: 'import'
      pattern: "import.*decodeJwt.*from 'jose'"
    - from: 'auth/cloud/src/index.ts'
      to: '@mastra/core/ee/defaults/roles'
      via: 'import'
      pattern: "import.*resolvePermissions.*from '@mastra/core"
    - from: 'auth/cloud/src/index.ts:getCurrentUser'
      to: 'jose.decodeJwt'
      via: 'decodes sessionToken JWT locally'
      pattern: "decodeJwt\\(sessionToken\\)"
    - from: 'auth/cloud/src/client.ts:exchangeCode'
      to: 'handleCallback'
      via: 'returns jwt field for sessionToken'
      pattern: "jwt:\\s*data\\.jwt"
    - from: 'auth/cloud/src/client.ts:parseUser'
      to: 'CloudUser.sessionToken'
      via: 'jwt param populates sessionToken'
      pattern: "this\\.parseUser\\(data\\.user,\\s*data\\.jwt\\)"
---

<objective>
Wire MastraCloudAuth provider to use local JWT decoding for sessionToken flow.

Purpose: Eliminate API calls for user info and permissions — decode JWT locally, resolve roles via core
Output: Updated provider with handleCallback, getPermissions, createSession, getCurrentUser methods using JWT
</objective>

<execution_context>
@/Users/yj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-provider-integration/03-CONTEXT.md
@.planning/phases/03-provider-integration/03-RESEARCH.md
@auth/cloud/src/client.ts
@auth/cloud/src/index.ts
@packages/core/src/ee/defaults/roles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add jose dependency, update CloudUser type, update exchangeCode to return JWT</name>
  <files>
    auth/cloud/package.json
    auth/cloud/src/client.ts
  </files>
  <action>
1. Add `jose` to dependencies in package.json:
   ```json
   "dependencies": {
     "jose": "^5.9.6"
   }
   ```

2. Update CloudUser interface in client.ts:
   - Add REQUIRED `sessionToken: string` field (per 03-CONTEXT.md: sessionToken is required, not optional)
   - REMOVE `roles: string[]` field (role comes from JWT now)
   - Keep: id, email, name?, avatarUrl?, createdAt, metadata?
   - Note: `avatarUrl` is the correct field name (maps from API's `avatar_url` in parseUser)

   Final CloudUser interface:

   ```typescript
   export interface CloudUser {
     id: string;
     email: string;
     sessionToken: string; // REQUIRED - JWT token
     name?: string;
     avatarUrl?: string; // maps from API's avatar_url
     createdAt: Date;
     metadata?: Record<string, unknown>;
   }
   ```

3. Add JWTClaims interface in client.ts (for type safety):

   ```typescript
   export interface JWTClaims {
     sub: string; // user id
     email: string;
     role: string; // "owner", "admin", "member", "viewer"
     name?: string;
     avatar?: string;
     exp: number;
     iat: number;
   }
   ```

4. Update exchangeCode() to extract JWT and pass to parseUser:
   - Cloud API callback returns JWT as `data.jwt` field
   - Change return type to `Promise<{ user: CloudUser; session: CloudSession; jwt: string }>`
   - Update implementation:

     ```typescript
     async exchangeCode(options: ExchangeCodeOptions): Promise<{ user: CloudUser; session: CloudSession; jwt: string }> {
       const data = await this.request<{
         user: Record<string, unknown>;
         session: Record<string, unknown>;
         jwt: string;  // Cloud returns JWT as 'jwt' field
       }>(
         `${this.apiPrefix}/auth/callback`,
         {
           method: 'POST',
           body: JSON.stringify({ code: options.code }),
         },
       );

       return {
         user: this.parseUser(data.user, data.jwt),  // Pass jwt to parseUser
         session: this.parseSession(data.session),
         jwt: data.jwt,
       };
     }
     ```

5. Update parseUser() signature and implementation:
   - Change signature to: `private parseUser(data: Record<string, unknown>, jwt?: string): CloudUser`
   - When jwt provided, use it as sessionToken
   - When no jwt, use empty string for sessionToken (legacy API responses)
   - REMOVE roles from return object (no longer part of CloudUser)

   Updated implementation:

   ```typescript
   private parseUser(data: Record<string, unknown>, jwt?: string): CloudUser {
     return {
       id: data['id'] as string,
       email: data['email'] as string,
       sessionToken: jwt ?? '',  // JWT becomes sessionToken
       name: data['name'] as string | undefined,
       avatarUrl: data['avatar_url'] as string | undefined,
       createdAt: new Date(data['created_at'] as string),
       metadata: data['metadata'] as Record<string, unknown> | undefined,
     };
   }
   ```

6. Run `pnpm install` in auth/cloud to install jose
   </action>
   <verify> - `grep -q '"jose"' auth/cloud/package.json` returns 0 - `grep -q 'sessionToken: string' auth/cloud/src/client.ts` returns 0 - `grep -q 'jwt: string' auth/cloud/src/client.ts` returns 0 (in exchangeCode return type) - `! grep -q 'roles:' auth/cloud/src/client.ts` returns 0 (roles field REMOVED from CloudUser) - `grep -q 'parseUser(data.user, data.jwt)' auth/cloud/src/client.ts` returns 0 (jwt passed to parseUser) - `pnpm typecheck --filter @mastra/auth-cloud` passes (or shows only index.ts errors expected to be fixed in Task 2)
   </verify>
   <done> - jose is in dependencies - CloudUser has required sessionToken field (not optional) - CloudUser does NOT have roles field - CloudUser keeps avatarUrl field (maps from avatar_url) - JWTClaims interface exists and is exported - exchangeCode() extracts `data.jwt` and returns { user, session, jwt } - parseUser() accepts jwt param and populates sessionToken field - parseUser() call in exchangeCode passes data.jwt as second argument
   </done>
   </task>

<task type="auto">
  <name>Task 2: Update provider methods for JWT-based flow</name>
  <files>
    auth/cloud/src/index.ts
  </files>
  <action>
1. Add imports at top of index.ts:
   ```typescript
   import { decodeJwt } from 'jose';
   import { resolvePermissions, DEFAULT_ROLES } from '@mastra/core/ee/defaults/roles';
   ```

2. Update handleCallback():
   - Call client.exchangeCode() — now returns { user, session, jwt }
   - Decode JWT locally with decodeJwt(jwt) to validate structure
   - User already has sessionToken populated from Task 1's parseUser changes
   - Return SSOCallbackResult with user and tokens:
     ```typescript
     const { user, session, jwt } = await this.client.exchangeCode({ code });
     // Validate JWT is decodable (throws if malformed)
     decodeJwt(jwt);
     return {
       user,
       tokens: {
         accessToken: jwt,
         expiresAt: session.expiresAt,
       },
     };
     ```

3. Update getPermissions(user: CloudUser):
   - Remove token parameter (token is on user.sessionToken)
   - Decode JWT from user.sessionToken using decodeJwt()
   - Extract role claim: `const claims = decodeJwt(user.sessionToken); const role = claims.role as string;`
   - If no role claim, log warning and return empty array []
   - Call resolvePermissions([role], DEFAULT_ROLES) to get permission strings
   - Wrap in try/catch, throw CloudApiError on decode failure:
     ```typescript
     try {
       const claims = decodeJwt(user.sessionToken);
       const role = claims.role as string;
       if (!role) {
         console.warn('MastraCloudAuth: JWT missing role claim');
         return [];
       }
       return resolvePermissions([role], DEFAULT_ROLES);
     } catch (error) {
       throw new CloudApiError(
         `Failed to decode session token: ${error instanceof Error ? error.message : 'unknown error'}`,
         401,
         'invalid_token',
       );
     }
     ```

4. Update createSession():
   - Throw CloudApiError with 501 status (not generic Error):
     ```typescript
     throw new CloudApiError(
       'MastraCloudAuth does not support createSession(). Use SSO flow via handleCallback() instead.',
       501,
       'not_implemented',
     );
     ```
   - Add import for CloudApiError from './client' if not already imported

5. Update hasPermission, hasAllPermissions, hasAnyPermission:
   - Remove token parameter from calls to getPermissions()
   - Just pass user directly: `const permissions = await this.getPermissions(user);`

6. Update getCurrentUser(request: Request):
   **CRITICAL: sessionToken IS the JWT. Decode it locally — NO API call to client.getUser().**
   - Extract sessionToken from cookie (via extractSessionToken)
   - sessionToken IS the JWT containing all user info
   - Decode it with decodeJwt(sessionToken) to get claims (sub, email, name, avatar, role)
   - Construct CloudUser from decoded claims:

     ```typescript
     async getCurrentUser(request: Request): Promise<CloudUser | null> {
       const sessionToken = this.extractSessionToken(request);
       if (!sessionToken) return null;

       try {
         // sessionToken IS the JWT - decode it to get user info
         const claims = decodeJwt(sessionToken);

         // Construct CloudUser from JWT claims
         return {
           id: claims.sub as string,
           email: claims.email as string,
           sessionToken: sessionToken,  // Store the JWT itself
           name: claims.name as string | undefined,
           avatarUrl: claims.avatar as string | undefined,
           createdAt: new Date((claims.iat as number) * 1000),  // iat is issued-at timestamp
         };
       } catch (error) {
         // Invalid/malformed JWT - user is not authenticated
         return null;
       }
     }
     ```

   - NO call to client.getUser() — all info is in the JWT

7. Update getRoles(user: CloudUser):
   - Decode JWT from user.sessionToken
   - Return [claims.role] as single-element array (or empty if no role)

8. Update hasRole(user: CloudUser, role: string):
   - Decode JWT and compare claims.role === role
     </action>
     <verify>
   - `pnpm typecheck --filter @mastra/auth-cloud` passes
   - `grep -q "decodeJwt" auth/cloud/src/index.ts` returns 0
   - `grep -q "resolvePermissions" auth/cloud/src/index.ts` returns 0
   - `grep -q "501" auth/cloud/src/index.ts` returns 0
   - `grep "getCurrentUser" -A 15 auth/cloud/src/index.ts | grep -q "decodeJwt(sessionToken)"` returns 0
   - `! grep "getCurrentUser" -A 15 auth/cloud/src/index.ts | grep -q "client.getUser"` returns 0 (NO API call)
     </verify>
     <done>
   - handleCallback() uses jwt from exchangeCode(), validates with decodeJwt()
   - getPermissions() decodes JWT from user.sessionToken, calls resolvePermissions()
   - createSession() throws CloudApiError(501)
   - hasPermission/hasAllPermissions/hasAnyPermission call getPermissions(user) without token param
   - getCurrentUser() decodes sessionToken JWT locally to construct CloudUser (NO API call)
   - getRoles() and hasRole() decode JWT to get role
   - TypeScript compiles
     </done>
     </task>

</tasks>

<verification>
1. TypeScript compilation: `pnpm typecheck --filter @mastra/auth-cloud`
2. Dependency check: `cat auth/cloud/package.json | grep jose`
3. Pattern verification:
   - `grep "sessionToken: string" auth/cloud/src/client.ts`
   - `grep "jwt: string" auth/cloud/src/client.ts`
   - `! grep "roles:" auth/cloud/src/client.ts` (roles removed)
   - `grep "parseUser(data.user, data.jwt)" auth/cloud/src/client.ts`
   - `grep "decodeJwt" auth/cloud/src/index.ts`
   - `grep "resolvePermissions" auth/cloud/src/index.ts`
   - `grep "501" auth/cloud/src/index.ts`
4. getCurrentUser verification:
   - `grep "getCurrentUser" -A 15 auth/cloud/src/index.ts | grep "decodeJwt(sessionToken)"` (decodes JWT locally)
   - `! grep "getCurrentUser" -A 20 auth/cloud/src/index.ts | grep "client.getUser"` (NO API call)
</verification>

<success_criteria>

- jose dependency added to package.json
- CloudUser.sessionToken is required string (not optional)
- CloudUser does NOT have roles field
- CloudUser keeps avatarUrl field (maps from avatar_url)
- exchangeCode() extracts `data.jwt` and returns { user, session, jwt }
- parseUser() called with `data.jwt` to populate sessionToken
- handleCallback() uses jwt from exchangeCode, returns CloudUser with sessionToken
- getPermissions() decodes JWT from user.sessionToken, calls resolvePermissions()
- getCurrentUser() decodes sessionToken JWT locally — NO client.getUser() call
- createSession() throws CloudApiError(501)
- `pnpm typecheck --filter @mastra/auth-cloud` passes
  </success_criteria>

<output>
After completion, create `.planning/phases/03-provider-integration/03-01-SUMMARY.md`
</output>
