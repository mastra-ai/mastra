---
phase: 10-infrastructure-foundations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/agent/types.ts
  - packages/deployer/src/server/browser-stream/types.ts
  - packages/deployer/src/server/browser-stream/viewer-registry.ts
autonomous: true

must_haves:
  truths:
    - "BrowserToolsetLike interface exposes injectMouseEvent() and injectKeyboardEvent() with signatures matching concrete BrowserToolset"
    - "Server sends viewport metadata (width, height) to clients when screencast starts and when dimensions change"
    - "ClientInputMessage union type exists with MouseInputMessage and KeyboardInputMessage discriminated by type field"
    - "Existing raw base64 frame protocol is unchanged (frames still sent as plain strings, not JSON-wrapped)"
  artifacts:
    - path: "packages/core/src/agent/types.ts"
      provides: "BrowserToolsetLike with injectMouseEvent and injectKeyboardEvent"
      contains: "injectMouseEvent"
    - path: "packages/deployer/src/server/browser-stream/types.ts"
      provides: "ClientInputMessage, MouseInputMessage, KeyboardInputMessage, ViewportMessage types"
      contains: "ClientInputMessage"
    - path: "packages/deployer/src/server/browser-stream/viewer-registry.ts"
      provides: "Viewport metadata broadcasting on stream start and dimension change"
      contains: "broadcastViewport"
  key_links:
    - from: "packages/deployer/src/server/browser-stream/viewer-registry.ts"
      to: "packages/deployer/src/server/browser-stream/types.ts"
      via: "imports ViewportMessage type"
      pattern: "import.*ViewportMessage"
    - from: "packages/deployer/src/server/browser-stream/viewer-registry.ts"
      to: "packages/core/src/agent/types.ts"
      via: "BrowserToolsetLike (via BrowserStreamConfig) now has inject methods available"
      pattern: "toolset\\.inject"
---

<objective>
Define type interfaces and implement viewport metadata broadcasting that enable Phase 11+ input routing.

Purpose: Phase 10 is the foundation for all browser input injection. Without these interface extensions, the server cannot call inject methods through the BrowserToolsetLike abstraction. Without viewport metadata, the client cannot map coordinates. Without ClientInputMessage types, there is no contract for client-to-server input messages.

Output: Extended BrowserToolsetLike interface, ClientInputMessage union type, and viewport metadata broadcasting in ViewerRegistry.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files to modify
@packages/core/src/agent/types.ts
@packages/deployer/src/server/browser-stream/types.ts
@packages/deployer/src/server/browser-stream/viewer-registry.ts

# Reference: concrete inject method signatures
@integrations/agent-browser/src/toolset.ts (lines 273-302 for inject method signatures)
@integrations/agent-browser/src/screencast/types.ts (ScreencastFrameData.viewport shape)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BrowserToolsetLike interface and define ClientInputMessage types</name>
  <files>
    packages/core/src/agent/types.ts
    packages/deployer/src/server/browser-stream/types.ts
  </files>
  <action>
**INFRA-01: Extend BrowserToolsetLike interface**

In `packages/core/src/agent/types.ts`, add two methods to the `BrowserToolsetLike` interface (after the `close()` method, before the closing brace):

```typescript
/**
 * Inject a mouse event into the browser via CDP.
 * Used by server to forward user mouse interactions from live view.
 */
injectMouseEvent(event: {
  type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';
  x: number;
  y: number;
  button?: 'left' | 'right' | 'middle' | 'none';
  clickCount?: number;
  deltaX?: number;
  deltaY?: number;
  modifiers?: number;
}): Promise<void>;

/**
 * Inject a keyboard event into the browser via CDP.
 * Used by server to forward user keyboard interactions from live view.
 */
injectKeyboardEvent(event: {
  type: 'keyDown' | 'keyUp' | 'char';
  key?: string;
  code?: string;
  text?: string;
  modifiers?: number;
}): Promise<void>;
```

These signatures MUST match the concrete `BrowserToolset` methods exactly (same parameter shapes).

**INFRA-03: Define ClientInputMessage types**

In `packages/deployer/src/server/browser-stream/types.ts`, add the following types AFTER the existing `BrowserStreamConfig` interface:

```typescript
/**
 * Mouse input message from client to server.
 * Client sends these when user interacts with the live view frame.
 */
export interface MouseInputMessage {
  type: 'mouse';
  /** CDP mouse event type */
  eventType: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';
  /** X coordinate in browser viewport pixels */
  x: number;
  /** Y coordinate in browser viewport pixels */
  y: number;
  /** Mouse button */
  button?: 'left' | 'right' | 'middle' | 'none';
  /** Click count (1 for single, 2 for double) */
  clickCount?: number;
  /** Horizontal scroll delta (for mouseWheel) */
  deltaX?: number;
  /** Vertical scroll delta (for mouseWheel) */
  deltaY?: number;
  /** CDP modifier bitmask (1=Alt, 2=Ctrl, 4=Meta, 8=Shift) */
  modifiers?: number;
}

/**
 * Keyboard input message from client to server.
 * Client sends these when user types in the live view.
 */
export interface KeyboardInputMessage {
  type: 'keyboard';
  /** CDP keyboard event type */
  eventType: 'keyDown' | 'keyUp' | 'char';
  /** Key value (e.g., 'a', 'Enter', 'ArrowLeft') */
  key?: string;
  /** Physical key code (e.g., 'KeyA', 'Enter') */
  code?: string;
  /** Text to insert (for printable characters in 'char' events) */
  text?: string;
  /** CDP modifier bitmask (1=Alt, 2=Ctrl, 4=Meta, 8=Shift) */
  modifiers?: number;
}

/**
 * Union type for all client-to-server input messages.
 * Discriminated by the `type` field.
 */
export type ClientInputMessage = MouseInputMessage | KeyboardInputMessage;
```

Also add a `ViewportMessage` type for the server-to-client viewport metadata:

```typescript
/**
 * Viewport metadata message sent from server to client.
 * Sent on stream start and when viewport dimensions change.
 * Client uses this to map click coordinates from scaled frame to browser viewport.
 */
export interface ViewportMessage {
  viewport: {
    width: number;
    height: number;
  };
}
```
  </action>
  <verify>
Run TypeScript compilation check from the repo root:
```bash
cd packages/core && npx tsc --noEmit --pretty 2>&1 | head -20
cd packages/deployer && npx tsc --noEmit --pretty 2>&1 | head -20
```
Both should pass with no errors related to the new types.

Verify the concrete BrowserToolset satisfies the updated interface by checking no type errors arise in agent.ts or wherever BrowserToolsetLike is used.
  </verify>
  <done>
- BrowserToolsetLike interface has injectMouseEvent() and injectKeyboardEvent() with parameter types matching BrowserToolset concrete class
- MouseInputMessage, KeyboardInputMessage, and ClientInputMessage types exported from browser-stream/types.ts
- ViewportMessage type exported from browser-stream/types.ts
- All type discriminated by `type` field for runtime switching
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement viewport metadata broadcasting in ViewerRegistry</name>
  <files>
    packages/deployer/src/server/browser-stream/viewer-registry.ts
  </files>
  <action>
**INFRA-02: Viewport metadata broadcasting**

Modify `packages/deployer/src/server/browser-stream/viewer-registry.ts` to track and broadcast viewport metadata.

1. **Import ViewportMessage type** at the top:
```typescript
import type { StatusMessage, BrowserStreamConfig, ViewportMessage } from './types.js';
```

2. **Add lastViewport tracking** as a new private Map alongside the existing ones:
```typescript
/** Map of agentId to last known viewport dimensions (for change detection) */
private lastViewports = new Map<string, { width: number; height: number }>();
```

3. **Add broadcastViewport method** (similar pattern to broadcastUrlIfChanged):
```typescript
/**
 * Broadcast viewport metadata to all viewers for an agent.
 * Only sends if dimensions have changed from last broadcast.
 * Called on stream start and on each frame to detect dimension changes.
 */
private broadcastViewportIfChanged(agentId: string, viewport: { width: number; height: number }): void {
  const last = this.lastViewports.get(agentId);
  if (last && last.width === viewport.width && last.height === viewport.height) {
    return;
  }

  this.lastViewports.set(agentId, { width: viewport.width, height: viewport.height });

  const viewerSet = this.viewers.get(agentId);
  if (!viewerSet) return;

  const message: ViewportMessage = { viewport: { width: viewport.width, height: viewport.height } };
  const json = JSON.stringify(message);
  for (const ws of viewerSet) {
    try {
      ws.send(json);
    } catch (error) {
      console.warn('[ViewerRegistry] Error broadcasting viewport:', error);
    }
  }
}
```

4. **Wire into frame handler in doStartScreencast** - modify the `stream.on('frame', ...)` handler to also call viewport broadcast:

Change the existing:
```typescript
stream.on('frame', frame => {
  this.broadcastFrame(agentId, frame.data);
  this.broadcastUrlIfChanged(agentId, toolset.getCurrentUrl());
});
```

To:
```typescript
stream.on('frame', frame => {
  this.broadcastFrame(agentId, frame.data);
  this.broadcastViewportIfChanged(agentId, frame.viewport);
  this.broadcastUrlIfChanged(agentId, toolset.getCurrentUrl());
});
```

This broadcasts viewport metadata on the first frame (initial dimensions) and whenever the viewport dimensions change (e.g., browser resize). The change detection ensures no redundant messages.

5. **Clean up viewport tracking on viewer removal** - in `removeViewer`, add cleanup alongside `lastUrls.delete`:
```typescript
this.lastUrls.delete(agentId);
this.lastViewports.delete(agentId);
```

6. **Clean up viewport tracking in closeBrowserSession** - add alongside the existing `lastUrls.delete`:
```typescript
this.lastUrls.delete(agentId);
this.lastViewports.delete(agentId);
```

**CRITICAL**: The raw base64 frame protocol MUST remain unchanged. `broadcastFrame` still sends the raw string. Viewport metadata is sent as a SEPARATE JSON message via `broadcastViewportIfChanged`. The client distinguishes frame data (raw string, not valid JSON) from metadata messages (JSON objects with known shapes like `{ viewport: ... }`, `{ status: ... }`, `{ url: ... }`).
  </action>
  <verify>
1. TypeScript check: `cd packages/deployer && npx tsc --noEmit --pretty 2>&1 | head -20` — no errors
2. Verify frame handler has both broadcastFrame (raw string) AND broadcastViewportIfChanged (JSON) calls
3. Verify broadcastViewportIfChanged only sends when dimensions actually change (check conditional logic)
4. Verify cleanup: lastViewports.delete in removeViewer and closeBrowserSession
5. Build check: `cd packages/deployer && pnpm build 2>&1 | tail -5` — builds successfully
  </verify>
  <done>
- ViewerRegistry tracks viewport dimensions per agent
- Viewport metadata broadcast as JSON `{ viewport: { width, height } }` on first frame and dimension changes
- Raw base64 frame protocol unchanged (frames still sent as plain strings via broadcastFrame)
- Viewport tracking cleaned up on viewer removal and browser session close
  </done>
</task>

</tasks>

<verification>
1. **Type compatibility check**: `BrowserToolset` (concrete) satisfies `BrowserToolsetLike` (interface) — verify by running TypeScript check across both packages/core and integrations/agent-browser
2. **Build check**: Run `pnpm build` from repo root — all packages build without errors
3. **Protocol preservation**: Confirm `broadcastFrame` method signature and implementation is unchanged (still sends raw string, not JSON-wrapped)
4. **Export check**: Verify `ClientInputMessage`, `MouseInputMessage`, `KeyboardInputMessage`, `ViewportMessage` are exported from browser-stream/types.ts
</verification>

<success_criteria>
1. `BrowserToolsetLike` interface in packages/core includes `injectMouseEvent()` and `injectKeyboardEvent()` with matching signatures
2. `ClientInputMessage` union type exported from browser-stream types with `MouseInputMessage | KeyboardInputMessage` discriminated by `type` field
3. `ViewportMessage` type exported from browser-stream types
4. ViewerRegistry broadcasts viewport metadata as separate JSON message on stream start and dimension change
5. Raw base64 frame broadcasting is unchanged
6. Full build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-infrastructure-foundations/10-01-SUMMARY.md`
</output>
