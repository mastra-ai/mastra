---
phase: 08-transport-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/deployer/src/server/browser-stream/types.ts
  - packages/deployer/src/server/browser-stream/viewer-registry.ts
  - packages/deployer/src/server/browser-stream/browser-stream.ts
  - packages/deployer/src/server/browser-stream/index.ts
  - packages/deployer/package.json
autonomous: true

must_haves:
  truths:
    - "ViewerRegistry tracks connected WebSocket clients per agentId"
    - "WebSocket route handler exists at /browser/:agentId/stream"
    - "Frames are broadcast to all connected viewers for an agent"
    - "Screencast starts on first viewer, stops on last viewer disconnect"
  artifacts:
    - path: "packages/deployer/src/server/browser-stream/types.ts"
      provides: "Status and error message type definitions"
      exports: ["StatusMessage", "ErrorMessage", "BrowserStreamConfig"]
    - path: "packages/deployer/src/server/browser-stream/viewer-registry.ts"
      provides: "Viewer tracking with reference counting"
      exports: ["ViewerRegistry"]
    - path: "packages/deployer/src/server/browser-stream/browser-stream.ts"
      provides: "WebSocket route setup function"
      exports: ["setupBrowserStream"]
    - path: "packages/deployer/src/server/browser-stream/index.ts"
      provides: "Barrel export for browser-stream module"
  key_links:
    - from: "viewer-registry.ts"
      to: "BrowserToolset.startScreencast()"
      via: "addViewer triggers screencast start"
      pattern: "startScreencast"
    - from: "browser-stream.ts"
      to: "viewer-registry.ts"
      via: "WebSocket handlers call registry methods"
      pattern: "registry\\.(add|remove)Viewer"
---

<objective>
Create the browser stream WebSocket module with viewer registry and route setup.

Purpose: Implements the core WebSocket infrastructure for relaying screencast frames to Studio clients. The viewer registry manages connection lifecycle and ensures screencasts only run when viewers are connected.

Output: Complete browser-stream module with types, ViewerRegistry class, and WebSocket route setup function ready for integration into the deployer server.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-transport-layer/08-CONTEXT.md
@.planning/phases/08-transport-layer/08-RESEARCH.md
@.planning/phases/07-screencast-api/07-01-SUMMARY.md
@integrations/agent-browser/src/screencast/screencast-stream.ts
@integrations/agent-browser/src/toolset.ts
@packages/deployer/src/server/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser-stream types and ViewerRegistry class</name>
  <files>
    packages/deployer/src/server/browser-stream/types.ts
    packages/deployer/src/server/browser-stream/viewer-registry.ts
    packages/deployer/package.json
  </files>
  <action>
1. Add @hono/node-ws dependency to packages/deployer/package.json:
   ```bash
   cd packages/deployer && pnpm add @hono/node-ws
   ```

2. Create `types.ts` with message protocol types from CONTEXT.md:
   - StatusMessage: { status: 'connected' | 'browser_starting' | 'streaming' | 'browser_closed' }
   - ErrorMessage: { error: 'browser_crashed' | 'screencast_failed' | 'auth_failed', message: string }
   - BrowserStreamConfig: { getToolset: (agentId: string) => BrowserToolset | undefined }

3. Create `viewer-registry.ts` implementing reference-counted viewer tracking:
   - Map<string, Set<WSContext>> for viewers per agentId
   - Map<string, ScreencastStream> for active screencasts per agentId
   - addViewer(agentId, ws, getToolset): Adds viewer, starts screencast if first viewer
   - removeViewer(agentId, ws): Removes viewer, stops screencast if last viewer
   - broadcastFrame(agentId, data): Send binary frame to all viewers
   - broadcastStatus(agentId, status): Send JSON status to all viewers

   Key behavior:
   - When viewer count goes 0 -> 1: Call getToolset(agentId), then toolset.startScreencast()
   - Wire stream.on('frame') to broadcastFrame
   - Wire stream.on('stop') to broadcastStatus with browser_closed
   - When viewer count goes 1 -> 0: Call stream.stop(), remove from screencasts map

   Import WSContext from @hono/node-ws for WebSocket type.
  </action>
  <verify>
    - pnpm build:deployers (or cd packages/deployer && pnpm build) compiles without errors
    - types.ts exports StatusMessage, ErrorMessage, BrowserStreamConfig
    - viewer-registry.ts exports ViewerRegistry class
  </verify>
  <done>
    ViewerRegistry class with reference-counted viewer tracking and automatic screencast lifecycle management
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket route setup function</name>
  <files>
    packages/deployer/src/server/browser-stream/browser-stream.ts
    packages/deployer/src/server/browser-stream/index.ts
  </files>
  <action>
1. Create `browser-stream.ts` with setupBrowserStream function:
   ```typescript
   import { createNodeWebSocket } from '@hono/node-ws';
   import type { Hono } from 'hono';
   import { ViewerRegistry } from './viewer-registry.js';
   import type { BrowserStreamConfig } from './types.js';

   export function setupBrowserStream(
     app: Hono,
     config: BrowserStreamConfig
   ) {
     const { injectWebSocket, upgradeWebSocket } = createNodeWebSocket({ app });
     const registry = new ViewerRegistry();

     app.get('/browser/:agentId/stream', upgradeWebSocket((c) => {
       const agentId = c.req.param('agentId');

       return {
         onOpen(event, ws) {
           // Send connected status
           ws.send(JSON.stringify({ status: 'connected' }));

           // Add to registry (starts screencast if first viewer)
           registry.addViewer(agentId, ws, config.getToolset);
         },

         onMessage(event, ws) {
           // Future: handle input events for Phase 10+
         },

         onClose(event, ws) {
           // Remove from registry (stops screencast if last viewer)
           registry.removeViewer(agentId, ws);
         },

         onError(event, ws) {
           console.error('[BrowserStream] WebSocket error:', event);
           registry.removeViewer(agentId, ws);
         },
       };
     }));

     return { injectWebSocket, registry };
   }
   ```

2. Create `index.ts` barrel export:
   ```typescript
   export { setupBrowserStream } from './browser-stream.js';
   export { ViewerRegistry } from './viewer-registry.js';
   export type { StatusMessage, ErrorMessage, BrowserStreamConfig } from './types.js';
   ```

Note: The injectWebSocket function returned must be called AFTER serve() in the server setup - this will be done in Plan 02.

Handle the case where getToolset returns undefined (no browser for this agent):
- Send status { status: 'connected' } initially
- When trying to start screencast, if no toolset, just keep connection open
- When toolset becomes available (future: via some notification), start screencast
  </action>
  <verify>
    - pnpm build:deployers compiles without errors
    - browser-stream.ts exports setupBrowserStream function
    - index.ts re-exports all public types and functions
  </verify>
  <done>
    setupBrowserStream function that registers WebSocket route and returns injectWebSocket for server integration
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cd packages/deployer && pnpm build` succeeds
2. `packages/deployer/src/server/browser-stream/` contains 4 files (types.ts, viewer-registry.ts, browser-stream.ts, index.ts)
3. TypeScript types resolve correctly (no compile errors)
4. @hono/node-ws is in packages/deployer/package.json dependencies
</verification>

<success_criteria>
- browser-stream module compiles and exports setupBrowserStream
- ViewerRegistry implements reference-counted viewer tracking
- WebSocket route defined at /browser/:agentId/stream
- Types match CONTEXT.md protocol specification
- Module is ready for integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/08-transport-layer/08-01-SUMMARY.md`
</output>
