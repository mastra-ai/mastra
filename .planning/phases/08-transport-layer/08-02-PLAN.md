---
phase: 08-transport-layer
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/deployer/src/server/index.ts
  - packages/deployer/src/server/types.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket connection can be established at /browser/:agentId/stream"
    - "Connected clients receive frames when screencast is active"
    - "Disconnecting clients are cleaned up without memory leaks"
    - "Screencast only runs when at least one viewer is connected"
  artifacts:
    - path: "packages/deployer/src/server/index.ts"
      provides: "Server with WebSocket support integrated"
      contains: "injectWebSocket"
    - path: "packages/deployer/src/server/types.ts"
      provides: "Extended ServerBundleOptions with browserToolsets"
  key_links:
    - from: "packages/deployer/src/server/index.ts"
      to: "browser-stream/browser-stream.ts"
      via: "setupBrowserStream import and call"
      pattern: "setupBrowserStream"
    - from: "packages/deployer/src/server/index.ts"
      to: "injectWebSocket"
      via: "Call after serve() returns server"
      pattern: "injectWebSocket\\(server\\)"
---

<objective>
Integrate WebSocket browser stream into the deployer server.

Purpose: Completes the transport layer by wiring the browser-stream module into the Mastra deployer's createNodeServer function. After this plan, Studio clients can connect to `/browser/:agentId/stream` and receive screencast frames.

Output: Modified deployer server that supports WebSocket connections for browser screencast streaming.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-transport-layer/08-CONTEXT.md
@.planning/phases/08-transport-layer/08-RESEARCH.md
@.planning/phases/08-transport-layer/08-01-SUMMARY.md
@packages/deployer/src/server/index.ts
@packages/deployer/src/server/types.ts
@packages/deployer/src/server/browser-stream/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ServerBundleOptions to accept BrowserToolset registry</name>
  <files>
    packages/deployer/src/server/types.ts
  </files>
  <action>
1. Import BrowserToolset type:
   ```typescript
   import type { BrowserToolset } from '@mastra/agent-browser';
   ```

2. Extend ServerBundleOptions to include browserToolsets map:
   ```typescript
   export type ServerBundleOptions = {
     studio?: boolean;
     isDev?: boolean;
     tools: Record<string, Tool>;
     browserToolsets?: Map<string, BrowserToolset>;
   };
   ```

   The browserToolsets map is keyed by agentId and provides the BrowserToolset instance for each agent that has browser capabilities. This allows the WebSocket handler to look up the correct toolset when a viewer connects.

   Note: This is optional - if not provided, WebSocket connections will still work but won't stream frames until a toolset is registered. This supports the case where agents are created dynamically.
  </action>
  <verify>
    - cd packages/deployer && pnpm build compiles without errors
    - ServerBundleOptions includes optional browserToolsets property
  </verify>
  <done>
    ServerBundleOptions extended with browserToolsets registry for agent-to-toolset mapping
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate browser-stream WebSocket into server setup</name>
  <files>
    packages/deployer/src/server/index.ts
  </files>
  <action>
1. Import setupBrowserStream at top of file:
   ```typescript
   import { setupBrowserStream } from './browser-stream/index.js';
   ```

2. In createHonoServer function, BEFORE any route registration (before CORS middleware to avoid header conflicts as noted in RESEARCH.md pitfalls):
   - Call setupBrowserStream with the app and a getToolset function
   - Store the returned injectWebSocket for later use

   ```typescript
   // Browser stream WebSocket setup - MUST be before CORS middleware
   // to avoid "can't modify immutable headers" error
   const browserStreamSetup = setupBrowserStream(app, {
     getToolset: (agentId: string) => options.browserToolsets?.get(agentId),
   });
   ```

3. Modify createNodeServer to call injectWebSocket AFTER serve():
   - Return injectWebSocket from createHonoServer (modify return type)
   - In createNodeServer, after the serve() call, invoke injectWebSocket(server)

   ```typescript
   // After serve() returns:
   browserStreamSetup.injectWebSocket(server);
   ```

4. Update createHonoServer return to include the injectWebSocket:
   ```typescript
   return { app, injectWebSocket: browserStreamSetup?.injectWebSocket };
   ```
   And update createNodeServer to destructure:
   ```typescript
   const { app, injectWebSocket } = await createHonoServer(mastra, options);
   // ...after serve()...
   if (injectWebSocket) {
     injectWebSocket(server);
   }
   ```

Important considerations from RESEARCH.md:
- WebSocket route MUST be registered before CORS middleware (see Pitfall 3)
- injectWebSocket MUST be called after serve() returns (see Pitfall 1)
- The route is GET /browser/:agentId/stream for WebSocket upgrade
  </action>
  <verify>
    - cd packages/deployer && pnpm build compiles without errors
    - createHonoServer calls setupBrowserStream
    - createNodeServer calls injectWebSocket after serve()
    - WebSocket route is registered before CORS middleware
  </verify>
  <done>
    WebSocket browser stream fully integrated into deployer server with correct initialization order
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `pnpm build:deployers` succeeds without errors
2. Server starts normally when running `pnpm dev` in a Mastra project
3. Code inspection confirms:
   - setupBrowserStream called before CORS middleware
   - injectWebSocket called after serve()
   - browserToolsets option available in ServerBundleOptions
</verification>

<success_criteria>
- XPORT-01: WebSocket endpoint exists at `/browser/:agentId/stream`
- XPORT-02: WebSocket handler relays CDP frames via ViewerRegistry.broadcastFrame
- XPORT-03: Connections cleaned up in onClose/onError handlers
- XPORT-04: Screencast lifecycle managed by ViewerRegistry reference counting
- All requirements from Phase 8 are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/08-transport-layer/08-02-SUMMARY.md`
</output>
