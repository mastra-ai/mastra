---
phase: 07-screencast-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - integrations/agent-browser/src/screencast/types.ts
  - integrations/agent-browser/src/screencast/constants.ts
  - integrations/agent-browser/src/screencast/screencast-stream.ts
  - integrations/agent-browser/src/screencast/index.ts
  - integrations/agent-browser/src/toolset.ts
  - integrations/agent-browser/src/index.ts
  - integrations/agent-browser/package.json
autonomous: true

must_haves:
  truths:
    - "Calling startScreencast() on BrowserToolset begins receiving CDP frames"
    - "Calling stopScreencast() stops frame delivery and releases resources"
    - "Each frame triggers CDP screencastFrameAck (handled by agent-browser internally)"
    - "injectMouseEvent() passes events to CDP"
    - "injectKeyboardEvent() passes events to CDP"
  artifacts:
    - path: "integrations/agent-browser/src/screencast/types.ts"
      provides: "ScreencastEvents, ScreencastOptions, ScreencastFrameData, ScreencastError interfaces"
      exports: ["ScreencastEvents", "ScreencastOptions", "ScreencastFrameData", "ScreencastError"]
    - path: "integrations/agent-browser/src/screencast/screencast-stream.ts"
      provides: "ScreencastStream class with event emitter pattern"
      exports: ["ScreencastStream"]
    - path: "integrations/agent-browser/src/toolset.ts"
      provides: "startScreencast, injectMouseEvent, injectKeyboardEvent methods"
      contains: "async startScreencast"
  key_links:
    - from: "integrations/agent-browser/src/toolset.ts"
      to: "ScreencastStream"
      via: "import and instantiation"
      pattern: "new ScreencastStream"
    - from: "integrations/agent-browser/src/screencast/screencast-stream.ts"
      to: "BrowserManager.startScreencast"
      via: "delegate to agent-browser"
      pattern: "browserManager\\.startScreencast"
    - from: "integrations/agent-browser/src/toolset.ts"
      to: "BrowserManager.injectMouseEvent"
      via: "passthrough call"
      pattern: "browser\\.injectMouseEvent"
---

<objective>
Implement the Screencast API layer for BrowserToolset, enabling CDP screencast capture and input injection.

Purpose: Provides the programmatic API that Phase 8 (Transport Layer) will use to capture and relay browser frames to Studio clients. Input injection methods are passthrough for future interaction features.

Output: BrowserToolset gains `startScreencast()`, `stopScreencast()` (via stream), `injectMouseEvent()`, and `injectKeyboardEvent()` methods.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-screencast-api/07-CONTEXT.md
@.planning/phases/07-screencast-api/07-RESEARCH.md

# Existing codebase
@integrations/agent-browser/src/toolset.ts
@integrations/agent-browser/src/types.ts
@integrations/agent-browser/src/index.ts
@integrations/agent-browser/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create screencast types and constants</name>
  <files>
    integrations/agent-browser/src/screencast/types.ts
    integrations/agent-browser/src/screencast/constants.ts
    integrations/agent-browser/package.json
  </files>
  <action>
1. Add `typed-emitter` as a regular dependency (not devDependency - types exported in public API):
   ```bash
   cd integrations/agent-browser && pnpm add typed-emitter
   ```

2. Create `integrations/agent-browser/src/screencast/types.ts` with:
   - `ScreencastEvents` interface for typed event emitter:
     - `frame: (frame: ScreencastFrameData) => void`
     - `error: (error: ScreencastError) => void`
     - `stop: (reason: 'manual' | 'browser_closed' | 'error') => void`
     - `reconnecting: (attempt: number, maxAttempts: number) => void`
     - `reconnected: () => void`
   - `ScreencastFrameData` interface (matches RESEARCH.md):
     - `data: string` (base64)
     - `timestamp: number`
     - `viewport: { width, height, offsetTop, scrollOffsetX, scrollOffsetY, pageScaleFactor }`
     - `sessionId: number`
   - `ScreencastError` interface:
     - `code: 'cdp_error' | 'browser_closed' | 'retry_exhausted' | 'unknown'`
     - `message: string`
     - `cause?: Error`
     - `canRetry: boolean`
   - `ScreencastOptions` interface (user-facing, subset of CDP):
     - `format?: 'jpeg' | 'png'`
     - `quality?: number` (0-100)
     - `maxWidth?: number`
     - `maxHeight?: number`
     - `everyNthFrame?: number`

3. Create `integrations/agent-browser/src/screencast/constants.ts` with:
   - `SCREENCAST_DEFAULTS`: Required<ScreencastOptions> = { format: 'jpeg', quality: 70, maxWidth: 1280, maxHeight: 720, everyNthFrame: 2 }
   - `MAX_RETRIES = 3`
   - `RETRY_DELAYS = [1000, 2000, 4000]` (exponential backoff, capped)
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd integrations/agent-browser && pnpm exec tsc --noEmit src/screencast/types.ts src/screencast/constants.ts
```
  </verify>
  <done>
Types and constants files exist with all interfaces and constants defined. `typed-emitter` is in package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ScreencastStream class</name>
  <files>
    integrations/agent-browser/src/screencast/screencast-stream.ts
    integrations/agent-browser/src/screencast/index.ts
  </files>
  <action>
1. Create `integrations/agent-browser/src/screencast/screencast-stream.ts`:
   - Import EventEmitter from 'events', TypedEmitter from 'typed-emitter'
   - Import BrowserManager from 'agent-browser/dist/browser.js'
   - Import types from './types.js' and constants from './constants.js'

   - Class signature: `export class ScreencastStream extends (EventEmitter as new () => TypedEmitter<ScreencastEvents>)`

   - Private state:
     - `active: boolean = false`
     - `options: Required<ScreencastOptions>`
     - `browserManager: BrowserManager`

   - Constructor: `constructor(browserManager: BrowserManager, options?: ScreencastOptions)`
     - Call `super()`
     - Merge options with SCREENCAST_DEFAULTS

   - `async start(): Promise<void>`:
     - If already active, return early
     - Call `startInternal()`
     - Set `this.active = true`

   - `private async startInternal(): Promise<void>`:
     - Call `this.browserManager.startScreencast(callback, this.options)`
     - In callback, transform ScreencastFrame to ScreencastFrameData:
       - `data: frame.data`
       - `timestamp: frame.metadata.timestamp ?? Date.now()`
       - `viewport: { width: frame.metadata.deviceWidth, height: frame.metadata.deviceHeight, offsetTop: frame.metadata.offsetTop, scrollOffsetX: frame.metadata.scrollOffsetX, scrollOffsetY: frame.metadata.scrollOffsetY, pageScaleFactor: frame.metadata.pageScaleFactor }`
       - `sessionId: frame.sessionId`
     - Emit 'frame' event with transformed data
     - Note: BrowserManager handles screencastFrameAck internally

   - `async stop(): Promise<void>`:
     - If not active, return early
     - Set `this.active = false`
     - Try/catch `this.browserManager.stopScreencast()`
     - console.warn on error (don't throw - cleanup is best-effort)
     - Emit 'stop' with reason 'manual'

   - `isActive(): boolean`: return `this.active`

2. Create `integrations/agent-browser/src/screencast/index.ts`:
   - Re-export all types from './types.js'
   - Re-export ScreencastStream from './screencast-stream.js'
   - Re-export constants from './constants.js'
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd integrations/agent-browser && pnpm exec tsc --noEmit src/screencast/index.ts
```
  </verify>
  <done>
ScreencastStream class implements event emitter pattern with start(), stop(), isActive() methods. Frame transformation maps agent-browser format to our ScreencastFrameData format.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate screencast and input injection into BrowserToolset</name>
  <files>
    integrations/agent-browser/src/toolset.ts
    integrations/agent-browser/src/index.ts
  </files>
  <action>
1. Update `integrations/agent-browser/src/toolset.ts`:

   Add import at top:
   ```typescript
   import { ScreencastStream, type ScreencastOptions } from './screencast/index.js';
   ```

   Add methods to BrowserToolset class:

   ```typescript
   /**
    * Start screencast streaming. Returns a stream object with event emitter interface.
    * If browser not yet launched, waits for launch before starting.
    *
    * @param options - Screencast configuration (format, quality, dimensions)
    * @returns Promise resolving to ScreencastStream with event emitter interface
    *
    * @example
    * const stream = await browserTools.startScreencast({ quality: 80 });
    * stream.on('frame', (frame) => {
    *   console.log(`Frame: ${frame.viewport.width}x${frame.viewport.height}`);
    * });
    * stream.on('stop', (reason) => console.log('Stopped:', reason));
    * // Later...
    * await stream.stop();
    */
   async startScreencast(options?: ScreencastOptions): Promise<ScreencastStream> {
     const browser = await this.getBrowser();
     const stream = new ScreencastStream(browser, options);
     await stream.start();
     return stream;
   }

   /**
    * Inject a mouse event via CDP passthrough.
    * Waits for browser to be ready if not launched.
    *
    * @param event - CDP-compatible mouse event parameters
    */
   async injectMouseEvent(event: {
     type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';
     x: number;
     y: number;
     button?: 'left' | 'right' | 'middle' | 'none';
     clickCount?: number;
     deltaX?: number;
     deltaY?: number;
     modifiers?: number;
   }): Promise<void> {
     const browser = await this.getBrowser();
     await browser.injectMouseEvent(event);
   }

   /**
    * Inject a keyboard event via CDP passthrough.
    * Waits for browser to be ready if not launched.
    *
    * @param event - CDP-compatible keyboard event parameters
    */
   async injectKeyboardEvent(event: {
     type: 'keyDown' | 'keyUp' | 'char';
     key?: string;
     code?: string;
     text?: string;
     modifiers?: number;
   }): Promise<void> {
     const browser = await this.getBrowser();
     await browser.injectKeyboardEvent(event);
   }
   ```

2. Update `integrations/agent-browser/src/index.ts` to export screencast types:
   ```typescript
   // Add to existing exports
   export {
     ScreencastStream,
     type ScreencastOptions,
     type ScreencastFrameData,
     type ScreencastError,
     type ScreencastEvents,
     SCREENCAST_DEFAULTS,
     MAX_RETRIES,
   } from './screencast/index.js';
   ```

3. Build the package to verify everything compiles:
   ```bash
   cd integrations/agent-browser && pnpm build:lib
   ```
  </action>
  <verify>
1. Package builds successfully:
   ```bash
   cd integrations/agent-browser && pnpm build:lib
   ```

2. Exports are accessible:
   ```bash
   cd integrations/agent-browser && node -e "import('./dist/index.js').then(m => console.log('ScreencastStream:', typeof m.ScreencastStream, 'SCREENCAST_DEFAULTS:', m.SCREENCAST_DEFAULTS))"
   ```
  </verify>
  <done>
BrowserToolset has startScreencast(), injectMouseEvent(), injectKeyboardEvent() methods. All screencast types are exported from package index. Package builds without errors.
  </done>
</task>

</tasks>

<verification>
1. **Build verification:**
   ```bash
   cd integrations/agent-browser && pnpm build:lib
   ```

2. **Type check:**
   ```bash
   cd integrations/agent-browser && pnpm exec tsc --noEmit
   ```

3. **Export verification:**
   ```bash
   cd integrations/agent-browser && node -e "
     import('./dist/index.js').then(m => {
       console.log('BrowserToolset:', typeof m.BrowserToolset);
       console.log('ScreencastStream:', typeof m.ScreencastStream);
       console.log('SCREENCAST_DEFAULTS:', JSON.stringify(m.SCREENCAST_DEFAULTS));
       console.log('Has startScreencast:', 'startScreencast' in m.BrowserToolset.prototype);
       console.log('Has injectMouseEvent:', 'injectMouseEvent' in m.BrowserToolset.prototype);
       console.log('Has injectKeyboardEvent:', 'injectKeyboardEvent' in m.BrowserToolset.prototype);
     });
   "
   ```

4. **Requirements coverage:**
   - CAST-01: `startScreencast()` method exists on BrowserToolset
   - CAST-02: `stop()` method exists on ScreencastStream
   - CAST-03: CDP ack handled by agent-browser internally (no code needed)
   - CAST-04: `injectMouseEvent()` method exists on BrowserToolset
   - CAST-05: `injectKeyboardEvent()` method exists on BrowserToolset
</verification>

<success_criteria>
1. `pnpm build:lib` succeeds in integrations/agent-browser
2. BrowserToolset.startScreencast() returns ScreencastStream
3. ScreencastStream emits 'frame', 'error', 'stop' events with correct types
4. BrowserToolset.injectMouseEvent() and injectKeyboardEvent() delegate to BrowserManager
5. All types exported from package index
6. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-screencast-api/07-01-SUMMARY.md`
</output>
