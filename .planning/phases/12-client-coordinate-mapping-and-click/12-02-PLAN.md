---
phase: 12-client-coordinate-mapping-and-click
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts
autonomous: true

must_haves:
  truths:
    - "useBrowserStream parses ViewportMessage JSON and exposes viewport state"
    - "useBrowserStream exposes a stable sendMessage callback for writing to WebSocket"
    - "Existing frame/status/url parsing behavior is unchanged"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts"
      provides: "viewport state and sendMessage callback in return type"
      exports: ["useBrowserStream", "StreamStatus"]
  key_links:
    - from: "use-browser-stream.ts (viewport)"
      to: "ViewerRegistry viewport broadcasting (Phase 10)"
      via: "JSON.parse of { viewport: { width, height } } messages"
      pattern: "parsed\\.viewport"
    - from: "use-browser-stream.ts (sendMessage)"
      to: "use-mouse-interaction.ts (Plan 03)"
      via: "sendMessage callback used to send MouseInputMessage JSON"
      pattern: "sendMessage.*wsRef\\.current\\.send"
---

<objective>
Extend useBrowserStream hook to parse ViewportMessage metadata from the server and expose viewport dimensions state plus a stable sendMessage callback for downstream input injection.

Purpose: The mouse interaction hook (Plan 03) needs two things from the WebSocket: (1) viewport dimensions to calculate coordinate mapping, and (2) a way to send MouseInputMessage JSON back to the server. Rather than creating a second WebSocket or leaking the ref, useBrowserStream exposes these cleanly.

Output: Modified use-browser-stream.ts with viewport and sendMessage in the return type.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-infrastructure-foundations/10-01-SUMMARY.md
@packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts
@packages/deployer/src/server/browser-stream/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add viewport state and sendMessage to useBrowserStream</name>
  <files>packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts</files>
  <action>
    Modify the existing useBrowserStream hook to add viewport parsing and sendMessage:

    1. **Add viewport state:**
       ```typescript
       const [viewport, setViewport] = useState<{ width: number; height: number } | null>(null);
       ```

    2. **Extend UseBrowserStreamReturn interface:**
       ```typescript
       interface UseBrowserStreamReturn {
         // ... existing fields (status, error, currentUrl, connect, disconnect, isActive) ...
         viewport: { width: number; height: number } | null;
         sendMessage: (data: string) => void;
       }
       ```

    3. **Parse ViewportMessage in ws.onmessage:** Inside the `if (data.startsWith('{'))` block, after successful JSON parse, add viewport detection:
       ```typescript
       // Add viewport type to the parsed type annotation:
       const parsed = JSON.parse(data) as {
         status?: string;
         error?: string;
         url?: string;
         viewport?: { width: number; height: number };
       };

       // After the existing url check, add:
       if (parsed.viewport) {
         setViewport(parsed.viewport);
       }
       ```
       IMPORTANT: The viewport message is a separate JSON message from the server (Phase 10 ViewerRegistry broadcasts `{ viewport: { width, height } }`). It does NOT have a status field. It will be parsed in the existing JSON branch. The viewport check should NOT be inside the `if (parsed.status)` block -- it should be at the same level as the url check.

    4. **Create stable sendMessage callback:**
       ```typescript
       const sendMessage = useCallback((data: string) => {
         if (wsRef.current?.readyState === WebSocket.OPEN) {
           wsRef.current.send(data);
         }
       }, []);
       ```
       Place this after the disconnect callback definition and before the connect callback. The empty dependency array is correct because wsRef is a ref (stable identity).

    5. **Reset viewport on disconnect:** In the `disconnect` callback, after `setError(null)`, add:
       ```typescript
       setViewport(null);
       ```

    6. **Return new fields:** Add viewport and sendMessage to the return object:
       ```typescript
       return {
         status,
         error,
         currentUrl,
         viewport,
         sendMessage,
         connect,
         disconnect,
         isActive,
       };
       ```

    Do NOT:
    - Change the WebSocket URL construction or connection logic
    - Modify the frame handling (non-JSON messages are still raw base64)
    - Change the reconnection or visibility logic
    - Import any new dependencies
  </action>
  <verify>
    `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools/packages/playground-ui && pnpm build` succeeds with no type errors. Verify the return type includes viewport and sendMessage by checking the built output or running `pnpm typecheck` from the monorepo root.
  </verify>
  <done>
    useBrowserStream returns viewport (null initially, populated when server sends ViewportMessage) and sendMessage (stable callback that sends string data over WebSocket when connected). Existing behavior for status, error, currentUrl, frames, reconnection, and visibility handling is unchanged.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes across the monorepo (no breakage in consumers of useBrowserStream)
- `packages/playground-ui` builds successfully
- useBrowserStream return type includes viewport and sendMessage
- Existing BrowserViewFrame component still compiles (it destructures from useBrowserStream, but ignores new fields via rest)
</verification>

<success_criteria>
- viewport state exposed: null initially, set when `{ viewport: { width, height } }` JSON received
- sendMessage callback exposed: sends string to WebSocket when readyState is OPEN
- viewport reset to null on disconnect
- All existing hook behavior preserved (status mapping, url tracking, frame callbacks, reconnection)
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-coordinate-mapping-and-click/12-02-SUMMARY.md`
</output>
