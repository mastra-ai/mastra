---
phase: 12-client-coordinate-mapping-and-click
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/playground-ui/src/domains/agents/utils/coordinate-mapping.ts
  - packages/playground-ui/src/domains/agents/utils/__tests__/coordinate-mapping.test.ts
autonomous: true

must_haves:
  truths:
    - "mapClientToViewport returns correct viewport coordinates for clicks on the rendered image area"
    - "mapClientToViewport returns null for clicks in letterbox/pillarbox regions"
    - "normalizeWheelDelta converts line-mode and page-mode deltas to pixel values and clamps to max 500"
    - "getModifiers produces correct CDP bitmask (Alt=1, Ctrl=2, Meta=4, Shift=8)"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/utils/coordinate-mapping.ts"
      provides: "Pure coordinate mapping, wheel normalization, modifier mapping"
      exports: ["mapClientToViewport", "normalizeWheelDelta", "getModifiers"]
    - path: "packages/playground-ui/src/domains/agents/utils/__tests__/coordinate-mapping.test.ts"
      provides: "Tests for all three exported functions"
      contains: "describe.*mapClientToViewport"
  key_links:
    - from: "coordinate-mapping.ts"
      to: "use-mouse-interaction.ts (Plan 03)"
      via: "import { mapClientToViewport, normalizeWheelDelta, getModifiers }"
      pattern: "mapClientToViewport|normalizeWheelDelta|getModifiers"
---

<objective>
TDD implementation of pure coordinate mapping, wheel delta normalization, and modifier key bitmask functions for the browser live view mouse interaction layer.

Purpose: These pure functions are the mathematical core of Phase 12. Coordinate mapping translates scaled img element clicks to browser viewport CSS pixels accounting for object-fit: contain letterboxing. Wheel normalization handles cross-browser deltaMode differences. Modifier mapping converts JS event flags to CDP bitmask. All are pure (no DOM, no React, no side effects) and benefit strongly from test-first development.

Output: Tested coordinate-mapping.ts with mapClientToViewport, normalizeWheelDelta, and getModifiers exports.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-client-coordinate-mapping-and-click/12-RESEARCH.md
</context>

<feature>
  <name>Coordinate Mapping and Input Helpers</name>
  <files>
    packages/playground-ui/src/domains/agents/utils/coordinate-mapping.ts
    packages/playground-ui/src/domains/agents/utils/__tests__/coordinate-mapping.test.ts
  </files>
  <behavior>
    Three pure functions with defined inputs and outputs:

    **1. mapClientToViewport(clientX, clientY, elemRect, viewport) -> {x, y} | null**

    The function maps a mouse event's clientX/clientY to browser viewport CSS pixel coordinates, accounting for object-fit: contain letterboxing on the img element.

    Algorithm:
    - relX = clientX - elemRect.left; relY = clientY - elemRect.top
    - scale = Math.min(elemRect.width / viewport.width, elemRect.height / viewport.height)
    - renderedWidth = viewport.width * scale; renderedHeight = viewport.height * scale
    - offsetX = (elemRect.width - renderedWidth) / 2; offsetY = (elemRect.height - renderedHeight) / 2
    - imageX = relX - offsetX; imageY = relY - offsetY
    - If imageX < 0 or imageY < 0 or imageX > renderedWidth or imageY > renderedHeight: return null
    - Return { x: imageX / scale, y: imageY / scale }

    Types needed:
    ```typescript
    interface ElementRect { left: number; top: number; width: number; height: number; }
    interface ViewportDimensions { width: number; height: number; }
    interface MappedCoordinates { x: number; y: number; }
    ```

    Test cases:
    - Exact fit (same aspect ratio): elemRect 800x600 at (0,0), viewport 1600x1200 -> click (400,300) maps to (800,600). Scale=0.5, no offset.
    - Pillarbox (viewport wider than element): elemRect 800x600, viewport 1920x1080 -> scale = min(800/1920, 600/1080) = min(0.4167, 0.5556) = 0.4167. Rendered: 800x450. OffsetY = (600-450)/2 = 75. Click at center (400,300) -> imageX=400, imageY=300-75=225 -> viewport (400/0.4167, 225/0.4167) = (960, 540).
    - Letterbox (viewport taller than element): elemRect 800x600, viewport 800x1200 -> scale = min(800/800, 600/1200) = 0.5. Rendered: 400x600. OffsetX = (800-400)/2 = 200. Click at (400,300) -> imageX=400-200=200, imageY=300 -> viewport (200/0.5, 300/0.5) = (400, 600).
    - Click in left pillarbox: same as letterbox case, click at (100,300) -> imageX=100-200=-100 < 0 -> return null.
    - Click in top letterbox: pillarbox case, click at (400, 50) -> imageY=50-75=-25 < 0 -> return null.
    - Corner accuracy: click at (0+offsetX, 0+offsetY) = top-left of rendered area maps to (0, 0). Click at (offsetX+renderedWidth, offsetY+renderedHeight) maps to (viewport.width, viewport.height).

    **2. normalizeWheelDelta(delta, deltaMode, viewportHeight?) -> number**

    Converts wheel event delta to CSS pixels and clamps to [-500, 500].
    - deltaMode 0 (DOM_DELTA_PIXEL): pixels = delta
    - deltaMode 1 (DOM_DELTA_LINE): pixels = delta * 16
    - deltaMode 2 (DOM_DELTA_PAGE): pixels = delta * (viewportHeight ?? 800)
    - Clamp result to [-500, 500]

    Test cases:
    - Pixel mode: normalizeWheelDelta(120, 0) = 120
    - Line mode: normalizeWheelDelta(3, 1) = 48 (3 * 16)
    - Page mode: normalizeWheelDelta(1, 2, 900) = 500 (1 * 900 = 900, clamped to 500)
    - Page mode without viewportHeight: normalizeWheelDelta(1, 2) = 500 (1 * 800, clamped to 500)
    - Negative delta: normalizeWheelDelta(-300, 0) = -300
    - Extreme positive clamping: normalizeWheelDelta(1000, 0) = 500
    - Extreme negative clamping: normalizeWheelDelta(-1000, 0) = -500

    **3. getModifiers(event) -> number**

    CDP bitmask from JS modifier flags: Alt=1, Ctrl=2, Meta=4, Shift=8.

    Test cases (use partial event objects):
    - No modifiers: getModifiers({altKey:false, ctrlKey:false, metaKey:false, shiftKey:false}) = 0
    - Alt only: 1
    - Ctrl only: 2
    - Meta only: 4
    - Shift only: 8
    - Ctrl+Shift: 10 (2|8)
    - All modifiers: 15 (1|2|4|8)
  </behavior>
  <implementation>
    Create the utils directory if needed. Write coordinate-mapping.ts exporting the three functions with the interfaces. Use the exact algorithm from the research. No React dependencies -- pure TypeScript module.

    The test file should use vitest (existing test framework in this package). Group tests by function using describe blocks. Use the test cases above.
  </implementation>
</feature>

<verification>
- `cd packages/playground-ui && pnpm test -- coordinate-mapping` passes all tests
- `pnpm typecheck` passes (no type errors in new files)
- All three functions exported and importable
</verification>

<success_criteria>
- mapClientToViewport correctly maps coordinates for exact-fit, pillarbox, and letterbox scenarios
- mapClientToViewport returns null for clicks in letterbox/pillarbox black bar regions
- normalizeWheelDelta converts deltaMode 0/1/2 to pixel values and clamps to [-500, 500]
- getModifiers produces correct CDP bitmask for all modifier key combinations
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-coordinate-mapping-and-click/12-01-SUMMARY.md`
</output>
