---
phase: 12-client-coordinate-mapping-and-click
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
autonomous: true

must_haves:
  truths:
    - "User clicks on live view frame and click is dispatched to correct browser element"
    - "Clicks in letterbox regions are silently ignored"
    - "Right-clicks forwarded to browser, host context menu suppressed"
    - "Modifier keys (Ctrl, Shift, Alt, Meta) included in CDP bitmask"
    - "Mouse wheel events dispatched as CDP mouseWheel with normalized deltas"
    - "mouseMoved events throttled to ~30/sec via requestAnimationFrame"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts"
      provides: "Mouse event handling hook with coordinate mapping, click/scroll/move composition"
      exports: ["useMouseInteraction"]
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx"
      provides: "BrowserViewFrame wired with mouse interaction"
  key_links:
    - from: "use-mouse-interaction.ts"
      to: "coordinate-mapping.ts (Plan 01)"
      via: "import { mapClientToViewport, normalizeWheelDelta, getModifiers }"
      pattern: "from.*coordinate-mapping"
    - from: "use-mouse-interaction.ts"
      to: "use-browser-stream.ts (Plan 02)"
      via: "sendMessage callback and viewport state passed as options"
      pattern: "sendMessage\\(JSON\\.stringify"
    - from: "browser-view-frame.tsx"
      to: "use-mouse-interaction.ts"
      via: "useMouseInteraction({ imgRef, viewport, sendMessage, enabled })"
      pattern: "useMouseInteraction"
    - from: "use-mouse-interaction.ts"
      to: "server input-handler.ts (Phase 11)"
      via: "MouseInputMessage JSON over WebSocket"
      pattern: "type.*mouse.*eventType"
---

<objective>
Create the useMouseInteraction hook that handles click, scroll, right-click, and mouse move events on the browser live view img element, and wire it into BrowserViewFrame.

Purpose: This is the final integration plan for Phase 12. The pure math (Plan 01) and WebSocket extensions (Plan 02) are composed here into a React hook that attaches DOM event listeners to the img element, maps coordinates, composes CDP event sequences, and sends them over the WebSocket. BrowserViewFrame is updated to use the hook.

Output: Working mouse interaction on the browser live view -- clicks, scrolls, right-clicks, modifier keys, and throttled mouse moves all dispatched to the remote browser.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-client-coordinate-mapping-and-click/12-RESEARCH.md
@packages/playground-ui/src/domains/agents/hooks/use-browser-stream.ts
@packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
@packages/playground-ui/src/domains/agents/utils/coordinate-mapping.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useMouseInteraction hook</name>
  <files>packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts</files>
  <action>
    Create a new React hook that attaches mouse/wheel/contextmenu event listeners to an img element and sends CDP input messages over WebSocket.

    **Interface:**
    ```typescript
    interface UseMouseInteractionOptions {
      imgRef: React.RefObject<HTMLImageElement | null>;
      viewport: { width: number; height: number } | null;
      sendMessage: (data: string) => void;
      enabled: boolean;
    }

    export function useMouseInteraction(options: UseMouseInteractionOptions): void {
      // Hook has no return value -- it's a side-effect-only hook
    }
    ```

    **Implementation details:**

    1. **Refs for closure freshness:** Store viewport and sendMessage in refs (updated via useEffect) so event handlers always read current values without re-attaching listeners:
       ```typescript
       const viewportRef = useRef(options.viewport);
       const sendRef = useRef(options.sendMessage);
       useEffect(() => { viewportRef.current = options.viewport; }, [options.viewport]);
       useEffect(() => { sendRef.current = options.sendMessage; }, [options.sendMessage]);
       ```

    2. **Helper: sendMouseEvent** (inside the hook, not exported):
       ```typescript
       function sendMouseEvent(
         eventType: 'mouseMoved' | 'mousePressed' | 'mouseReleased' | 'mouseWheel',
         x: number, y: number,
         button?: 'left' | 'right' | 'middle' | 'none',
         clickCount?: number,
         modifiers?: number,
         deltaX?: number,
         deltaY?: number,
       ): void {
         const msg: Record<string, unknown> = { type: 'mouse', eventType, x, y };
         if (button !== undefined) msg.button = button;
         if (clickCount !== undefined) msg.clickCount = clickCount;
         if (modifiers !== undefined) msg.modifiers = modifiers;
         if (deltaX !== undefined) msg.deltaX = deltaX;
         if (deltaY !== undefined) msg.deltaY = deltaY;
         sendRef.current(JSON.stringify(msg));
       }
       ```

    3. **Main useEffect** with all event listeners. Guard: if `!options.enabled` or `!options.imgRef.current`, skip (return early with no-op cleanup). Attach listeners to `imgElement = options.imgRef.current`.

    4. **mousedown handler:**
       - Get viewport from viewportRef.current. If null, return early.
       - Get rect via `imgElement.getBoundingClientRect()`.
       - Call `mapClientToViewport(e.clientX, e.clientY, rect, viewport)`. If null (letterbox), return.
       - Map button: `e.button === 2 ? 'right' : e.button === 1 ? 'middle' : 'left'`
       - Get modifiers via `getModifiers(e)`.
       - Send sequence: `sendMouseEvent('mouseMoved', mapped.x, mapped.y, undefined, undefined, modifiers)` then `sendMouseEvent('mousePressed', mapped.x, mapped.y, button, 1, modifiers)`.

    5. **mouseup handler:**
       - Same viewport/rect/mapping guards as mousedown.
       - Map button same way.
       - Send: `sendMouseEvent('mouseReleased', mapped.x, mapped.y, button, 1, getModifiers(e))`.

    6. **contextmenu handler:** `e.preventDefault()` -- suppresses host context menu so right-clicks go through mousedown/mouseup instead.

    7. **wheel handler:**
       - `e.preventDefault()` to prevent host page scrolling.
       - Viewport null guard.
       - Map coordinates via `mapClientToViewport`. If null, return.
       - Normalize deltas: `const normDeltaX = normalizeWheelDelta(e.deltaX, e.deltaMode, viewport.height)` and same for deltaY.
       - Send: `sendMouseEvent('mouseWheel', mapped.x, mapped.y, undefined, undefined, getModifiers(e), normDeltaX, normDeltaY)`.

    8. **mousemove handler with rAF throttle:**
       - Declare outside the handler: `let rafId: number | null = null; let lastMoveTime = 0; let pendingMoveEvent: MouseEvent | null = null;`
       - `const FRAME_INTERVAL = 1000 / 30;` (~33.33ms for 30fps cap)
       - Handler: store `pendingMoveEvent = e`. If `rafId !== null`, return (already scheduled).
       - Schedule rAF: `rafId = requestAnimationFrame((now) => { rafId = null; if (!pendingMoveEvent) return; const delta = now - lastMoveTime; if (delta < FRAME_INTERVAL) return; lastMoveTime = now; /* map and send */ pendingMoveEvent = null; })`.
       - Inside the rAF callback, get viewport from ref, map coordinates, send mouseMoved if mapped is not null.

    9. **Attach listeners:**
       ```typescript
       imgElement.addEventListener('mousedown', handleMouseDown);
       imgElement.addEventListener('mouseup', handleMouseUp);
       imgElement.addEventListener('contextmenu', handleContextMenu);
       imgElement.addEventListener('wheel', handleWheel, { passive: false });
       imgElement.addEventListener('mousemove', handleMouseMove);
       ```
       IMPORTANT: `wheel` must use `{ passive: false }` to allow `preventDefault()`.

    10. **Cleanup:** Remove all five listeners. Cancel any pending rAF via `cancelAnimationFrame(rafId)` if non-null.

    11. **useEffect dependencies:** `[options.enabled, options.imgRef]` -- these are the structural deps. viewport and sendMessage are read from refs.

    **Imports needed:**
    ```typescript
    import { useEffect, useRef } from 'react';
    import { mapClientToViewport, normalizeWheelDelta, getModifiers } from '../utils/coordinate-mapping';
    ```

    Do NOT:
    - Store mapped coordinates in React state (causes re-renders at mouse-move rate)
    - Use lodash throttle/debounce (rAF is the correct approach)
    - Import or use MouseInputMessage type from deployer package (the client doesn't import server types; it constructs the JSON shape directly)
    - Await any response from sendMessage (fire-and-forget)
  </action>
  <verify>
    `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools/packages/playground-ui && pnpm build` succeeds with no type errors.
  </verify>
  <done>
    useMouseInteraction hook handles mousedown (CDP mouseMoved+mousePressed), mouseup (CDP mouseReleased), contextmenu (preventDefault), wheel (normalized CDP mouseWheel), and mousemove (rAF-throttled CDP mouseMoved). All coordinate mapping uses mapClientToViewport. All events guarded by viewport !== null. Letterbox clicks silently ignored. Modifiers included in all events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire useMouseInteraction into BrowserViewFrame</name>
  <files>packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx</files>
  <action>
    Modify BrowserViewFrame to use the useMouseInteraction hook:

    1. **Import the hook:**
       ```typescript
       import { useMouseInteraction } from '../../hooks/use-mouse-interaction';
       ```

    2. **Extract viewport and sendMessage from useBrowserStream:** Change the destructured return:
       ```typescript
       const { status, error, currentUrl, viewport, sendMessage, connect } = useBrowserStream({
         agentId,
         enabled: true,
         onFrame: handleFrame,
       });
       ```

    3. **Call useMouseInteraction:**
       ```typescript
       useMouseInteraction({
         imgRef,
         viewport,
         sendMessage,
         enabled: status === 'streaming',
       });
       ```
       Place this after the useBrowserStream call and before the status/url useEffect callbacks. The `enabled` flag is `status === 'streaming'` so mouse interaction only works when frames are being received (no interaction during connecting/loading/error states).

    4. **Add cursor styling to img element:** Update the img className to include cursor-pointer when streaming so the user knows the frame is interactive:
       ```typescript
       className={cn(
         'absolute inset-0 w-full h-full object-contain',
         hasFrame ? 'opacity-100' : 'opacity-0',
         status === 'streaming' && 'cursor-pointer',
       )}
       ```

    Do NOT:
    - Change the component's props interface
    - Modify the handleFrame callback
    - Change the overlay logic (loading, reconnecting, error)
    - Add any new state for mouse interaction (the hook handles everything internally)
  </action>
  <verify>
    `cd /Users/abhiramaiyer/.superset/worktrees/mastra/ab-tools/packages/playground-ui && pnpm build` succeeds. Verify BrowserViewFrame renders without errors by checking the build output has no warnings about the component.
  </verify>
  <done>
    BrowserViewFrame passes imgRef, viewport, sendMessage, and enabled flag to useMouseInteraction. Mouse interaction is active only during streaming state. Cursor changes to pointer when streaming to indicate interactivity. All existing rendering behavior preserved.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes across the monorepo
- `packages/playground-ui` builds successfully
- BrowserViewFrame imports and uses useMouseInteraction
- useMouseInteraction imports mapClientToViewport, normalizeWheelDelta, getModifiers from coordinate-mapping.ts
- The full chain is wired: img events -> useMouseInteraction -> mapClientToViewport -> sendMessage -> WebSocket -> server handleInputMessage -> CDP
</verification>

<success_criteria>
- Clicking on the live view sends CDP mouseMoved + mousePressed + mouseReleased sequence with mapped coordinates
- Clicking on letterbox regions sends nothing
- Right-clicking suppresses host context menu and sends button:'right' to CDP
- Modifier keys included as CDP bitmask in all mouse events
- Wheel events send CDP mouseWheel with both deltaX and deltaY, normalized across browsers, clamped to 500
- Mouse moves throttled to ~30/sec via requestAnimationFrame
- Mouse interaction only active when status is 'streaming'
</success_criteria>

<output>
After completion, create `.planning/phases/12-client-coordinate-mapping-and-click/12-03-SUMMARY.md`
</output>
