---
phase: 02-execution-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/datasets/run/index.ts
  - packages/core/src/datasets/run/types.ts
  - packages/core/src/datasets/run/executor.ts
  - packages/core/src/datasets/run/scorer.ts
  - packages/core/src/datasets/index.ts
autonomous: true

must_haves:
  truths:
    - "runDataset() executes items against target with p-map concurrency"
    - "Run status transitions: pending -> running -> completed/failed"
    - "Results include output, latency, error for each item"
    - "Scorers applied inline and scores saved to ScoresStorage"
    - "AbortSignal respected for cancellation"
  artifacts:
    - path: "packages/core/src/datasets/run/index.ts"
      provides: "runDataset() main entry point"
      exports: ["runDataset"]
    - path: "packages/core/src/datasets/run/types.ts"
      provides: "RunConfig, ItemResult, RunSummary types"
      contains: "interface RunConfig"
    - path: "packages/core/src/datasets/run/executor.ts"
      provides: "Target execution helpers"
      exports: ["executeTarget"]
    - path: "packages/core/src/datasets/run/scorer.ts"
      provides: "Scoring helpers"
      exports: ["runScorersForItem"]
  key_links:
    - from: "packages/core/src/datasets/run/index.ts"
      to: "packages/core/src/storage/domains/datasets/base.ts"
      via: "loads items via DatasetsStorage"
      pattern: "getItemsByVersion"
    - from: "packages/core/src/datasets/run/index.ts"
      to: "p-map"
      via: "concurrent execution"
      pattern: "pMap.*concurrency"
    - from: "packages/core/src/datasets/run/scorer.ts"
      to: "packages/core/src/mastra/hooks.ts"
      via: "validateAndSaveScore for persistence"
      pattern: "validateAndSaveScore"
---

<objective>
Implement the core run orchestration that executes dataset items against targets with concurrent scoring.

Purpose: This is the execution engine - the heart of Phase 2's value proposition
Output: runDataset() function with p-map execution, target adapters, inline scoring
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-execution-core/02-CONTEXT.md
@.planning/phases/02-execution-core/02-RESEARCH.md
@.planning/phases/02-execution-core/02-01-SUMMARY.md

# Reference patterns
@packages/core/src/evals/run/index.ts
@packages/core/src/mastra/hooks.ts
@packages/core/src/mastra/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run types</name>
  <files>packages/core/src/datasets/run/types.ts</files>
  <action>
Define the public API types for runDataset():

```typescript
import type { MastraScorer } from '../../evals/base';
import type { TargetType, RunStatus } from '../../storage/types';

export interface RunConfig {
  datasetId: string;
  targetType: TargetType;
  targetId: string;
  scorers?: (MastraScorer<any, any, any, any> | string)[];  // Instances or stored IDs
  version?: Date;  // Pin to specific dataset version (default: latest)
  maxConcurrency?: number;  // Default: 5
  signal?: AbortSignal;  // For cancellation
}

export interface ItemResult {
  itemId: string;
  itemVersion: Date;
  input: unknown;
  output: unknown | null;
  expectedOutput: unknown | null;
  latency: number;  // ms
  error: string | null;
  startedAt: Date;
  completedAt: Date;
  retryCount: number;
}

export interface ScorerResult {
  scorerId: string;
  scorerName: string;
  score: number | null;
  reason: string | null;
  error: string | null;
}

export interface ItemWithScores extends ItemResult {
  scores: ScorerResult[];
}

export interface RunSummary {
  runId: string;
  status: RunStatus;
  totalItems: number;
  succeededCount: number;
  failedCount: number;
  startedAt: Date;
  completedAt: Date;
  results: ItemWithScores[];
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>RunConfig, ItemResult, RunSummary types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create target executor</name>
  <files>packages/core/src/datasets/run/executor.ts</files>
  <action>
Implement target execution following runEvals pattern:

```typescript
import type { Agent } from '../../agent';
import { isSupportedLanguageModel } from '../../agent';
import type { Workflow } from '../../workflows';
import type { MastraScorer } from '../../evals/base';
import type { DatasetItem, TargetType } from '../../storage/types';

export type Target = Agent | Workflow | MastraScorer<any, any, any, any>;

export interface ExecutionResult {
  output: unknown;
  error: string | null;
}

/**
 * Execute a dataset item against a target (agent, workflow, scorer, processor).
 * Phase 2 focuses on agent and workflow; scorer/processor deferred to Phase 4.
 */
export async function executeTarget(
  target: Target,
  targetType: TargetType,
  item: DatasetItem,
): Promise<ExecutionResult> {
  try {
    switch (targetType) {
      case 'agent':
        return await executeAgent(target as Agent, item);
      case 'workflow':
        return await executeWorkflow(target as Workflow, item);
      case 'scorer':
      case 'processor':
        // Deferred to Phase 4 - for now throw clear error
        throw new Error(`Target type '${targetType}' not yet supported. Coming in Phase 4.`);
      default:
        throw new Error(`Unknown target type: ${targetType}`);
    }
  } catch (error) {
    return {
      output: null,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

async function executeAgent(agent: Agent, item: DatasetItem): Promise<ExecutionResult> {
  const model = await agent.getModel();

  // Use generate() - works for both v1 and v2 models
  // Pass input as-is - let agent handle normalization
  const result = isSupportedLanguageModel(model)
    ? await agent.generate(item.input as any, {
        scorers: {},
        returnScorerData: true,
      })
    : await (agent as any).generateLegacy?.(item.input as any, {
        scorers: {},
        returnScorerData: true,
      });

  return {
    output: result,
    error: null,
  };
}

async function executeWorkflow(workflow: Workflow, item: DatasetItem): Promise<ExecutionResult> {
  const run = await workflow.createRun({ disableScorers: true });
  const result = await run.start({
    inputData: item.input,
  });

  if (result.status === 'success') {
    return { output: result.result, error: null };
  } else {
    return { output: null, error: result.error?.message ?? 'Workflow failed' };
  }
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>executeTarget handles agent and workflow targets</done>
</task>

<task type="auto">
  <name>Task 3: Create scorer runner</name>
  <files>packages/core/src/datasets/run/scorer.ts</files>
  <action>
Implement inline scoring with error isolation:

```typescript
import type { MastraScorer } from '../../evals/base';
import type { Mastra } from '../../mastra';
import { validateAndSaveScore } from '../../mastra/hooks';
import type { MastraCompositeStore } from '../../storage/composite';
import type { DatasetItem, TargetType } from '../../storage/types';
import type { ScorerResult } from './types';

/**
 * Resolve scorers from mixed array of instances and string IDs.
 */
export function resolveScorers(
  mastra: Mastra,
  scorers?: (MastraScorer<any, any, any, any> | string)[],
): MastraScorer<any, any, any, any>[] {
  if (!scorers || scorers.length === 0) return [];

  return scorers
    .map(scorer => {
      if (typeof scorer === 'string') {
        const resolved = mastra.getScorerById(scorer);
        if (!resolved) {
          console.warn(`Scorer not found: ${scorer}`);
          return null;
        }
        return resolved;
      }
      return scorer;
    })
    .filter((s): s is MastraScorer<any, any, any, any> => s !== null);
}

/**
 * Run all scorers for a single item result.
 * Errors are isolated per scorer - one failing scorer doesn't affect others.
 */
export async function runScorersForItem(
  scorers: MastraScorer<any, any, any, any>[],
  item: DatasetItem,
  output: unknown,
  storage: MastraCompositeStore | null,
  runId: string,
  targetType: TargetType,
  targetId: string,
): Promise<ScorerResult[]> {
  if (scorers.length === 0) return [];

  const results: ScorerResult[] = [];

  for (const scorer of scorers) {
    const result = await runScorerSafe(scorer, item, output);
    results.push(result);

    // Persist score if storage available and score was computed
    if (storage && result.score !== null) {
      try {
        await validateAndSaveScore(storage, {
          scorerId: scorer.id,
          score: result.score,
          reason: result.reason ?? undefined,
          input: item.input,
          output,
          additionalContext: item.context,
          entityType: targetType.toUpperCase(),
          entityId: targetId,
          source: 'TEST',
          runId,
          scorer: {
            id: scorer.id,
            name: scorer.name,
            description: scorer.description ?? '',
          },
          entity: {
            id: targetId,
            name: targetId,
          },
        });
      } catch (saveError) {
        // Log but don't fail - score persistence is best-effort
        console.warn(`Failed to save score for scorer ${scorer.id}:`, saveError);
      }
    }
  }

  return results;
}

async function runScorerSafe(
  scorer: MastraScorer<any, any, any, any>,
  item: DatasetItem,
  output: unknown,
): Promise<ScorerResult> {
  try {
    const scoreResult = await scorer.run({
      input: item.input,
      output,
      groundTruth: item.expectedOutput,
    });

    return {
      scorerId: scorer.id,
      scorerName: scorer.name,
      score: scoreResult.score ?? null,
      reason: scoreResult.reason ?? null,
      error: null,
    };
  } catch (error) {
    return {
      scorerId: scorer.id,
      scorerName: scorer.name,
      score: null,
      reason: null,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>runScorersForItem applies scorers with error isolation</done>
</task>

<task type="auto">
  <name>Task 4: Create main runDataset function</name>
  <files>
    packages/core/src/datasets/run/index.ts
    packages/core/src/datasets/index.ts
  </files>
  <action>
Implement the main orchestration function:

**run/index.ts:**
```typescript
import type { Mastra } from '../../mastra';
import type { RunConfig, RunSummary, ItemWithScores, ItemResult } from './types';
import { executeTarget, type Target } from './executor';
import { resolveScorers, runScorersForItem } from './scorer';

export type { RunConfig, RunSummary, ItemWithScores, ItemResult } from './types';
export { executeTarget } from './executor';
export { resolveScorers, runScorersForItem } from './scorer';

/**
 * Run a dataset against a target with optional scoring.
 *
 * @param mastra - Mastra instance for storage and target resolution
 * @param config - Run configuration
 * @returns RunSummary with results and scores
 */
export async function runDataset(
  mastra: Mastra,
  config: RunConfig,
): Promise<RunSummary> {
  const {
    datasetId,
    targetType,
    targetId,
    scorers: scorerInput,
    version,
    maxConcurrency = 5,
    signal,
  } = config;

  const startedAt = new Date();
  const runId = crypto.randomUUID();

  // 1. Get storage and resolve components
  const storage = mastra.getStorage();
  const datasetsStore = storage?.stores.datasets;
  const runsStore = storage?.stores.runs;

  if (!datasetsStore) {
    throw new Error('DatasetsStorage not configured. Configure storage in Mastra instance.');
  }

  // 2. Load dataset and items
  const dataset = await datasetsStore.getDatasetById({ id: datasetId });
  if (!dataset) {
    throw new Error(`Dataset not found: ${datasetId}`);
  }

  const datasetVersion = version ?? dataset.version;
  const items = await datasetsStore.getItemsByVersion({
    datasetId,
    version: datasetVersion,
  });

  if (items.length === 0) {
    throw new Error(`No items in dataset ${datasetId} at version ${datasetVersion.toISOString()}`);
  }

  // 3. Resolve target
  const target = resolveTarget(mastra, targetType, targetId);
  if (!target) {
    throw new Error(`Target not found: ${targetType}/${targetId}`);
  }

  // 4. Resolve scorers
  const scorers = resolveScorers(mastra, scorerInput);

  // 5. Create run record (if storage available)
  if (runsStore) {
    await runsStore.createRun({
      id: runId,
      datasetId,
      datasetVersion,
      targetType,
      targetId,
      totalItems: items.length,
    });
    await runsStore.updateRun({
      id: runId,
      status: 'running',
      startedAt,
    });
  }

  // 6. Execute items with p-map
  let succeededCount = 0;
  let failedCount = 0;
  const results: ItemWithScores[] = [];

  try {
    const pMap = (await import('p-map')).default;

    await pMap(
      items,
      async (item) => {
        // Check for cancellation
        if (signal?.aborted) {
          throw new DOMException('Aborted', 'AbortError');
        }

        const itemStartedAt = new Date();
        const perfStart = performance.now();

        // Execute target
        const execResult = await executeTarget(target, targetType, item);

        const latency = performance.now() - perfStart;
        const itemCompletedAt = new Date();

        // Track success/failure
        if (execResult.error) {
          failedCount++;
        } else {
          succeededCount++;
        }

        // Build item result
        const itemResult: ItemResult = {
          itemId: item.id,
          itemVersion: item.version,
          input: item.input,
          output: execResult.output,
          expectedOutput: item.expectedOutput ?? null,
          latency,
          error: execResult.error,
          startedAt: itemStartedAt,
          completedAt: itemCompletedAt,
          retryCount: 0,
        };

        // Run scorers (inline, after target completes)
        const itemScores = await runScorersForItem(
          scorers,
          item,
          execResult.output,
          storage,
          runId,
          targetType,
          targetId,
        );

        // Persist result (if storage available)
        if (runsStore) {
          await runsStore.addResult({
            runId,
            itemId: item.id,
            itemVersion: item.version,
            input: item.input,
            output: execResult.output,
            expectedOutput: item.expectedOutput ?? null,
            latency,
            error: execResult.error,
            startedAt: itemStartedAt,
            completedAt: itemCompletedAt,
            retryCount: 0,
          });
        }

        results.push({
          ...itemResult,
          scores: itemScores,
        });
      },
      { concurrency: maxConcurrency },
    );
  } catch (error) {
    // Handle abort or other fatal errors
    const completedAt = new Date();

    if (runsStore) {
      await runsStore.updateRun({
        id: runId,
        status: 'failed',
        succeededCount,
        failedCount,
        completedAt,
      });
    }

    if (error instanceof DOMException && error.name === 'AbortError') {
      throw error;  // Re-throw abort
    }

    throw error;
  }

  // 7. Finalize run record
  const completedAt = new Date();
  const status = failedCount === items.length ? 'failed' : 'completed';

  if (runsStore) {
    await runsStore.updateRun({
      id: runId,
      status,
      succeededCount,
      failedCount,
      completedAt,
    });
  }

  return {
    runId,
    status,
    totalItems: items.length,
    succeededCount,
    failedCount,
    startedAt,
    completedAt,
    results,
  };
}

function resolveTarget(
  mastra: Mastra,
  targetType: string,
  targetId: string,
): Target | null {
  switch (targetType) {
    case 'agent':
      return mastra.getAgentById?.(targetId) ?? mastra.getAgent(targetId) ?? null;
    case 'workflow':
      return mastra.getWorkflowById?.(targetId) ?? mastra.getWorkflow(targetId) ?? null;
    case 'scorer':
      return mastra.getScorerById?.(targetId) ?? null;
    case 'processor':
      // Processors not yet in registry - Phase 4
      return null;
    default:
      return null;
  }
}
```

**datasets/index.ts** (create or update):
```typescript
export * from './run';
```
  </action>
  <verify>pnpm typecheck passes; runDataset function exported</verify>
  <done>runDataset orchestrates items with p-map, scoring, and persistence</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes from monorepo root
2. runDataset function in datasets/run/index.ts
3. Can import: `import { runDataset } from './datasets'`
4. Types defined in datasets/run/types.ts
</verification>

<success_criteria>
- runDataset() accepts RunConfig and returns RunSummary
- Items execute concurrently via p-map with maxConcurrency
- Status transitions: pending -> running -> completed/failed
- Results include output, latency, error per item
- Scorers run inline with error isolation
- AbortSignal stops execution on abort
</success_criteria>

<output>
After completion, create `.planning/phases/02-execution-core/02-03-SUMMARY.md`
</output>
