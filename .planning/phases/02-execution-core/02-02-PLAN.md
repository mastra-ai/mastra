---
phase: 02-execution-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/storage/domains/runs/inmemory.ts
  - packages/core/src/storage/domains/index.ts
  - packages/core/src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "RunsInMemory implements all RunsStorage abstract methods"
    - "RunsStorage exported from storage domains"
    - "createRun initializes run with pending status"
  artifacts:
    - path: "packages/core/src/storage/domains/runs/inmemory.ts"
      provides: "RunsInMemory class with full CRUD"
      exports: ["RunsInMemory"]
    - path: "packages/core/src/storage/domains/index.ts"
      provides: "Re-exports for all storage domains"
      contains: "RunsStorage"
  key_links:
    - from: "packages/core/src/storage/domains/runs/inmemory.ts"
      to: "packages/core/src/storage/domains/runs/base.ts"
      via: "extends RunsStorage"
      pattern: "extends RunsStorage"
---

<objective>
Implement RunsInMemory storage adapter for run lifecycle tracking and register exports.

Purpose: In-memory run tracking for development and testing - enables run orchestration without database
Output: RunsInMemory class, storage domain exports wired up
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-execution-core/02-01-SUMMARY.md

# Reference patterns
@packages/core/src/storage/domains/datasets/inmemory.ts
@packages/core/src/storage/domains/runs/base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RunsInMemory implementation</name>
  <files>packages/core/src/storage/domains/runs/inmemory.ts</files>
  <action>
Implement RunsInMemory following DatasetsInMemory pattern:

```typescript
import { RunsStorage } from './base';
import type {
  Run,
  RunResult,
  CreateRunInput,
  UpdateRunInput,
  AddRunResultInput,
  ListRunsInput,
  ListRunsOutput,
  ListRunResultsInput,
  ListRunResultsOutput,
} from '../../types';

export class RunsInMemory extends RunsStorage {
  #runs: Map<string, Run> = new Map();
  #results: Map<string, RunResult> = new Map();

  async dangerouslyClearAll(): Promise<void> {
    this.#runs.clear();
    this.#results.clear();
  }

  async createRun(input: CreateRunInput): Promise<Run> {
    const now = new Date();
    const run: Run = {
      id: input.id ?? crypto.randomUUID(),
      datasetId: input.datasetId,
      datasetVersion: input.datasetVersion,
      targetType: input.targetType,
      targetId: input.targetId,
      status: 'pending',
      totalItems: input.totalItems,
      succeededCount: 0,
      failedCount: 0,
      startedAt: null,
      completedAt: null,
      createdAt: now,
      updatedAt: now,
    };
    this.#runs.set(run.id, run);
    return run;
  }

  async updateRun(input: UpdateRunInput): Promise<Run> {
    const existing = this.#runs.get(input.id);
    if (!existing) {
      throw new Error(`Run not found: ${input.id}`);
    }
    const updated: Run = {
      ...existing,
      status: input.status ?? existing.status,
      succeededCount: input.succeededCount ?? existing.succeededCount,
      failedCount: input.failedCount ?? existing.failedCount,
      startedAt: input.startedAt ?? existing.startedAt,
      completedAt: input.completedAt ?? existing.completedAt,
      updatedAt: new Date(),
    };
    this.#runs.set(input.id, updated);
    return updated;
  }

  async getRunById(args: { id: string }): Promise<Run | null> {
    return this.#runs.get(args.id) ?? null;
  }

  async listRuns(args: ListRunsInput): Promise<ListRunsOutput> {
    let runs = Array.from(this.#runs.values());

    if (args.datasetId) {
      runs = runs.filter(r => r.datasetId === args.datasetId);
    }

    // Sort by createdAt descending
    runs.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const total = runs.length;
    const { offset = 0, limit = 100 } = args.pagination;
    const paginated = runs.slice(offset, offset + limit);

    return {
      runs: paginated,
      pagination: {
        total,
        offset,
        limit,
      },
    };
  }

  async deleteRun(args: { id: string }): Promise<void> {
    this.#runs.delete(args.id);
    // Also delete associated results
    for (const [resultId, result] of this.#results) {
      if (result.runId === args.id) {
        this.#results.delete(resultId);
      }
    }
  }

  async addResult(input: AddRunResultInput): Promise<RunResult> {
    const now = new Date();
    const result: RunResult = {
      id: input.id ?? crypto.randomUUID(),
      runId: input.runId,
      itemId: input.itemId,
      itemVersion: input.itemVersion,
      input: input.input,
      output: input.output,
      expectedOutput: input.expectedOutput,
      latency: input.latency,
      error: input.error,
      startedAt: input.startedAt,
      completedAt: input.completedAt,
      retryCount: input.retryCount,
      createdAt: now,
    };
    this.#results.set(result.id, result);
    return result;
  }

  async getResultById(args: { id: string }): Promise<RunResult | null> {
    return this.#results.get(args.id) ?? null;
  }

  async listResults(args: ListRunResultsInput): Promise<ListRunResultsOutput> {
    let results = Array.from(this.#results.values())
      .filter(r => r.runId === args.runId);

    // Sort by startedAt ascending (execution order)
    results.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());

    const total = results.length;
    const { offset = 0, limit = 100 } = args.pagination;
    const paginated = results.slice(offset, offset + limit);

    return {
      results: paginated,
      pagination: {
        total,
        offset,
        limit,
      },
    };
  }

  async deleteResultsByRunId(args: { runId: string }): Promise<void> {
    for (const [resultId, result] of this.#results) {
      if (result.runId === args.runId) {
        this.#results.delete(resultId);
      }
    }
  }
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>RunsInMemory implements all 9 abstract methods from RunsStorage</done>
</task>

<task type="auto">
  <name>Task 2: Update storage domain exports</name>
  <files>
    packages/core/src/storage/domains/runs/index.ts
    packages/core/src/storage/domains/index.ts
  </files>
  <action>
Wire up exports so RunsStorage and RunsInMemory are accessible:

**runs/index.ts** (update):
```typescript
export { RunsStorage } from './base';
export { RunsInMemory } from './inmemory';
```

**domains/index.ts** (add):
```typescript
export * from './runs';
```

Also update **storage/index.ts** if runs not exported:
- Check if storage/index.ts re-exports from domains/
- If not, add: `export * from './domains/runs';`
  </action>
  <verify>Can import RunsStorage from '@mastra/core' (or subpath); pnpm typecheck</verify>
  <done>RunsStorage and RunsInMemory exported from storage domain index</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes from monorepo root
2. RunsInMemory in domains/runs/inmemory.ts
3. Can import: `import { RunsStorage, RunsInMemory } from './storage/domains'`
4. createRun returns run with status 'pending'
</verification>

<success_criteria>
- All abstract methods implemented in RunsInMemory
- Exports wired through domain indexes
- No runtime errors on basic instantiation
</success_criteria>

<output>
After completion, create `.planning/phases/02-execution-core/02-02-SUMMARY.md`
</output>
