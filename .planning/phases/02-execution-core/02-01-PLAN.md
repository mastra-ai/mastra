---
phase: 02-execution-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/storage/types.ts
  - packages/core/src/storage/constants.ts
  - packages/core/src/storage/domains/runs/base.ts
  - packages/core/src/storage/domains/runs/index.ts
autonomous: true

must_haves:
  truths:
    - "Run and RunResult types defined with all required fields"
    - "RunsStorage abstract class defines complete CRUD contract"
    - "Table schemas registered for runs and results"
  artifacts:
    - path: "packages/core/src/storage/types.ts"
      provides: "Run, RunResult, CreateRunInput, UpdateRunInput types"
      contains: "interface Run"
    - path: "packages/core/src/storage/constants.ts"
      provides: "DATASET_RUNS_SCHEMA, DATASET_RUN_RESULTS_SCHEMA"
      contains: "TABLE_DATASET_RUNS"
    - path: "packages/core/src/storage/domains/runs/base.ts"
      provides: "RunsStorage abstract class"
      exports: ["RunsStorage"]
  key_links:
    - from: "packages/core/src/storage/domains/runs/base.ts"
      to: "packages/core/src/storage/types.ts"
      via: "import types"
      pattern: "import.*Run.*from"
---

<objective>
Define RunsStorage domain types, schemas, and abstract base class for tracking dataset run records and per-item results.

Purpose: Foundation for run lifecycle tracking - Phase 2's equivalent of Phase 1's DatasetsStorage base
Output: Run/RunResult types, table schemas, RunsStorage abstract class with CRUD contract
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-execution-core/02-CONTEXT.md
@.planning/phases/02-execution-core/02-RESEARCH.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md

# Reference patterns
@packages/core/src/storage/types.ts
@packages/core/src/storage/constants.ts
@packages/core/src/storage/domains/datasets/base.ts
@packages/core/src/storage/domains/scores/base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Run types to storage/types.ts</name>
  <files>packages/core/src/storage/types.ts</files>
  <action>
Add Run and RunResult interfaces plus all input/output types:

```typescript
// Run record (tracks overall run state)
export interface Run {
  id: string;
  datasetId: string;
  datasetVersion: Date;  // Version snapshot at run start
  targetType: 'agent' | 'workflow' | 'scorer' | 'processor';
  targetId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  totalItems: number;
  succeededCount: number;
  failedCount: number;
  startedAt: Date | null;
  completedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

// Per-item result record
export interface RunResult {
  id: string;
  runId: string;
  itemId: string;
  itemVersion: Date;
  input: unknown;
  output: unknown | null;
  expectedOutput: unknown | null;
  latency: number;  // ms
  error: string | null;
  startedAt: Date;
  completedAt: Date;
  retryCount: number;
  createdAt: Date;
}

// Input/output types for RunsStorage methods
export type TargetType = 'agent' | 'workflow' | 'scorer' | 'processor';
export type RunStatus = 'pending' | 'running' | 'completed' | 'failed';

export interface CreateRunInput {
  id?: string;
  datasetId: string;
  datasetVersion: Date;
  targetType: TargetType;
  targetId: string;
  totalItems: number;
}

export interface UpdateRunInput {
  id: string;
  status?: RunStatus;
  succeededCount?: number;
  failedCount?: number;
  startedAt?: Date;
  completedAt?: Date;
}

export interface AddRunResultInput {
  id?: string;
  runId: string;
  itemId: string;
  itemVersion: Date;
  input: unknown;
  output: unknown | null;
  expectedOutput: unknown | null;
  latency: number;
  error: string | null;
  startedAt: Date;
  completedAt: Date;
  retryCount: number;
}

export interface ListRunsInput {
  datasetId?: string;
  pagination: StoragePagination;
}

export interface ListRunsOutput {
  runs: Run[];
  pagination: StoragePaginationResult;
}

export interface ListRunResultsInput {
  runId: string;
  pagination: StoragePagination;
}

export interface ListRunResultsOutput {
  results: RunResult[];
  pagination: StoragePaginationResult;
}
```

Follow existing patterns from Dataset/DatasetItem types in the same file.
  </action>
  <verify>pnpm typecheck (from monorepo root) - no errors</verify>
  <done>Run and RunResult types defined with all CRUD input/output types</done>
</task>

<task type="auto">
  <name>Task 2: Add table schemas to storage/constants.ts</name>
  <files>packages/core/src/storage/constants.ts</files>
  <action>
Add table constants and schemas following existing patterns:

1. Add table constants near existing TABLE_DATASETS:
```typescript
export const TABLE_DATASET_RUNS = 'mastra_dataset_runs';
export const TABLE_DATASET_RUN_RESULTS = 'mastra_dataset_run_results';
```

2. Add to TABLE_NAMES type union:
```typescript
| typeof TABLE_DATASET_RUNS
| typeof TABLE_DATASET_RUN_RESULTS
```

3. Add schemas following DATASETS_SCHEMA pattern:
```typescript
export const DATASET_RUNS_SCHEMA: Record<string, StorageColumn> = {
  id: { type: 'text', nullable: false, primaryKey: true },
  datasetId: { type: 'text', nullable: false },
  datasetVersion: { type: 'timestamp', nullable: false },
  targetType: { type: 'text', nullable: false },
  targetId: { type: 'text', nullable: false },
  status: { type: 'text', nullable: false },
  totalItems: { type: 'integer', nullable: false },
  succeededCount: { type: 'integer', nullable: false },
  failedCount: { type: 'integer', nullable: false },
  startedAt: { type: 'timestamp', nullable: true },
  completedAt: { type: 'timestamp', nullable: true },
  createdAt: { type: 'timestamp', nullable: false },
  updatedAt: { type: 'timestamp', nullable: false },
};

export const DATASET_RUN_RESULTS_SCHEMA: Record<string, StorageColumn> = {
  id: { type: 'text', nullable: false, primaryKey: true },
  runId: { type: 'text', nullable: false },
  itemId: { type: 'text', nullable: false },
  itemVersion: { type: 'timestamp', nullable: false },
  input: { type: 'jsonb', nullable: false },
  output: { type: 'jsonb', nullable: true },
  expectedOutput: { type: 'jsonb', nullable: true },
  latency: { type: 'float', nullable: false },
  error: { type: 'text', nullable: true },
  startedAt: { type: 'timestamp', nullable: false },
  completedAt: { type: 'timestamp', nullable: false },
  retryCount: { type: 'integer', nullable: false },
  createdAt: { type: 'timestamp', nullable: false },
};
```

4. Register in TABLE_SCHEMAS map:
```typescript
[TABLE_DATASET_RUNS]: DATASET_RUNS_SCHEMA,
[TABLE_DATASET_RUN_RESULTS]: DATASET_RUN_RESULTS_SCHEMA,
```

5. Add table map entries to inmemory.ts data object to fix typecheck:
```typescript
mastra_dataset_runs: new Map(),
mastra_dataset_run_results: new Map(),
```
  </action>
  <verify>pnpm typecheck passes; grep for TABLE_DATASET_RUNS in constants.ts</verify>
  <done>DATASET_RUNS_SCHEMA and DATASET_RUN_RESULTS_SCHEMA registered in TABLE_SCHEMAS</done>
</task>

<task type="auto">
  <name>Task 3: Create RunsStorage abstract base class</name>
  <files>
    packages/core/src/storage/domains/runs/base.ts
    packages/core/src/storage/domains/runs/index.ts
  </files>
  <action>
Create the RunsStorage abstract class following DatasetsStorage/ScoresStorage pattern:

**base.ts:**
```typescript
import { StorageDomain } from '../base';
import type {
  Run,
  RunResult,
  CreateRunInput,
  UpdateRunInput,
  AddRunResultInput,
  ListRunsInput,
  ListRunsOutput,
  ListRunResultsInput,
  ListRunResultsOutput,
} from '../../types';

/**
 * Abstract base class for dataset runs storage domain.
 * Provides the contract for run lifecycle and result tracking.
 */
export abstract class RunsStorage extends StorageDomain {
  constructor() {
    super({
      component: 'STORAGE',
      name: 'RUNS',
    });
  }

  async dangerouslyClearAll(): Promise<void> {
    // Default no-op - subclasses override
  }

  // Run lifecycle
  abstract createRun(input: CreateRunInput): Promise<Run>;
  abstract updateRun(input: UpdateRunInput): Promise<Run>;
  abstract getRunById(args: { id: string }): Promise<Run | null>;
  abstract listRuns(args: ListRunsInput): Promise<ListRunsOutput>;
  abstract deleteRun(args: { id: string }): Promise<void>;

  // Results (per-item)
  abstract addResult(input: AddRunResultInput): Promise<RunResult>;
  abstract getResultById(args: { id: string }): Promise<RunResult | null>;
  abstract listResults(args: ListRunResultsInput): Promise<ListRunResultsOutput>;
  abstract deleteResultsByRunId(args: { runId: string }): Promise<void>;
}
```

**index.ts:**
```typescript
export { RunsStorage } from './base';
```
  </action>
  <verify>pnpm typecheck passes; file exists at packages/core/src/storage/domains/runs/base.ts</verify>
  <done>RunsStorage abstract class with 9 abstract methods defined</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes from monorepo root
2. Run and RunResult interfaces in storage/types.ts
3. TABLE_DATASET_RUNS and TABLE_DATASET_RUN_RESULTS in constants.ts
4. RunsStorage class in domains/runs/base.ts
</verification>

<success_criteria>
- All types compile without errors
- RunsStorage follows same pattern as DatasetsStorage/ScoresStorage
- Schemas registered in TABLE_SCHEMAS for both tables
- No runtime errors when importing from index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-execution-core/02-01-SUMMARY.md`
</output>
