---
phase: 06-browser-lifecycle-locking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - integrations/agent-browser/src/toolset.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Concurrent getBrowser() calls share the same browser instance"
    - "Second concurrent call awaits first launch (not starts new one)"
    - "All tools share same browser instance even when called in parallel"
    - "No orphaned browser processes on concurrent execution"
  artifacts:
    - path: "integrations/agent-browser/src/toolset.ts"
      provides: "BrowserToolset with race-free lazy initialization"
      contains: "launchPromise"
  key_links:
    - from: "getBrowser()"
      to: "launchPromise"
      via: "synchronous assignment before await"
      pattern: "if \\(!this\\.launchPromise\\)"
    - from: "close()"
      to: "launchPromise"
      via: "clear on close"
      pattern: "this\\.launchPromise = null"
---

<objective>
Add browser launch locking to prevent race conditions when multiple tools call getBrowser() concurrently.

Purpose: Audit finding - concurrent getBrowser() calls can launch multiple browser instances because the check-and-launch pattern has an async gap. This causes orphaned browser processes and inconsistent state.

Output: Updated toolset.ts with Singleton Promise pattern that guarantees exactly one browser launch regardless of concurrent access.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-browser-lifecycle-locking/06-RESEARCH.md

# Source file to modify
@integrations/agent-browser/src/toolset.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add launchPromise field and refactor getBrowser</name>
  <files>integrations/agent-browser/src/toolset.ts</files>
  <action>
Modify BrowserToolset class to implement Singleton Promise pattern:

1. Add new private field after browserManager declaration (around line 40):
   ```typescript
   /** Promise for in-progress browser launch - prevents concurrent launches */
   private launchPromise: Promise<BrowserManager> | null = null;
   ```

2. Replace the existing getBrowser() method (lines 79-101) with:
   ```typescript
   /**
    * Lazily initializes and returns the browser instance.
    * Uses Singleton Promise pattern to prevent concurrent launches.
    *
    * @returns Promise resolving to the BrowserManager instance
    */
   private async getBrowser(): Promise<BrowserManager> {
     // Fast path: already initialized
     if (this.browserManager) {
       return this.browserManager;
     }

     // Start launch if not in progress
     // CRITICAL: This assignment is synchronous - no await between check and assign
     if (!this.launchPromise) {
       this.launchPromise = this.launchBrowser();
     }

     // All concurrent callers share this same promise
     return this.launchPromise;
   }
   ```

3. Add new private launchBrowser() method after getBrowser():
   ```typescript
   /**
    * Internal method that performs the actual browser launch.
    * Only called once per toolset lifecycle (unless launch fails).
    *
    * @returns Promise resolving to the BrowserManager instance
    */
   private async launchBrowser(): Promise<BrowserManager> {
     const manager = new BrowserManager();
     try {
       await manager.launch({
         id: 'browser-toolset-launch',
         action: 'launch',
         headless: this.config.headless,
       });
       // Store the successfully launched browser
       this.browserManager = manager;
       return manager;
     } catch (error) {
       // Reset promise to allow retry on next call
       this.launchPromise = null;
       // Clean up partial state
       try {
         await manager.close();
       } catch {
         // Ignore cleanup errors
       }
       throw error;
     }
   }
   ```

Why Singleton Promise works: The assignment `this.launchPromise = this.launchBrowser()` happens synchronously before any await. JavaScript's single-threaded event loop guarantees no interleaving during synchronous code. All concurrent callers see the same promise.

Why reset on failure: If launch fails, setting launchPromise back to null allows a fresh retry on the next getBrowser() call.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd integrations/agent-browser && pnpm build
```

Verify new field exists:
```bash
grep -n "launchPromise" integrations/agent-browser/src/toolset.ts
```
  </verify>
  <done>
- launchPromise field added to BrowserToolset class
- getBrowser() uses Singleton Promise pattern (check launchPromise, not browserManager, for launch decision)
- launchBrowser() method contains actual launch logic with error handling
- TypeScript compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Update close() to clear launchPromise</name>
  <files>integrations/agent-browser/src/toolset.ts</files>
  <action>
Update the close() method (lines 118-129) to also clear launchPromise:

```typescript
/**
 * Closes the browser and releases resources.
 * Should be called when the toolset is no longer needed.
 * Safe to call multiple times - subsequent calls are no-ops.
 *
 * @example
 * ```typescript
 * const browserTools = new BrowserToolset();
 * try {
 *   // Use tools...
 * } finally {
 *   await browserTools.close();
 * }
 * ```
 */
async close(): Promise<void> {
  // Clear the launch promise to allow fresh launch after close
  this.launchPromise = null;

  if (this.browserManager) {
    try {
      await this.browserManager.close();
    } catch (error) {
      // Log but don't throw - cleanup should be best-effort
      console.warn('[BrowserToolset] Error closing browser:', error);
    } finally {
      this.browserManager = null;
    }
  }
}
```

Why this matters: Without clearing launchPromise, a sequence of close() -> getBrowser() would not start a fresh launch. The stale promise would return a closed/invalid browser reference.

Add the line `this.launchPromise = null;` at the START of close(), before checking browserManager. This ensures consistent state even if close() is called during an in-progress launch.
  </action>
  <verify>
Verify close() clears launchPromise:
```bash
grep -A5 "async close" integrations/agent-browser/src/toolset.ts | grep "launchPromise"
```

TypeScript compiles:
```bash
cd integrations/agent-browser && pnpm build
```
  </verify>
  <done>
- close() method clears launchPromise at start
- close() -> getBrowser() sequence works correctly (starts fresh launch)
- TypeScript compiles successfully
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build succeeds:
   ```bash
   cd integrations/agent-browser && pnpm build
   ```

2. Singleton Promise pattern is correctly implemented:
   ```bash
   # Check for launchPromise field
   grep "private launchPromise" integrations/agent-browser/src/toolset.ts

   # Check for synchronous assignment in getBrowser
   grep -A10 "private async getBrowser" integrations/agent-browser/src/toolset.ts | grep "this.launchPromise = this.launchBrowser()"

   # Check for reset in launchBrowser error path
   grep -A20 "private async launchBrowser" integrations/agent-browser/src/toolset.ts | grep "this.launchPromise = null"

   # Check close clears launchPromise
   grep -A5 "async close" integrations/agent-browser/src/toolset.ts | grep "this.launchPromise = null"
   ```

3. No duplicate browserManager checks in getBrowser (should check launchPromise for launch decision):
   ```bash
   grep -c "if (!this.browserManager)" integrations/agent-browser/src/toolset.ts
   # Should return 0 or 1 (only the fast-path check)
   ```
</verification>

<success_criteria>
- launchPromise: Promise<BrowserManager> | null field exists on BrowserToolset
- getBrowser() checks launchPromise (not browserManager) to decide whether to start launch
- launchBrowser() contains the actual launch logic
- launchBrowser() resets launchPromise to null on failure (allowing retry)
- close() clears both browserManager and launchPromise
- TypeScript compiles without errors
- Pattern matches 06-RESEARCH.md recommendations exactly
</success_criteria>

<output>
After completion, create `.planning/phases/06-browser-lifecycle-locking/06-01-SUMMARY.md`
</output>
