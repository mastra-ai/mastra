---
phase: 01-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - integrations/agent-browser/src/tools/navigate.ts
  - integrations/agent-browser/src/toolset.ts
  - integrations/agent-browser/src/index.ts
autonomous: true

must_haves:
  truths:
    - "BrowserToolset can be instantiated with optional config"
    - "BrowserToolset exposes navigate tool via tools property"
    - "Navigate tool accepts url and waitUntil parameters"
    - "Browser launches lazily on first tool use (not at construction)"
    - "Browser closes cleanly via close() method"
    - "Navigation times out after 10 seconds with clear error message"
  artifacts:
    - path: "integrations/agent-browser/src/tools/navigate.ts"
      provides: "Navigate tool implementation"
      exports: ["createNavigateTool"]
    - path: "integrations/agent-browser/src/toolset.ts"
      provides: "BrowserToolset class with lifecycle management"
      exports: ["BrowserToolset"]
    - path: "integrations/agent-browser/src/index.ts"
      provides: "Package exports"
      exports: ["BrowserToolset", "BrowserToolsetConfig"]
  key_links:
    - from: "integrations/agent-browser/src/toolset.ts"
      to: "agent-browser"
      via: "BrowserManager import"
      pattern: "import.*BrowserManager.*from.*agent-browser"
    - from: "integrations/agent-browser/src/toolset.ts"
      to: "integrations/agent-browser/src/tools/navigate.ts"
      via: "createNavigateTool import"
      pattern: "createNavigateTool"
    - from: "integrations/agent-browser/src/toolset.ts"
      to: "getBrowser method"
      via: "lazy initialization pattern"
      pattern: "getBrowser.*Promise.*BrowserManager"
---

<objective>
Implement the navigate tool and BrowserToolset class with lazy browser initialization and proper cleanup.

Purpose: Deliver the core functionality allowing Mastra agents to navigate to URLs with lifecycle management.
Output: Working BrowserToolset that can be registered with agents, with navigate tool that respects timeouts and cleanup.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@packages/core/src/tools/tool.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement navigate tool</name>
  <files>
    integrations/agent-browser/src/tools/navigate.ts
  </files>
  <action>
Create the navigate tool following Mastra createTool patterns.

**Implementation requirements:**

```typescript
import { createTool, ToolExecutionContext } from '@mastra/core/tools';
import type { BrowserManager } from 'agent-browser';
import { navigateInputSchema, navigateOutputSchema, type NavigateOutput, type BrowserError } from '../types';

type NavigateToolContext = ToolExecutionContext & {
  getBrowser: () => Promise<BrowserManager>;
};

export function createNavigateTool(getBrowser: () => Promise<BrowserManager>, defaultTimeout: number) {
  return createTool({
    id: 'browser_navigate',
    description: 'Navigate the browser to a URL. Returns the final URL and page title after navigation completes.',
    inputSchema: navigateInputSchema,
    outputSchema: navigateOutputSchema,
    execute: async (input, context): Promise<NavigateOutput | BrowserError> => {
      const timeoutMs = defaultTimeout;

      try {
        const browser = await getBrowser();

        // Create timeout controller
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        // Link to context.abortSignal if provided
        if (context.abortSignal) {
          context.abortSignal.addEventListener('abort', () => controller.abort());
        }

        try {
          // Navigate with timeout
          // Note: agent-browser's navigate() may accept options object
          await browser.navigate(input.url, {
            timeout: timeoutMs,
            waitUntil: input.waitUntil || 'domcontentloaded',
          });

          // Get page info after navigation
          const page = browser.getPage(); // Assuming this API exists
          const url = page?.url() || input.url;
          const title = await page?.title() || '';

          return {
            success: true,
            url,
            title,
          };
        } finally {
          clearTimeout(timeoutId);
        }
      } catch (error) {
        // Return LLM-friendly error
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        const isTimeout = errorMessage.includes('timeout') || errorMessage.includes('aborted');

        return {
          success: false,
          error: `Navigation failed: ${errorMessage}`,
          hint: isTimeout
            ? 'The page took too long to load. Try a different URL or increase timeout.'
            : 'Check that the URL is valid and the site is accessible.',
        };
      }
    },
  });
}
```

**Key patterns to follow:**
1. Use createTool from @mastra/core/tools
2. Pass getBrowser as closure (not direct reference to avoid eager init)
3. Implement timeout with AbortController + setTimeout
4. Link to context.abortSignal for agent cancellation
5. Return structured error with hint for LLM recovery
6. Use try/finally for cleanup (clearTimeout)
7. Default waitUntil to 'domcontentloaded' (not networkidle)

**Note:** The exact agent-browser API (navigate options, getPage method) should be verified during implementation. The pattern is correct but method names may differ.
  </action>
  <verify>
    Run: grep -E "createTool|abortSignal|timeout|domcontentloaded" integrations/agent-browser/src/tools/navigate.ts
    Expect: All key patterns present in implementation
  </verify>
  <done>
    Navigate tool is implemented with:
    - 10-second timeout enforcement
    - abortSignal integration for cancellation
    - domcontentloaded as default waitUntil
    - LLM-friendly error responses with hints
    - try/finally cleanup pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement BrowserToolset class</name>
  <files>
    integrations/agent-browser/src/toolset.ts
    integrations/agent-browser/src/index.ts
  </files>
  <action>
Create the BrowserToolset class with lazy initialization and cleanup.

**toolset.ts implementation:**

```typescript
import { BrowserManager } from 'agent-browser';
import type { ToolAction } from '@mastra/core/tools';
import { createNavigateTool } from './tools/navigate';
import type { BrowserToolsetConfig } from './types';

/**
 * BrowserToolset provides browser automation tools for Mastra agents.
 *
 * @example
 * ```typescript
 * const browserTools = new BrowserToolset({ headless: true });
 *
 * const agent = new Agent({
 *   tools: browserTools.tools,
 * });
 *
 * // Browser launches lazily on first tool use
 * await agent.generate('Navigate to https://example.com');
 *
 * // Always close when done
 * await browserTools.close();
 * ```
 */
export class BrowserToolset {
  readonly name = 'agent-browser';

  private browserManager: BrowserManager | null = null;
  private config: Required<BrowserToolsetConfig>;

  readonly tools: Record<string, ToolAction<any, any>>;

  constructor(config: BrowserToolsetConfig = {}) {
    this.config = {
      headless: config.headless ?? true,
      timeout: config.timeout ?? 10_000, // 10 seconds
    };

    // Initialize tools with getBrowser closure
    this.tools = {
      browser_navigate: createNavigateTool(
        () => this.getBrowser(),
        this.config.timeout
      ),
    };
  }

  /**
   * Lazily initializes and returns the browser instance.
   * Browser is only launched on first tool use, not at construction.
   */
  private async getBrowser(): Promise<BrowserManager> {
    if (!this.browserManager) {
      this.browserManager = new BrowserManager();
      await this.browserManager.launch({
        headless: this.config.headless,
      });
    }
    return this.browserManager;
  }

  /**
   * Closes the browser and releases resources.
   * Should be called when the toolset is no longer needed.
   * Safe to call multiple times.
   */
  async close(): Promise<void> {
    if (this.browserManager) {
      try {
        // Note: Exact close method name TBD based on agent-browser API
        // Could be close(), quit(), shutdown(), or browser.close()
        await this.browserManager.close?.();
      } catch (error) {
        // Log but don't throw - cleanup should be best-effort
        console.warn('[BrowserToolset] Error closing browser:', error);
      } finally {
        this.browserManager = null;
      }
    }
  }
}
```

**index.ts implementation:**

```typescript
// Main exports
export { BrowserToolset } from './toolset';
export type { BrowserToolsetConfig, NavigateInput, NavigateOutput, BrowserError } from './types';
```

**Key patterns:**
1. Lazy initialization in getBrowser() - browser only starts on first use
2. Config with sensible defaults (headless: true, timeout: 10000)
3. Tools exposed via readonly tools property (matches Mastra pattern)
4. close() method with try/finally and null safety
5. Clean exports from index.ts

**Open questions from research to address during implementation:**
- Verify BrowserManager.close() method name (could be close, quit, shutdown)
- Verify BrowserManager.launch() options shape
- Verify how to get the Playwright Page from BrowserManager
  </action>
  <verify>
    Run: grep -E "getBrowser|close|browserManager|lazy" integrations/agent-browser/src/toolset.ts
    Expect: Lazy initialization pattern with getBrowser, close method, browserManager property
  </verify>
  <done>
    BrowserToolset class is implemented with:
    - Lazy browser initialization (launches on first tool use)
    - close() method for cleanup
    - Config with headless and timeout options
    - tools property exposing navigate tool
    - Proper exports from index.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Build and verify package</name>
  <files>
    (no new files - verification task)
  </files>
  <action>
Build the package to verify everything compiles correctly.

**Steps:**
1. Add integrations/agent-browser to pnpm-workspace.yaml if not already included
2. Run pnpm install from monorepo root to link dependencies
3. Build the package: cd integrations/agent-browser && pnpm build
4. Verify dist/ contains index.js, index.mjs, index.d.ts

**If build fails:**
- Check for TypeScript errors and fix
- Verify import paths are correct
- Check that @mastra/core paths resolve correctly

**Expected output:**
- dist/index.js (CommonJS)
- dist/index.mjs (ESM)
- dist/index.d.ts (TypeScript declarations)
  </action>
  <verify>
    Run: cd integrations/agent-browser && ls dist/ 2>/dev/null || echo "Build not run yet"
    Run: pnpm build 2>&1 | tail -20
    Expect: Build succeeds, dist/ contains expected files
  </verify>
  <done>
    Package builds successfully with:
    - No TypeScript errors
    - dist/ contains compiled output
    - Types are properly exported
  </done>
</task>

</tasks>

<verification>
1. BrowserToolset can be instantiated: `new BrowserToolset()` creates instance
2. Tools are accessible: `browserTools.tools.browser_navigate` exists
3. Navigate tool has correct schema: inputSchema includes url and waitUntil
4. Package builds: `pnpm build` succeeds in integrations/agent-browser
5. Exports work: `import { BrowserToolset } from '@mastra/agent-browser'` would resolve
</verification>

<success_criteria>
- BrowserToolset class exists with lazy initialization
- Navigate tool accepts url (required) and waitUntil (optional, default domcontentloaded)
- Navigate returns {success, url, title} on success or {success: false, error, hint} on failure
- Timeout is enforced at 10 seconds
- close() method cleans up browser resources
- Package builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-02-SUMMARY.md`
</output>
