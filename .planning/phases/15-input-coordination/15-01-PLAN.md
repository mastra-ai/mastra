---
phase: 15-input-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/playground-ui/src/domains/agents/hooks/use-input-coordination.ts
  - packages/playground-ui/src/domains/agents/components/browser-view/agent-busy-overlay.tsx
  - packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
autonomous: true

must_haves:
  truths:
    - "When agent is executing a browser tool call, a visual overlay appears on the browser frame showing which tool is running"
    - "User mouse clicks and scroll are suppressed during agent tool execution to prevent destructive races"
    - "User keyboard input continues uninterrupted during agent tool execution"
    - "Interactive mode ring changes color from green to amber when agent is busy"
    - "When agent tool call completes, overlay disappears and full user interaction resumes"
    - "Click ripple effects are suppressed during agent activity (no phantom feedback)"
  artifacts:
    - path: "packages/playground-ui/src/domains/agents/hooks/use-input-coordination.ts"
      provides: "Derives isAgentBusy and activeToolName from BrowserToolCallsContext"
      exports: ["useInputCoordination", "InputCoordinationState"]
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/agent-busy-overlay.tsx"
      provides: "Semi-transparent overlay with Loader2 spinner and tool name"
      exports: ["AgentBusyOverlay"]
    - path: "packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx"
      provides: "Wired coordination: overlay render, mouse/ripple suppression, ring color change"
  key_links:
    - from: "use-input-coordination.ts"
      to: "browser-tool-calls-context.tsx"
      via: "useBrowserToolCalls() hook consumption"
      pattern: "useBrowserToolCalls"
    - from: "browser-view-frame.tsx"
      to: "use-input-coordination.ts"
      via: "useInputCoordination() hook call"
      pattern: "useInputCoordination"
    - from: "browser-view-frame.tsx"
      to: "use-mouse-interaction.ts"
      via: "enabled prop gated by !isAgentBusy"
      pattern: "enabled:.*!isAgentBusy"
    - from: "browser-view-frame.tsx"
      to: "agent-busy-overlay.tsx"
      via: "conditional render when isAgentBusy"
      pattern: "isAgentBusy && <AgentBusyOverlay"
---

<objective>
Add input coordination between user interaction and agent browser tool calls.

Purpose: Prevent destructive race conditions when the user clicks/scrolls during agent
tool execution (stale refs, double navigation, element invalidation). This is the final
phase of v1.2 Browser Input Injection.

Output: useInputCoordination hook, AgentBusyOverlay component, and BrowserViewFrame
wiring that suppresses clicks/scroll during agent activity while showing a visual busy
indicator.
</objective>

<execution_context>
@/Users/abhiramaiyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abhiramaiyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-input-coordination/15-RESEARCH.md

# Source files to read before implementing
@packages/playground-ui/src/domains/agents/context/browser-tool-calls-context.tsx
@packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
@packages/playground-ui/src/domains/agents/hooks/use-mouse-interaction.ts
@packages/playground-ui/src/domains/agents/hooks/use-click-ripple.ts
@packages/playground-ui/src/domains/agents/components/browser-view/browser-tool-call-item.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useInputCoordination hook and AgentBusyOverlay component</name>
  <files>
    packages/playground-ui/src/domains/agents/hooks/use-input-coordination.ts
    packages/playground-ui/src/domains/agents/components/browser-view/agent-busy-overlay.tsx
  </files>
  <action>
Create two new files:

**use-input-coordination.ts:**
- Import `useMemo` from React and `useBrowserToolCalls` from `../context/browser-tool-calls-context`
- Export `InputCoordinationState` interface with: `isAgentBusy: boolean`, `activeToolName: string | null`, `pendingCount: number`
- Export `useInputCoordination()` hook that:
  - Calls `useBrowserToolCalls()` to get `toolCalls` array
  - Uses `useMemo` to derive: filter `toolCalls` where `tc.status === 'pending'`, compute `isAgentBusy = pendingCalls.length > 0`, extract `activeToolName = isAgentBusy ? pendingCalls[0].toolName : null`
  - Returns `{ isAgentBusy, activeToolName, pendingCount }`
  - Dependency array: `[toolCalls]`
- Add JSDoc explaining this derives state from existing context (no new infrastructure)

**agent-busy-overlay.tsx:**
- Import `Loader2` from `lucide-react` (same import pattern as browser-tool-call-item.tsx)
- Define `TOOL_DISPLAY_NAMES` map: `browser_navigate: 'Navigating'`, `browser_click: 'Clicking'`, `browser_type: 'Typing'`, `browser_scroll: 'Scrolling'`, `browser_screenshot: 'Capturing'`, `browser_snapshot: 'Reading page'`, `browser_close: 'Closing'`, `browser_select: 'Selecting'`
- Export `AgentBusyOverlayProps` interface with `toolName: string | null`
- Export `AgentBusyOverlay` component that renders:
  - Outer div: `absolute inset-0 bg-surface1/40 flex items-center justify-center z-10 cursor-not-allowed`
  - Inner div: `flex items-center gap-2 bg-surface2 px-3 py-1.5 rounded-md border border-border1 shadow-sm`
  - `Loader2` with classes `h-3.5 w-3.5 text-accent1 animate-spin`
  - `span` with classes `text-xs font-medium text-neutral4` showing `Agent: {displayName}`
  - `displayName` derived from `TOOL_DISPLAY_NAMES[toolName]` falling back to `toolName.replace('browser_', '')` or `'Working'` if null
- The outer div's default pointer-events absorb clicks, preventing them from reaching the img element beneath
  </action>
  <verify>
Run `pnpm build` from `packages/playground-ui` -- both new files compile without type errors.
Verify imports resolve: `useBrowserToolCalls` from context, `Loader2` from lucide-react, `useMemo` from react.
  </verify>
  <done>
useInputCoordination hook derives isAgentBusy boolean from BrowserToolCallsContext pending status.
AgentBusyOverlay component renders semi-transparent overlay with Loader2 spinner and tool display name.
Both files compile cleanly with no type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire coordination into BrowserViewFrame</name>
  <files>
    packages/playground-ui/src/domains/agents/components/browser-view/browser-view-frame.tsx
  </files>
  <action>
Modify browser-view-frame.tsx to integrate input coordination:

**New imports (add at top with existing imports):**
- `import { useInputCoordination } from '../../hooks/use-input-coordination';`
- `import { AgentBusyOverlay } from './agent-busy-overlay';`

**Add coordination hook call** (after existing hook calls, before useEffect blocks):
- `const { isAgentBusy, activeToolName } = useInputCoordination();`

**Gate useMouseInteraction** by changing the enabled prop:
- FROM: `enabled: status === 'streaming'`
- TO: `enabled: status === 'streaming' && !isAgentBusy`
- This cleanly removes all mouse event listeners (mousedown, mouseup, wheel, mousemove, contextmenu) when agent is busy, because the hook's useEffect cleanup runs on enabled change.

**Gate useClickRipple** by changing the enabled prop:
- FROM: `enabled: status === 'streaming' && hasFrame`
- TO: `enabled: status === 'streaming' && hasFrame && !isAgentBusy`
- This prevents phantom ripple feedback during agent activity.

**Do NOT modify useKeyboardInteraction** -- it stays gated by `isInteractive` only. Keyboard input continues during agent activity per research recommendation (keyboard is safe, click/scroll are destructive).

**Update container div ring classes:**
- FROM: `isInteractive && 'ring-2 ring-accent1'`
- TO two separate conditions:
  - `isInteractive && !isAgentBusy && 'ring-2 ring-accent1'` (green ring: user active, agent idle)
  - `isInteractive && isAgentBusy && 'ring-2 ring-amber-400'` (amber ring: user interactive but agent busy)

**Add AgentBusyOverlay render** in JSX, between the ClickRippleOverlay and the loading skeleton:
- `{isAgentBusy && <AgentBusyOverlay toolName={activeToolName} />}`
- Place it AFTER the ClickRippleOverlay (ripples clear naturally via animation) and BEFORE the loading/reconnecting/error overlays (those have higher priority with bg-surface1/80-90 opacity).

**Important constraints:**
- Do NOT change the img onClick handler (handleFrameClick) -- the user can still enter interactive mode even during agent activity. The ring color will show amber immediately if agent is busy.
- Do NOT add any new state variables -- isAgentBusy is derived from context, not stored locally.
- Do NOT modify any other hooks or components -- the coordination is entirely within this wiring.
  </action>
  <verify>
Run `pnpm build` from `packages/playground-ui` -- compiles without type errors.
Verify the diff shows exactly these changes:
1. Two new import lines (useInputCoordination, AgentBusyOverlay)
2. One new hook call line (useInputCoordination)
3. useMouseInteraction enabled prop has `&& !isAgentBusy`
4. useClickRipple enabled prop has `&& !isAgentBusy`
5. Container div cn() has two ring conditions instead of one
6. AgentBusyOverlay conditional render in JSX
No other lines changed.
  </verify>
  <done>
BrowserViewFrame consumes useInputCoordination to derive isAgentBusy.
Mouse clicks and scroll are suppressed during agent tool execution (useMouseInteraction disabled).
Click ripple effects are suppressed during agent tool execution (useClickRipple disabled).
Keyboard input continues during agent activity (useKeyboardInteraction unchanged).
Ring changes from green (ring-accent1) to amber (ring-amber-400) when agent is busy and user is in interactive mode.
AgentBusyOverlay renders conditionally when isAgentBusy is true, showing tool name and spinner.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` in `packages/playground-ui` completes without errors
2. No type errors in any of the three files (hook, overlay, frame)
3. `useInputCoordination` imports and consumes `useBrowserToolCalls` correctly
4. `AgentBusyOverlay` imports `Loader2` from `lucide-react` and renders with design tokens
5. `browser-view-frame.tsx` has exactly 2 new imports, 1 new hook call, 2 modified enabled props, updated ring classes, and 1 new conditional render
6. `useKeyboardInteraction` call is NOT modified (keyboard continues during agent activity)
7. No new dependencies added to package.json
</verification>

<success_criteria>
- COORD-01: Input state tracking distinguishes agent-active periods (isAgentBusy derived from pending tool calls) vs user-active periods (isInteractive state) vs idle (neither)
- COORD-02: Visual indicator (AgentBusyOverlay with Loader2 spinner + tool name + amber ring) shows when agent is executing a browser tool call
- COORD-03: User input during agent tool execution is handled gracefully -- mouse clicks/scroll suppressed via enabled=false, keyboard continues uninterrupted, visual overlay absorbs stray clicks
- Race condition mitigation: Click/scroll suppression prevents destructive races between user clicks and agent tool calls. Known limitation: ~16ms render-cycle race window between tool dispatch and React re-render (documented, not eliminated)
</success_criteria>

<output>
After completion, create `.planning/phases/15-input-coordination/15-01-SUMMARY.md`
</output>
