---
phase: 06-playground-integration
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/server/handlers/datasets.ts
  - packages/core/src/datasets/run/index.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - 'Run trigger returns immediately with runId'
    - 'Run executes in background without blocking response'
    - 'UI polling sees pending -> running -> completed transitions'
  artifacts:
    - path: 'packages/server/src/server/handlers/datasets.ts'
      provides: 'Async run trigger endpoint'
  key_links:
    - from: 'TRIGGER_RUN_ROUTE handler'
      to: 'runDataset()'
      via: 'spawn without await, return runId immediately'
---

<objective>
Make run trigger asynchronous - return runId immediately, execute in background.

Purpose: UAT test 14 failed - run trigger blocks until completion
Output: Server returns runId immediately, background execution updates status
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/run-trigger-sync.md
@packages/server/src/server/handlers/datasets.ts
@packages/core/src/datasets/run/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make TRIGGER_RUN_ROUTE async</name>
  <files>
    packages/server/src/server/handlers/datasets.ts
  </files>
  <action>
Modify TRIGGER_RUN_ROUTE handler in datasets.ts:

Current flow (blocking):

```
const summary = await runDataset(mastra, {...});
return summary;
```

New flow (async):

1. Create run record with status='pending' BEFORE spawning execution
   - Need to call runsStore.createRun() directly to get runId
   - Import createRun params type if needed
2. Get runId from created run record
3. Spawn runDataset() without await - fire and forget
   - Use setImmediate() or Promise-based spawn pattern
   - Don't use process.nextTick (too early)
   - Pattern: `void (async () => { await runDataset(...) })().catch(err => console.error(err))`
4. Return { id: runId, status: 'pending', ... } immediately

The runDataset function already:

- Updates run status to 'running' on start
- Updates run status to 'completed' or 'failed' on finish
- UI polling (useDatasetRun) already polls every 2s for pending/running

Important: runDataset() must handle its own errors since we won't await it.
Add try/catch wrapper in the spawn to log errors and update run status to 'failed'.
</action>
<verify>
Build succeeds:

```bash
cd packages/server && pnpm build
```

Manual test:

1. Start dev server
2. Trigger a run from UI
3. Response should return immediately (< 100ms)
4. Run status should show 'pending' then 'running' then 'completed'
   </verify>
   <done>
   Run trigger returns immediately with pending status, execution happens in background
   </done>
   </task>

</tasks>

<verification>
1. Build: `cd packages/server && pnpm build`
2. Run dev server: `pnpm dev:playground`
3. Create dataset with 5+ items
4. Trigger run
5. Verify: Response immediate, status transitions visible in UI
</verification>

<success_criteria>

- UAT test 14 passes: Run trigger is async with status polling
- Response time < 500ms regardless of dataset size
- UI shows pending -> running -> completed transitions
  </success_criteria>

<output>
After completion, create `.planning/phases/06-playground-integration/06-08-SUMMARY.md`
</output>
