---
phase: 06-playground-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - client-sdks/client-js/src/types.ts
  - client-sdks/client-js/src/client.ts
autonomous: true

must_haves:
  truths:
    - "client.listDatasets() returns datasets array"
    - "client.createDataset(params) creates and returns dataset"
    - "client.getDataset(id) returns dataset with items"
    - "client.triggerDatasetRun(params) starts run execution"
    - "client.getDatasetRunResults(runId) returns results"
    - "client.compareRuns(params) returns comparison result"
  artifacts:
    - path: "client-sdks/client-js/src/types.ts"
      provides: "TypeScript types for dataset API requests/responses"
    - path: "client-sdks/client-js/src/client.ts"
      provides: "MastraClient methods for dataset operations"
  key_links:
    - from: "client-sdks/client-js/src/client.ts"
      to: "/api/datasets"
      via: "this.request() HTTP calls"
---

<objective>
Add dataset methods to MastraClient for playground-ui hooks.

Purpose: Provide typed client methods that playground hooks will call.
Output: Complete client API for datasets, runs, results, and comparison.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-playground-integration/06-01-SUMMARY.md

# Reference pattern
@client-sdks/client-js/src/client.ts
@client-sdks/client-js/src/types.ts

# Types to match
@packages/core/src/storage/types.ts
@packages/core/src/datasets/run/analytics/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dataset types to client-js</name>
  <files>client-sdks/client-js/src/types.ts</files>
  <action>
Add TypeScript types for dataset API to types.ts. Follow existing patterns (e.g., CreateMemoryThreadParams).

Types to add:

```typescript
// Dataset types
export interface Dataset {
  id: string;
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
  version: Date;
  createdAt: Date;
  updatedAt: Date;
}

export interface DatasetItem {
  id: string;
  datasetId: string;
  input: unknown;
  expectedOutput?: unknown;
  metadata?: Record<string, unknown>;
  version: Date;
  createdAt: Date;
  updatedAt: Date;
}

// Request params
export interface CreateDatasetParams {
  name: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

export interface UpdateDatasetParams {
  datasetId: string;
  name?: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

export interface AddDatasetItemParams {
  datasetId: string;
  input: unknown;
  expectedOutput?: unknown;
  metadata?: Record<string, unknown>;
}

export interface UpdateDatasetItemParams {
  datasetId: string;
  itemId: string;
  input?: unknown;
  expectedOutput?: unknown;
  metadata?: Record<string, unknown>;
}

export interface TriggerDatasetRunParams {
  datasetId: string;
  targetType: 'agent' | 'workflow' | 'scorer';
  targetId: string;
  scorerIds?: string[];
}

export interface CompareRunsParams {
  runIdA: string;
  runIdB: string;
  thresholds?: Record<string, { value: number; direction?: 'higher-is-better' | 'lower-is-better' }>;
}

// Response types
export interface ListDatasetsResponse {
  datasets: Dataset[];
  pagination: { page: number; perPage: number; total: number };
}

export interface ListDatasetItemsResponse {
  items: DatasetItem[];
  pagination: { page: number; perPage: number; total: number };
}

export interface DatasetRun {
  id: string;
  datasetId: string;
  datasetVersion: Date;
  targetType: string;
  targetId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

export interface ListDatasetRunsResponse {
  runs: DatasetRun[];
  pagination: { page: number; perPage: number; total: number };
}

export interface DatasetRunResult {
  id: string;
  runId: string;
  itemId: string;
  output: unknown;
  error?: string;
  latencyMs: number;
  createdAt: Date;
}

export interface ListDatasetRunResultsResponse {
  results: DatasetRunResult[];
  pagination: { page: number; perPage: number; total: number };
}

export interface CompareRunsResponse {
  runA: { id: string; datasetVersion: Date };
  runB: { id: string; datasetVersion: Date };
  versionMismatch: boolean;
  hasRegression: boolean;
  scorers: Record<string, {
    statsA: { avgScore: number; count: number; passRate: number };
    statsB: { avgScore: number; count: number; passRate: number };
    delta: number;
    regressed: boolean;
    threshold: number;
  }>;
  items: Array<{
    itemId: string;
    inBothRuns: boolean;
    scoresA: Record<string, number | null>;
    scoresB: Record<string, number | null>;
  }>;
  warnings: string[];
}
```

Place these after existing types, maintaining alphabetical or grouped organization.
  </action>
  <verify>TypeScript compiles: `cd client-sdks/client-js && pnpm tsc --noEmit`</verify>
  <done>All dataset types exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add dataset methods to MastraClient</name>
  <files>client-sdks/client-js/src/client.ts</files>
  <action>
Add methods to MastraClient class following existing patterns (listAgents, getAgent, etc.).

Methods to add:

```typescript
// Dataset CRUD
public listDatasets(pagination?: { page?: number; perPage?: number }): Promise<ListDatasetsResponse> {
  const params = new URLSearchParams();
  if (pagination?.page !== undefined) params.set('page', String(pagination.page));
  if (pagination?.perPage !== undefined) params.set('perPage', String(pagination.perPage));
  const query = params.toString();
  return this.request(`/api/datasets${query ? `?${query}` : ''}`);
}

public createDataset(params: CreateDatasetParams): Promise<Dataset> {
  return this.request('/api/datasets', { method: 'POST', body: JSON.stringify(params) });
}

public getDataset(datasetId: string): Promise<Dataset> {
  return this.request(`/api/datasets/${datasetId}`);
}

public updateDataset(params: UpdateDatasetParams): Promise<Dataset> {
  const { datasetId, ...body } = params;
  return this.request(`/api/datasets/${datasetId}`, { method: 'PATCH', body: JSON.stringify(body) });
}

public deleteDataset(datasetId: string): Promise<void> {
  return this.request(`/api/datasets/${datasetId}`, { method: 'DELETE' });
}

// Item CRUD
public listDatasetItems(datasetId: string, pagination?: { page?: number; perPage?: number }): Promise<ListDatasetItemsResponse> {
  const params = new URLSearchParams();
  if (pagination?.page !== undefined) params.set('page', String(pagination.page));
  if (pagination?.perPage !== undefined) params.set('perPage', String(pagination.perPage));
  const query = params.toString();
  return this.request(`/api/datasets/${datasetId}/items${query ? `?${query}` : ''}`);
}

public addDatasetItem(params: AddDatasetItemParams): Promise<DatasetItem> {
  const { datasetId, ...body } = params;
  return this.request(`/api/datasets/${datasetId}/items`, { method: 'POST', body: JSON.stringify(body) });
}

public updateDatasetItem(params: UpdateDatasetItemParams): Promise<DatasetItem> {
  const { datasetId, itemId, ...body } = params;
  return this.request(`/api/datasets/${datasetId}/items/${itemId}`, { method: 'PATCH', body: JSON.stringify(body) });
}

public deleteDatasetItem(datasetId: string, itemId: string): Promise<void> {
  return this.request(`/api/datasets/${datasetId}/items/${itemId}`, { method: 'DELETE' });
}

// Run operations
public listDatasetRuns(datasetId: string, pagination?: { page?: number; perPage?: number }): Promise<ListDatasetRunsResponse> {
  const params = new URLSearchParams();
  if (pagination?.page !== undefined) params.set('page', String(pagination.page));
  if (pagination?.perPage !== undefined) params.set('perPage', String(pagination.perPage));
  const query = params.toString();
  return this.request(`/api/datasets/${datasetId}/runs${query ? `?${query}` : ''}`);
}

public triggerDatasetRun(params: TriggerDatasetRunParams): Promise<DatasetRun> {
  const { datasetId, ...body } = params;
  return this.request(`/api/datasets/${datasetId}/runs`, { method: 'POST', body: JSON.stringify(body) });
}

public getDatasetRun(runId: string): Promise<DatasetRun> {
  return this.request(`/api/runs/${runId}`);
}

public listDatasetRunResults(runId: string, pagination?: { page?: number; perPage?: number }): Promise<ListDatasetRunResultsResponse> {
  const params = new URLSearchParams();
  if (pagination?.page !== undefined) params.set('page', String(pagination.page));
  if (pagination?.perPage !== undefined) params.set('perPage', String(pagination.perPage));
  const query = params.toString();
  return this.request(`/api/runs/${runId}/results${query ? `?${query}` : ''}`);
}

// Analytics
public compareRuns(params: CompareRunsParams): Promise<CompareRunsResponse> {
  return this.request('/api/runs/compare', { method: 'POST', body: JSON.stringify(params) });
}
```

Import the new types at top of file.
Group dataset methods together in the class (after existing methods like listAgents).
  </action>
  <verify>
1. TypeScript compiles: `cd client-sdks/client-js && pnpm tsc --noEmit`
2. Methods exist: grep for "listDatasets" in client.ts
  </verify>
  <done>All dataset methods added to MastraClient</done>
</task>

</tasks>

<verification>
1. All TypeScript compiles in client-js package
2. Types are properly exported from types.ts
3. Methods follow existing MastraClient patterns
4. Request paths match server routes from 06-01
</verification>

<success_criteria>
- client.listDatasets() method exists and is typed
- client.triggerDatasetRun() method exists and is typed
- client.compareRuns() method exists and is typed
- All method signatures match server API contracts
</success_criteria>

<output>
After completion, create `.planning/phases/06-playground-integration/06-02-SUMMARY.md`
</output>
