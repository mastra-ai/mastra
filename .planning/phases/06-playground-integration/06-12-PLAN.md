---
phase: 06-playground-integration
plan: 12
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/storage/types.ts
  - packages/core/src/datasets/run/orchestrator.ts
  - packages/core/src/datasets/run/scorer.ts
  - packages/server/src/server/schemas/datasets.ts
  - packages/playground-ui/src/domains/datasets/components/results/result-detail-dialog.tsx
  - packages/playground/src/pages/datasets/dataset/run/index.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - 'RunResult type includes scores array'
    - 'Scores stored with result during run execution'
    - 'API response includes scores per result'
    - 'Results table displays scores from result.scores'
    - 'View Trace link navigates to working trace view'
  artifacts:
    - path: 'packages/core/src/storage/types.ts'
      provides: 'scores field in RunResult'
      contains: 'scores.*ScorerResult'
    - path: 'packages/server/src/server/schemas/datasets.ts'
      provides: 'scores in runResultResponseSchema'
      contains: 'scores.*z.array'
    - path: 'packages/playground-ui/src/domains/datasets/components/results/result-detail-dialog.tsx'
      provides: 'Working trace link'
      contains: '/observability.*traceId'
---

<objective>
Fix two UAT gaps: scores not linked to results, and trace link navigation.

Purpose: Complete the results view with inline scores and working trace access.
Output: Scores display per result row, trace link opens observability view.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-playground-integration/06-UAT-retest-2.md
@packages/core/src/storage/types.ts
@packages/core/src/datasets/run/orchestrator.ts
@packages/core/src/datasets/run/scorer.ts
@packages/server/src/server/schemas/datasets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scores to RunResult type</name>
  <files>packages/core/src/storage/types.ts</files>
  <action>
Add scores field to RunResult interface.

Import ScorerResult type and add to RunResult:

```typescript
/** Per-item result record */
export interface RunResult {
  // ... existing fields ...
  /** Scores from scorers applied during run */
  scores: ScorerResult[];
  createdAt: Date;
}
```

Also add ScorerResult to the file if not already there:

```typescript
/** Score result from a single scorer */
export interface ScorerResult {
  scorerId: string;
  scorerName: string;
  score: number | null;
  reason: string | null;
  error: string | null;
}
```

Update AddRunResultInput to include optional scores field.
</action>
<verify>Check types compile with `pnpm build --filter=@mastra/core`</verify>
<done>RunResult has scores: ScorerResult[] field</done>
</task>

<task type="auto">
  <name>Task 2: Store scores with result during execution</name>
  <files>
    packages/core/src/datasets/run/orchestrator.ts
    packages/core/src/datasets/run/scorer.ts
  </files>
  <action>
Modify run orchestration to include scores in result.

In orchestrator.ts, when saving result after item execution:

1. Run scorers and get ScorerResult[]
2. Include scores array in the result being saved

The scorer.ts `runScorersForItem` already returns ScorerResult[].
Update the orchestrator to pass these to addResult.

Find where addResult is called and add the scores:

```typescript
await runsStorage.addResult({
  // ... existing fields ...
  scores: scorerResults,
});
```

Remove the separate score persistence in scorer.ts (validateAndSaveScore calls) since scores are now embedded in results.
</action>
<verify>Run dataset against agent with scorers, check result has scores in DB</verify>
<done>Scores saved as part of RunResult, not separately</done>
</task>

<task type="auto">
  <name>Task 3: Update storage implementations for scores</name>
  <files>
    packages/core/src/storage/domains/runs/inmemory.ts
    stores/libsql/src/storage/domains/runs/index.ts
  </files>
  <action>
Update both storage backends to handle scores field.

**InMemory:** Already stores full object, just needs to include scores.

**LibSQL:**

1. Add `scores` column to DATASET_RUN_RESULTS_SCHEMA (TEXT, JSON serialized)
2. Update addResult to serialize scores to JSON
3. Update transformResultRow to parse scores from JSON

Schema addition:

```typescript
scores: {
  type: 'TEXT',
  nullable: true,
}
```

Transform:

```typescript
scores: row.scores ? JSON.parse(row.scores as string) : [],
```

  </action>
  <verify>Build passes for both packages</verify>
  <done>Both storage backends persist and retrieve scores</done>
</task>

<task type="auto">
  <name>Task 4: Add scores to server response schema</name>
  <files>packages/server/src/server/schemas/datasets.ts</files>
  <action>
Add scores array to runResultResponseSchema.

After traceId field, add:

```typescript
scores: z.array(z.object({
  scorerId: z.string(),
  scorerName: z.string(),
  score: z.number().nullable(),
  reason: z.string().nullable(),
  error: z.string().nullable(),
})),
```

  </action>
  <verify>`pnpm build --filter=@mastra/server` passes</verify>
  <done>API response schema includes scores array</done>
</task>

<task type="auto">
  <name>Task 5: Update UI to use result.scores</name>
  <files>
    packages/playground-ui/src/domains/datasets/hooks/use-dataset-runs.ts
    packages/playground-ui/src/domains/datasets/components/results/results-table.tsx
    packages/playground/src/pages/datasets/dataset/run/index.tsx
  </files>
  <action>
Simplify UI to use scores from results directly.

1. Remove useScoresByRunId hook usage from run/index.tsx
2. Update ResultsTable to read scores from result.scores instead of separate scores prop
3. Keep ResultsTable props backward compatible if needed

In run/index.tsx:

- Remove: `const { data: scores = {} } = useScoresByRunId(runId!);`
- ResultsTable gets scores from results directly

In ResultsTable:

- Check if component already handles result.scores or needs update
  </action>
  <verify>Build passes, scores display in UI</verify>
  <done>UI displays scores from result.scores</done>
  </task>

<task type="auto">
  <name>Task 6: Fix trace link navigation</name>
  <files>packages/playground-ui/src/domains/datasets/components/results/result-detail-dialog.tsx</files>
  <action>
Update trace link to use correct observability route.

Change from:

```typescript
<Link href={`/traces/${result.traceId}`} ...>
```

To:

```typescript
<Link href={`/observability?traceId=${result.traceId}`} ...>
```

This navigates to the observability page with the trace pre-selected, opening the TraceDialog.
</action>
<verify>Click View Trace, verify it opens observability with trace dialog</verify>
<done>View Trace link navigates to /observability?traceId=xxx</done>
</task>

</tasks>

<verification>
- `pnpm build` passes for core, libsql, server, playground-ui, playground
- RunResult type includes scores field
- Scores stored in database with results
- API returns scores in result objects
- ResultsTable shows scores per row
- View Trace opens observability page with trace dialog
</verification>

<success_criteria>

- scores: ScorerResult[] in RunResult type
- Orchestrator saves scores with result
- Both storage backends handle scores
- Server schema includes scores
- UI displays scores from result.scores (not separate query)
- Trace link goes to /observability?traceId=xxx
  </success_criteria>

<output>
After completion, create `.planning/phases/06-playground-integration/06-12-SUMMARY.md`
</output>
