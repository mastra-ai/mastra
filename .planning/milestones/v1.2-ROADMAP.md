# Milestone v1.2: Browser Input Injection

**Status:** SHIPPED 2026-01-30
**Phases:** 10-15
**Total Plans:** 9

## Overview

Users can click, type, and scroll in the live view panel to unblock agents stuck on CAPTCHAs, popups, or login prompts (assist mode). Full input injection pipeline from client UI through WebSocket transport to CDP browser injection, with coordinate mapping, focus management, visual feedback, and agent-busy coordination.

## Phases

### Phase 10: Infrastructure Foundations
**Goal**: Interface extensions and viewport metadata delivery enable input routing
**Depends on**: None (extends existing Phase 7-9 infrastructure)
**Plans**: 1 plan

Plans:
- [x] 10-01: Interface extensions, input message types, and viewport metadata broadcasting

**Requirements**: INFRA-01, INFRA-02, INFRA-03

**Success Criteria**:
1. `BrowserToolsetLike` interface includes `injectMouseEvent()` and `injectKeyboardEvent()` signatures matching concrete `BrowserToolset` implementation
2. Server broadcasts viewport metadata (width, height) to clients on stream start and when dimensions change
3. `ClientInputMessage` union type defined with MouseInputMessage and KeyboardInputMessage discriminated by type field
4. Existing raw base64 frame protocol unchanged (metadata sent separately, not embedded in frame)

---

### Phase 11: Server Input Routing
**Goal**: WebSocket message handler routes user input to CDP injection methods
**Depends on**: Phase 10 (needs BrowserToolsetLike extension and ClientInputMessage types)
**Plans**: 1 plan

Plans:
- [x] 11-01: Input handler module with validation, routing, and onMessage wiring

**Requirements**: ROUTE-01, ROUTE-02, ROUTE-03

**Success Criteria**:
1. Server `onMessage` handler parses JSON input messages and switches on type field to route to toolset inject methods
2. Malformed input messages are silently ignored with no acknowledgment (fire-and-forget pattern)
3. Mouse input messages call `BrowserToolset.injectMouseEvent()` with complete 3-event sequence
4. Keyboard input messages call `BrowserToolset.injectKeyboardEvent()` with appropriate sequences
5. Server validates message structure before routing

---

### Phase 12: Client Coordinate Mapping and Click
**Goal**: User can click and scroll in the live view frame with accurate coordinate mapping
**Depends on**: Phase 10 (needs viewport metadata), Phase 11 (needs server routing)
**Plans**: 3 plans

Plans:
- [x] 12-01: TDD: Pure coordinate mapping, wheel normalization, and modifier key functions
- [x] 12-02: Extend useBrowserStream with viewport parsing and sendMessage
- [x] 12-03: useMouseInteraction hook and BrowserViewFrame wiring

**Requirements**: CLICK-01, CLICK-02, CLICK-03, CLICK-04, CLICK-05, CLICK-06, SCROLL-01, SCROLL-02, VIS-03

**Success Criteria**:
1. User clicks on live view frame dispatched to correct browser element accounting for object-contain letterboxing
2. Coordinate mapping function is pure with no growing error
3. Clicks in letterbox regions ignored
4. Right-clicks forwarded to browser
5. Modifier keys forwarded as CDP bitmask
6. Mouse wheel events dispatched as CDP mouseWheel with normalized deltas
7. mouseMoved events throttled to max 30/sec

---

### Phase 13: Focus Management and Keyboard
**Goal**: User can type in the live view without keyboard events leaking to host page
**Depends on**: Phase 11 (needs server routing)
**Plans**: 2 plans

Plans:
- [x] 13-01: Key-mapping utility and useKeyboardInteraction hook
- [x] 13-02: Interactive mode state and BrowserViewFrame wiring

**Requirements**: KEY-01, KEY-02, KEY-03, KEY-04, FOCUS-01, FOCUS-02, FOCUS-03

**Success Criteria**:
1. Live view requires explicit click to enter interactive mode
2. Printable characters use 3-event CDP sequence (keyDown -> char -> keyUp)
3. Non-printable keys use 2-event sequence (keyDown -> keyUp)
4. Modifier key state tracked and included in CDP bitmask
5. Escape/click-outside exits interactive mode
6. Keyboard events do NOT leak to host page when focused

---

### Phase 14: Visual Feedback and Polish
**Goal**: User receives immediate visual confirmation for input actions despite frame latency
**Depends on**: Phase 12 (needs click working)
**Plans**: 1 plan

Plans:
- [x] 14-01: Click ripple overlay with letterbox-aware positioning (VIS-01 already complete from Phase 13)

**Requirements**: VIS-01, VIS-02

**Success Criteria**:
1. Interactive mode indicator visible when panel is accepting input
2. Click ripple effect appears immediately at click position
3. Ripple positions correctly accounting for letterbox offset

---

### Phase 15: Input Coordination
**Goal**: User input and agent tool calls coexist without destructive race conditions
**Depends on**: Phases 10-14 (all prior phases must complete)
**Plans**: 1 plan

Plans:
- [x] 15-01: useInputCoordination hook, AgentBusyOverlay component, and BrowserViewFrame wiring

**Requirements**: COORD-01, COORD-02, COORD-03

**Success Criteria**:
1. Input state tracking distinguishes IDLE, AGENT_ACTIVE, and USER_ACTIVE periods
2. Visual indicator shows when agent is executing a tool call
3. User input during agent execution handled gracefully
4. No destructive races between user clicks and agent tool calls

---

## Milestone Summary

**Key Decisions:**
- ClientInputMessage discriminated union with type field for mouse/keyboard dispatch
- Viewport metadata as separate JSON message (raw base64 frame protocol unchanged)
- Fire-and-forget input injection (no ack latency)
- object-fit:contain letterbox coordinate mapping (pure function)
- rAF throttle at 30fps for mouse move
- key.length === 1 for printable key detection
- Escape consumed by hook (exits interactive mode, never forwarded to browser)
- IME guard with isComposing + keyCode 229 for cross-browser compatibility
- Interactive mode gated by explicit frame click
- Container-relative ripple coordinates (display-space CSS pixels)
- Agent-busy derived from BrowserToolCallsContext (no new infrastructure)
- Mouse suppressed, keyboard continues during agent activity

**Issues Resolved:**
- Coordinate mapping accuracy across all viewport aspect ratios
- Keyboard event leaking to host page (capture-phase listeners with stopPropagation)
- IME composition handling for international input
- Agent-user input race conditions (mouse/scroll suppression)

**Issues Deferred:**
- Full takeover mode (exclusive user control) — v1.3
- Dismiss button for stuck agent overlay — future
- Agent auto-detection of page changes after user input — deferred

**Technical Debt:**
- ~16ms render-cycle race window between tool dispatch and React re-render (documented, not eliminated)
- Stuck busy overlay relies on 10s tool timeout as safety net (no dismiss button)

---

_For current project status, see .planning/ROADMAP.md_
_Archived: 2026-01-30_
