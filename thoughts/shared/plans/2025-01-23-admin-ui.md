# LANE 9: @mastra/admin-ui Implementation Plan

## Overview

**Package**: `@mastra/admin-ui`
**Location**: `packages/admin-ui/`
**Priority**: P1
**Dependencies**: LANES 1-5 (Backend complete), LANE 4 (Local Source for project listing)

This plan details the implementation of the Admin Dashboard UI, which provides a web interface for managing teams, projects, deployments, and observability data within the MastraAdmin platform.

---

## Tech Stack

Based on analysis of existing `playground-ui` patterns, the admin-ui will use:

| Category             | Technology                                     | Rationale                                       |
| -------------------- | ---------------------------------------------- | ----------------------------------------------- |
| **Build Tool**       | Vite 7.x                                       | Fast HMR, matches playground-ui                 |
| **UI Library**       | React 19                                       | Latest stable, matches playground-ui            |
| **Routing**          | React Router 7.x                               | Client-side routing, matches playground pattern |
| **State Management** | TanStack Query v5 + Zustand                    | Server state caching + lightweight client state |
| **Styling**          | Tailwind CSS 3.4 + playground-ui tokens        | Reuse existing design system tokens             |
| **Components**       | Radix UI primitives + playground-ui components | Accessible, reuse DS components                 |
| **Forms**            | React Hook Form + Zod                          | Type-safe validation                            |
| **Tables**           | TanStack React Table                           | Complex data grids                              |
| **Icons**            | Lucide React                                   | Consistent with playground-ui                   |
| **Notifications**    | Sonner                                         | Toast notifications                             |
| **Auth Client**      | @supabase/supabase-js                          | Direct Supabase client                          |
| **API Client**       | fetch + TanStack Query                         | REST API consumption                            |
| **Real-time**        | Native WebSocket                               | Build logs, server health                       |

---

## Directory Structure

```
packages/admin-ui/
├── src/
│   ├── main.tsx                        # Application entry point
│   ├── App.tsx                         # Root component with providers
│   ├── index.css                       # Global styles + Tailwind
│   │
│   ├── routes/                         # React Router pages
│   │   ├── index.tsx                   # Route definitions
│   │   │
│   │   ├── auth/                       # Public auth routes
│   │   │   ├── login.tsx
│   │   │   ├── signup.tsx
│   │   │   ├── forgot-password.tsx
│   │   │   └── invite-accept.tsx       # /invite/:inviteId
│   │   │
│   │   ├── dashboard/                  # Protected dashboard routes
│   │   │   ├── layout.tsx              # Dashboard shell with sidebar
│   │   │   ├── home.tsx                # Dashboard home (team/project overview)
│   │   │   │
│   │   │   ├── teams/
│   │   │   │   ├── index.tsx           # Team list
│   │   │   │   ├── new.tsx             # Create team
│   │   │   │   ├── [teamId]/
│   │   │   │   │   ├── index.tsx       # Team overview
│   │   │   │   │   ├── settings.tsx    # Team settings
│   │   │   │   │   ├── members.tsx     # Team members
│   │   │   │   │   └── projects/
│   │   │   │   │       ├── index.tsx   # Team projects list
│   │   │   │   │       └── new.tsx     # Create project (with source picker)
│   │   │   │
│   │   │   ├── projects/
│   │   │   │   └── [projectId]/
│   │   │   │       ├── index.tsx       # Project overview
│   │   │   │       ├── settings.tsx    # Project settings
│   │   │   │       ├── env-vars.tsx    # Environment variables
│   │   │   │       ├── deployments/
│   │   │   │       │   ├── index.tsx   # Deployments list
│   │   │   │       │   ├── new.tsx     # Create deployment
│   │   │   │       │   └── [deploymentId]/
│   │   │   │       │       ├── index.tsx      # Deployment detail
│   │   │   │       │       └── builds/
│   │   │   │       │           └── [buildId].tsx  # Build logs
│   │   │   │       └── observability/
│   │   │   │           ├── index.tsx   # Observability dashboard
│   │   │   │           ├── traces.tsx  # Traces list
│   │   │   │           ├── logs.tsx    # Logs viewer
│   │   │   │           └── metrics.tsx # Metrics dashboard
│   │   │   │
│   │   │   └── settings.tsx            # User settings
│   │   │
│   │   └── not-found.tsx               # 404 page
│   │
│   ├── components/                     # Shared components
│   │   ├── auth/
│   │   │   ├── login-form.tsx
│   │   │   ├── signup-form.tsx
│   │   │   └── auth-guard.tsx
│   │   │
│   │   ├── dashboard/
│   │   │   ├── sidebar.tsx
│   │   │   ├── header.tsx
│   │   │   ├── team-switcher.tsx
│   │   │   └── breadcrumbs.tsx
│   │   │
│   │   ├── teams/
│   │   │   ├── team-card.tsx
│   │   │   ├── team-table.tsx
│   │   │   ├── team-form.tsx
│   │   │   ├── member-table.tsx
│   │   │   ├── member-invite-dialog.tsx
│   │   │   └── role-badge.tsx
│   │   │
│   │   ├── projects/
│   │   │   ├── project-card.tsx
│   │   │   ├── project-table.tsx
│   │   │   ├── project-form.tsx
│   │   │   ├── source-picker.tsx       # ProjectSourcePicker
│   │   │   ├── source-type-icon.tsx    # SourceTypeIcon
│   │   │   └── validation-status.tsx
│   │   │
│   │   ├── deployments/
│   │   │   ├── deployment-card.tsx     # DeploymentCard
│   │   │   ├── deployment-table.tsx
│   │   │   ├── deployment-form.tsx
│   │   │   ├── deployment-status-badge.tsx
│   │   │   ├── deployment-actions.tsx
│   │   │   └── deployment-url.tsx
│   │   │
│   │   ├── builds/
│   │   │   ├── build-table.tsx
│   │   │   ├── build-status-badge.tsx
│   │   │   ├── build-log-viewer.tsx    # BuildLogViewer (real-time)
│   │   │   └── build-progress.tsx
│   │   │
│   │   ├── env-vars/
│   │   │   ├── env-var-table.tsx
│   │   │   ├── env-var-form.tsx
│   │   │   └── secret-toggle.tsx
│   │   │
│   │   ├── observability/
│   │   │   ├── trace-table.tsx
│   │   │   ├── trace-detail.tsx
│   │   │   ├── span-tree.tsx
│   │   │   ├── log-viewer.tsx
│   │   │   ├── metrics-chart.tsx
│   │   │   └── time-range-picker.tsx
│   │   │
│   │   ├── servers/
│   │   │   ├── server-status-card.tsx
│   │   │   ├── server-health-badge.tsx
│   │   │   ├── server-logs-viewer.tsx   # Real-time logs
│   │   │   └── resource-usage.tsx
│   │   │
│   │   └── ui/                         # Generic UI components (or import from playground-ui)
│   │       ├── button.tsx
│   │       ├── input.tsx
│   │       ├── select.tsx
│   │       ├── dialog.tsx
│   │       ├── table.tsx
│   │       ├── badge.tsx
│   │       ├── card.tsx
│   │       ├── skeleton.tsx
│   │       ├── empty-state.tsx
│   │       └── confirm-dialog.tsx
│   │
│   ├── hooks/                          # Custom hooks
│   │   ├── use-admin-client.ts         # Admin API client instance
│   │   ├── use-auth.ts                 # Supabase auth state
│   │   ├── use-current-team.ts         # Current team context
│   │   ├── use-websocket.ts            # WebSocket connection
│   │   │
│   │   ├── teams/
│   │   │   ├── use-teams.ts            # List teams
│   │   │   ├── use-team.ts             # Single team
│   │   │   ├── use-create-team.ts
│   │   │   ├── use-update-team.ts
│   │   │   ├── use-delete-team.ts
│   │   │   ├── use-team-members.ts
│   │   │   ├── use-invite-member.ts
│   │   │   └── use-remove-member.ts
│   │   │
│   │   ├── projects/
│   │   │   ├── use-projects.ts         # List projects
│   │   │   ├── use-project.ts          # Single project
│   │   │   ├── use-create-project.ts
│   │   │   ├── use-update-project.ts
│   │   │   ├── use-delete-project.ts
│   │   │   ├── use-project-sources.ts  # List available sources
│   │   │   └── use-env-vars.ts
│   │   │
│   │   ├── deployments/
│   │   │   ├── use-deployments.ts
│   │   │   ├── use-deployment.ts
│   │   │   ├── use-create-deployment.ts
│   │   │   ├── use-trigger-deploy.ts
│   │   │   ├── use-stop-deployment.ts
│   │   │   ├── use-restart-deployment.ts
│   │   │   └── use-rollback-deployment.ts
│   │   │
│   │   ├── builds/
│   │   │   ├── use-builds.ts
│   │   │   ├── use-build.ts
│   │   │   ├── use-build-logs.ts       # WebSocket logs
│   │   │   └── use-cancel-build.ts
│   │   │
│   │   ├── servers/
│   │   │   ├── use-server.ts
│   │   │   ├── use-server-health.ts    # WebSocket health
│   │   │   └── use-server-logs.ts      # WebSocket logs
│   │   │
│   │   └── observability/
│   │       ├── use-traces.ts
│   │       ├── use-trace.ts
│   │       ├── use-logs.ts
│   │       └── use-metrics.ts
│   │
│   ├── lib/                            # Utilities
│   │   ├── admin-client.ts             # Admin API client
│   │   ├── websocket-client.ts         # WebSocket manager
│   │   ├── supabase.ts                 # Supabase client
│   │   ├── utils.ts                    # General utilities (cn, etc.)
│   │   ├── format.ts                   # Date/number formatters
│   │   └── constants.ts
│   │
│   ├── stores/                         # Zustand stores
│   │   ├── auth-store.ts               # Auth state with persistence
│   │   ├── team-store.ts               # Current team selection
│   │   ├── ui-store.ts                 # UI preferences (sidebar, theme)
│   │   └── websocket-store.ts          # WebSocket connection state
│   │
│   ├── providers/                      # React context providers
│   │   ├── auth-provider.tsx
│   │   ├── query-provider.tsx
│   │   └── admin-client-provider.tsx
│   │
│   └── types/                          # TypeScript types
│       ├── api.ts                      # API response types
│       └── index.ts
│
├── public/
│   ├── favicon.ico
│   └── logo.svg
│
├── index.html                          # Vite HTML entry
├── vite.config.ts
├── tailwind.config.ts
├── postcss.config.js
├── tsconfig.json
├── tsconfig.node.json
├── package.json
└── README.md
```

---

## Implementation Phases

### Phase 1: Package Setup & Foundation

**Goal**: Establish project structure, tooling, and basic infrastructure.

#### 1.1 Package Configuration

**File: `package.json`**

```json
{
  "name": "@mastra/admin-ui",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --port 3001",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint .",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router": "^7.6.0",
    "@tanstack/react-query": "^5.90.0",
    "@tanstack/react-table": "^8.21.0",
    "zustand": "^5.0.0",
    "zod": "^4.1.0",
    "react-hook-form": "^7.59.0",
    "@hookform/resolvers": "^5.0.0",
    "@supabase/supabase-js": "^2.45.0",
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-select": "^2.1.0",
    "@radix-ui/react-dropdown-menu": "^2.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "lucide-react": "^0.522.0",
    "sonner": "^2.0.0",
    "date-fns": "^4.1.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.5.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@vitejs/plugin-react": "^4.4.0",
    "vite": "^7.3.0",
    "typescript": "^5.7.0",
    "tailwindcss": "^3.4.0",
    "postcss": "^8.5.0",
    "autoprefixer": "^10.4.0",
    "@playwright/test": "^1.48.0"
  }
}
```

**File: `vite.config.ts`**

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3001,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
      '/ws': {
        target: 'ws://localhost:3000',
        ws: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
});
```

**File: `tailwind.config.ts`**

```typescript
import type { Config } from 'tailwindcss';

const config: Config = {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        // Reuse playground-ui token values
        surface1: 'var(--surface1)',
        surface2: 'var(--surface2)',
        surface3: 'var(--surface3)',
        surface4: 'var(--surface4)',
        surface5: 'var(--surface5)',
        neutral1: 'var(--neutral1)',
        neutral2: 'var(--neutral2)',
        neutral3: 'var(--neutral3)',
        neutral6: 'var(--neutral6)',
        neutral9: 'var(--neutral9)',
        accent1: 'var(--accent1)',
        accent2: 'var(--accent2)',
        border: 'var(--border)',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        mono: ['Geist Mono', 'monospace'],
      },
    },
  },
  plugins: [],
};

export default config;
```

**File: `index.html`**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/logo.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MastraAdmin</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

#### 1.2 Environment Configuration

**File: `.env.example`**

```bash
# Supabase Auth
VITE_SUPABASE_URL=http://localhost:54321
VITE_SUPABASE_ANON_KEY=your-anon-key

# Admin Server API
VITE_ADMIN_API_URL=http://localhost:3000/api
VITE_ADMIN_WS_URL=ws://localhost:3000/ws
```

#### 1.3 Application Entry Point

**File: `src/main.tsx`**

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from 'sonner';
import { App } from './App';
import { AuthProvider } from './providers/auth-provider';
import { AdminClientProvider } from './providers/admin-client-provider';
import './index.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60, // 1 minute
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <QueryClientProvider client={queryClient}>
        <AuthProvider>
          <AdminClientProvider>
            <App />
            <Toaster />
          </AdminClientProvider>
        </AuthProvider>
      </QueryClientProvider>
    </BrowserRouter>
  </React.StrictMode>
);
```

**File: `src/App.tsx`**

```typescript
import { Routes, Route, Navigate } from 'react-router';
import { useAuth } from './hooks/use-auth';

// Auth routes
import { LoginPage } from './routes/auth/login';
import { SignupPage } from './routes/auth/signup';
import { ForgotPasswordPage } from './routes/auth/forgot-password';
import { InviteAcceptPage } from './routes/auth/invite-accept';

// Dashboard routes
import { DashboardLayout } from './routes/dashboard/layout';
import { DashboardHome } from './routes/dashboard/home';
import { TeamsPage } from './routes/dashboard/teams';
import { NewTeamPage } from './routes/dashboard/teams/new';
import { TeamOverview } from './routes/dashboard/teams/[teamId]';
import { TeamSettings } from './routes/dashboard/teams/[teamId]/settings';
import { TeamMembers } from './routes/dashboard/teams/[teamId]/members';
import { TeamProjects } from './routes/dashboard/teams/[teamId]/projects';
import { NewProjectPage } from './routes/dashboard/teams/[teamId]/projects/new';
import { ProjectOverview } from './routes/dashboard/projects/[projectId]';
import { ProjectSettings } from './routes/dashboard/projects/[projectId]/settings';
import { ProjectEnvVars } from './routes/dashboard/projects/[projectId]/env-vars';
import { DeploymentsPage } from './routes/dashboard/projects/[projectId]/deployments';
import { NewDeploymentPage } from './routes/dashboard/projects/[projectId]/deployments/new';
import { DeploymentDetail } from './routes/dashboard/projects/[projectId]/deployments/[deploymentId]';
import { BuildLogs } from './routes/dashboard/projects/[projectId]/deployments/[deploymentId]/builds/[buildId]';
import { ObservabilityDashboard } from './routes/dashboard/projects/[projectId]/observability';
import { TracesPage } from './routes/dashboard/projects/[projectId]/observability/traces';
import { LogsPage } from './routes/dashboard/projects/[projectId]/observability/logs';
import { MetricsPage } from './routes/dashboard/projects/[projectId]/observability/metrics';
import { UserSettings } from './routes/dashboard/settings';
import { NotFoundPage } from './routes/not-found';

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-surface1">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-accent1" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

function PublicRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-surface1">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-accent1" />
      </div>
    );
  }

  if (isAuthenticated) {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
}

export function App() {
  return (
    <Routes>
      {/* Public auth routes */}
      <Route path="/login" element={<PublicRoute><LoginPage /></PublicRoute>} />
      <Route path="/signup" element={<PublicRoute><SignupPage /></PublicRoute>} />
      <Route path="/forgot-password" element={<PublicRoute><ForgotPasswordPage /></PublicRoute>} />
      <Route path="/invite/:inviteId" element={<InviteAcceptPage />} />

      {/* Protected dashboard routes */}
      <Route
        path="/"
        element={
          <ProtectedRoute>
            <DashboardLayout />
          </ProtectedRoute>
        }
      >
        <Route index element={<DashboardHome />} />
        <Route path="teams" element={<TeamsPage />} />
        <Route path="teams/new" element={<NewTeamPage />} />
        <Route path="teams/:teamId" element={<TeamOverview />} />
        <Route path="teams/:teamId/settings" element={<TeamSettings />} />
        <Route path="teams/:teamId/members" element={<TeamMembers />} />
        <Route path="teams/:teamId/projects" element={<TeamProjects />} />
        <Route path="teams/:teamId/projects/new" element={<NewProjectPage />} />
        <Route path="projects/:projectId" element={<ProjectOverview />} />
        <Route path="projects/:projectId/settings" element={<ProjectSettings />} />
        <Route path="projects/:projectId/env-vars" element={<ProjectEnvVars />} />
        <Route path="projects/:projectId/deployments" element={<DeploymentsPage />} />
        <Route path="projects/:projectId/deployments/new" element={<NewDeploymentPage />} />
        <Route path="projects/:projectId/deployments/:deploymentId" element={<DeploymentDetail />} />
        <Route path="projects/:projectId/deployments/:deploymentId/builds/:buildId" element={<BuildLogs />} />
        <Route path="projects/:projectId/observability" element={<ObservabilityDashboard />} />
        <Route path="projects/:projectId/observability/traces" element={<TracesPage />} />
        <Route path="projects/:projectId/observability/logs" element={<LogsPage />} />
        <Route path="projects/:projectId/observability/metrics" element={<MetricsPage />} />
        <Route path="settings" element={<UserSettings />} />
      </Route>

      {/* 404 */}
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}
```

#### 1.4 Supabase Client Setup

**File: `src/lib/supabase.ts`**

```typescript
import { createClient, SupabaseClient, Session, User } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase: SupabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
});

export type { Session, User };
```

---

### Phase 2: Admin API Client

**Goal**: Create a type-safe client for the admin-server API.

#### 2.1 Base Client

**File: `src/lib/admin-client.ts`**

```typescript
import type {
  Team,
  TeamMember,
  TeamInvite,
  Project,
  Deployment,
  Build,
  RunningServer,
  ProjectSource,
  EncryptedEnvVar,
} from '@mastra/admin';

export interface AdminClientConfig {
  baseUrl: string;
  getToken: () => Promise<string | null>;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
  hasMore: boolean;
}

export interface AdminClientError {
  error: string;
  code?: string;
  details?: Record<string, unknown>;
  requestId?: string;
}

export class AdminClient {
  private baseUrl: string;
  private getToken: () => Promise<string | null>;

  constructor(config: AdminClientConfig) {
    this.baseUrl = config.baseUrl;
    this.getToken = config.getToken;
  }

  private async request<T>(
    method: string,
    path: string,
    options?: {
      body?: unknown;
      params?: Record<string, string | number | undefined>;
      teamId?: string;
    },
  ): Promise<T> {
    const token = await this.getToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const url = new URL(`${this.baseUrl}${path}`);
    if (options?.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== undefined) {
          url.searchParams.set(key, String(value));
        }
      });
    }

    const headers: HeadersInit = {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    };

    if (options?.teamId) {
      headers['X-Team-Id'] = options.teamId;
    }

    const response = await fetch(url.toString(), {
      method,
      headers,
      body: options?.body ? JSON.stringify(options.body) : undefined,
    });

    if (!response.ok) {
      const error = (await response.json()) as AdminClientError;
      throw new AdminApiError(error, response.status);
    }

    return response.json();
  }

  // ============================================================
  // Auth
  // ============================================================
  auth = {
    me: () => this.request<{ user: User }>('GET', '/auth/me'),
    logout: () => this.request<void>('POST', '/auth/logout'),
  };

  // ============================================================
  // Teams
  // ============================================================
  teams = {
    list: (params?: { page?: number; perPage?: number }) =>
      this.request<PaginatedResponse<Team>>('GET', '/teams', { params }),

    get: (teamId: string) => this.request<Team>('GET', `/teams/${teamId}`),

    create: (data: { name: string; slug?: string }) => this.request<Team>('POST', '/teams', { body: data }),

    update: (teamId: string, data: { name?: string; settings?: TeamSettings }) =>
      this.request<Team>('PATCH', `/teams/${teamId}`, { body: data }),

    delete: (teamId: string) => this.request<void>('DELETE', `/teams/${teamId}`),

    // Members
    listMembers: (teamId: string, params?: { page?: number; perPage?: number }) =>
      this.request<PaginatedResponse<TeamMember & { user: User }>>('GET', `/teams/${teamId}/members`, { params }),

    inviteMember: (teamId: string, data: { email: string; role: TeamRole }) =>
      this.request<TeamInvite>('POST', `/teams/${teamId}/members`, { body: data }),

    updateMemberRole: (teamId: string, userId: string, role: TeamRole) =>
      this.request<TeamMember>('PATCH', `/teams/${teamId}/members/${userId}`, { body: { role } }),

    removeMember: (teamId: string, userId: string) =>
      this.request<void>('DELETE', `/teams/${teamId}/members/${userId}`),

    // Invites
    listInvites: (teamId: string) => this.request<PaginatedResponse<TeamInvite>>('GET', `/teams/${teamId}/invites`),

    cancelInvite: (teamId: string, inviteId: string) =>
      this.request<void>('DELETE', `/teams/${teamId}/invites/${inviteId}`),
  };

  // ============================================================
  // Invites (public)
  // ============================================================
  invites = {
    accept: (inviteId: string) => this.request<{ team: Team }>('POST', `/invites/${inviteId}/accept`),
  };

  // ============================================================
  // Sources
  // ============================================================
  sources = {
    list: (teamId: string) => this.request<ProjectSource[]>('GET', `/teams/${teamId}/sources`),

    get: (sourceId: string) => this.request<ProjectSource>('GET', `/sources/${sourceId}`),

    validate: (sourceId: string) =>
      this.request<{ valid: boolean; error?: string }>('POST', `/sources/${sourceId}/validate`),
  };

  // ============================================================
  // Projects
  // ============================================================
  projects = {
    list: (teamId: string, params?: { page?: number; perPage?: number }) =>
      this.request<PaginatedResponse<Project>>('GET', `/teams/${teamId}/projects`, { params }),

    get: (projectId: string) => this.request<Project>('GET', `/projects/${projectId}`),

    create: (teamId: string, data: CreateProjectInput) =>
      this.request<Project>('POST', `/teams/${teamId}/projects`, { body: data }),

    update: (projectId: string, data: Partial<Project>) =>
      this.request<Project>('PATCH', `/projects/${projectId}`, { body: data }),

    delete: (projectId: string) => this.request<void>('DELETE', `/projects/${projectId}`),

    // Environment Variables
    getEnvVars: (projectId: string) => this.request<EncryptedEnvVar[]>('GET', `/projects/${projectId}/env-vars`),

    setEnvVar: (projectId: string, data: { key: string; value: string; isSecret: boolean }) =>
      this.request<void>('POST', `/projects/${projectId}/env-vars`, { body: data }),

    deleteEnvVar: (projectId: string, key: string) =>
      this.request<void>('DELETE', `/projects/${projectId}/env-vars/${key}`),

    // API Tokens
    listApiTokens: (projectId: string) => this.request<ProjectApiToken[]>('GET', `/projects/${projectId}/api-tokens`),

    createApiToken: (projectId: string, data: { name: string; scopes: string[]; expiresAt?: string }) =>
      this.request<{ token: string; tokenInfo: ProjectApiToken }>('POST', `/projects/${projectId}/api-tokens`, {
        body: data,
      }),

    revokeApiToken: (projectId: string, tokenId: string) =>
      this.request<void>('DELETE', `/projects/${projectId}/api-tokens/${tokenId}`),
  };

  // ============================================================
  // Deployments
  // ============================================================
  deployments = {
    list: (projectId: string, params?: { page?: number; perPage?: number }) =>
      this.request<PaginatedResponse<Deployment>>('GET', `/projects/${projectId}/deployments`, { params }),

    get: (deploymentId: string) => this.request<Deployment>('GET', `/deployments/${deploymentId}`),

    create: (projectId: string, data: CreateDeploymentInput) =>
      this.request<Deployment>('POST', `/projects/${projectId}/deployments`, { body: data }),

    update: (deploymentId: string, data: Partial<Deployment>) =>
      this.request<Deployment>('PATCH', `/deployments/${deploymentId}`, { body: data }),

    delete: (deploymentId: string) => this.request<void>('DELETE', `/deployments/${deploymentId}`),

    // Actions
    deploy: (deploymentId: string) => this.request<Build>('POST', `/deployments/${deploymentId}/deploy`),

    stop: (deploymentId: string) => this.request<void>('POST', `/deployments/${deploymentId}/stop`),

    restart: (deploymentId: string) => this.request<Build>('POST', `/deployments/${deploymentId}/restart`),

    rollback: (deploymentId: string, buildId?: string) =>
      this.request<Build>('POST', `/deployments/${deploymentId}/rollback`, { body: { buildId } }),
  };

  // ============================================================
  // Builds
  // ============================================================
  builds = {
    list: (deploymentId: string, params?: { page?: number; perPage?: number }) =>
      this.request<PaginatedResponse<Build>>('GET', `/deployments/${deploymentId}/builds`, { params }),

    get: (buildId: string) => this.request<Build>('GET', `/builds/${buildId}`),

    getLogs: (buildId: string) => this.request<{ logs: string }>('GET', `/builds/${buildId}/logs`),

    cancel: (buildId: string) => this.request<void>('POST', `/builds/${buildId}/cancel`),
  };

  // ============================================================
  // Servers
  // ============================================================
  servers = {
    get: (deploymentId: string) => this.request<RunningServer>('GET', `/deployments/${deploymentId}/server`),

    getHealth: (serverId: string) =>
      this.request<{ status: HealthStatus; details?: ServerHealthDetails }>('GET', `/servers/${serverId}/health`),

    getLogs: (serverId: string, params?: { limit?: number; since?: string }) =>
      this.request<{ logs: string[] }>('GET', `/servers/${serverId}/logs`, { params }),

    getMetrics: (serverId: string) => this.request<ServerMetrics>('GET', `/servers/${serverId}/metrics`),
  };

  // ============================================================
  // Observability
  // ============================================================
  observability = {
    traces: {
      list: (projectId: string, params?: TraceQueryParams) =>
        this.request<PaginatedResponse<Trace>>('GET', `/projects/${projectId}/traces`, { params }),

      get: (traceId: string) => this.request<TraceWithSpans>('GET', `/traces/${traceId}`),
    },

    logs: {
      list: (projectId: string, params?: LogQueryParams) =>
        this.request<PaginatedResponse<LogEntry>>('GET', `/projects/${projectId}/logs`, { params }),
    },

    metrics: {
      get: (projectId: string, params?: MetricQueryParams) =>
        this.request<AggregatedMetrics>('GET', `/projects/${projectId}/metrics`, { params }),
    },

    scores: {
      list: (projectId: string, params?: ScoreQueryParams) =>
        this.request<PaginatedResponse<Score>>('GET', `/projects/${projectId}/scores`, { params }),
    },
  };
}

export class AdminApiError extends Error {
  code?: string;
  details?: Record<string, unknown>;
  requestId?: string;
  statusCode: number;

  constructor(error: AdminClientError, statusCode: number) {
    super(error.error);
    this.name = 'AdminApiError';
    this.code = error.code;
    this.details = error.details;
    this.requestId = error.requestId;
    this.statusCode = statusCode;
  }
}
```

#### 2.2 Client Provider & Hook

**File: `src/providers/admin-client-provider.tsx`**

```typescript
import { createContext, useContext, useMemo, ReactNode } from 'react';
import { AdminClient } from '@/lib/admin-client';
import { useAuth } from '@/hooks/use-auth';

const AdminClientContext = createContext<AdminClient | null>(null);

export function AdminClientProvider({ children }: { children: ReactNode }) {
  const { session } = useAuth();

  const client = useMemo(() => {
    return new AdminClient({
      baseUrl: import.meta.env.VITE_ADMIN_API_URL,
      getToken: async () => session?.access_token ?? null,
    });
  }, [session?.access_token]);

  return (
    <AdminClientContext.Provider value={client}>
      {children}
    </AdminClientContext.Provider>
  );
}

export function useAdminClient(): AdminClient {
  const client = useContext(AdminClientContext);
  if (!client) {
    throw new Error('useAdminClient must be used within AdminClientProvider');
  }
  return client;
}
```

---

### Phase 3: WebSocket Client for Real-time Updates

**Goal**: Implement WebSocket client for build logs, server health, and deployment status.

#### 3.1 WebSocket Manager

**File: `src/lib/websocket-client.ts`**

```typescript
type MessageHandler = (event: WebSocketEvent) => void;
type ConnectionHandler = () => void;

export interface WebSocketClientConfig {
  url: string;
  getToken: () => Promise<string | null>;
  reconnectDelay?: number;
  maxReconnectAttempts?: number;
}

export interface WebSocketEvent {
  type: string;
  payload: unknown;
}

export interface BuildLogEvent {
  type: 'build:log';
  payload: {
    buildId: string;
    line: string;
    timestamp: string;
    level: 'info' | 'warn' | 'error';
  };
}

export interface BuildStatusEvent {
  type: 'build:status';
  payload: {
    buildId: string;
    status: BuildStatus;
    message?: string;
  };
}

export interface ServerLogEvent {
  type: 'server:log';
  payload: {
    serverId: string;
    line: string;
    timestamp: string;
    stream: 'stdout' | 'stderr';
  };
}

export interface ServerHealthEvent {
  type: 'server:health';
  payload: {
    serverId: string;
    status: HealthStatus;
    lastCheck: string;
    details?: {
      memoryUsageMb?: number;
      cpuPercent?: number;
      uptime?: number;
    };
  };
}

export interface DeploymentStatusEvent {
  type: 'deployment:status';
  payload: {
    deploymentId: string;
    status: DeploymentStatus;
    publicUrl?: string;
  };
}

export class WebSocketClient {
  private ws: WebSocket | null = null;
  private config: WebSocketClientConfig;
  private subscriptions = new Map<string, Set<MessageHandler>>();
  private connectionHandlers = new Set<ConnectionHandler>();
  private disconnectionHandlers = new Set<ConnectionHandler>();
  private reconnectAttempts = 0;
  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
  private clientId: string | null = null;

  constructor(config: WebSocketClientConfig) {
    this.config = {
      reconnectDelay: 1000,
      maxReconnectAttempts: 10,
      ...config,
    };
  }

  async connect(): Promise<void> {
    const token = await this.config.getToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const url = new URL(this.config.url);
    url.searchParams.set('token', token);

    this.ws = new WebSocket(url.toString());

    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
      this.connectionHandlers.forEach(handler => handler());
    };

    this.ws.onmessage = event => {
      try {
        const message = JSON.parse(event.data) as { type: string; payload: unknown };

        if (message.type === 'connected') {
          this.clientId = (message.payload as { clientId: string }).clientId;
          this.resubscribeAll();
          return;
        }

        const channel = this.extractChannel(message);
        if (channel) {
          const handlers = this.subscriptions.get(channel);
          handlers?.forEach(handler => handler(message as WebSocketEvent));
        }
      } catch (e) {
        console.error('Failed to parse WebSocket message:', e);
      }
    };

    this.ws.onclose = () => {
      this.disconnectionHandlers.forEach(handler => handler());
      this.attemptReconnect();
    };

    this.ws.onerror = error => {
      console.error('WebSocket error:', error);
    };
  }

  private extractChannel(message: { type: string; payload: unknown }): string | null {
    const payload = message.payload as Record<string, string>;
    switch (message.type) {
      case 'build:log':
      case 'build:status':
        return `build:${payload.buildId}`;
      case 'server:log':
      case 'server:health':
        return `server:${payload.serverId}`;
      case 'deployment:status':
        return `deployment:${payload.deploymentId}`;
      default:
        return null;
    }
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts >= (this.config.maxReconnectAttempts ?? 10)) {
      console.error('Max reconnect attempts reached');
      return;
    }

    const delay = Math.min((this.config.reconnectDelay ?? 1000) * Math.pow(2, this.reconnectAttempts), 30000);

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  private resubscribeAll(): void {
    for (const channel of this.subscriptions.keys()) {
      this.sendSubscribe(channel);
    }
  }

  private sendSubscribe(channel: string): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'subscribe', payload: { channel } }));
    }
  }

  private sendUnsubscribe(channel: string): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'unsubscribe', payload: { channel } }));
    }
  }

  subscribe(channel: string, handler: MessageHandler): () => void {
    if (!this.subscriptions.has(channel)) {
      this.subscriptions.set(channel, new Set());
      this.sendSubscribe(channel);
    }
    this.subscriptions.get(channel)!.add(handler);

    return () => {
      const handlers = this.subscriptions.get(channel);
      if (handlers) {
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.subscriptions.delete(channel);
          this.sendUnsubscribe(channel);
        }
      }
    };
  }

  onConnect(handler: ConnectionHandler): () => void {
    this.connectionHandlers.add(handler);
    return () => this.connectionHandlers.delete(handler);
  }

  onDisconnect(handler: ConnectionHandler): () => void {
    this.disconnectionHandlers.add(handler);
    return () => this.disconnectionHandlers.delete(handler);
  }

  disconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    this.ws?.close();
    this.ws = null;
    this.subscriptions.clear();
  }

  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}
```

#### 3.2 WebSocket Hook

**File: `src/hooks/use-websocket.ts`**

```typescript
import { useEffect, useState, useCallback } from 'react';
import {
  WebSocketClient,
  WebSocketEvent,
  BuildLogEvent,
  BuildStatusEvent,
  ServerLogEvent,
  ServerHealthEvent,
  DeploymentStatusEvent,
} from '@/lib/websocket-client';
import { useAuth } from './use-auth';

let sharedClient: WebSocketClient | null = null;

export function useWebSocket() {
  const { session } = useAuth();
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    if (!session?.access_token) return;

    if (!sharedClient) {
      sharedClient = new WebSocketClient({
        url: import.meta.env.VITE_ADMIN_WS_URL,
        getToken: async () => session.access_token,
      });
    }

    sharedClient.connect();

    const unsubConnect = sharedClient.onConnect(() => setIsConnected(true));
    const unsubDisconnect = sharedClient.onDisconnect(() => setIsConnected(false));

    return () => {
      unsubConnect();
      unsubDisconnect();
    };
  }, [session?.access_token]);

  const subscribe = useCallback((channel: string, handler: (event: WebSocketEvent) => void) => {
    if (!sharedClient) return () => {};
    return sharedClient.subscribe(channel, handler);
  }, []);

  return { isConnected, subscribe };
}

export function useBuildLogs(buildId: string | undefined) {
  const [logs, setLogs] = useState<string[]>([]);
  const [status, setStatus] = useState<string | null>(null);
  const { subscribe } = useWebSocket();

  useEffect(() => {
    if (!buildId) return;

    const unsubscribe = subscribe(`build:${buildId}`, event => {
      if (event.type === 'build:log') {
        const payload = event.payload as BuildLogEvent['payload'];
        setLogs(prev => [...prev, `[${payload.timestamp}] ${payload.line}`]);
      } else if (event.type === 'build:status') {
        const payload = event.payload as BuildStatusEvent['payload'];
        setStatus(payload.status);
      }
    });

    return unsubscribe;
  }, [buildId, subscribe]);

  return { logs, status, clearLogs: () => setLogs([]) };
}

export function useServerHealth(serverId: string | undefined) {
  const [health, setHealth] = useState<ServerHealthEvent['payload'] | null>(null);
  const { subscribe } = useWebSocket();

  useEffect(() => {
    if (!serverId) return;

    const unsubscribe = subscribe(`server:${serverId}`, event => {
      if (event.type === 'server:health') {
        setHealth(event.payload as ServerHealthEvent['payload']);
      }
    });

    return unsubscribe;
  }, [serverId, subscribe]);

  return health;
}

export function useServerLogs(serverId: string | undefined) {
  const [logs, setLogs] = useState<ServerLogEvent['payload'][]>([]);
  const { subscribe } = useWebSocket();

  useEffect(() => {
    if (!serverId) return;

    const unsubscribe = subscribe(`server:${serverId}`, event => {
      if (event.type === 'server:log') {
        setLogs(prev => [...prev.slice(-999), event.payload as ServerLogEvent['payload']]);
      }
    });

    return unsubscribe;
  }, [serverId, subscribe]);

  return { logs, clearLogs: () => setLogs([]) };
}

export function useDeploymentStatus(deploymentId: string | undefined) {
  const [status, setStatus] = useState<DeploymentStatusEvent['payload'] | null>(null);
  const { subscribe } = useWebSocket();

  useEffect(() => {
    if (!deploymentId) return;

    const unsubscribe = subscribe(`deployment:${deploymentId}`, event => {
      if (event.type === 'deployment:status') {
        setStatus(event.payload as DeploymentStatusEvent['payload']);
      }
    });

    return unsubscribe;
  }, [deploymentId, subscribe]);

  return status;
}
```

---

### Phase 4: Authentication Flow

**Goal**: Implement login, signup, and auth state management.

#### 4.1 Auth Provider & Hook

**File: `src/providers/auth-provider.tsx`**

```typescript
import { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react';
import { useNavigate } from 'react-router';
import { supabase, Session, User } from '@/lib/supabase';

interface AuthContextType {
  user: User | null;
  session: Session | null;
  loading: boolean;
  isAuthenticated: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, name: string) => Promise<void>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        setLoading(false);
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  const signIn = useCallback(
    async (email: string, password: string) => {
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;
      navigate('/');
    },
    [navigate]
  );

  const signUp = useCallback(
    async (email: string, password: string, name: string) => {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { name },
        },
      });
      if (error) throw error;
      navigate('/login?message=Check your email to confirm your account');
    },
    [navigate]
  );

  const signOut = useCallback(async () => {
    await supabase.auth.signOut();
    navigate('/login');
  }, [navigate]);

  const resetPassword = useCallback(
    async (email: string) => {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/reset-password`,
      });
      if (error) throw error;
    },
    []
  );

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        loading,
        isAuthenticated: !!session,
        signIn,
        signUp,
        signOut,
        resetPassword,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

#### 4.2 Login Page

**File: `src/routes/auth/login.tsx`**

```typescript
import { useState } from 'react';
import { Link, useSearchParams } from 'react-router';
import { useAuth } from '@/hooks/use-auth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const { signIn } = useAuth();
  const [searchParams] = useSearchParams();
  const message = searchParams.get('message');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setLoading(true);

    try {
      await signIn(email, password);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to sign in');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-surface1">
      <div className="w-full max-w-md p-8 bg-surface2 rounded-lg border border-border">
        <h1 className="text-2xl font-semibold text-neutral9 mb-6">Sign in</h1>

        {message && (
          <div className="mb-4 p-3 bg-accent1/10 text-accent1 rounded-md text-sm">
            {message}
          </div>
        )}

        {error && (
          <div className="mb-4 p-3 bg-red-500/10 text-red-500 rounded-md text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm text-neutral6 mb-1">
              Email
            </label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>

          <div>
            <label htmlFor="password" className="block text-sm text-neutral6 mb-1">
              Password
            </label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>

          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? 'Signing in...' : 'Sign in'}
          </Button>
        </form>

        <div className="mt-4 text-center text-sm text-neutral6">
          <Link to="/forgot-password" className="text-accent1 hover:underline">
            Forgot password?
          </Link>
        </div>

        <div className="mt-6 text-center text-sm text-neutral6">
          Don't have an account?{' '}
          <Link to="/signup" className="text-accent1 hover:underline">
            Sign up
          </Link>
        </div>
      </div>
    </div>
  );
}
```

---

### Phase 5: Dashboard Shell & Navigation

**Goal**: Create the main dashboard layout with sidebar, header, and team switcher.

#### 5.1 Dashboard Layout

**File: `src/routes/dashboard/layout.tsx`**

```typescript
import { Outlet } from 'react-router';
import { Sidebar } from '@/components/dashboard/sidebar';
import { Header } from '@/components/dashboard/header';

export function DashboardLayout() {
  return (
    <div className="flex h-screen bg-surface1">
      <Sidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Header />
        <main className="flex-1 overflow-auto p-6">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
```

#### 5.2 Sidebar Component

**File: `src/components/dashboard/sidebar.tsx`**

```typescript
import { Link, useLocation } from 'react-router';
import { cn } from '@/lib/utils';
import { TeamSwitcher } from './team-switcher';
import {
  LayoutDashboard,
  Users,
  FolderGit2,
  Rocket,
  Activity,
  Settings,
} from 'lucide-react';
import { useCurrentTeam } from '@/hooks/use-current-team';

const navigation = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Teams', href: '/teams', icon: Users },
];

const teamNavigation = [
  { name: 'Projects', href: '/projects', icon: FolderGit2 },
  { name: 'Deployments', href: '/deployments', icon: Rocket },
  { name: 'Observability', href: '/observability', icon: Activity },
  { name: 'Settings', href: '/settings', icon: Settings },
];

export function Sidebar() {
  const location = useLocation();
  const { currentTeam } = useCurrentTeam();

  return (
    <div className="w-64 bg-surface2 border-r border-border flex flex-col">
      {/* Logo */}
      <div className="p-4 border-b border-border">
        <Link to="/" className="flex items-center gap-2">
          <span className="text-lg font-semibold text-neutral9">MastraAdmin</span>
        </Link>
      </div>

      {/* Team Switcher */}
      <div className="p-4 border-b border-border">
        <TeamSwitcher />
      </div>

      {/* Navigation */}
      <nav className="flex-1 p-4 space-y-1">
        {navigation.map((item) => {
          const isActive = location.pathname === item.href;
          return (
            <Link
              key={item.name}
              to={item.href}
              className={cn(
                'flex items-center gap-3 px-3 py-2 rounded-md text-sm',
                isActive
                  ? 'bg-accent1/10 text-accent1'
                  : 'text-neutral6 hover:bg-surface3 hover:text-neutral9'
              )}
            >
              <item.icon className="h-4 w-4" />
              {item.name}
            </Link>
          );
        })}

        {currentTeam && (
          <>
            <div className="pt-4 pb-2">
              <span className="px-3 text-xs font-medium text-neutral3 uppercase">
                Team
              </span>
            </div>
            {teamNavigation.map((item) => {
              const href = `/teams/${currentTeam.id}${item.href}`;
              const isActive = location.pathname.startsWith(href);
              return (
                <Link
                  key={item.name}
                  to={href}
                  className={cn(
                    'flex items-center gap-3 px-3 py-2 rounded-md text-sm',
                    isActive
                      ? 'bg-accent1/10 text-accent1'
                      : 'text-neutral6 hover:bg-surface3 hover:text-neutral9'
                  )}
                >
                  <item.icon className="h-4 w-4" />
                  {item.name}
                </Link>
              );
            })}
          </>
        )}
      </nav>
    </div>
  );
}
```

#### 5.3 Team Switcher

**File: `src/components/dashboard/team-switcher.tsx`**

```typescript
import { useState } from 'react';
import { useNavigate } from 'react-router';
import { Check, ChevronsUpDown, Plus } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
} from '@/components/ui/command';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { useTeams } from '@/hooks/teams/use-teams';
import { useCurrentTeam } from '@/hooks/use-current-team';

export function TeamSwitcher() {
  const [open, setOpen] = useState(false);
  const navigate = useNavigate();
  const { data: teams } = useTeams();
  const { currentTeam, setCurrentTeam } = useCurrentTeam();

  const handleSelect = (teamId: string) => {
    const team = teams?.data.find((t) => t.id === teamId);
    if (team) {
      setCurrentTeam(team);
      setOpen(false);
      navigate(`/teams/${team.id}`);
    }
  };

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
        >
          {currentTeam?.name ?? 'Select team...'}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-56 p-0">
        <Command>
          <CommandInput placeholder="Search teams..." />
          <CommandList>
            <CommandEmpty>No teams found.</CommandEmpty>
            <CommandGroup heading="Teams">
              {teams?.data.map((team) => (
                <CommandItem
                  key={team.id}
                  value={team.id}
                  onSelect={() => handleSelect(team.id)}
                >
                  <Check
                    className={cn(
                      'mr-2 h-4 w-4',
                      currentTeam?.id === team.id ? 'opacity-100' : 'opacity-0'
                    )}
                  />
                  {team.name}
                </CommandItem>
              ))}
            </CommandGroup>
            <CommandSeparator />
            <CommandGroup>
              <CommandItem
                onSelect={() => {
                  setOpen(false);
                  navigate('/teams/new');
                }}
              >
                <Plus className="mr-2 h-4 w-4" />
                Create Team
              </CommandItem>
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
```

---

### Phase 6: Key Domain Components

_(Components remain the same as before - ProjectSourcePicker, BuildLogViewer, DeploymentCard, EnvVarTable - but with React Router imports instead of Next.js)_

The key changes from the original plan:

- Replace `next/link` with `react-router` `Link`
- Replace `useRouter` from Next.js with `useNavigate` from React Router
- Replace `usePathname` with `useLocation().pathname`
- Replace `useSearchParams` from Next.js with React Router's version

---

## Success Criteria

### Phase 1: Package Setup

- [ ] Vite app scaffolded with React 19
- [ ] React Router configured with all routes
- [ ] Tailwind CSS configured with playground-ui tokens
- [ ] TypeScript strict mode enabled
- [ ] ESLint and Prettier configured
- [ ] Build succeeds: `pnpm build`
- [ ] Dev server works: `pnpm dev`

### Phase 2: API Client

- [ ] AdminClient covers all admin-server endpoints
- [ ] Error handling with typed AdminApiError
- [ ] Token-based authentication works
- [ ] TanStack Query hooks for all endpoints

### Phase 3: WebSocket

- [ ] WebSocket connection established with auth
- [ ] Automatic reconnection with exponential backoff
- [ ] Channel subscription/unsubscription works
- [ ] Build log streaming works in real-time
- [ ] Server health updates received

### Phase 4: Authentication

- [ ] Login with email/password works
- [ ] Signup with email verification
- [ ] Password reset flow
- [ ] Auth state persists across page refreshes
- [ ] Protected routes redirect to login
- [ ] Public routes redirect authenticated users to dashboard

### Phase 5: Dashboard Shell

- [ ] Sidebar navigation works
- [ ] Team switcher shows all teams
- [ ] Team context persists in URL
- [ ] Breadcrumbs show current location
- [ ] Responsive layout on mobile

### Phase 6: Domain Components

- [ ] Team CRUD operations work
- [ ] Team member invite/remove works
- [ ] Project creation with source picker works
- [ ] Source validation shows status
- [ ] Deployment create/trigger/stop works
- [ ] Build logs stream in real-time
- [ ] Environment variables CRUD works

### Phase 7: Observability

- [ ] Traces list with filtering
- [ ] Trace detail with span tree
- [ ] Logs viewer with search
- [ ] Metrics charts render
- [ ] Time range picker works

---

## Testing Strategy

### Unit Tests (Vitest)

- Component rendering tests
- Hook behavior tests
- API client method tests
- WebSocket client tests

### Integration Tests

- Auth flow end-to-end
- Team management flow
- Project creation flow
- Deployment flow

### E2E Tests (Playwright)

- Full user journey: login → create team → create project → deploy
- Real-time log streaming
- Error handling and recovery

---

## Open Questions

1. **playground-ui reuse**: Should we import components from `@mastra/playground-ui` or duplicate them?
   - **Recommendation**: Import directly from `@mastra/playground-ui` as a dependency

2. **State management**: Is Zustand sufficient or do we need more?
   - **Recommendation**: Zustand for UI state + TanStack Query for server state is sufficient

3. **i18n**: Is internationalization needed?
   - **Recommendation**: Not for MVP, can be added later

4. **Build output**: Should admin-ui be embedded in admin-server or served separately?
   - **Recommendation**: Build as static assets that admin-server can serve, similar to playground

---

## Related Documents

- [Master Plan](./2025-01-23-mastra-admin-master-plan.md)
- [Admin Core Plan](./2025-01-23-admin-core.md)
- [Admin Server Plan](./2025-01-23-admin-server.md)
- [Local Source Plan](./2025-01-23-source-local.md)
