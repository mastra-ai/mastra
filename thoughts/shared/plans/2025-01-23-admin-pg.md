# LANE 2: @mastra/admin-pg (PostgreSQL Storage)

## Overview

**Package**: `@mastra/admin-pg`
**Location**: `stores/admin-pg/`
**Priority**: P0
**Dependencies**: LANE 1 (Core Package - `@mastra/admin`)

This package implements PostgreSQL storage for MastraAdmin, following the established `stores/pg/` pattern. It provides persistent storage for all admin entities: users, teams, projects, deployments, builds, running servers, routes, and RBAC.

---

## Directory Structure

```
stores/admin-pg/
├── src/
│   ├── index.ts                      # Package exports
│   ├── storage.ts                    # PostgresAdminStorage main class
│   ├── shared/
│   │   └── config.ts                 # Configuration types and validation
│   ├── client.ts                     # PoolAdapter & DbClient (reuse from pg)
│   ├── db/
│   │   └── index.ts                  # AdminPgDB class (core database layer)
│   ├── domains/
│   │   ├── users.ts                  # UsersPG domain
│   │   ├── teams.ts                  # TeamsPG domain
│   │   ├── projects.ts               # ProjectsPG domain
│   │   ├── deployments.ts            # DeploymentsPG domain
│   │   ├── builds.ts                 # BuildsPG domain
│   │   ├── servers.ts                # RunningServersPG domain
│   │   ├── routes.ts                 # RoutesPG domain
│   │   ├── rbac.ts                   # RbacPG domain
│   │   └── utils.ts                  # Shared utilities
│   └── migrations/
│       └── 001_initial.ts            # Initial schema migration
├── package.json
├── tsconfig.json
├── tsconfig.build.json
├── tsup.config.ts
├── vitest.config.ts
├── turbo.json
├── eslint.config.js
└── docker-compose.yml                # For local testing
```

---

## Implementation Phases

### Phase 1: Package Setup & Configuration

#### 1.1 Create package.json

```json
{
  "name": "@mastra/admin-pg",
  "version": "0.1.0",
  "description": "PostgreSQL storage adapter for MastraAdmin",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "./package.json": "./package.json"
  },
  "files": ["dist", "CHANGELOG.md"],
  "scripts": {
    "build": "pnpm build:lib",
    "build:lib": "tsup --config tsup.config.ts",
    "test": "vitest run",
    "test:watch": "vitest watch",
    "pretest": "docker compose up -d && sleep 2",
    "posttest": "docker compose down -v",
    "typecheck": "tsc --noEmit",
    "lint": "eslint src/"
  },
  "dependencies": {
    "pg": "^8.16.3",
    "async-mutex": "^0.5.0"
  },
  "peerDependencies": {
    "@mastra/admin": "workspace:*"
  },
  "devDependencies": {
    "@mastra/admin": "workspace:*",
    "@types/pg": "^8.11.6",
    "tsup": "^8.0.0",
    "typescript": "^5.4.0",
    "vitest": "^1.6.0"
  },
  "engines": {
    "node": ">=22.13.0"
  }
}
```

#### 1.2 Create tsconfig.json

```json
{
  "extends": "../../tsconfig.node.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*", "tsup.config.ts", "vitest.config.ts"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

#### 1.3 Create tsup.config.ts

```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm', 'cjs'],
  dts: true,
  clean: true,
  splitting: true,
  treeshake: { preset: 'smallest' },
  sourcemap: true,
});
```

#### 1.4 Create vitest.config.ts

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    include: ['src/**/*.test.ts'],
    testTimeout: 30000,
    hookTimeout: 30000,
  },
});
```

#### 1.5 Create docker-compose.yml

```yaml
version: '3.8'
services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: mastra
      POSTGRES_PASSWORD: mastra
      POSTGRES_DB: mastra_admin_test
    ports:
      - '5433:5432'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U mastra -d mastra_admin_test']
      interval: 2s
      timeout: 5s
      retries: 10
```

---

### Phase 2: Configuration System

#### 2.1 Create src/shared/config.ts

```typescript
import type { Pool } from 'pg';

/**
 * Base configuration shared by all PostgresAdminStorage configs
 */
export interface PostgresAdminBaseConfig {
  /** Unique identifier for this storage instance */
  id?: string;
  /** PostgreSQL schema name (default: 'mastra_admin') */
  schemaName?: string;
  /** Skip automatic table initialization */
  disableInit?: boolean;
  /** Skip creation of default indexes */
  skipDefaultIndexes?: boolean;
}

/**
 * Config using an existing pg.Pool instance
 */
export interface PoolInstanceConfig extends PostgresAdminBaseConfig {
  pool: Pool;
}

/**
 * Config using a connection string
 */
export interface ConnectionStringConfig extends PostgresAdminBaseConfig {
  connectionString: string;
}

/**
 * Config using explicit host/port/credentials
 */
export interface HostConfig extends PostgresAdminBaseConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  ssl?: boolean | object;
}

/**
 * Union of all valid config types
 */
export type PostgresAdminStorageConfig =
  | PoolInstanceConfig
  | ConnectionStringConfig
  | HostConfig;

/**
 * Type guards for config discrimination
 */
export function isPoolConfig(config: PostgresAdminStorageConfig): config is PoolInstanceConfig {
  return 'pool' in config && config.pool !== undefined;
}

export function isConnectionStringConfig(
  config: PostgresAdminStorageConfig
): config is ConnectionStringConfig {
  return 'connectionString' in config && typeof config.connectionString === 'string';
}

export function isHostConfig(config: PostgresAdminStorageConfig): config is HostConfig {
  return 'host' in config && 'port' in config && 'database' in config;
}

/**
 * Validate configuration
 */
export function validateConfig(config: PostgresAdminStorageConfig): void {
  if (isPoolConfig(config)) {
    if (!config.pool) {
      throw new Error('PostgresAdminStorage: pool must be a valid pg.Pool instance');
    }
    return;
  }

  if (isConnectionStringConfig(config)) {
    if (!config.connectionString || config.connectionString.trim() === '') {
      throw new Error('PostgresAdminStorage: connectionString must be a non-empty string');
    }
    return;
  }

  if (isHostConfig(config)) {
    if (!config.host || !config.database || !config.user) {
      throw new Error('PostgresAdminStorage: host, database, and user are required');
    }
    if (typeof config.port !== 'number' || config.port <= 0) {
      throw new Error('PostgresAdminStorage: port must be a positive number');
    }
    return;
  }

  throw new Error('PostgresAdminStorage: invalid configuration provided');
}

/**
 * Parse SQL identifier to prevent SQL injection
 */
export function parseSqlIdentifier(value: string, label: string): string {
  // Only allow alphanumeric and underscore
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)) {
    throw new Error(
      `PostgresAdminStorage: ${label} contains invalid characters. ` +
        'Only letters, numbers, and underscores are allowed.'
    );
  }
  return value;
}
```

---

### Phase 3: Database Client Layer

#### 3.1 Create src/client.ts

```typescript
import type { Pool, PoolClient, QueryResult, QueryResultRow } from 'pg';

/**
 * Query parameter values
 */
export type QueryValues = unknown[] | Record<string, unknown>;

/**
 * Transaction client interface
 */
export interface TxClient {
  readonly $pool: Pool;
  none(query: string, values?: QueryValues): Promise<null>;
  one<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T>;
  oneOrNone<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T | null>;
  any<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]>;
  manyOrNone<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]>;
  many<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]>;
  query<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<QueryResult<T>>;
  batch<T>(promises: Promise<T>[]): Promise<T[]>;
}

/**
 * Database client interface
 */
export interface DbClient extends Omit<TxClient, 'batch'> {
  connect(): Promise<PoolClient>;
  tx<T>(callback: (t: TxClient) => Promise<T>): Promise<T>;
}

/**
 * Pool adapter implementing DbClient
 */
export class PoolAdapter implements DbClient {
  readonly $pool: Pool;

  constructor(pool: Pool) {
    this.$pool = pool;
  }

  async connect(): Promise<PoolClient> {
    return this.$pool.connect();
  }

  async none(query: string, values?: QueryValues): Promise<null> {
    await this.$pool.query(query, values as unknown[]);
    return null;
  }

  async one<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T> {
    const result = await this.$pool.query<T>(query, values as unknown[]);
    if (result.rowCount !== 1) {
      throw new Error(`Expected exactly 1 row, got ${result.rowCount}`);
    }
    return result.rows[0];
  }

  async oneOrNone<T extends QueryResultRow>(
    query: string,
    values?: QueryValues
  ): Promise<T | null> {
    const result = await this.$pool.query<T>(query, values as unknown[]);
    if (result.rowCount === 0) return null;
    if (result.rowCount === 1) return result.rows[0];
    throw new Error(`Expected 0 or 1 row, got ${result.rowCount}`);
  }

  async any<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    const result = await this.$pool.query<T>(query, values as unknown[]);
    return result.rows;
  }

  async manyOrNone<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    return this.any<T>(query, values);
  }

  async many<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    const result = await this.$pool.query<T>(query, values as unknown[]);
    if (result.rowCount === 0) {
      throw new Error('Expected at least 1 row, got 0');
    }
    return result.rows;
  }

  async query<T extends QueryResultRow>(
    query: string,
    values?: QueryValues
  ): Promise<QueryResult<T>> {
    return this.$pool.query<T>(query, values as unknown[]);
  }

  async tx<T>(callback: (t: TxClient) => Promise<T>): Promise<T> {
    const client = await this.$pool.connect();
    try {
      await client.query('BEGIN');
      const txClient = new TransactionClient(client, this.$pool);
      const result = await callback(txClient);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}

/**
 * Transaction client implementation
 */
class TransactionClient implements TxClient {
  readonly $pool: Pool;
  private client: PoolClient;

  constructor(client: PoolClient, pool: Pool) {
    this.client = client;
    this.$pool = pool;
  }

  async none(query: string, values?: QueryValues): Promise<null> {
    await this.client.query(query, values as unknown[]);
    return null;
  }

  async one<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T> {
    const result = await this.client.query<T>(query, values as unknown[]);
    if (result.rowCount !== 1) {
      throw new Error(`Expected exactly 1 row, got ${result.rowCount}`);
    }
    return result.rows[0];
  }

  async oneOrNone<T extends QueryResultRow>(
    query: string,
    values?: QueryValues
  ): Promise<T | null> {
    const result = await this.client.query<T>(query, values as unknown[]);
    if (result.rowCount === 0) return null;
    if (result.rowCount === 1) return result.rows[0];
    throw new Error(`Expected 0 or 1 row, got ${result.rowCount}`);
  }

  async any<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    const result = await this.client.query<T>(query, values as unknown[]);
    return result.rows;
  }

  async manyOrNone<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    return this.any<T>(query, values);
  }

  async many<T extends QueryResultRow>(query: string, values?: QueryValues): Promise<T[]> {
    const result = await this.client.query<T>(query, values as unknown[]);
    if (result.rowCount === 0) {
      throw new Error('Expected at least 1 row, got 0');
    }
    return result.rows;
  }

  async query<T extends QueryResultRow>(
    query: string,
    values?: QueryValues
  ): Promise<QueryResult<T>> {
    return this.client.query<T>(query, values as unknown[]);
  }

  async batch<T>(promises: Promise<T>[]): Promise<T[]> {
    return Promise.all(promises);
  }
}

export type { Pool, PoolClient, QueryResult };
```

---

### Phase 4: Database Schema & Tables

#### 4.1 Create src/migrations/001_initial.ts

```typescript
/**
 * Initial database schema for MastraAdmin
 *
 * Tables:
 * - users: User accounts
 * - teams: Organizational units
 * - team_members: User-team relationships
 * - team_invites: Pending team invitations
 * - team_installations: External service installations (GitHub App, etc.)
 * - projects: Mastra project configurations
 * - project_env_vars: Encrypted environment variables
 * - project_api_tokens: API tokens for project access
 * - deployments: Deployment instances (production, staging, preview)
 * - builds: Build queue and history
 * - running_servers: Active server instances
 * - routes: Edge router registrations
 * - roles: Custom RBAC roles
 * - role_assignments: Role-user-resource mappings
 */

export const TABLES = {
  users: 'admin_users',
  teams: 'admin_teams',
  team_members: 'admin_team_members',
  team_invites: 'admin_team_invites',
  team_installations: 'admin_team_installations',
  projects: 'admin_projects',
  project_env_vars: 'admin_project_env_vars',
  project_api_tokens: 'admin_project_api_tokens',
  deployments: 'admin_deployments',
  builds: 'admin_builds',
  running_servers: 'admin_running_servers',
  routes: 'admin_routes',
  roles: 'admin_roles',
  role_assignments: 'admin_role_assignments',
} as const;

export type TableName = (typeof TABLES)[keyof typeof TABLES];

/**
 * Schema definitions for each table
 */
export const TABLE_SCHEMAS: Record<TableName, string> = {
  // Users table
  [TABLES.users]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    external_id VARCHAR(255) UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255),
    avatar_url TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
  `,

  // Teams table
  [TABLES.teams]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL UNIQUE,
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
  `,

  // Team members table
  [TABLES.team_members]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES ${TABLES.teams}(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES ${TABLES.users}(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member',
    joined_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(team_id, user_id)
  `,

  // Team invites table
  [TABLES.team_invites]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES ${TABLES.teams}(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'member',
    invited_by UUID NOT NULL REFERENCES ${TABLES.users}(id),
    token VARCHAR(255) NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    accepted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
  `,

  // Team installations table (GitHub App, etc.)
  [TABLES.team_installations]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES ${TABLES.teams}(id) ON DELETE CASCADE,
    provider VARCHAR(50) NOT NULL,
    installation_id VARCHAR(255) NOT NULL,
    account_name VARCHAR(255),
    account_type VARCHAR(50),
    permissions JSONB DEFAULT '{}',
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(team_id, provider, installation_id)
  `,

  // Projects table
  [TABLES.projects]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES ${TABLES.teams}(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL,
    source_type VARCHAR(50) NOT NULL,
    source_config JSONB NOT NULL,
    default_branch VARCHAR(255) DEFAULT 'main',
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(team_id, slug)
  `,

  // Project environment variables table
  [TABLES.project_env_vars]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES ${TABLES.projects}(id) ON DELETE CASCADE,
    deployment_type VARCHAR(50),
    key VARCHAR(255) NOT NULL,
    encrypted_value TEXT NOT NULL,
    is_secret BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(project_id, deployment_type, key)
  `,

  // Project API tokens table
  [TABLES.project_api_tokens]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES ${TABLES.projects}(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    token_prefix VARCHAR(10) NOT NULL,
    scopes JSONB DEFAULT '[]',
    last_used_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    created_by UUID NOT NULL REFERENCES ${TABLES.users}(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
  `,

  // Deployments table
  [TABLES.deployments]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES ${TABLES.projects}(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    branch VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    current_build_id UUID,
    public_url TEXT,
    internal_host VARCHAR(255),
    internal_port INTEGER,
    env_var_overrides JSONB DEFAULT '[]',
    auto_shutdown BOOLEAN DEFAULT false,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(project_id, type, branch)
  `,

  // Builds table
  [TABLES.builds]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    deployment_id UUID NOT NULL REFERENCES ${TABLES.deployments}(id) ON DELETE CASCADE,
    trigger VARCHAR(50) NOT NULL,
    triggered_by VARCHAR(255) NOT NULL,
    commit_sha VARCHAR(255),
    commit_message TEXT,
    status VARCHAR(50) NOT NULL DEFAULT 'queued',
    logs TEXT DEFAULT '',
    error_message TEXT,
    queued_at TIMESTAMPTZ DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
  `,

  // Running servers table
  [TABLES.running_servers]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    deployment_id UUID NOT NULL REFERENCES ${TABLES.deployments}(id) ON DELETE CASCADE,
    build_id UUID NOT NULL REFERENCES ${TABLES.builds}(id),
    process_id INTEGER,
    container_id VARCHAR(255),
    host VARCHAR(255) NOT NULL,
    port INTEGER NOT NULL,
    health_status VARCHAR(50) NOT NULL DEFAULT 'starting',
    last_health_check TIMESTAMPTZ,
    memory_usage_mb REAL,
    cpu_percent REAL,
    started_at TIMESTAMPTZ DEFAULT NOW(),
    stopped_at TIMESTAMPTZ
  `,

  // Routes table
  [TABLES.routes]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    deployment_id UUID NOT NULL REFERENCES ${TABLES.deployments}(id) ON DELETE CASCADE,
    project_id UUID NOT NULL REFERENCES ${TABLES.projects}(id) ON DELETE CASCADE,
    subdomain VARCHAR(255) NOT NULL,
    target_host VARCHAR(255) NOT NULL,
    target_port INTEGER NOT NULL,
    public_url TEXT NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    tls_enabled BOOLEAN DEFAULT true,
    provider_route_id VARCHAR(255),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_health_check TIMESTAMPTZ,
    UNIQUE(subdomain)
  `,

  // Roles table
  [TABLES.roles]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID REFERENCES ${TABLES.teams}(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    permissions JSONB NOT NULL DEFAULT '[]',
    is_system BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(team_id, name)
  `,

  // Role assignments table
  [TABLES.role_assignments]: `
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role_id UUID NOT NULL REFERENCES ${TABLES.roles}(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES ${TABLES.users}(id) ON DELETE CASCADE,
    resource_type VARCHAR(50),
    resource_id UUID,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(role_id, user_id, resource_type, resource_id)
  `,
};

/**
 * Default indexes for performance
 */
export const DEFAULT_INDEXES = [
  // Users
  { table: TABLES.users, columns: ['email'], unique: true },
  { table: TABLES.users, columns: ['external_id'], unique: true },

  // Teams
  { table: TABLES.teams, columns: ['slug'], unique: true },

  // Team members
  { table: TABLES.team_members, columns: ['team_id'] },
  { table: TABLES.team_members, columns: ['user_id'] },
  { table: TABLES.team_members, columns: ['team_id', 'user_id'], unique: true },

  // Team invites
  { table: TABLES.team_invites, columns: ['team_id'] },
  { table: TABLES.team_invites, columns: ['email'] },
  { table: TABLES.team_invites, columns: ['token'], unique: true },

  // Team installations
  { table: TABLES.team_installations, columns: ['team_id'] },
  { table: TABLES.team_installations, columns: ['provider', 'installation_id'] },

  // Projects
  { table: TABLES.projects, columns: ['team_id'] },
  { table: TABLES.projects, columns: ['team_id', 'slug'], unique: true },

  // Project env vars
  { table: TABLES.project_env_vars, columns: ['project_id'] },
  { table: TABLES.project_env_vars, columns: ['project_id', 'deployment_type', 'key'], unique: true },

  // Project API tokens
  { table: TABLES.project_api_tokens, columns: ['project_id'] },
  { table: TABLES.project_api_tokens, columns: ['token_hash'], unique: true },

  // Deployments
  { table: TABLES.deployments, columns: ['project_id'] },
  { table: TABLES.deployments, columns: ['project_id', 'type'] },
  { table: TABLES.deployments, columns: ['status'] },
  { table: TABLES.deployments, columns: ['project_id', 'type', 'branch'], unique: true },

  // Builds
  { table: TABLES.builds, columns: ['deployment_id'] },
  { table: TABLES.builds, columns: ['status'] },
  { table: TABLES.builds, columns: ['status', 'queued_at'] }, // For queue ordering
  { table: TABLES.builds, columns: ['deployment_id', 'created_at DESC'] },

  // Running servers
  { table: TABLES.running_servers, columns: ['deployment_id'] },
  { table: TABLES.running_servers, columns: ['health_status'] },
  { table: TABLES.running_servers, columns: ['deployment_id', 'stopped_at'] },

  // Routes
  { table: TABLES.routes, columns: ['deployment_id'] },
  { table: TABLES.routes, columns: ['project_id'] },
  { table: TABLES.routes, columns: ['subdomain'], unique: true },
  { table: TABLES.routes, columns: ['status'] },

  // Roles
  { table: TABLES.roles, columns: ['team_id'] },
  { table: TABLES.roles, columns: ['team_id', 'name'], unique: true },

  // Role assignments
  { table: TABLES.role_assignments, columns: ['role_id'] },
  { table: TABLES.role_assignments, columns: ['user_id'] },
  { table: TABLES.role_assignments, columns: ['resource_type', 'resource_id'] },
];
```

---

### Phase 5: Core Database Layer

#### 5.1 Create src/db/index.ts

```typescript
import { Mutex } from 'async-mutex';
import type { DbClient } from '../client';
import { TABLES, TABLE_SCHEMAS, DEFAULT_INDEXES, type TableName } from '../migrations/001_initial';
import { parseSqlIdentifier } from '../shared/config';

interface AdminPgDBConfig {
  client: DbClient;
  schemaName?: string;
  skipDefaultIndexes?: boolean;
}

interface CreateIndexOptions {
  name?: string;
  table: string;
  columns: string[];
  unique?: boolean;
  where?: string;
}

/**
 * Core database layer for MastraAdmin PostgreSQL storage
 */
export class AdminPgDB {
  private client: DbClient;
  private schema: string;
  private skipDefaultIndexes: boolean;

  private static schemaSetupRegistry = new Map<string, Promise<void>>();
  private static schemaSetupMutex = new Mutex();

  constructor(config: AdminPgDBConfig) {
    this.client = config.client;
    this.schema = config.schemaName ? parseSqlIdentifier(config.schemaName, 'schema') : 'mastra_admin';
    this.skipDefaultIndexes = config.skipDefaultIndexes ?? false;
  }

  /**
   * Get qualified table name with schema
   */
  private qualifiedTable(table: TableName): string {
    return `"${this.schema}"."${table}"`;
  }

  /**
   * Setup schema if not public
   */
  private async setupSchema(): Promise<void> {
    if (this.schema === 'public') return;

    const key = `${this.client.$pool.options.host}:${this.client.$pool.options.port}:${this.schema}`;

    const existingSetup = AdminPgDB.schemaSetupRegistry.get(key);
    if (existingSetup) {
      await existingSetup;
      return;
    }

    const release = await AdminPgDB.schemaSetupMutex.acquire();
    try {
      const recheck = AdminPgDB.schemaSetupRegistry.get(key);
      if (recheck) {
        await recheck;
        return;
      }

      const setupPromise = this.client.none(`CREATE SCHEMA IF NOT EXISTS "${this.schema}"`);
      AdminPgDB.schemaSetupRegistry.set(key, setupPromise);
      await setupPromise;
    } finally {
      release();
    }
  }

  /**
   * Initialize all tables
   */
  async init(): Promise<void> {
    await this.setupSchema();

    // Create tables in order (respecting foreign key constraints)
    const tableOrder: TableName[] = [
      TABLES.users,
      TABLES.teams,
      TABLES.team_members,
      TABLES.team_invites,
      TABLES.team_installations,
      TABLES.projects,
      TABLES.project_env_vars,
      TABLES.project_api_tokens,
      TABLES.deployments,
      TABLES.builds,
      TABLES.running_servers,
      TABLES.routes,
      TABLES.roles,
      TABLES.role_assignments,
    ];

    for (const table of tableOrder) {
      await this.createTable(table);
    }

    // Create default indexes
    if (!this.skipDefaultIndexes) {
      await this.createDefaultIndexes();
    }

    // Setup updated_at triggers
    await this.setupUpdatedAtTriggers();
  }

  /**
   * Create a single table
   */
  private async createTable(table: TableName): Promise<void> {
    // Replace table references with schema-qualified names
    let schema = TABLE_SCHEMAS[table];
    for (const [, tableName] of Object.entries(TABLES)) {
      schema = schema.replace(
        new RegExp(`REFERENCES ${tableName}\\(`, 'g'),
        `REFERENCES "${this.schema}"."${tableName}"(`
      );
    }

    const sql = `
      CREATE TABLE IF NOT EXISTS ${this.qualifiedTable(table)} (
        ${schema}
      )
    `;
    await this.client.none(sql);
  }

  /**
   * Create default indexes
   */
  private async createDefaultIndexes(): Promise<void> {
    for (const index of DEFAULT_INDEXES) {
      const name =
        index.unique
          ? `${this.schema}_${index.table}_${index.columns.join('_')}_unique`
          : `${this.schema}_${index.table}_${index.columns.join('_')}_idx`;

      await this.createIndex({
        name: name.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
        table: index.table,
        columns: index.columns,
        unique: index.unique,
      });
    }
  }

  /**
   * Create an index
   */
  async createIndex(options: CreateIndexOptions): Promise<void> {
    const { name, table, columns, unique, where } = options;
    const indexName = name || `${this.schema}_${table}_${columns.join('_')}_idx`;
    const uniqueStr = unique ? 'UNIQUE' : '';
    const whereStr = where ? `WHERE ${where}` : '';
    const columnsStr = columns.map(c => {
      // Handle DESC/ASC in column names
      const parts = c.split(' ');
      if (parts.length === 1) return `"${c}"`;
      return `"${parts[0]}" ${parts.slice(1).join(' ')}`;
    }).join(', ');

    const sql = `
      CREATE ${uniqueStr} INDEX IF NOT EXISTS "${indexName}"
      ON ${this.qualifiedTable(table as TableName)} (${columnsStr})
      ${whereStr}
    `;

    try {
      await this.client.none(sql);
    } catch (error) {
      // Ignore "already exists" errors
      if (!(error instanceof Error && error.message.includes('already exists'))) {
        throw error;
      }
    }
  }

  /**
   * Setup updated_at triggers
   */
  private async setupUpdatedAtTriggers(): Promise<void> {
    // Create the trigger function
    const functionSql = `
      CREATE OR REPLACE FUNCTION "${this.schema}".update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';
    `;
    await this.client.none(functionSql);

    // Tables that have updated_at column
    const tablesWithUpdatedAt: TableName[] = [
      TABLES.users,
      TABLES.teams,
      TABLES.team_installations,
      TABLES.projects,
      TABLES.project_env_vars,
      TABLES.deployments,
      TABLES.routes,
      TABLES.roles,
    ];

    for (const table of tablesWithUpdatedAt) {
      const triggerName = `${table}_updated_at_trigger`;
      const triggerSql = `
        DROP TRIGGER IF EXISTS "${triggerName}" ON ${this.qualifiedTable(table)};
        CREATE TRIGGER "${triggerName}"
        BEFORE UPDATE ON ${this.qualifiedTable(table)}
        FOR EACH ROW
        EXECUTE FUNCTION "${this.schema}".update_updated_at_column();
      `;
      await this.client.none(triggerSql);
    }
  }

  /**
   * Insert a record
   */
  async insert<T extends Record<string, unknown>>(
    table: TableName,
    data: T
  ): Promise<T & { id: string }> {
    const keys = Object.keys(data);
    const values = Object.values(data);
    const placeholders = keys.map((_, i) => `$${i + 1}`);
    const columns = keys.map(k => `"${this.toSnakeCase(k)}"`);

    const sql = `
      INSERT INTO ${this.qualifiedTable(table)} (${columns.join(', ')})
      VALUES (${placeholders.join(', ')})
      RETURNING *
    `;

    const row = await this.client.one(sql, values);
    return this.transformRow<T & { id: string }>(row);
  }

  /**
   * Batch insert records
   */
  async batchInsert<T extends Record<string, unknown>>(
    table: TableName,
    records: T[]
  ): Promise<(T & { id: string })[]> {
    if (records.length === 0) return [];

    return this.client.tx(async tx => {
      const results: (T & { id: string })[] = [];
      for (const record of records) {
        const keys = Object.keys(record);
        const values = Object.values(record);
        const placeholders = keys.map((_, i) => `$${i + 1}`);
        const columns = keys.map(k => `"${this.toSnakeCase(k)}"`);

        const sql = `
          INSERT INTO ${this.qualifiedTable(table)} (${columns.join(', ')})
          VALUES (${placeholders.join(', ')})
          RETURNING *
        `;

        const row = await tx.one(sql, values);
        results.push(this.transformRow<T & { id: string }>(row));
      }
      return results;
    });
  }

  /**
   * Update a record
   */
  async update<T extends Record<string, unknown>>(
    table: TableName,
    id: string,
    data: Partial<T>
  ): Promise<(T & { id: string }) | null> {
    const keys = Object.keys(data);
    if (keys.length === 0) return null;

    const values = Object.values(data);
    const setClause = keys.map((k, i) => `"${this.toSnakeCase(k)}" = $${i + 1}`).join(', ');

    const sql = `
      UPDATE ${this.qualifiedTable(table)}
      SET ${setClause}
      WHERE id = $${keys.length + 1}
      RETURNING *
    `;

    const row = await this.client.oneOrNone(sql, [...values, id]);
    return row ? this.transformRow<T & { id: string }>(row) : null;
  }

  /**
   * Delete a record
   */
  async delete(table: TableName, id: string): Promise<boolean> {
    const sql = `DELETE FROM ${this.qualifiedTable(table)} WHERE id = $1`;
    const result = await this.client.query(sql, [id]);
    return (result.rowCount ?? 0) > 0;
  }

  /**
   * Find a record by ID
   */
  async findById<T>(table: TableName, id: string): Promise<(T & { id: string }) | null> {
    const sql = `SELECT * FROM ${this.qualifiedTable(table)} WHERE id = $1`;
    const row = await this.client.oneOrNone(sql, [id]);
    return row ? this.transformRow<T & { id: string }>(row) : null;
  }

  /**
   * Find records by condition
   */
  async findBy<T>(
    table: TableName,
    conditions: Record<string, unknown>,
    options?: { limit?: number; offset?: number; orderBy?: string }
  ): Promise<(T & { id: string })[]> {
    const { where, values } = this.buildWhereClause(conditions);
    let sql = `SELECT * FROM ${this.qualifiedTable(table)} ${where}`;

    if (options?.orderBy) {
      sql += ` ORDER BY ${options.orderBy}`;
    }
    if (options?.limit) {
      sql += ` LIMIT ${options.limit}`;
    }
    if (options?.offset) {
      sql += ` OFFSET ${options.offset}`;
    }

    const rows = await this.client.any(sql, values);
    return rows.map(row => this.transformRow<T & { id: string }>(row));
  }

  /**
   * Find one record by condition
   */
  async findOneBy<T>(
    table: TableName,
    conditions: Record<string, unknown>
  ): Promise<(T & { id: string }) | null> {
    const results = await this.findBy<T>(table, conditions, { limit: 1 });
    return results[0] || null;
  }

  /**
   * Count records
   */
  async count(table: TableName, conditions?: Record<string, unknown>): Promise<number> {
    const { where, values } = conditions
      ? this.buildWhereClause(conditions)
      : { where: '', values: [] };

    const sql = `SELECT COUNT(*) as count FROM ${this.qualifiedTable(table)} ${where}`;
    const result = await this.client.one<{ count: string }>(sql, values);
    return parseInt(result.count, 10);
  }

  /**
   * Execute raw SQL
   */
  async query<T>(sql: string, values?: unknown[]): Promise<T[]> {
    const rows = await this.client.any(sql, values);
    return rows.map(row => this.transformRow<T>(row));
  }

  /**
   * Execute in transaction
   */
  async transaction<T>(callback: (db: AdminPgDB) => Promise<T>): Promise<T> {
    return this.client.tx(async () => {
      return callback(this);
    });
  }

  /**
   * Build WHERE clause from conditions
   */
  private buildWhereClause(conditions: Record<string, unknown>): {
    where: string;
    values: unknown[];
  } {
    const keys = Object.keys(conditions);
    if (keys.length === 0) return { where: '', values: [] };

    const clauses: string[] = [];
    const values: unknown[] = [];

    for (const key of keys) {
      const value = conditions[key];
      const column = `"${this.toSnakeCase(key)}"`;

      if (value === null) {
        clauses.push(`${column} IS NULL`);
      } else if (Array.isArray(value)) {
        const placeholders = value.map((_, i) => `$${values.length + i + 1}`);
        clauses.push(`${column} IN (${placeholders.join(', ')})`);
        values.push(...value);
      } else if (typeof value === 'object' && value !== null) {
        // Handle operators like { gte: 5, lte: 10 }
        const ops = value as Record<string, unknown>;
        for (const [op, opValue] of Object.entries(ops)) {
          values.push(opValue);
          const placeholder = `$${values.length}`;
          switch (op) {
            case 'gte':
              clauses.push(`${column} >= ${placeholder}`);
              break;
            case 'lte':
              clauses.push(`${column} <= ${placeholder}`);
              break;
            case 'gt':
              clauses.push(`${column} > ${placeholder}`);
              break;
            case 'lt':
              clauses.push(`${column} < ${placeholder}`);
              break;
            case 'ne':
              clauses.push(`${column} != ${placeholder}`);
              break;
            case 'like':
              clauses.push(`${column} LIKE ${placeholder}`);
              break;
            case 'ilike':
              clauses.push(`${column} ILIKE ${placeholder}`);
              break;
            default:
              throw new Error(`Unknown operator: ${op}`);
          }
        }
      } else {
        values.push(value);
        clauses.push(`${column} = $${values.length}`);
      }
    }

    return { where: `WHERE ${clauses.join(' AND ')}`, values };
  }

  /**
   * Transform database row to camelCase
   */
  private transformRow<T>(row: Record<string, unknown>): T {
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(row)) {
      const camelKey = this.toCamelCase(key);
      // Parse JSONB columns
      if (typeof value === 'string' && (value.startsWith('{') || value.startsWith('['))) {
        try {
          result[camelKey] = JSON.parse(value);
        } catch {
          result[camelKey] = value;
        }
      } else {
        result[camelKey] = value;
      }
    }
    return result as T;
  }

  /**
   * Convert camelCase to snake_case
   */
  private toSnakeCase(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }

  /**
   * Convert snake_case to camelCase
   */
  private toCamelCase(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }

  /**
   * Get the underlying client for direct access
   */
  get db(): DbClient {
    return this.client;
  }

  /**
   * Get schema name
   */
  get schemaName(): string {
    return this.schema;
  }
}

export { TABLES, type TableName };
```

---

### Phase 6: Domain Implementations

#### 6.1 Create src/domains/utils.ts

```typescript
import type { DbClient } from '../client';
import type { Pool } from 'pg';
import { PoolAdapter } from '../client';

export interface PgDomainConfig {
  client?: DbClient;
  pool?: Pool;
  schemaName?: string;
  skipDefaultIndexes?: boolean;
}

export function resolvePgConfig(config: PgDomainConfig): {
  client: DbClient;
  schemaName?: string;
  skipDefaultIndexes?: boolean;
} {
  if (config.client) {
    return {
      client: config.client,
      schemaName: config.schemaName,
      skipDefaultIndexes: config.skipDefaultIndexes,
    };
  }

  if (config.pool) {
    return {
      client: new PoolAdapter(config.pool),
      schemaName: config.schemaName,
      skipDefaultIndexes: config.skipDefaultIndexes,
    };
  }

  throw new Error('Either client or pool must be provided');
}
```

#### 6.2 Create src/domains/users.ts

```typescript
import type { User } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export class UsersPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.users] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  async createUser(data: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    return this.db.insert<User>(TABLES.users, data);
  }

  async getUserById(id: string): Promise<User | null> {
    return this.db.findById<User>(TABLES.users, id);
  }

  async getUserByEmail(email: string): Promise<User | null> {
    return this.db.findOneBy<User>(TABLES.users, { email });
  }

  async getUserByExternalId(externalId: string): Promise<User | null> {
    return this.db.findOneBy<User>(TABLES.users, { externalId });
  }

  async updateUser(id: string, data: Partial<User>): Promise<User | null> {
    return this.db.update<User>(TABLES.users, id, data);
  }

  async deleteUser(id: string): Promise<boolean> {
    return this.db.delete(TABLES.users, id);
  }

  async listUsers(options?: { limit?: number; offset?: number }): Promise<User[]> {
    return this.db.findBy<User>(TABLES.users, {}, { ...options, orderBy: 'created_at DESC' });
  }
}
```

#### 6.3 Create src/domains/teams.ts

```typescript
import type { Team, TeamMember, TeamInvite, TeamInstallation } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export class TeamsPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [
    TABLES.teams,
    TABLES.team_members,
    TABLES.team_invites,
    TABLES.team_installations,
  ] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  // Team operations
  async createTeam(data: Omit<Team, 'id' | 'createdAt' | 'updatedAt'>): Promise<Team> {
    return this.db.insert<Team>(TABLES.teams, data);
  }

  async getTeamById(id: string): Promise<Team | null> {
    return this.db.findById<Team>(TABLES.teams, id);
  }

  async getTeamBySlug(slug: string): Promise<Team | null> {
    return this.db.findOneBy<Team>(TABLES.teams, { slug });
  }

  async updateTeam(id: string, data: Partial<Team>): Promise<Team | null> {
    return this.db.update<Team>(TABLES.teams, id, data);
  }

  async deleteTeam(id: string): Promise<boolean> {
    return this.db.delete(TABLES.teams, id);
  }

  async listTeamsForUser(userId: string): Promise<Team[]> {
    const sql = `
      SELECT t.* FROM "${this.db.schemaName}"."${TABLES.teams}" t
      INNER JOIN "${this.db.schemaName}"."${TABLES.team_members}" tm ON t.id = tm.team_id
      WHERE tm.user_id = $1
      ORDER BY t.name
    `;
    return this.db.query<Team>(sql, [userId]);
  }

  // Team member operations
  async addTeamMember(
    data: Omit<TeamMember, 'id' | 'joinedAt'>
  ): Promise<TeamMember> {
    return this.db.insert<TeamMember>(TABLES.team_members, data);
  }

  async removeTeamMember(teamId: string, userId: string): Promise<boolean> {
    const member = await this.db.findOneBy<TeamMember>(TABLES.team_members, { teamId, userId });
    if (!member) return false;
    return this.db.delete(TABLES.team_members, member.id);
  }

  async getTeamMember(teamId: string, userId: string): Promise<TeamMember | null> {
    return this.db.findOneBy<TeamMember>(TABLES.team_members, { teamId, userId });
  }

  async listTeamMembers(teamId: string): Promise<TeamMember[]> {
    return this.db.findBy<TeamMember>(TABLES.team_members, { teamId });
  }

  async updateTeamMemberRole(teamId: string, userId: string, role: string): Promise<TeamMember | null> {
    const member = await this.getTeamMember(teamId, userId);
    if (!member) return null;
    return this.db.update<TeamMember>(TABLES.team_members, member.id, { role });
  }

  // Team invite operations
  async createInvite(
    data: Omit<TeamInvite, 'id' | 'createdAt' | 'acceptedAt'>
  ): Promise<TeamInvite> {
    return this.db.insert<TeamInvite>(TABLES.team_invites, data);
  }

  async getInviteByToken(token: string): Promise<TeamInvite | null> {
    return this.db.findOneBy<TeamInvite>(TABLES.team_invites, { token });
  }

  async acceptInvite(token: string): Promise<TeamInvite | null> {
    const invite = await this.getInviteByToken(token);
    if (!invite) return null;
    return this.db.update<TeamInvite>(TABLES.team_invites, invite.id, {
      acceptedAt: new Date(),
    });
  }

  async listPendingInvites(teamId: string): Promise<TeamInvite[]> {
    return this.db.findBy<TeamInvite>(TABLES.team_invites, {
      teamId,
      acceptedAt: null,
    });
  }

  async deleteInvite(id: string): Promise<boolean> {
    return this.db.delete(TABLES.team_invites, id);
  }

  // Team installation operations
  async createInstallation(
    data: Omit<TeamInstallation, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<TeamInstallation> {
    return this.db.insert<TeamInstallation>(TABLES.team_installations, data);
  }

  async getInstallation(
    teamId: string,
    provider: string,
    installationId: string
  ): Promise<TeamInstallation | null> {
    return this.db.findOneBy<TeamInstallation>(TABLES.team_installations, {
      teamId,
      provider,
      installationId,
    });
  }

  async listInstallations(teamId: string): Promise<TeamInstallation[]> {
    return this.db.findBy<TeamInstallation>(TABLES.team_installations, { teamId });
  }

  async deleteInstallation(id: string): Promise<boolean> {
    return this.db.delete(TABLES.team_installations, id);
  }
}
```

#### 6.4 Create src/domains/projects.ts

```typescript
import type { Project, ProjectEnvVar, ProjectApiToken } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export class ProjectsPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [
    TABLES.projects,
    TABLES.project_env_vars,
    TABLES.project_api_tokens,
  ] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  // Project operations
  async createProject(
    data: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<Project> {
    return this.db.insert<Project>(TABLES.projects, data);
  }

  async getProjectById(id: string): Promise<Project | null> {
    return this.db.findById<Project>(TABLES.projects, id);
  }

  async getProjectBySlug(teamId: string, slug: string): Promise<Project | null> {
    return this.db.findOneBy<Project>(TABLES.projects, { teamId, slug });
  }

  async updateProject(id: string, data: Partial<Project>): Promise<Project | null> {
    return this.db.update<Project>(TABLES.projects, id, data);
  }

  async deleteProject(id: string): Promise<boolean> {
    return this.db.delete(TABLES.projects, id);
  }

  async listProjects(teamId: string): Promise<Project[]> {
    return this.db.findBy<Project>(TABLES.projects, { teamId }, { orderBy: 'name' });
  }

  // Environment variable operations
  async setEnvVar(
    data: Omit<ProjectEnvVar, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<ProjectEnvVar> {
    // Upsert: delete existing then insert
    const existing = await this.db.findOneBy<ProjectEnvVar>(TABLES.project_env_vars, {
      projectId: data.projectId,
      deploymentType: data.deploymentType,
      key: data.key,
    });
    if (existing) {
      await this.db.delete(TABLES.project_env_vars, existing.id);
    }
    return this.db.insert<ProjectEnvVar>(TABLES.project_env_vars, data);
  }

  async getEnvVar(
    projectId: string,
    key: string,
    deploymentType?: string
  ): Promise<ProjectEnvVar | null> {
    return this.db.findOneBy<ProjectEnvVar>(TABLES.project_env_vars, {
      projectId,
      key,
      deploymentType: deploymentType ?? null,
    });
  }

  async listEnvVars(projectId: string, deploymentType?: string): Promise<ProjectEnvVar[]> {
    const conditions: Record<string, unknown> = { projectId };
    if (deploymentType !== undefined) {
      conditions.deploymentType = deploymentType;
    }
    return this.db.findBy<ProjectEnvVar>(TABLES.project_env_vars, conditions, { orderBy: 'key' });
  }

  async deleteEnvVar(id: string): Promise<boolean> {
    return this.db.delete(TABLES.project_env_vars, id);
  }

  // API token operations
  async createApiToken(
    data: Omit<ProjectApiToken, 'id' | 'createdAt' | 'lastUsedAt'>
  ): Promise<ProjectApiToken> {
    return this.db.insert<ProjectApiToken>(TABLES.project_api_tokens, data);
  }

  async getApiTokenByHash(tokenHash: string): Promise<ProjectApiToken | null> {
    return this.db.findOneBy<ProjectApiToken>(TABLES.project_api_tokens, { tokenHash });
  }

  async listApiTokens(projectId: string): Promise<ProjectApiToken[]> {
    return this.db.findBy<ProjectApiToken>(TABLES.project_api_tokens, { projectId });
  }

  async updateApiTokenLastUsed(id: string): Promise<void> {
    await this.db.update<ProjectApiToken>(TABLES.project_api_tokens, id, {
      lastUsedAt: new Date(),
    });
  }

  async deleteApiToken(id: string): Promise<boolean> {
    return this.db.delete(TABLES.project_api_tokens, id);
  }
}
```

#### 6.5 Create src/domains/deployments.ts

```typescript
import type { Deployment } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export type DeploymentType = 'production' | 'staging' | 'preview';
export type DeploymentStatus = 'pending' | 'building' | 'running' | 'stopped' | 'failed';

export class DeploymentsPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.deployments] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  async createDeployment(
    data: Omit<Deployment, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<Deployment> {
    return this.db.insert<Deployment>(TABLES.deployments, data);
  }

  async getDeploymentById(id: string): Promise<Deployment | null> {
    return this.db.findById<Deployment>(TABLES.deployments, id);
  }

  async getDeployment(
    projectId: string,
    type: DeploymentType,
    branch: string
  ): Promise<Deployment | null> {
    return this.db.findOneBy<Deployment>(TABLES.deployments, { projectId, type, branch });
  }

  async getProductionDeployment(projectId: string): Promise<Deployment | null> {
    return this.db.findOneBy<Deployment>(TABLES.deployments, {
      projectId,
      type: 'production',
    });
  }

  async updateDeployment(id: string, data: Partial<Deployment>): Promise<Deployment | null> {
    return this.db.update<Deployment>(TABLES.deployments, id, data);
  }

  async updateDeploymentStatus(id: string, status: DeploymentStatus): Promise<Deployment | null> {
    return this.updateDeployment(id, { status });
  }

  async setCurrentBuild(deploymentId: string, buildId: string): Promise<Deployment | null> {
    return this.updateDeployment(deploymentId, { currentBuildId: buildId });
  }

  async deleteDeployment(id: string): Promise<boolean> {
    return this.db.delete(TABLES.deployments, id);
  }

  async listDeployments(projectId: string): Promise<Deployment[]> {
    return this.db.findBy<Deployment>(
      TABLES.deployments,
      { projectId },
      { orderBy: 'created_at DESC' }
    );
  }

  async listDeploymentsByType(projectId: string, type: DeploymentType): Promise<Deployment[]> {
    return this.db.findBy<Deployment>(
      TABLES.deployments,
      { projectId, type },
      { orderBy: 'created_at DESC' }
    );
  }

  async listActiveDeployments(projectId: string): Promise<Deployment[]> {
    return this.db.findBy<Deployment>(
      TABLES.deployments,
      { projectId, status: ['running', 'building', 'pending'] },
      { orderBy: 'created_at DESC' }
    );
  }

  async listPreviewDeployments(projectId: string): Promise<Deployment[]> {
    return this.listDeploymentsByType(projectId, 'preview');
  }

  async cleanupExpiredPreviews(): Promise<number> {
    const sql = `
      DELETE FROM "${this.db.schemaName}"."${TABLES.deployments}"
      WHERE type = 'preview' AND expires_at < NOW()
      RETURNING id
    `;
    const result = await this.db.query<{ id: string }>(sql);
    return result.length;
  }
}
```

#### 6.6 Create src/domains/builds.ts

```typescript
import type { Build } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export type BuildTrigger = 'manual' | 'webhook' | 'schedule' | 'rollback';
export type BuildStatus = 'queued' | 'building' | 'deploying' | 'succeeded' | 'failed' | 'cancelled';

export class BuildsPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.builds] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  async createBuild(data: Omit<Build, 'id' | 'createdAt'>): Promise<Build> {
    return this.db.insert<Build>(TABLES.builds, {
      ...data,
      status: data.status || 'queued',
      queuedAt: data.queuedAt || new Date(),
    });
  }

  async getBuildById(id: string): Promise<Build | null> {
    return this.db.findById<Build>(TABLES.builds, id);
  }

  async updateBuild(id: string, data: Partial<Build>): Promise<Build | null> {
    return this.db.update<Build>(TABLES.builds, id, data);
  }

  async updateBuildStatus(id: string, status: BuildStatus): Promise<Build | null> {
    const updates: Partial<Build> = { status };

    if (status === 'building') {
      updates.startedAt = new Date();
    } else if (['succeeded', 'failed', 'cancelled'].includes(status)) {
      updates.completedAt = new Date();
    }

    return this.updateBuild(id, updates);
  }

  async appendBuildLogs(id: string, logs: string): Promise<void> {
    const sql = `
      UPDATE "${this.db.schemaName}"."${TABLES.builds}"
      SET logs = COALESCE(logs, '') || $1
      WHERE id = $2
    `;
    await this.db.db.none(sql, [logs, id]);
  }

  async setBuildError(id: string, errorMessage: string): Promise<Build | null> {
    return this.updateBuild(id, {
      status: 'failed',
      errorMessage,
      completedAt: new Date(),
    });
  }

  async deleteBuild(id: string): Promise<boolean> {
    return this.db.delete(TABLES.builds, id);
  }

  async listBuilds(deploymentId: string, options?: { limit?: number }): Promise<Build[]> {
    return this.db.findBy<Build>(
      TABLES.builds,
      { deploymentId },
      { orderBy: 'created_at DESC', limit: options?.limit }
    );
  }

  // Build queue operations
  async enqueue(
    deploymentId: string,
    trigger: BuildTrigger,
    triggeredBy: string,
    commitSha?: string,
    commitMessage?: string
  ): Promise<Build> {
    return this.createBuild({
      deploymentId,
      trigger,
      triggeredBy,
      commitSha: commitSha ?? null,
      commitMessage: commitMessage ?? null,
      status: 'queued',
      logs: '',
      errorMessage: null,
      queuedAt: new Date(),
      startedAt: null,
      completedAt: null,
    });
  }

  async dequeue(): Promise<Build | null> {
    // Use FOR UPDATE SKIP LOCKED for concurrent queue access
    const sql = `
      UPDATE "${this.db.schemaName}"."${TABLES.builds}"
      SET status = 'building', started_at = NOW()
      WHERE id = (
        SELECT id FROM "${this.db.schemaName}"."${TABLES.builds}"
        WHERE status = 'queued'
        ORDER BY queued_at ASC
        FOR UPDATE SKIP LOCKED
        LIMIT 1
      )
      RETURNING *
    `;
    const rows = await this.db.query<Build>(sql);
    return rows[0] || null;
  }

  async getQueuePosition(buildId: string): Promise<number> {
    const build = await this.getBuildById(buildId);
    if (!build || build.status !== 'queued') return -1;

    const sql = `
      SELECT COUNT(*) as position
      FROM "${this.db.schemaName}"."${TABLES.builds}"
      WHERE status = 'queued' AND queued_at < $1
    `;
    const result = await this.db.db.one<{ position: string }>(sql, [build.queuedAt]);
    return parseInt(result.position, 10) + 1;
  }

  async getQueueLength(): Promise<number> {
    return this.db.count(TABLES.builds, { status: 'queued' });
  }

  async cancelQueuedBuilds(deploymentId: string): Promise<number> {
    const sql = `
      UPDATE "${this.db.schemaName}"."${TABLES.builds}"
      SET status = 'cancelled', completed_at = NOW()
      WHERE deployment_id = $1 AND status = 'queued'
      RETURNING id
    `;
    const result = await this.db.query<{ id: string }>(sql, [deploymentId]);
    return result.length;
  }
}
```

#### 6.7 Create src/domains/servers.ts

```typescript
import type { RunningServer } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export type HealthStatus = 'starting' | 'healthy' | 'unhealthy' | 'stopping';

export class RunningServersPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.running_servers] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  async registerServer(
    data: Omit<RunningServer, 'id' | 'startedAt' | 'stoppedAt'>
  ): Promise<RunningServer> {
    return this.db.insert<RunningServer>(TABLES.running_servers, {
      ...data,
      healthStatus: data.healthStatus || 'starting',
    });
  }

  async getServerById(id: string): Promise<RunningServer | null> {
    return this.db.findById<RunningServer>(TABLES.running_servers, id);
  }

  async getServerByDeployment(deploymentId: string): Promise<RunningServer | null> {
    return this.db.findOneBy<RunningServer>(TABLES.running_servers, {
      deploymentId,
      stoppedAt: null,
    });
  }

  async updateServer(id: string, data: Partial<RunningServer>): Promise<RunningServer | null> {
    return this.db.update<RunningServer>(TABLES.running_servers, id, data);
  }

  async updateHealthStatus(
    id: string,
    status: HealthStatus,
    metrics?: { memoryUsageMb?: number; cpuPercent?: number }
  ): Promise<RunningServer | null> {
    return this.updateServer(id, {
      healthStatus: status,
      lastHealthCheck: new Date(),
      ...metrics,
    });
  }

  async stopServer(id: string): Promise<RunningServer | null> {
    return this.updateServer(id, {
      healthStatus: 'stopping',
      stoppedAt: new Date(),
    });
  }

  async listRunningServers(deploymentId?: string): Promise<RunningServer[]> {
    const conditions: Record<string, unknown> = { stoppedAt: null };
    if (deploymentId) {
      conditions.deploymentId = deploymentId;
    }
    return this.db.findBy<RunningServer>(
      TABLES.running_servers,
      conditions,
      { orderBy: 'started_at DESC' }
    );
  }

  async listAllServers(deploymentId: string, options?: { limit?: number }): Promise<RunningServer[]> {
    return this.db.findBy<RunningServer>(
      TABLES.running_servers,
      { deploymentId },
      { orderBy: 'started_at DESC', limit: options?.limit }
    );
  }

  async getUnhealthyServers(thresholdMinutes: number = 5): Promise<RunningServer[]> {
    const sql = `
      SELECT * FROM "${this.db.schemaName}"."${TABLES.running_servers}"
      WHERE stopped_at IS NULL
        AND (
          health_status = 'unhealthy'
          OR (last_health_check IS NOT NULL AND last_health_check < NOW() - INTERVAL '${thresholdMinutes} minutes')
        )
      ORDER BY started_at DESC
    `;
    return this.db.query<RunningServer>(sql);
  }

  async cleanupStoppedServers(olderThanDays: number = 7): Promise<number> {
    const sql = `
      DELETE FROM "${this.db.schemaName}"."${TABLES.running_servers}"
      WHERE stopped_at IS NOT NULL
        AND stopped_at < NOW() - INTERVAL '${olderThanDays} days'
      RETURNING id
    `;
    const result = await this.db.query<{ id: string }>(sql);
    return result.length;
  }
}
```

#### 6.8 Create src/domains/routes.ts

```typescript
import type { RouteInfo, RouteConfig } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export type RouteStatus = 'pending' | 'active' | 'unhealthy' | 'error';

// Internal database representation
interface RouteRecord {
  id: string;
  deploymentId: string;
  projectId: string;
  subdomain: string;
  targetHost: string;
  targetPort: number;
  publicUrl: string;
  status: RouteStatus;
  tlsEnabled: boolean;
  providerRouteId: string | null;
  metadata: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
  lastHealthCheck: Date | null;
}

export class RoutesPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.routes] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  async createRoute(
    config: RouteConfig & { publicUrl: string }
  ): Promise<RouteInfo> {
    const record = await this.db.insert<RouteRecord>(TABLES.routes, {
      deploymentId: config.deploymentId,
      projectId: config.projectId,
      subdomain: config.subdomain,
      targetHost: config.targetHost,
      targetPort: config.targetPort,
      publicUrl: config.publicUrl,
      status: 'pending',
      tlsEnabled: config.tls ?? true,
      providerRouteId: null,
      metadata: {},
    });

    return this.toRouteInfo(record);
  }

  async getRouteById(id: string): Promise<RouteInfo | null> {
    const record = await this.db.findById<RouteRecord>(TABLES.routes, id);
    return record ? this.toRouteInfo(record) : null;
  }

  async getRouteByDeployment(deploymentId: string): Promise<RouteInfo | null> {
    const record = await this.db.findOneBy<RouteRecord>(TABLES.routes, { deploymentId });
    return record ? this.toRouteInfo(record) : null;
  }

  async getRouteBySubdomain(subdomain: string): Promise<RouteInfo | null> {
    const record = await this.db.findOneBy<RouteRecord>(TABLES.routes, { subdomain });
    return record ? this.toRouteInfo(record) : null;
  }

  async updateRoute(
    id: string,
    data: Partial<RouteConfig>
  ): Promise<RouteInfo | null> {
    const record = await this.db.update<RouteRecord>(TABLES.routes, id, data);
    return record ? this.toRouteInfo(record) : null;
  }

  async updateRouteStatus(id: string, status: RouteStatus): Promise<RouteInfo | null> {
    const record = await this.db.update<RouteRecord>(TABLES.routes, id, { status });
    return record ? this.toRouteInfo(record) : null;
  }

  async updateRouteHealth(id: string, healthy: boolean): Promise<RouteInfo | null> {
    const record = await this.db.update<RouteRecord>(TABLES.routes, id, {
      status: healthy ? 'active' : 'unhealthy',
      lastHealthCheck: new Date(),
    });
    return record ? this.toRouteInfo(record) : null;
  }

  async setProviderRouteId(id: string, providerRouteId: string): Promise<RouteInfo | null> {
    const record = await this.db.update<RouteRecord>(TABLES.routes, id, { providerRouteId });
    return record ? this.toRouteInfo(record) : null;
  }

  async deleteRoute(id: string): Promise<boolean> {
    return this.db.delete(TABLES.routes, id);
  }

  async listRoutes(projectId: string): Promise<RouteInfo[]> {
    const records = await this.db.findBy<RouteRecord>(
      TABLES.routes,
      { projectId },
      { orderBy: 'created_at DESC' }
    );
    return records.map(r => this.toRouteInfo(r));
  }

  async listActiveRoutes(): Promise<RouteInfo[]> {
    const records = await this.db.findBy<RouteRecord>(
      TABLES.routes,
      { status: 'active' },
      { orderBy: 'subdomain' }
    );
    return records.map(r => this.toRouteInfo(r));
  }

  private toRouteInfo(record: RouteRecord): RouteInfo {
    return {
      routeId: record.id,
      deploymentId: record.deploymentId,
      publicUrl: record.publicUrl,
      status: record.status,
      createdAt: record.createdAt,
      lastHealthCheck: record.lastHealthCheck ?? undefined,
    };
  }
}
```

#### 6.9 Create src/domains/rbac.ts

```typescript
import type { Role, RoleAssignment } from '@mastra/admin';
import { AdminPgDB, TABLES } from '../db';
import type { PgDomainConfig } from './utils';
import { resolvePgConfig } from './utils';

export class RbacPG {
  private db: AdminPgDB;

  static readonly MANAGED_TABLES = [TABLES.roles, TABLES.role_assignments] as const;

  constructor(config: PgDomainConfig) {
    const { client, schemaName, skipDefaultIndexes } = resolvePgConfig(config);
    this.db = new AdminPgDB({ client, schemaName, skipDefaultIndexes });
  }

  // Role operations
  async createRole(data: Omit<Role, 'id' | 'createdAt' | 'updatedAt'>): Promise<Role> {
    return this.db.insert<Role>(TABLES.roles, data);
  }

  async getRoleById(id: string): Promise<Role | null> {
    return this.db.findById<Role>(TABLES.roles, id);
  }

  async getRoleByName(teamId: string | null, name: string): Promise<Role | null> {
    return this.db.findOneBy<Role>(TABLES.roles, { teamId, name });
  }

  async updateRole(id: string, data: Partial<Role>): Promise<Role | null> {
    return this.db.update<Role>(TABLES.roles, id, data);
  }

  async deleteRole(id: string): Promise<boolean> {
    return this.db.delete(TABLES.roles, id);
  }

  async listRoles(teamId?: string): Promise<Role[]> {
    if (teamId) {
      // Team-specific + system roles
      const sql = `
        SELECT * FROM "${this.db.schemaName}"."${TABLES.roles}"
        WHERE team_id = $1 OR is_system = true
        ORDER BY is_system DESC, name
      `;
      return this.db.query<Role>(sql, [teamId]);
    }
    return this.db.findBy<Role>(TABLES.roles, {}, { orderBy: 'name' });
  }

  async listSystemRoles(): Promise<Role[]> {
    return this.db.findBy<Role>(TABLES.roles, { isSystem: true });
  }

  // Role assignment operations
  async assignRole(
    data: Omit<RoleAssignment, 'id' | 'createdAt'>
  ): Promise<RoleAssignment> {
    return this.db.insert<RoleAssignment>(TABLES.role_assignments, data);
  }

  async removeRoleAssignment(
    roleId: string,
    userId: string,
    resourceType?: string,
    resourceId?: string
  ): Promise<boolean> {
    const assignment = await this.db.findOneBy<RoleAssignment>(TABLES.role_assignments, {
      roleId,
      userId,
      resourceType: resourceType ?? null,
      resourceId: resourceId ?? null,
    });
    if (!assignment) return false;
    return this.db.delete(TABLES.role_assignments, assignment.id);
  }

  async getUserRoleAssignments(userId: string): Promise<RoleAssignment[]> {
    return this.db.findBy<RoleAssignment>(TABLES.role_assignments, { userId });
  }

  async getUserRolesForResource(
    userId: string,
    resourceType: string,
    resourceId: string
  ): Promise<Role[]> {
    const sql = `
      SELECT r.* FROM "${this.db.schemaName}"."${TABLES.roles}" r
      INNER JOIN "${this.db.schemaName}"."${TABLES.role_assignments}" ra ON r.id = ra.role_id
      WHERE ra.user_id = $1
        AND (
          (ra.resource_type IS NULL AND ra.resource_id IS NULL)
          OR (ra.resource_type = $2 AND ra.resource_id = $3)
        )
    `;
    return this.db.query<Role>(sql, [userId, resourceType, resourceId]);
  }

  async hasPermission(
    userId: string,
    permission: string,
    resourceType?: string,
    resourceId?: string
  ): Promise<boolean> {
    const roles = resourceType && resourceId
      ? await this.getUserRolesForResource(userId, resourceType, resourceId)
      : await this.getUserRoles(userId);

    return roles.some(role =>
      Array.isArray(role.permissions) && role.permissions.includes(permission)
    );
  }

  private async getUserRoles(userId: string): Promise<Role[]> {
    const sql = `
      SELECT r.* FROM "${this.db.schemaName}"."${TABLES.roles}" r
      INNER JOIN "${this.db.schemaName}"."${TABLES.role_assignments}" ra ON r.id = ra.role_id
      WHERE ra.user_id = $1
    `;
    return this.db.query<Role>(sql, [userId]);
  }

  // Initialize system roles
  async initializeSystemRoles(): Promise<void> {
    const systemRoles = [
      {
        name: 'platform_admin',
        description: 'Full platform administration access',
        permissions: ['*'],
        isSystem: true,
        teamId: null,
      },
      {
        name: 'team_owner',
        description: 'Full team access including member management',
        permissions: [
          'team:read', 'team:update', 'team:delete',
          'team:members:read', 'team:members:write',
          'project:*', 'deployment:*', 'build:*',
        ],
        isSystem: true,
        teamId: null,
      },
      {
        name: 'team_admin',
        description: 'Team administration without deletion',
        permissions: [
          'team:read', 'team:update',
          'team:members:read', 'team:members:write',
          'project:*', 'deployment:*', 'build:*',
        ],
        isSystem: true,
        teamId: null,
      },
      {
        name: 'team_member',
        description: 'Standard team member access',
        permissions: [
          'team:read',
          'project:read', 'project:create', 'project:update',
          'deployment:read', 'deployment:create',
          'build:read', 'build:create',
        ],
        isSystem: true,
        teamId: null,
      },
      {
        name: 'team_viewer',
        description: 'Read-only team access',
        permissions: [
          'team:read',
          'project:read',
          'deployment:read',
          'build:read',
        ],
        isSystem: true,
        teamId: null,
      },
    ];

    for (const role of systemRoles) {
      const existing = await this.getRoleByName(null, role.name);
      if (!existing) {
        await this.createRole(role);
      }
    }
  }
}
```

---

### Phase 7: Main Storage Class

#### 7.1 Create src/storage.ts

```typescript
import { Pool } from 'pg';
import type { AdminStorage } from '@mastra/admin';
import { PoolAdapter, type DbClient } from './client';
import { AdminPgDB } from './db';
import {
  type PostgresAdminStorageConfig,
  isPoolConfig,
  isConnectionStringConfig,
  isHostConfig,
  validateConfig,
  parseSqlIdentifier,
} from './shared/config';
import { UsersPG } from './domains/users';
import { TeamsPG } from './domains/teams';
import { ProjectsPG } from './domains/projects';
import { DeploymentsPG } from './domains/deployments';
import { BuildsPG } from './domains/builds';
import { RunningServersPG } from './domains/servers';
import { RoutesPG } from './domains/routes';
import { RbacPG } from './domains/rbac';

/**
 * PostgreSQL storage implementation for MastraAdmin
 */
export class PostgresAdminStorage implements AdminStorage {
  readonly type = 'postgres' as const;

  private pool: Pool;
  private client: DbClient;
  private adminDb: AdminPgDB;
  private ownsPool: boolean;
  private schema: string;
  private isInitialized = false;
  private config: PostgresAdminStorageConfig;

  // Domain stores
  readonly users: UsersPG;
  readonly teams: TeamsPG;
  readonly projects: ProjectsPG;
  readonly deployments: DeploymentsPG;
  readonly builds: BuildsPG;
  readonly servers: RunningServersPG;
  readonly routes: RoutesPG;
  readonly rbac: RbacPG;

  constructor(config: PostgresAdminStorageConfig) {
    validateConfig(config);
    this.config = config;

    this.schema = config.schemaName
      ? parseSqlIdentifier(config.schemaName, 'schema')
      : 'mastra_admin';

    // Create or wrap pool
    if (isPoolConfig(config)) {
      this.pool = config.pool;
      this.ownsPool = false;
    } else {
      this.pool = this.createPool(config);
      this.ownsPool = true;
    }

    this.client = new PoolAdapter(this.pool);

    // Create domain config
    const domainConfig = {
      client: this.client,
      schemaName: this.schema,
      skipDefaultIndexes: config.skipDefaultIndexes,
    };

    // Initialize domain stores
    this.users = new UsersPG(domainConfig);
    this.teams = new TeamsPG(domainConfig);
    this.projects = new ProjectsPG(domainConfig);
    this.deployments = new DeploymentsPG(domainConfig);
    this.builds = new BuildsPG(domainConfig);
    this.servers = new RunningServersPG(domainConfig);
    this.routes = new RoutesPG(domainConfig);
    this.rbac = new RbacPG(domainConfig);

    // Create admin db for initialization
    this.adminDb = new AdminPgDB(domainConfig);
  }

  /**
   * Create PostgreSQL connection pool
   */
  private createPool(config: PostgresAdminStorageConfig): Pool {
    if (isConnectionStringConfig(config)) {
      return new Pool({
        connectionString: config.connectionString,
        max: 20,
        idleTimeoutMillis: 30000,
      });
    }

    if (isHostConfig(config)) {
      return new Pool({
        host: config.host,
        port: config.port,
        database: config.database,
        user: config.user,
        password: config.password,
        ssl: config.ssl,
        max: 20,
        idleTimeoutMillis: 30000,
      });
    }

    throw new Error('Invalid configuration');
  }

  /**
   * Initialize storage (create tables, indexes, etc.)
   */
  async init(): Promise<void> {
    if (this.isInitialized) return;
    if (this.config.disableInit) {
      this.isInitialized = true;
      return;
    }

    await this.adminDb.init();
    await this.rbac.initializeSystemRoles();
    this.isInitialized = true;
  }

  /**
   * Close the connection pool
   */
  async close(): Promise<void> {
    if (this.ownsPool) {
      await this.pool.end();
    }
  }

  /**
   * Get raw database client for advanced operations
   */
  get db(): DbClient {
    return this.client;
  }

  /**
   * Get raw pool for ORM integration
   */
  get rawPool(): Pool {
    return this.pool;
  }

  /**
   * Get schema name
   */
  get schemaName(): string {
    return this.schema;
  }
}
```

---

### Phase 8: Package Exports

#### 8.1 Create src/index.ts

```typescript
// Main storage class
export { PostgresAdminStorage } from './storage';

// Configuration types
export type {
  PostgresAdminStorageConfig,
  PostgresAdminBaseConfig,
  PoolInstanceConfig,
  ConnectionStringConfig,
  HostConfig,
} from './shared/config';

// Client types
export type { DbClient, TxClient, QueryValues } from './client';
export { PoolAdapter } from './client';

// Domain classes (for advanced usage)
export { UsersPG } from './domains/users';
export { TeamsPG } from './domains/teams';
export { ProjectsPG } from './domains/projects';
export { DeploymentsPG } from './domains/deployments';
export { BuildsPG } from './domains/builds';
export { RunningServersPG } from './domains/servers';
export { RoutesPG } from './domains/routes';
export { RbacPG } from './domains/rbac';

// Database utilities
export { AdminPgDB, TABLES, type TableName } from './db';

// Migration schemas (for external tooling)
export { TABLE_SCHEMAS, DEFAULT_INDEXES } from './migrations/001_initial';
```

---

## Success Criteria

### Automated Verification

- [ ] Package builds successfully: `cd stores/admin-pg && pnpm build`
- [ ] TypeScript types compile: `pnpm typecheck`
- [ ] Linting passes: `pnpm lint`
- [ ] Unit tests pass: `pnpm test`

### Manual Verification

- [ ] Can create PostgresAdminStorage with connection string
- [ ] Can create PostgresAdminStorage with host config
- [ ] Can create PostgresAdminStorage with existing pool
- [ ] All tables are created on init()
- [ ] All indexes are created on init()
- [ ] System roles are initialized
- [ ] CRUD operations work for all domains:
  - [ ] Users
  - [ ] Teams and members
  - [ ] Projects and env vars
  - [ ] Deployments
  - [ ] Builds (including queue operations)
  - [ ] Running servers
  - [ ] Routes
  - [ ] RBAC roles and assignments
- [ ] Build queue correctly orders by queued_at
- [ ] Build dequeue uses FOR UPDATE SKIP LOCKED
- [ ] Transactions work correctly
- [ ] Connection pool is properly closed

### Integration Tests to Write

1. **Storage initialization**
   - Creates schema if not exists
   - Creates all tables
   - Creates all indexes
   - Initializes system roles

2. **User operations**
   - Create, read, update, delete user
   - Find by email/external ID

3. **Team operations**
   - Create team with owner
   - Add/remove members
   - Create/accept invites
   - Manage installations

4. **Project operations**
   - Create project
   - Set/get env vars
   - Create/validate API tokens

5. **Deployment lifecycle**
   - Create production/staging/preview deployments
   - Update status transitions
   - List by type/status

6. **Build queue**
   - Enqueue builds
   - Dequeue respects FIFO
   - Concurrent dequeue safety
   - Queue position calculation

7. **Server management**
   - Register running server
   - Update health status
   - Stop server
   - Cleanup old servers

8. **Route management**
   - Create route
   - Update target
   - Health check updates

9. **RBAC**
   - Assign roles
   - Check permissions
   - Resource-scoped permissions

---

## Dependencies on LANE 1

This package depends on types from `@mastra/admin`:

```typescript
// Types needed from @mastra/admin
import type {
  AdminStorage,
  User,
  Team,
  TeamMember,
  TeamInvite,
  TeamInstallation,
  Project,
  ProjectEnvVar,
  ProjectApiToken,
  Deployment,
  Build,
  RunningServer,
  RouteInfo,
  RouteConfig,
  Role,
  RoleAssignment,
} from '@mastra/admin';
```

The `AdminStorage` interface in LANE 1 should define:

```typescript
export interface AdminStorage {
  readonly type: string;

  init(): Promise<void>;
  close(): Promise<void>;

  readonly users: UserStorage;
  readonly teams: TeamStorage;
  readonly projects: ProjectStorage;
  readonly deployments: DeploymentStorage;
  readonly builds: BuildStorage;
  readonly servers: RunningServerStorage;
  readonly routes: RouteStorage;
  readonly rbac: RbacStorage;
}
```

---

## Notes

1. **Schema naming**: Uses `mastra_admin` by default to avoid conflicts with existing Mastra tables
2. **Table prefixes**: All tables prefixed with `admin_` for clarity
3. **Foreign keys**: Full referential integrity with CASCADE deletes
4. **Indexes**: Comprehensive indexes for common query patterns
5. **Build queue**: Uses PostgreSQL's `FOR UPDATE SKIP LOCKED` for concurrent-safe dequeue
6. **Timestamps**: Uses `TIMESTAMPTZ` for timezone-aware timestamps
7. **JSONB**: Used for flexible metadata, settings, and permissions storage
