/**
 * Auto-generated Drizzle schema for Mastra tables.
 *
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Regenerate with: pnpm generate:drizzle
 *
 * @generated
 */
import {
  pgTable,
  pgSchema,
  text,
  jsonb,
  timestamp,
  index,
  doublePrecision,
  unique,
  primaryKey,
  boolean,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { relations } from 'drizzle-orm/relations';

export interface MastraSchemaConfig {
  /** PostgreSQL schema name (e.g., 'mastra'). Defaults to 'public'. */
  schemaName?: string;
}

export function createMastraSchema(config?: MastraSchemaConfig) {
  const schemaName = config?.schemaName;
  const table = (schemaName ? pgSchema(schemaName).table : pgTable) as typeof pgTable;
  const mastraAgents = table('mastra_agents', {
    id: text().primaryKey().notNull(),
    name: text().notNull(),
    description: text(),
    instructions: text().notNull(),
    model: jsonb().notNull(),
    tools: jsonb(),
    defaultOptions: jsonb(),
    workflows: jsonb(),
    agents: jsonb(),
    inputProcessors: jsonb(),
    outputProcessors: jsonb(),
    memory: jsonb(),
    scorers: jsonb(),
    metadata: jsonb(),
    createdAt: timestamp({ mode: 'string' }).notNull(),
    updatedAt: timestamp({ mode: 'string' }).notNull(),
    createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
  });

  const mastraThreads = table(
    'mastra_threads',
    {
      id: text().primaryKey().notNull(),
      resourceId: text().notNull(),
      title: text().notNull(),
      metadata: jsonb(),
      createdAt: timestamp({ mode: 'string' }).notNull(),
      updatedAt: timestamp({ mode: 'string' }).notNull(),
      createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    },
    table => [
      index('mastra_threads_resourceid_createdat_idx').using(
        'btree',
        table.resourceId.asc().nullsLast(),
        table.createdAt.desc().nullsFirst(),
      ),
    ],
  );

  const mastraMessages = table(
    'mastra_messages',
    {
      id: text().primaryKey().notNull(),
      threadId: text('thread_id').notNull(),
      content: text().notNull(),
      role: text().notNull(),
      type: text().notNull(),
      createdAt: timestamp({ mode: 'string' }).notNull(),
      resourceId: text(),
      createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    },
    table => [
      index('mastra_messages_thread_id_createdat_idx').using(
        'btree',
        table.threadId.asc().nullsLast(),
        table.createdAt.desc().nullsFirst(),
      ),
    ],
  );

  const mastraResources = table('mastra_resources', {
    id: text().primaryKey().notNull(),
    workingMemory: text(),
    metadata: jsonb(),
    createdAt: timestamp({ mode: 'string' }).notNull(),
    updatedAt: timestamp({ mode: 'string' }).notNull(),
    createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
  });

  const mastraScorers = table(
    'mastra_scorers',
    {
      id: text().primaryKey().notNull(),
      scorerId: text().notNull(),
      traceId: text(),
      spanId: text(),
      runId: text().notNull(),
      scorer: jsonb().notNull(),
      preprocessStepResult: jsonb(),
      extractStepResult: jsonb(),
      analyzeStepResult: jsonb(),
      score: doublePrecision().notNull(),
      reason: text(),
      metadata: jsonb(),
      preprocessPrompt: text(),
      extractPrompt: text(),
      generateScorePrompt: text(),
      generateReasonPrompt: text(),
      analyzePrompt: text(),
      reasonPrompt: text(),
      input: jsonb().notNull(),
      output: jsonb().notNull(),
      additionalContext: jsonb(),
      requestContext: jsonb(),
      entityType: text(),
      entity: jsonb(),
      entityId: text(),
      source: text().notNull(),
      resourceId: text(),
      threadId: text(),
      createdAt: timestamp({ mode: 'string' }).notNull(),
      updatedAt: timestamp({ mode: 'string' }).notNull(),
      createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    },
    table => [
      index('mastra_scores_trace_id_span_id_created_at_idx').using(
        'btree',
        table.traceId.asc().nullsLast(),
        table.spanId.asc().nullsLast(),
        table.createdAt.desc().nullsFirst(),
      ),
    ],
  );

  const mastraWorkflowSnapshot = table(
    'mastra_workflow_snapshot',
    {
      workflowName: text('workflow_name').notNull(),
      runId: text('run_id').notNull(),
      resourceId: text(),
      snapshot: jsonb().notNull(),
      createdAt: timestamp({ mode: 'string' }).notNull(),
      updatedAt: timestamp({ mode: 'string' }).notNull(),
      createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    },
    table => [unique('mastra_workflow_snapshot_workflow_name_run_id_key').on(table.workflowName, table.runId)],
  );

  const mastraAiSpans = table(
    'mastra_ai_spans',
    {
      traceId: text().notNull(),
      spanId: text().notNull(),
      name: text().notNull(),
      spanType: text().notNull(),
      isEvent: boolean().notNull(),
      startedAt: timestamp({ mode: 'string' }).notNull(),
      parentSpanId: text(),
      entityType: text(),
      entityId: text(),
      entityName: text(),
      userId: text(),
      organizationId: text(),
      resourceId: text(),
      runId: text(),
      sessionId: text(),
      threadId: text(),
      requestId: text(),
      environment: text(),
      source: text(),
      serviceName: text(),
      scope: jsonb(),
      metadata: jsonb(),
      tags: jsonb(),
      attributes: jsonb(),
      links: jsonb(),
      input: jsonb(),
      output: jsonb(),
      error: jsonb(),
      endedAt: timestamp({ mode: 'string' }),
      createdAt: timestamp({ mode: 'string' }).notNull(),
      updatedAt: timestamp({ mode: 'string' }),
      startedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      endedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      createdAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
      updatedAtZ: timestamp({ withTimezone: true, mode: 'string' }).defaultNow(),
    },
    table => [
      index('mastra_ai_spans_entitytype_entityid_idx').using(
        'btree',
        table.entityType.asc().nullsLast(),
        table.entityId.asc().nullsLast(),
      ),
      index('mastra_ai_spans_entitytype_entityname_idx').using(
        'btree',
        table.entityType.asc().nullsLast(),
        table.entityName.asc().nullsLast(),
      ),
      index('mastra_ai_spans_metadata_gin_idx').using('gin', table.metadata.asc().nullsLast()),
      index('mastra_ai_spans_name_idx').using('btree', table.name.asc().nullsLast()),
      index('mastra_ai_spans_orgid_userid_idx').using(
        'btree',
        table.organizationId.asc().nullsLast(),
        table.userId.asc().nullsLast(),
      ),
      index('mastra_ai_spans_parentspanid_startedat_idx').using(
        'btree',
        table.parentSpanId.asc().nullsLast(),
        table.startedAt.desc().nullsFirst(),
      ),
      index('mastra_ai_spans_root_spans_idx')
        .using('btree', table.startedAt.desc().nullsFirst())
        .where(sql`("parentSpanId" IS NULL)`),
      index('mastra_ai_spans_spantype_startedat_idx').using(
        'btree',
        table.spanType.asc().nullsLast(),
        table.startedAt.desc().nullsFirst(),
      ),
      index('mastra_ai_spans_tags_gin_idx').using('gin', table.tags.asc().nullsLast()),
      index('mastra_ai_spans_traceid_startedat_idx').using(
        'btree',
        table.traceId.asc().nullsLast(),
        table.startedAt.desc().nullsFirst(),
      ),
      primaryKey({ columns: [table.traceId, table.spanId], name: 'mastra_ai_spans_traceid_spanid_pk' }),
    ],
  );
  return {
    mastraAgents,
    mastraThreads,
    mastraMessages,
    mastraResources,
    mastraScorers,
    mastraWorkflowSnapshot,
    mastraAiSpans,
  };
}

/** Type representing all Mastra tables. Use for compile-time safety. */
export type MastraSchema = ReturnType<typeof createMastraSchema>;

/**
 * Create Drizzle relations for the Mastra schema.
 * Pass the schema from createMastraSchema() to get typed relations.
 */
export function createMastraRelations(schema: MastraSchema) {
  const {} = schema;

  return {};
}

/** Type representing Mastra relations. */
export type MastraRelations = ReturnType<typeof createMastraRelations>;
