# Memory in Workflows

Mastra's memory system integrates seamlessly with workflows, allowing you to maintain context across multiple steps and agent interactions. This section explains how to use memory within Mastra workflows.

## Understanding Memory in Workflows

In Mastra workflows:
- Each workflow step can access shared memory context
- Memory persists across steps in the workflow
- Multiple agents can share memory within a single workflow
- Context and conversation history are maintained throughout the process

This enables complex multi-step interactions where context is preserved, such as:
- Multi-stage customer support interactions
- Data collection and processing pipelines
- Collaborative tasks involving multiple specialized agents

## Workflow Memory Architecture

When using memory in workflows, the memory context is managed at the workflow level:

```
┌──────────────────────────────────────────────────────────┐
│                      Workflow                             │
│                                                           │
│  ┌─────────┐        ┌─────────┐        ┌─────────┐       │
│  │ Step 1  │───────►│ Step 2  │───────►│ Step 3  │       │
│  └─────────┘        └─────────┘        └─────────┘       │
│       │                  │                  │            │
│       ▼                  ▼                  ▼            │
│  ┌─────────────────────────────────────────────────┐    │
│  │                Shared Memory                     │    │
│  └─────────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────────┘
```

## Setting Up Memory in Workflows

To use memory in workflows, configure the memory instance and pass it to the workflow:

```typescript
import { Workflow } from "@mastra/core/workflow";
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

// Create a shared memory instance
const memory = new Memory();

// Create agents with shared memory
const intakeAgent = new Agent({
  name: "IntakeAgent",
  instructions: "You collect initial information from users.",
  model: openai("gpt-4o"),
  memory: memory,
});

const processingAgent = new Agent({
  name: "ProcessingAgent",
  instructions: "You process the information collected by the intake agent.",
  model: openai("gpt-4o"),
  memory: memory,
});

// Define a workflow that uses these agents
const supportWorkflow = new Workflow({
  id: "customer_support",
  steps: {
    intake: {
      agent: intakeAgent,
      next: "processing",
    },
    processing: {
      agent: processingAgent,
      next: "end",
    },
  },
});
```

## Using Memory in Workflow Steps

Each workflow step should use the same `resourceId` and `threadId` to maintain context:

```typescript
// Starting a workflow with memory
const instance = await supportWorkflow.start({
  input: "I need help with my subscription",
  metadata: {
    resourceId: "customer_123",
    threadId: "support_456",
  },
});

// The resourceId and threadId are passed to each step
// Each agent receives the memory context from previous steps
```

## Working with Step-Specific Context

Sometimes you want to maintain both shared context and step-specific context:

```typescript
// Define a workflow with memory scoping
const complexWorkflow = new Workflow({
  id: "complex_support",
  steps: {
    intake: {
      agent: intakeAgent,
      next: "processing",
      execute: async (context) => {
        // Use shared memory thread
        const result = await intakeAgent.generate(context.input, {
          resourceId: context.metadata.resourceId,
          threadId: context.metadata.threadId,
        });
        
        return {
          output: result.content,
          metadata: {
            intakeData: { /* step-specific data */ },
          },
        };
      },
    },
    processing: {
      agent: processingAgent,
      next: "end",
      execute: async (context) => {
        // Access shared memory plus step-specific metadata
        const intakeData = context.metadata.intakeData;
        
        const result = await processingAgent.generate(
          `Process this request: ${context.input}. Intake data: ${JSON.stringify(intakeData)}`,
          {
            resourceId: context.metadata.resourceId,
            threadId: context.metadata.threadId,
          }
        );
        
        return {
          output: result.content,
        };
      },
    },
  },
});
```

## Memory with Step Inputs and Outputs

Workflow steps can pass inputs and outputs while maintaining memory context:

```typescript
// Define workflow with step inputs/outputs
const dataWorkflow = new Workflow({
  id: "data_processing",
  steps: {
    collect: {
      agent: dataCollectionAgent,
      next: "analyze",
      execute: async (context) => {
        const result = await dataCollectionAgent.generate("Collect user data", {
          resourceId: context.metadata.resourceId,
          threadId: context.metadata.threadId,
        });
        
        // Extract structured data from result
        const userData = JSON.parse(result.content);
        
        return {
          output: "Data collected successfully",
          userData, // Pass to next step
        };
      },
    },
    analyze: {
      agent: dataAnalysisAgent,
      next: "end",
      execute: async (context) => {
        // Access both memory context and passed data
        const { userData } = context;
        
        const result = await dataAnalysisAgent.generate(
          `Analyze this user data: ${JSON.stringify(userData)}`,
          {
            resourceId: context.metadata.resourceId,
            threadId: context.metadata.threadId,
          }
        );
        
        return {
          output: result.content,
        };
      },
    },
  },
});
```

## Working Memory in Workflows

Working memory is particularly useful in workflows to maintain persistent facts across steps:

```typescript
// Create memory with working memory enabled
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
    },
  },
});

// Working memory will be updated by agents across workflow steps
// Each agent can see and update the same working memory
```

## Best Practices for Memory in Workflows

1. **Use consistent IDs**: Always use the same `resourceId` and `threadId` across all steps
2. **Pass metadata**: Include memory identifiers in workflow metadata
3. **Consider memory scope**: Determine whether memory should be shared or isolated
4. **Optimize context**: Balance memory retrieval with token limitations
5. **Use working memory**: For maintaining critical facts across many steps
6. **Handle transitions**: Consider how context flows between human and automated steps

## Example: Customer Support Workflow with Memory

```typescript
import { Workflow } from "@mastra/core/workflow";
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

// Create a shared memory instance
const memory = new Memory({
  options: {
    workingMemory: { enabled: true },
  },
});

// Create specialized agents
const intakeAgent = new Agent({
  name: "IntakeAgent",
  instructions: "You collect initial information from users for support tickets.",
  model: openai("gpt-4o"),
  memory: memory,
});

const technicalAgent = new Agent({
  name: "TechnicalAgent",
  instructions: "You provide technical troubleshooting based on collected information.",
  model: openai("gpt-4o"),
  memory: memory,
});

const followupAgent = new Agent({
  name: "FollowupAgent",
  instructions: "You confirm the issue is resolved and gather feedback.",
  model: openai("gpt-4o"),
  memory: memory,
});

// Define support workflow
const supportWorkflow = new Workflow({
  id: "customer_support",
  steps: {
    intake: {
      agent: intakeAgent,
      next: "technical",
    },
    technical: {
      agent: technicalAgent,
      next: "followup",
    },
    followup: {
      agent: followupAgent,
      next: "end",
    },
  },
});

// Execute workflow with memory
const instance = await supportWorkflow.start({
  input: "I can't access my account after the recent update",
  metadata: {
    resourceId: "customer_789",
    threadId: "support_ticket_123",
  },
});

// Each step has access to the full conversation history
// Working memory preserves important user details across steps
```

## Related Features

- **[Memory Threads](../4-memory-threads/index.md)**: Understanding thread and resource concepts
- **[Working Memory](./3.3-working-memory.md)**: Maintaining persistent facts across workflow steps 