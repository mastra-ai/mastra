# Authentication with Memory Threads

Integrating authentication with Mastra's memory system is essential for building secure, multi-user applications. This section explains how to connect your authentication system with memory threads to create secure, personalized agent experiences.

## Memory and Authentication Concepts

Mastra's memory system ties naturally to authentication through:
- **resourceId**: Maps to authenticated user IDs
- **threadId**: Represents a specific conversation context
- **Access control**: Ensures users can only access their own threads

## Authentication Integration

### Connecting User Identity to ResourceId

A common pattern is to use the authenticated user's ID as the `resourceId` in memory operations:

```typescript
// Example using user ID as resourceId
async function handleAgentRequest(userId, message, threadId) {
  // Map authenticated user ID to resourceId
  const resourceId = `user_${userId}`;
  
  // Use this resourceId for memory operations
  const response = await agent.stream(message, {
    resourceId,
    threadId,
  });
  
  return response;
}
```

### Middleware-Based Authentication

In API routes, use middleware to authenticate users and attach identity information:

```typescript
import { Mastra } from '@mastra/core';
import { registerApiRoute } from "@mastra/core/server";

// Create an authentication middleware
const authMiddleware = async (c, next) => {
  // Get auth token from header
  const authHeader = c.req.header('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  
  try {
    // Verify JWT token (implement with your auth library)
    const token = authHeader.split(' ')[1];
    const user = verifyToken(token);
    
    // Attach user to context
    c.set('user', user);
    
    // Continue to route handler
    await next();
  } catch (error) {
    return c.json({ error: "Invalid token" }, 401);
  }
};

// Register protected route with authentication
export const mastra = new Mastra({
  server: {
    apiRoutes: [
      registerApiRoute('/api/chat', {
        method: 'POST',
        middleware: [authMiddleware],
        handler: async (c) => {
          // Get authenticated user
          const user = c.get('user');
          
          // Get request data
          const { message, threadId } = await c.req.json();
          
          // Use user ID as resourceId
          const resourceId = `user_${user.id}`;
          
          // Stream with user's memory
          const stream = await agent.stream(message, {
            resourceId,
            threadId: threadId || crypto.randomUUID(),
          });
          
          return stream.toDataStreamResponse();
        }
      })
    ]
  }
});
```

## Authentication Frameworks Integration

### Next.js with NextAuth.js/Auth.js

```typescript
// app/api/chat/route.ts
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";

export async function POST(request: Request) {
  // Get authenticated user session
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  
  const { message, threadId } = await request.json();
  
  // Use authenticated user ID as resourceId
  const resourceId = `user_${session.user.id}`;
  
  const stream = await agent.stream(message, {
    resourceId,
    threadId: threadId || crypto.randomUUID(),
  });
  
  return stream.toDataStreamResponse();
}
```

### Express with JWT

```typescript
import express from 'express';
import jwt from 'jsonwebtoken';

const app = express();
app.use(express.json());

// JWT middleware
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) return res.sendStatus(401);
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// Protected route
app.post('/api/chat', authenticateToken, async (req, res) => {
  const { message, threadId } = req.body;
  const resourceId = `user_${req.user.id}`;
  
  const stream = await agent.stream(message, {
    resourceId,
    threadId: threadId || crypto.randomUUID(),
  });
  
  stream.toReadableStream().pipe(res);
});
```

## Security Considerations

### Thread Access Control

Ensure users can only access their own threads:

```typescript
// Thread access middleware
const ensureThreadAccess = async (c, next) => {
  const user = c.get('user');
  const threadId = c.req.param('threadId');
  
  // Get thread from memory
  const thread = await memory.getThreadById({ threadId });
  
  // Verify thread exists and belongs to user
  if (!thread || thread.resourceId !== `user_${user.id}`) {
    return c.json({ error: "Thread not found or access denied" }, 404);
  }
  
  // Continue to handler
  await next();
};

// Apply to thread routes
registerApiRoute('/api/threads/:threadId', {
  method: 'GET',
  middleware: [authMiddleware, ensureThreadAccess],
  handler: async (c) => {
    // Safe to proceed - user owns the thread
    const threadId = c.req.param('threadId');
    // ...
  }
})
```

### JWT Best Practices

When using JWTs for authentication:
1. Keep tokens short-lived
2. Use HTTPS for all communication
3. Store sensitive user data in token claims only when necessary
4. Implement token refresh mechanisms
5. Use strong signing secrets

## Multi-Tenant Considerations

For applications serving multiple organizations:

```typescript
// Multi-tenant example
async function handleAgentRequest(userId, orgId, message, threadId) {
  // Include organization in resourceId
  const resourceId = `org_${orgId}:user_${userId}`;
  
  const response = await agent.stream(message, {
    resourceId,
    threadId,
  });
  
  return response;
}
```

## Working with Anonymous Users

For public-facing agents that still need memory:

```typescript
// Anonymous user support
function getResourceId(session) {
  if (session?.user) {
    // Authenticated user
    return `user_${session.user.id}`;
  } else {
    // Anonymous user - use session ID or device fingerprint
    return `anon_${session.id}`;
  }
}
```

## Frontend Integration

Client-side code needs to manage authentication tokens and thread IDs:

```typescript
// React component with auth integration
function ChatComponent() {
  const { data: session } = useSession();
  const [threadId, setThreadId] = useState(localStorage.getItem('threadId'));
  
  const handleSendMessage = async (message) => {
    if (!session) {
      // Handle unauthenticated user
      return;
    }
    
    // Create thread ID if not exists
    if (!threadId) {
      const newThreadId = crypto.randomUUID();
      setThreadId(newThreadId);
      localStorage.setItem('threadId', newThreadId);
    }
    
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.accessToken}`,
      },
      body: JSON.stringify({
        message,
        threadId,
      }),
    });
    
    // Handle response
  };
  
  return (
    // Chat UI implementation
  );
}
```

## Related Features

- **[Memory Threads](../4-memory-threads/index.md)**: Understanding thread and resource concepts
- **[Multiple Users](./4.3-multiple-users.md)**: Managing threads for multiple users
- **[Admin UIs](./4.4-admin-ui.md)**: Building secure interfaces to manage user conversations 