# Building Admin UIs to Manage Threads

Mastra's memory system enables you to build administrative interfaces for viewing, searching, and manipulating conversation threads. This section covers how to create management UIs for your memory data.

## Why Build Admin UIs?

Memory thread management interfaces enable:
- Support staff to view conversation history
- Content moderation of user-agent interactions
- Analytics on conversation patterns
- Troubleshooting memory-related issues
- Data management for compliance purposes

## Using Memory API Methods

Mastra provides several API methods that are useful for building admin interfaces:

### Getting Thread Information

To retrieve thread information, use these memory methods:

```typescript
// Get a specific thread by ID
const thread = await memory.getThreadById({
  threadId: "thread_123",
});

// Get all threads for a specific user/resource
const threads = await memory.getThreadsByResourceId({
  resourceId: "user_456",
});

// Get thread messages
const { messages } = await memory.query({
  threadId: "thread_123",
  selectBy: { all: true }, // Get all messages in the thread
});
```

### Thread Management Operations

You can also perform management operations on threads:

```typescript
// Create a new thread
const thread = await memory.createThread({
  resourceId: "user_123",
  title: "Support Conversation",
  metadata: {
    category: "support",
    priority: "high"
  }
});

// Update thread metadata
await memory.updateThread({
  id: "thread_123",
  title: "Updated Title",
  metadata: {
    status: "resolved",
  },
});

// Delete a thread
await memory.deleteThread("thread_123");
```

## Building a Basic Admin API

Here's how to create a simple admin API with custom routes:

```typescript
import { Mastra } from '@mastra/core';
import { registerApiRoute } from "@mastra/core/server";
import { Memory } from "@mastra/memory";

const memory = new Memory();

// Add custom API routes for thread management
export const mastra = new Mastra({
  server: {
    apiRoutes: [
      // Get all threads (with pagination)
      registerApiRoute('/api/admin/threads', {
        method: 'GET',
        middleware: [authMiddleware], // Add your authentication middleware
        handler: async (c) => {
          const url = new URL(c.req.url);
          const page = parseInt(url.searchParams.get("page") || "1");
          const limit = parseInt(url.searchParams.get("limit") || "20");
          const resourceId = url.searchParams.get("resourceId");
          
          // Simple implementation - in production you would need to implement pagination
          const threads = resourceId 
            ? await memory.getThreadsByResourceId({ resourceId })
            : await memory.getAllThreads();
          
          return c.json({ threads });
        }
      }),
      
      // Get thread details with messages
      registerApiRoute('/api/admin/threads/:threadId', {
        method: 'GET',
        middleware: [authMiddleware],
        handler: async (c) => {
          const threadId = c.req.param('threadId');
          
          const thread = await memory.getThreadById({ threadId });
          if (!thread) {
            return c.json({ error: "Thread not found" }, 404);
          }
          
          const { messages } = await memory.query({
            threadId,
            selectBy: { all: true },
          });
          
          return c.json({ thread, messages });
        }
      }),
      
      // Delete a thread
      registerApiRoute('/api/admin/threads/:threadId', {
        method: 'DELETE',
        middleware: [authMiddleware],
        handler: async (c) => {
          const threadId = c.req.param('threadId');
          
          await memory.deleteThread(threadId);
          
          return c.json({ success: true });
        }
      })
    ]
  }
});
```

## Securing Admin Routes

It's critical to secure admin APIs with proper authentication and authorization:

```typescript
// Example authentication middleware
const authMiddleware = async (c, next) => {
  // Check for authentication header
  const authHeader = c.req.header('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  
  // Validate token
  const token = authHeader.split(' ')[1];
  try {
    // Implement your token validation logic
    const user = validateToken(token);
    
    // Check if user has admin permissions
    if (!user.isAdmin) {
      return c.json({ error: "Forbidden" }, 403);
    }
    
    // Attach user to context
    c.set('user', user);
    
    // Continue to handler
    await next();
  } catch (error) {
    return c.json({ error: "Invalid token" }, 401);
  }
};
```

## Frontend Admin Components

Here's a simple React component for displaying a list of threads:

```jsx
// ThreadList.jsx
import { useState, useEffect } from 'react';

export function ThreadList() {
  const [threads, setThreads] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchThreads() {
      try {
        const response = await fetch('/api/admin/threads', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
          }
        });
        
        if (!response.ok) throw new Error('Failed to fetch threads');
        
        const data = await response.json();
        setThreads(data.threads);
      } catch (error) {
        console.error('Error fetching threads:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchThreads();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div className="admin-panel">
      <h1>Thread Management</h1>
      
      <table className="thread-table">
        <thead>
          <tr>
            <th>ID</th>
            <th>User</th>
            <th>Title</th>
            <th>Created</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {threads.map(thread => (
            <tr key={thread.id}>
              <td>{thread.id}</td>
              <td>{thread.resourceId}</td>
              <td>{thread.title || "Untitled"}</td>
              <td>{new Date(thread.createdAt).toLocaleString()}</td>
              <td>
                <a href={`/admin/threads/${thread.id}`}>View</a>
                <button onClick={() => handleDelete(thread.id)}>Delete</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

## Best Practices

1. **Authentication**: Always secure admin interfaces with strong authentication
2. **Authorization**: Implement role-based access controls for different admin functions
3. **Pagination**: Implement pagination for thread and message lists
4. **Filtering**: Allow filtering by user, date range, and other criteria
5. **Audit Logging**: Log all admin actions for accountability
6. **Data Privacy**: Consider data privacy laws when displaying user data

## Related Features

- **[Memory Threads](../4-memory-threads/index.md)**: Understanding thread and resource concepts
- **[Multiple Users](./4.3-multiple-users.md)**: Managing threads for multiple users
- **[Authentication](./4.5-auth.md)**: Securing admin interfaces with authentication 