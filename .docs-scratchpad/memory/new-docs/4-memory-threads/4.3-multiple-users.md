# Handling Multiple Users

Mastra's memory system is designed to handle multiple users efficiently through the resource and thread model. This section explains how to manage conversations for multiple users while maintaining separate contexts.

## Understanding Resources and Threads

In Mastra, user management is built around two key concepts:

1. **resourceId**: Identifies the user or entity (e.g., "user_123")
2. **threadId**: Identifies a specific conversation thread (e.g., "support_456")

This separation allows you to:
- Maintain separate conversations for each user
- Track multiple conversation threads per user
- Prevent context bleed between users
- Build multi-user applications with isolated memory

```
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│  Resource A   │     │  Resource B   │     │  Resource C   │
│ (User 123)    │     │ (User 456)    │     │ (User 789)    │
└───────┬───────┘     └───────┬───────┘     └───────┬───────┘
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Threads    │     │   Threads    │     │   Threads    │
├──────────────┤     ├──────────────┤     ├──────────────┤
│ Thread A-1   │     │ Thread B-1   │     │ Thread C-1   │
│ Thread A-2   │     │ Thread B-2   │     │ Thread C-2   │
│ Thread A-3   │     │              │     │ Thread C-3   │
└──────────────┘     └──────────────┘     └──────────────┘
```

## Basic Multi-User Implementation

Setting up memory for multiple users is straightforward:

```typescript
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

// Single memory instance for all users
const memory = new Memory();
const agent = new Agent({
  name: "SupportAgent",
  instructions: "You provide customer support.",
  model: openai("gpt-4o"),
  memory,
});

// Use with different users
await agent.stream("I need help with my account", {
  resourceId: "user_alice",  // First user
  threadId: "support_thread_1",
});

await agent.stream("How do I upgrade my plan?", {
  resourceId: "user_bob",    // Second user (isolated)
  threadId: "support_thread_2",
});

// Continue conversation with first user
await agent.stream("Did you find a solution to my problem?", {
  resourceId: "user_alice",
  threadId: "support_thread_1",
});
```

## Multiple Threads Per User

Users can have multiple conversation threads for different topics:

```typescript
const userId = "user_charlie";

// Support conversation
await agent.stream("I need help with billing", {
  resourceId: userId,
  threadId: "support_thread",
});

// Product feedback conversation (separate context)
await agent.stream("I have some suggestions for your product", {
  resourceId: userId,
  threadId: "feedback_thread",
});

// Continue support conversation with context intact
await agent.stream("Did you find my billing issue?", {
  resourceId: userId,
  threadId: "support_thread",
});
```

## Working Memory with Multiple Users

Working memory is isolated by resourceId, ensuring each user has separate persistent information:

```typescript
// Create memory with working memory enabled
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
    },
  },
});

// User preferences are stored per resourceId
await agent.stream("I prefer dark mode and compact layouts", {
  resourceId: "user_alice",
  threadId: "preferences_thread",
});

await agent.stream("I prefer light mode and expanded layouts", {
  resourceId: "user_bob",
  threadId: "preferences_thread",
});

// Each user's preferences are remembered separately
await agent.stream("What display mode do I prefer?", {
  resourceId: "user_alice",
  threadId: "preferences_thread",
});
// Response: "You prefer dark mode and compact layouts"
```

## Thread Management and Retrieval

You can programmatically access and manage user threads:

```typescript
// Get all threads for a specific user
const threads = await memory.getThreadsByResourceId({
  resourceId: "user_alice",
});

// Display thread information
console.log(`User Alice has ${threads.length} conversation threads`);
threads.forEach(thread => {
  console.log(`- ${thread.id}: ${thread.title || 'Untitled'}`);
});
```

## Memory Sharing Between Agents

You can control whether agents share memory or have isolated contexts:

```typescript
// Agents with isolated memory (different threadIds)
await agentA.stream("Message for Agent A", {
  resourceId: "user_123",
  threadId: "conversation_with_agent_A",
});

await agentB.stream("Message for Agent B", {
  resourceId: "user_123", 
  threadId: "conversation_with_agent_B",
});

// Agents with shared memory (same resourceId and threadId)
await specialistAgent.stream("The user has a premium account", {
  resourceId: "user_123",
  threadId: "support_thread_456",
});

await generalAgent.stream("What type of account does the user have?", {
  resourceId: "user_123",
  threadId: "support_thread_456",
}); 
// Second agent will know about the premium account information
```

## Integration with Authentication

In real applications, derive the resourceId from your authentication system:

```typescript
// Generic example (works with any auth system)
async function handleChat(userId, message, threadId) {
  const resourceId = `user_${userId}`;
  
  const stream = await agent.stream(message, {
    resourceId,
    threadId: threadId || crypto.randomUUID(),
  });
  
  return stream;
}
```

## Production Considerations

For applications with many users:

1. **Use a scalable database**: PostgreSQL is recommended for production
2. **Configure connection pooling**: Adjust pool size based on user load
3. **Implement data lifecycle policies**: Create strategies for archiving old threads
4. **Consider security**: Ensure proper access controls and data isolation

```typescript
import { PostgresStore, PgVector } from "@mastra/pg";

// Production-ready memory configuration
const memory = new Memory({
  storage: new PostgresStore({
    connectionString: process.env.DATABASE_URL!,
    pool: { max: 20 },
  }),
  vector: new PgVector(process.env.DATABASE_URL!),
});
```

## Best Practices

1. **Use consistent ID formats**: Follow patterns like `user_123` for resourceIds
2. **Create descriptive thread IDs**: Use formats like `support_thread_123` for clarity
3. **Handle error cases**: Account for missing threads or resources
4. **Build user interfaces**: Help users manage and navigate their conversation history
5. **Consider data privacy**: Implement mechanisms for data deletion and export

## Related Features

- **[Memory Threads](../4-memory-threads/index.md)**: Understanding thread and resource concepts
- **[Authentication](./4.5-auth.md)**: Integrating memory with authentication systems
- **[Admin UIs](./4.4-admin-ui.md)**: Building interfaces to manage user conversations 