# Handling Multiple Users

Mastra's memory system is designed to handle multiple users efficiently through the resource and thread model. This section explains how to manage conversations for multiple users while maintaining separate contexts.

## Multiple Users Architecture

In Mastra, user management is built around two key concepts:

1. **resourceId**: Identifies the user or entity (e.g., "user_123")
2. **threadId**: Identifies a specific conversation thread (e.g., "support_456")

This separation allows you to:
- Maintain separate conversations for each user
- Track multiple conversation threads per user
- Prevent context bleed between users
- Build multi-user applications with isolated memory

```
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│   Resource A  │     │   Resource B  │     │   Resource C  │
│  (User 123)   │     │  (User 456)   │     │  (User 789)   │
└───────┬───────┘     └───────┬───────┘     └───────┬───────┘
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Threads    │     │   Threads    │     │   Threads    │
├──────────────┤     ├──────────────┤     ├──────────────┤
│ Thread A-1   │     │ Thread B-1   │     │ Thread C-1   │
│ Thread A-2   │     │ Thread B-2   │     │ Thread C-2   │
│ Thread A-3   │     │              │     │ Thread C-3   │
└──────────────┘     └──────────────┘     └──────────────┘
```

## Setting Up Multi-User Memory

To implement multi-user memory, create a memory instance that will be shared across users:

```typescript
import { Memory } from "@mastra/memory";
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";

// Create a single memory instance for all users
const memory = new Memory();

// Create an agent with this memory
const agent = new Agent({
  name: "SupportAgent",
  instructions: "You provide customer support.",
  model: openai("gpt-4o"),
  memory: memory,
});
```

## Managing User Conversations

To manage conversations for different users, use distinct resourceId values:

```typescript
// Conversation with User A
await agent.stream("I need help with my account", {
  resourceId: "user_alice",
  threadId: "support_thread_1",
});

// Conversation with User B (completely isolated)
await agent.stream("How do I upgrade my plan?", {
  resourceId: "user_bob",
  threadId: "support_thread_2",
});

// Another conversation with User A (continues previous context)
await agent.stream("Did you find a solution to my problem?", {
  resourceId: "user_alice",
  threadId: "support_thread_1",
});
```

## Memory Sharing Between Agents

By controlling `resourceId` and `threadId` parameters, you can determine how memory is shared or isolated between different agents:

### Isolating Memory Between Agents

To give each agent its own separate memory, use different `threadId` values:

```typescript
// Agent 1 with its own memory
await agentA.stream("Message for Agent A", {
  resourceId: "user_123",
  threadId: "conversation_with_agent_A",
});

// Agent 2 with separate memory
await agentB.stream("Message for Agent B", {
  resourceId: "user_123", 
  threadId: "conversation_with_agent_B",
});
```

### Sharing Memory Between Agents

To have multiple agents share the same conversation history, use the same `resourceId` and `threadId`:

```typescript
// First agent stores some information
await specialistAgent.stream("The user has a premium account", {
  resourceId: "user_123",
  threadId: "support_thread_456",
});

// Second agent can access the same conversation history
await generalAgent.stream("What type of account does the user have?", {
  resourceId: "user_123",
  threadId: "support_thread_456",
}); 
// This agent will know about the premium account information
```

When to use shared vs. isolated memory depends on your application's requirements:
- **Use shared memory** when agents are collaborating on the same task or need awareness of each other's actions
- **Use isolated memory** when agents serve different purposes and shouldn't interfere with each other's context

## User Management in Applications

In real applications, you'll typically derive resourceId from user authentication:

```typescript
// Express.js example
app.post('/api/chat', authenticate, async (req, res) => {
  const { message, threadId } = req.body;
  const userId = req.user.id; // From authentication middleware
  
  // Use user ID as resource ID
  const resourceId = `user_${userId}`;
  
  // Stream with isolated memory per user
  const stream = await agent.stream(message, {
    resourceId,
    threadId,
  });
  
  // Stream response
  stream.toReadableStream().pipe(res);
});
```

## Working Memory for Multiple Users

Working memory is also isolated by resourceId, ensuring each user has separate persistent memory:

```typescript
// Create memory with working memory enabled
const memory = new Memory({
  options: {
    workingMemory: {
      enabled: true,
    },
  },
});

// User A - establish preferences
await agent.stream("I prefer dark mode and compact layouts", {
  resourceId: "user_alice",
  threadId: "preferences_thread",
});

// User B - establish different preferences (isolated)
await agent.stream("I prefer light mode and expanded layouts", {
  resourceId: "user_bob",
  threadId: "preferences_thread",
});

// Later, User A's preferences are remembered
await agent.stream("What display mode do I prefer?", {
  resourceId: "user_alice",
  threadId: "preferences_thread",
});
// Response: "You prefer dark mode and compact layouts"
```

## Thread Management for Users

Users can have multiple conversation threads for different topics:

```typescript
// User with multiple conversation threads
const userId = "user_charlie";

// Support conversation
await agent.stream("I need help with billing", {
  resourceId: userId,
  threadId: "support_thread",
});

// Product feedback conversation (separate context)
await agent.stream("I have some suggestions for your product", {
  resourceId: userId,
  threadId: "feedback_thread",
});

// Continue support conversation
await agent.stream("Did you find my billing issue?", {
  resourceId: userId,
  threadId: "support_thread",
});
```

## Retrieving User Threads

You can retrieve all threads for a specific user:

```typescript
// Get all threads for a user
const threads = await memory.getThreadsByResourceId({
  resourceId: "user_alice",
});

console.log(`User Alice has ${threads.length} conversation threads`);
threads.forEach(thread => {
  console.log(`- ${thread.id}: ${thread.title || 'Untitled'}`);
});
```

## Multi-User Memory Storage Considerations

For production applications with many users:

1. **Database Choice**: Use a scalable database backend (PostgreSQL recommended)
2. **Connection Pooling**: Configure appropriate connection pools for concurrent users
3. **Index Optimization**: Ensure proper indexing on resourceId and threadId fields
4. **Resource Cleanup**: Implement policies for archiving or deleting old threads
5. **Content Isolation**: Verify that user data remains isolated

```typescript
import { PostgresStore, PgVector } from "@mastra/pg";
import { Memory } from "@mastra/memory";

// Production-ready memory for multi-user systems
const memory = new Memory({
  storage: new PostgresStore({
    connectionString: process.env.DATABASE_URL!,
    pool: {
      max: 20, // Adjust based on expected concurrent users
    },
  }),
  vector: new PgVector(process.env.DATABASE_URL!),
});
```

## User Authentication Integration

In most applications, you'll integrate memory with your authentication system:

```typescript
// Next.js API route with Auth.js
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";

export async function POST(request: Request) {
  // Get authenticated user
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  
  const { message, threadId } = await request.json();
  
  // Use authenticated user ID
  const resourceId = `user_${session.user.id}`;
  
  // Stream with user's memory
  const stream = await agent.stream(message, {
    resourceId,
    threadId: threadId || crypto.randomUUID(),
  });
  
  return stream.toDataStreamResponse();
}
```

## Security Considerations

When handling multiple users, consider these security aspects:

1. **Data Separation**: Verify that memory retrieval strictly enforces resourceId boundaries
2. **Access Controls**: Implement controls to prevent unauthorized thread access
3. **Content Filtering**: Consider filtering sensitive information from persistent storage
4. **Encryption**: For highly sensitive applications, encrypt stored conversations
5. **User Deletion**: Support complete user data deletion (right to be forgotten)

## Best Practices for Multi-User Systems

1. **Consistent ID Schemas**: Use predictable formats for resourceId (e.g., "user_123")
2. **Thread Naming**: Implement descriptive thread titles for better organization
3. **Error Handling**: Handle cases where threads or resources don't exist
4. **Scalability**: Monitor performance with increasing user counts
5. **User Interfaces**: Build UIs that help users manage their conversation threads

## Related Features

- **[Memory Threads](../4-memory-threads/index.md)**: Understanding thread and resource concepts
- **[Authentication](./4.5-auth.md)**: Integrating memory with authentication systems
- **[Admin UIs](./4.4-admin-ui.md)**: Building interfaces to manage user conversations 