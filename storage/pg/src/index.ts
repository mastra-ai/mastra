import { MastraStorage, MessageType, StorageColumn, TABLE_NAMES, ThreadType, WorkflowRunState } from '@mastra/core';
import pg from 'pg';
import pgPromise from 'pg-promise';
import type { IDatabase, IMain } from 'pg-promise';

export interface PostgresConfig {
  connectionString?: string;
  host?: string;
  port?: number;
  database?: string;
  user?: string;
  password?: string;
  ssl?: boolean;
}

export class PostgresStore extends MastraStorage {
  private db: IDatabase<any>;
  private pgp: IMain;
  private pool: pg.Pool;
  hasTables: boolean = false;

  constructor(config: PostgresConfig) {
    super('Postgres');
    this.pgp = pgPromise();
    this.db = this.pgp(config);
    this.pool = new pg.Pool({ connectionString: config.connectionString });
  }

  protected async createTable(tableName: TABLE_NAMES, schema: Record<string, StorageColumn>): Promise<void> {
    const columns = Object.entries(schema).map(([name, column]) => {
      let definition = `${this.pgp.as.name(name)} ${column.type === 'text' ? 'TEXT' : 'TIMESTAMP WITH TIME ZONE'}`;
      if (!column.nullable) {
        definition += ' NOT NULL';
      }
      return definition;
    });

    const primaryKeys = Object.entries(schema)
      .filter(([_, column]) => column.primaryKey)
      .map(([name]) => this.pgp.as.name(name));

    const tableQuery = `
      CREATE TABLE IF NOT EXISTS ${this.pgp.as.name(tableName)} (
        ${columns.join(',\n        ')}${primaryKeys.length > 0 ? `,\n        PRIMARY KEY (${primaryKeys.join(', ')})` : ''}
      );
    `;

    this.logger.debug('Creating table', {
      tableName,
      tableQuery,
    });

    await this.db.none(tableQuery);
  }

  async clearTable(tableName: string): Promise<void> {
    await this.db.none(`TRUNCATE TABLE ${this.pgp.as.name(tableName)}`);
  }

  // TODO: this was generated by windsurf and isn't verified to work yet
  protected async insert(tableName: TABLE_NAMES, record: Record<string, any>): Promise<void> {
    const columns = Object.keys(record);
    const placeholders = columns.map((_, i) => `$${i + 1}`);
    const values = Object.values(record);

    const query = `INSERT INTO ${this.pgp.as.name(tableName)} (${columns.map(col => this.pgp.as.name(col)).join(', ')}) VALUES (${placeholders.join(', ')})`;
    await this.db.none(query, values);
  }

  // TODO: this was generated by windsurf and isn't verified to work yet
  protected async load<R>(tableName: TABLE_NAMES, keys: Record<string, string>): Promise<R | null> {
    const columns = Object.keys(keys);
    const values = Object.values(keys);
    const conditions = columns.map((col, i) => `${this.pgp.as.name(col)} = $${i + 1}`).join(' AND ');
    const query = `SELECT * FROM ${this.pgp.as.name(tableName)} WHERE ${conditions}`;
    const result = await this.db.oneOrNone(query, values);
    return result as R | null;
  }

  async persistWorkflowSnapshot(params: {
    tableName: string;
    workflowName: string;
    runId: string;
    snapshot: WorkflowRunState;
  }): Promise<void> {
    const { tableName, workflowName, runId, snapshot } = params;

    await this.db.none(
      `
      INSERT INTO ${this.pgp.as.name(tableName)}
        (workflow_name, run_id, snapshot, updated_at)
      VALUES
        ($1, $2, $3, CURRENT_TIMESTAMP)
      ON CONFLICT (workflow_name, run_id)
      DO UPDATE SET
        snapshot = EXCLUDED.snapshot,
        updated_at = CURRENT_TIMESTAMP
    `,
      [workflowName, runId, snapshot],
    );
  }

  async loadWorkflowSnapshot(params: {
    tableName: string;
    workflowName: string;
    runId: string;
  }): Promise<WorkflowRunState | null> {
    const { tableName, workflowName, runId } = params;

    const result = await this.db.oneOrNone(
      `
      SELECT snapshot
      FROM ${this.pgp.as.name(tableName)}
      WHERE workflow_name = $1
        AND run_id = $2
    `,
      [workflowName, runId],
    );

    return result?.snapshot || null;
  }

  async getThreadById({ threadId }: { threadId: string }): Promise<ThreadType | null> {
    await this.ensureTablesExist();

    const client = await this.pool.connect();
    try {
      const result = await client.query<ThreadType>(
        `
                SELECT id, title, created_at AS createdAt, updated_at AS updatedAt, resourceid, metadata
                FROM mastra_threads
                WHERE id = $1
            `,
        [threadId],
      );

      return result.rows[0] || null;
    } finally {
      client.release();
    }
  }

  async getThreadsByResourceId({ resourceid }: { resourceid: string }): Promise<ThreadType[]> {
    await this.ensureTablesExist();

    const client = await this.pool.connect();
    try {
      const result = await client.query<ThreadType>(
        `
                SELECT id, title, resourceid, created_at AS createdAt, updated_at AS updatedAt, metadata
                FROM mastra_threads
                WHERE resourceid = $1
            `,
        [resourceid],
      );
      return result.rows;
    } finally {
      client.release();
    }
  }

  async saveThread({ thread }: { thread: ThreadType }): Promise<ThreadType> {
    await this.ensureTablesExist();

    const client = await this.pool.connect();
    try {
      const { id, title, createdAt, updatedAt, resourceid, metadata } = thread;
      const result = await client.query<ThreadType>(
        `
                INSERT INTO mastra_threads (id, title, created_at, updated_at, resourceid, metadata)
                VALUES ($1, $2, $3, $4, $5, $6)
                ON CONFLICT (id) DO UPDATE SET title = $2, updated_at = $4, resourceid = $5, metadata = $6
                RETURNING id, title, created_at AS createdAt, updated_at AS updatedAt, resourceid, metadata
            `,
        [id, title, createdAt, updatedAt, resourceid, JSON.stringify(metadata)],
      );
      return result?.rows?.[0]!;
    } finally {
      client.release();
    }
  }

  async updateThread(id: string, title: string, metadata: Record<string, unknown>): Promise<ThreadType> {
    const client = await this.pool.connect();
    try {
      const result = await client.query<ThreadType>(
        `
                UPDATE mastra_threads
                SET title = $1, metadata = $2, updated_at = NOW()
                WHERE id = $3
                RETURNING *
                `,
        [title, JSON.stringify(metadata), id],
      );
      return result?.rows?.[0]!;
    } finally {
      client.release();
    }
  }

  async deleteThread(id: string): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query(
        `
                DELETE FROM mastra_messages
                WHERE thread_id = $1
                `,
        [id],
      );

      await client.query(
        `
                DELETE FROM mastra_threads
                WHERE id = $1
                `,
        [id],
      );
    } finally {
      client.release();
    }
  }

  async getMessages<T = unknown>(_params: { threadId: string }): Promise<T> {
    throw new Error('not implemented yet');
  }

  async saveMessages(_params: { messages: MessageType[] }): Promise<MessageType[]> {
    throw new Error('not implemented yet');
  }

  async validateToolCallArgs({ hashedArgs }: { hashedArgs: string }): Promise<boolean> {
    await this.ensureTablesExist();

    const client = await this.pool.connect();

    try {
      const toolArgsResult = await client.query<{ toolCallIds: string; toolCallArgs: string; createdAt: string }>(
        ` SELECT tool_call_ids as toolCallIds, 
                tool_call_args as toolCallArgs,
                created_at AS createdAt
         FROM mastra_messages
         WHERE tool_call_args::jsonb @> $1
         AND tool_call_args_expire_at > $2
         ORDER BY created_at ASC
         LIMIT 1`,
        [JSON.stringify([hashedArgs]), new Date().toISOString()],
      );

      return toolArgsResult.rows.length > 0;
    } catch (error) {
      console.log('error checking if valid arg exists====', error);
      return false;
    } finally {
      client.release();
    }
  }

  async ensureTablesExist(): Promise<void> {
    if (this.hasTables) {
      return;
    }

    const client = await this.pool.connect();
    try {
      // Check if the threads table exists
      const threadsResult = await client.query<{ exists: boolean }>(`
                SELECT EXISTS (
                    SELECT 1
                    FROM information_schema.tables
                    WHERE table_name = 'mastra_threads'
                );
            `);

      if (!threadsResult?.rows?.[0]?.exists) {
        await client.query(`
                    CREATE TABLE IF NOT EXISTS mastra_threads (
                        id UUID PRIMARY KEY,
                        resourceid TEXT,
                        title TEXT,
                        created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                        updated_at TIMESTAMP WITH TIME ZONE NOT NULL,
                        metadata JSONB
                    );
                `);
      }

      // Check if the messages table exists
      const messagesResult = await client.query<{ exists: boolean }>(`
                SELECT EXISTS (
                    SELECT 1
                    FROM information_schema.tables
                    WHERE table_name = 'mastra_messages'
                );
            `);

      if (!messagesResult?.rows?.[0]?.exists) {
        await client.query(`
                    CREATE TABLE IF NOT EXISTS mastra_messages (
                        id UUID PRIMARY KEY,
                        content TEXT NOT NULL,
                        role VARCHAR(20) NOT NULL,
                        created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                        tool_call_ids TEXT DEFAULT NULL,
                        tool_call_args TEXT DEFAULT NULL,
                        tool_call_args_expire_at TIMESTAMP WITH TIME ZONE DEFAULT NULL,
                        type VARCHAR(20) NOT NULL,
                        tokens INTEGER DEFAULT NULL,
                        thread_id UUID NOT NULL,
                        FOREIGN KEY (thread_id) REFERENCES mastra_threads(id)
                    );
                `);
      }
    } finally {
      client.release();
      this.hasTables = true;
    }
  }

  async close(): Promise<void> {
    await this.db.$pool.end();
  }
}
